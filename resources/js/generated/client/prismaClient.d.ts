/**
 * Client
 **/

import * as runtime from './runtime/index'
declare const prisma: unique symbol
export type PrismaPromise<A> = Promise<A> & { [prisma]: true }
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
    [K in keyof Tuple]: K extends `${number}`
        ? Tuple[K] extends PrismaPromise<infer X>
            ? X
            : UnwrapPromise<Tuple[K]>
        : UnwrapPromise<Tuple[K]>
}

/**
 * Model Benefactors
 *
 */
export type Benefactors = {
    /**
     * @zod.string.uuid()
     */
    id: string
    tenant_id: string
    deleted_at: Date | null
    created_at: Date | null
    updated_at: Date | null
}

/**
 * Model Cache
 *
 */
export type Cache = {
    key: string
    value: string
    /**
     * @zod.number.int().gte(-2147483648).lte(2147483647)
     */
    expiration: number
}

/**
 * Model Cache_locks
 *
 */
export type Cache_locks = {
    key: string
    owner: string
    /**
     * @zod.number.int().gte(-2147483648).lte(2147483647)
     */
    expiration: number
}

/**
 * Model Domains
 *
 */
export type Domains = {
    /**
     * @zod.string.uuid()
     */
    id: string
    domain: string
    tenant_id: string
    created_at: Date | null
    updated_at: Date | null
}

/**
 * Model Families
 *
 */
export type Families = {
    /**
     * @zod.string.uuid()
     */
    id: string
    name: string
    report: string
    tenant_id: string
    created_at: Date | null
    updated_at: Date | null
}

/**
 * Model Family_furnishing
 *
 */
export type Family_furnishing = {
    /**
     * @zod.string.uuid()
     */
    id: string
    /**
     * @zod.string.uuid()
     */
    family_id: string
    /**
     * @zod.string.uuid()
     */
    furnishing_id: string
    value: string
}

/**
 * Model Family_housing
 *
 */
export type Family_housing = {
    /**
     * @zod.string.uuid()
     */
    id: string
    /**
     * @zod.string.uuid()
     */
    family_id: string
    /**
     * @zod.string.uuid()
     */
    housing_id: string
    value: string
}

/**
 * Model Family_sponsorship
 *
 */
export type Family_sponsorship = {
    /**
     * @zod.string.uuid()
     */
    id: string
    /**
     * @zod.string.uuid()
     */
    family_id: string
    type: family_sponsorship_type
    value: string
    tenant_id: string
    created_at: Date | null
    updated_at: Date | null
}

/**
 * Model Furnishings
 *
 */
export type Furnishings = {
    /**
     * @zod.string.uuid()
     */
    id: string
    name: string
}

/**
 * Model Housings
 *
 */
export type Housings = {
    /**
     * @zod.string.uuid()
     */
    id: string
    name: string
}

/**
 * Model Income_sponsor
 *
 */
export type Income_sponsor = {
    /**
     * @zod.string.uuid()
     */
    id: string
    /**
     * @zod.string.uuid()
     */
    income_id: string
    /**
     * @zod.string.uuid()
     */
    sponsor_id: string
    tenant_id: string
    /**
     * @zod.custom.use(z.number().or(z.nan()))
     */
    value: number
    created_at: Date | null
    updated_at: Date | null
}

/**
 * Model Incomes
 *
 */
export type Incomes = {
    /**
     * @zod.string.uuid()
     */
    id: string
    name: string
}

/**
 * Model Media
 *
 */
export type Media = {
    /**
     * @zod.string.uuid()
     */
    id: string
    model_type: string
    model_id: bigint
    /**
     * @zod.string.uuid()
     */
    uuid: string | null
    collection_name: string
    name: string
    file_name: string
    mime_type: string | null
    disk: string
    conversions_disk: string | null
    size: bigint
    manipulations: Prisma.JsonValue
    custom_properties: Prisma.JsonValue
    generated_conversions: Prisma.JsonValue
    responsive_images: Prisma.JsonValue
    /**
     * @zod.number.int().gte(-2147483648).lte(2147483647)
     */
    order_column: number | null
    created_at: Date | null
    updated_at: Date | null
}

/**
 * Model Model_has_permissions
 *
 */
export type Model_has_permissions = {
    /**
     * @zod.string.uuid()
     */
    permission_id: string
    model_type: string
    /**
     * @zod.string.uuid()
     */
    model_uuid: string
}

/**
 * Model Model_has_roles
 *
 */
export type Model_has_roles = {
    /**
     * @zod.string.uuid()
     */
    role_id: string
    model_type: string
    /**
     * @zod.string.uuid()
     */
    model_uuid: string
}

/**
 * Model Orphan_sponsorship
 *
 */
export type Orphan_sponsorship = {
    /**
     * @zod.string.uuid()
     */
    id: string
    /**
     * @zod.string.uuid()
     */
    orphan_id: string
    type: orphan_sponsorship_type
    value: string | null
    tenant_id: string
    created_at: Date | null
    updated_at: Date | null
}

/**
 * Model Orphans
 *
 */
export type Orphans = {
    /**
     * @zod.string.uuid()
     */
    id: string
    first_name: string
    last_name: string
    birth_date: Date
    family_status: string
    health_status: string
    academic_level: string
    shoes_size: string
    pants_size: string
    shirt_size: string
    note: string
    tenant_id: string
    /**
     * @zod.string.uuid()
     */
    family_id: string
    /**
     * @zod.string.uuid()
     */
    created_by: string
    /**
     * @zod.string.uuid()
     */
    deleted_by: string | null
    created_at: Date | null
    updated_at: Date | null
}

/**
 * Model Password_reset_tokens
 *
 */
export type Password_reset_tokens = {
    email: string
    token: string
    created_at: Date | null
}

/**
 * Model Permissions
 *
 */
export type Permissions = {
    /**
     * @zod.string.uuid()
     */
    uuid: string
    name: string
    guard_name: string
    created_at: Date | null
    updated_at: Date | null
}

/**
 * Model Personal_access_tokens
 *
 */
export type Personal_access_tokens = {
    /**
     * @zod.string.uuid()
     */
    id: string
    tokenable_type: string
    /**
     * @zod.string.uuid()
     */
    tokenable_id: string
    name: string
    token: string
    abilities: string | null
    last_used_at: Date | null
    expires_at: Date | null
    created_at: Date | null
    updated_at: Date | null
}

/**
 * Model Role_has_permissions
 *
 */
export type Role_has_permissions = {
    /**
     * @zod.string.uuid()
     */
    permission_id: string
    /**
     * @zod.string.uuid()
     */
    role_id: string
}

/**
 * Model Roles
 *
 */
export type Roles = {
    /**
     * @zod.string.uuid()
     */
    uuid: string
    name: string
    guard_name: string
    created_at: Date | null
    updated_at: Date | null
}

/**
 * Model Second_sponsors
 *
 */
export type Second_sponsors = {
    /**
     * @zod.string.uuid()
     */
    id: string
    first_name: string
    last_name: string
    degree_of_kinship: string
    phone_number: string
    address: string
    /**
     * @zod.custom.use(z.number().or(z.nan()))
     */
    income: number
    /**
     * @zod.string.uuid()
     */
    family_id: string
    tenant_id: string
    deleted_at: Date | null
    created_at: Date | null
    updated_at: Date | null
}

/**
 * Model Sessions
 *
 */
export type Sessions = {
    id: string
    /**
     * @zod.string.uuid()
     */
    user_id: string | null
    ip_address: string | null
    user_agent: string | null
    payload: string
    /**
     * @zod.number.int().gte(-2147483648).lte(2147483647)
     */
    last_activity: number
}

/**
 * Model Settings
 *
 */
export type Settings = {
    /**
     * @zod.string.uuid()
     */
    id: string
    /**
     * @zod.string.uuid()
     */
    user_id: string
    theme: theme
    color_scheme: color_scheme
    layout: layout
    appearance: appearance
    notifications: Prisma.JsonValue | null
    created_at: Date | null
    updated_at: Date | null
}

/**
 * Model Sponsor_sponsorship
 *
 */
export type Sponsor_sponsorship = {
    /**
     * @zod.string.uuid()
     */
    id: string
    /**
     * @zod.string.uuid()
     */
    sponsor_id: string
    type: sponsor_sponsorship_type
    value: string
    tenant_id: string
    created_at: Date | null
    updated_at: Date | null
}

/**
 * Model Sponsors
 *
 */
export type Sponsors = {
    /**
     * @zod.string.uuid()
     */
    id: string
    /**
     * @zod.string.uuid()
     */
    zone_id: string
    /**
     * @zod.number.int().gte(-2147483648).lte(2147483647)
     */
    file_number: number
    start_date: Date
    name: string
    address: string
    phone_number: string
    sponsorship_type: string
    birth_date: Date
    father_name: string
    mother_name: string
    birth_certificate_number: string
    academic_level: string
    function: string
    health_status: string
    diploma: string | null
    card_number: string | null
    tenant_id: string
    /**
     * @zod.string.uuid()
     */
    created_by: string
    /**
     * @zod.string.uuid()
     */
    deleted_by: string | null
    deleted_at: Date | null
    created_at: Date | null
    updated_at: Date | null
}

/**
 * Model Sponsorships
 *
 */
export type Sponsorships = {
    /**
     * @zod.string.uuid()
     */
    id: string
    type: sponsorship_type
    name: string
    tenant_id: string
    deleted_at: Date | null
    created_at: Date | null
    updated_at: Date | null
}

/**
 * Model Spouses
 *
 */
export type Spouses = {
    /**
     * @zod.string.uuid()
     */
    id: string
    first_name: string
    last_name: string
    birth_date: Date
    death_date: Date
    function: string
    /**
     * @zod.custom.use(z.number().or(z.nan()))
     */
    income: number
    /**
     * @zod.string.uuid()
     */
    family_id: string
    tenant_id: string
    created_at: Date | null
    updated_at: Date | null
}

/**
 * Model Tenants
 *
 */
export type Tenants = {
    id: string
    data: Prisma.JsonValue | null
    created_at: Date | null
    updated_at: Date | null
}

/**
 * Model Users
 *
 */
export type Users = {
    /**
     * @zod.string.uuid()
     */
    id: string
    first_name: string
    last_name: string
    phone: string
    email: string
    email_verified_at: Date | null
    password: string
    remember_token: string | null
    tenant_id: string
    created_at: Date | null
    updated_at: Date | null
}

/**
 * Enums
 */

// Based on
// https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

export const appearance: {
    light: 'light'
    dark: 'dark'
}

export type appearance = (typeof appearance)[keyof typeof appearance]

export const color_scheme: {
    default: 'default'
    theme_1: 'theme_1'
    theme_2: 'theme_2'
    theme_3: 'theme_3'
    theme_4: 'theme_4'
}

export type color_scheme = (typeof color_scheme)[keyof typeof color_scheme]

export const family_sponsorship_type: {
    ramadan_basket: 'ramadan_basket'
    monthly_expense: 'monthly_expense'
    eid_al_adha: 'eid_al_adha'
    zakat: 'zakat'
    housing_assistance: 'housing_assistance'
}

export type family_sponsorship_type = (typeof family_sponsorship_type)[keyof typeof family_sponsorship_type]

export const layout: {
    top_menu: 'top_menu'
    simple_menu: 'simple_menu'
    side_menu: 'side_menu'
}

export type layout = (typeof layout)[keyof typeof layout]

export const orphan_sponsorship_type: {
    school_bag: 'school_bag'
    private_lessons: 'private_lessons'
    eid_suit: 'eid_suit'
    summer_camp: 'summer_camp'
    college_trips: 'college_trips'
    fellowship: 'fellowship'
    guaranteed_medical: 'guaranteed_medical'
    other: 'other'
}

export type orphan_sponsorship_type = (typeof orphan_sponsorship_type)[keyof typeof orphan_sponsorship_type]

export const sponsor_sponsorship_type: {
    guaranteed_medical: 'guaranteed_medical'
    support_the_draft: 'support_the_draft'
    literacy_classes: 'literacy_classes'
    direct_sponsorship: 'direct_sponsorship'
}

export type sponsor_sponsorship_type = (typeof sponsor_sponsorship_type)[keyof typeof sponsor_sponsorship_type]

export const sponsorship_type: {
    family: 'family'
    orphan: 'orphan'
    sponsor: 'sponsor'
}

export type sponsorship_type = (typeof sponsorship_type)[keyof typeof sponsorship_type]

export const theme: {
    enigma: 'enigma'
    icewall: 'icewall'
    tinker: 'tinker'
    rubick: 'rubick'
}

export type theme = (typeof theme)[keyof typeof theme]

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Benefactors
 * const benefactors = await prisma.benefactors.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
    T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
    U = 'log' extends keyof T
        ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition>
            ? Prisma.GetEvents<T['log']>
            : never
        : never,
    GlobalReject extends
        | Prisma.RejectOnNotFound
        | Prisma.RejectPerOperation
        | false
        | undefined = 'rejectOnNotFound' extends keyof T ? T['rejectOnNotFound'] : false
> {
    /**
     * ##  Prisma Client ʲˢ
     *
     * Type-safe database client for TypeScript & Node.js
     * @example
     * ```
     * const prisma = new PrismaClient()
     * // Fetch zero or more Benefactors
     * const benefactors = await prisma.benefactors.findMany()
     * ```
     *
     *
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
     */

    constructor(optionsArg?: Prisma.Subset<T, Prisma.PrismaClientOptions>)
    $on<V extends U | 'beforeExit'>(
        eventType: V,
        callback: (
            event: V extends 'query'
                ? Prisma.QueryEvent
                : V extends 'beforeExit'
                  ? () => Promise<void>
                  : Prisma.LogEvent
        ) => void
    ): void

    /**
     * Connect with the database
     */
    $connect(): Promise<void>

    /**
     * Disconnect from the database
     */
    $disconnect(): Promise<void>

    /**
     * Add a middleware
     */
    $use(cb: Prisma.Middleware): void

    /**
     * Executes a prepared raw query and returns the number of affected rows.
     * @example
     * ```
     * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
     * ```
     *
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
     */
    $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<number>

    /**
     * Executes a raw query and returns the number of affected rows.
     * Susceptible to SQL injections, see documentation.
     * @example
     * ```
     * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
     * ```
     *
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
     */
    $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<number>

    /**
     * Performs a prepared raw query and returns the `SELECT` data.
     * @example
     * ```
     * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
     * ```
     *
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
     */
    $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<T>

    /**
     * Performs a raw query and returns the `SELECT` data.
     * Susceptible to SQL injections, see documentation.
     * @example
     * ```
     * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
     * ```
     *
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
     */
    $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<T>

    /**
     * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
     * @example
     * ```
     * const [george, bob, alice] = await prisma.$transaction([
     *   prisma.user.create({ data: { name: 'George' } }),
     *   prisma.user.create({ data: { name: 'Bob' } }),
     *   prisma.user.create({ data: { name: 'Alice' } }),
     * ])
     * ```
     *
     * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
     */
    $transaction<P extends PrismaPromise<any>[]>(
        arg: [...P],
        options?: { isolationLevel?: Prisma.TransactionIsolationLevel }
    ): Promise<UnwrapTuple<P>>

    $transaction<R>(
        fn: (prisma: Prisma.TransactionClient) => Promise<R>,
        options?: { maxWait?: number; timeout?: number; isolationLevel?: Prisma.TransactionIsolationLevel }
    ): Promise<R>

    /**
     * `prisma.benefactors`: Exposes CRUD operations for the **Benefactors** model.
     * Example usage:
     * ```ts
     * // Fetch zero or more Benefactors
     * const benefactors = await prisma.benefactors.findMany()
     * ```
     */
    get benefactors(): Prisma.BenefactorsDelegate<GlobalReject>

    /**
     * `prisma.cache`: Exposes CRUD operations for the **Cache** model.
     * Example usage:
     * ```ts
     * // Fetch zero or more Caches
     * const caches = await prisma.cache.findMany()
     * ```
     */
    get cache(): Prisma.CacheDelegate<GlobalReject>

    /**
     * `prisma.cache_locks`: Exposes CRUD operations for the **Cache_locks** model.
     * Example usage:
     * ```ts
     * // Fetch zero or more Cache_locks
     * const cache_locks = await prisma.cache_locks.findMany()
     * ```
     */
    get cache_locks(): Prisma.Cache_locksDelegate<GlobalReject>

    /**
     * `prisma.domains`: Exposes CRUD operations for the **Domains** model.
     * Example usage:
     * ```ts
     * // Fetch zero or more Domains
     * const domains = await prisma.domains.findMany()
     * ```
     */
    get domains(): Prisma.DomainsDelegate<GlobalReject>

    /**
     * `prisma.families`: Exposes CRUD operations for the **Families** model.
     * Example usage:
     * ```ts
     * // Fetch zero or more Families
     * const families = await prisma.families.findMany()
     * ```
     */
    get families(): Prisma.FamiliesDelegate<GlobalReject>

    /**
     * `prisma.family_furnishing`: Exposes CRUD operations for the **Family_furnishing** model.
     * Example usage:
     * ```ts
     * // Fetch zero or more Family_furnishings
     * const family_furnishings = await prisma.family_furnishing.findMany()
     * ```
     */
    get family_furnishing(): Prisma.Family_furnishingDelegate<GlobalReject>

    /**
     * `prisma.family_housing`: Exposes CRUD operations for the **Family_housing** model.
     * Example usage:
     * ```ts
     * // Fetch zero or more Family_housings
     * const family_housings = await prisma.family_housing.findMany()
     * ```
     */
    get family_housing(): Prisma.Family_housingDelegate<GlobalReject>

    /**
     * `prisma.family_sponsorship`: Exposes CRUD operations for the **Family_sponsorship** model.
     * Example usage:
     * ```ts
     * // Fetch zero or more Family_sponsorships
     * const family_sponsorships = await prisma.family_sponsorship.findMany()
     * ```
     */
    get family_sponsorship(): Prisma.Family_sponsorshipDelegate<GlobalReject>

    /**
     * `prisma.furnishings`: Exposes CRUD operations for the **Furnishings** model.
     * Example usage:
     * ```ts
     * // Fetch zero or more Furnishings
     * const furnishings = await prisma.furnishings.findMany()
     * ```
     */
    get furnishings(): Prisma.FurnishingsDelegate<GlobalReject>

    /**
     * `prisma.housings`: Exposes CRUD operations for the **Housings** model.
     * Example usage:
     * ```ts
     * // Fetch zero or more Housings
     * const housings = await prisma.housings.findMany()
     * ```
     */
    get housings(): Prisma.HousingsDelegate<GlobalReject>

    /**
     * `prisma.income_sponsor`: Exposes CRUD operations for the **Income_sponsor** model.
     * Example usage:
     * ```ts
     * // Fetch zero or more Income_sponsors
     * const income_sponsors = await prisma.income_sponsor.findMany()
     * ```
     */
    get income_sponsor(): Prisma.Income_sponsorDelegate<GlobalReject>

    /**
     * `prisma.incomes`: Exposes CRUD operations for the **Incomes** model.
     * Example usage:
     * ```ts
     * // Fetch zero or more Incomes
     * const incomes = await prisma.incomes.findMany()
     * ```
     */
    get incomes(): Prisma.IncomesDelegate<GlobalReject>

    /**
     * `prisma.media`: Exposes CRUD operations for the **Media** model.
     * Example usage:
     * ```ts
     * // Fetch zero or more Media
     * const media = await prisma.media.findMany()
     * ```
     */
    get media(): Prisma.MediaDelegate<GlobalReject>

    /**
     * `prisma.model_has_permissions`: Exposes CRUD operations for the **Model_has_permissions** model.
     * Example usage:
     * ```ts
     * // Fetch zero or more Model_has_permissions
     * const model_has_permissions = await prisma.model_has_permissions.findMany()
     * ```
     */
    get model_has_permissions(): Prisma.Model_has_permissionsDelegate<GlobalReject>

    /**
     * `prisma.model_has_roles`: Exposes CRUD operations for the **Model_has_roles** model.
     * Example usage:
     * ```ts
     * // Fetch zero or more Model_has_roles
     * const model_has_roles = await prisma.model_has_roles.findMany()
     * ```
     */
    get model_has_roles(): Prisma.Model_has_rolesDelegate<GlobalReject>

    /**
     * `prisma.orphan_sponsorship`: Exposes CRUD operations for the **Orphan_sponsorship** model.
     * Example usage:
     * ```ts
     * // Fetch zero or more Orphan_sponsorships
     * const orphan_sponsorships = await prisma.orphan_sponsorship.findMany()
     * ```
     */
    get orphan_sponsorship(): Prisma.Orphan_sponsorshipDelegate<GlobalReject>

    /**
     * `prisma.orphans`: Exposes CRUD operations for the **Orphans** model.
     * Example usage:
     * ```ts
     * // Fetch zero or more Orphans
     * const orphans = await prisma.orphans.findMany()
     * ```
     */
    get orphans(): Prisma.OrphansDelegate<GlobalReject>

    /**
     * `prisma.password_reset_tokens`: Exposes CRUD operations for the **Password_reset_tokens** model.
     * Example usage:
     * ```ts
     * // Fetch zero or more Password_reset_tokens
     * const password_reset_tokens = await prisma.password_reset_tokens.findMany()
     * ```
     */
    get password_reset_tokens(): Prisma.Password_reset_tokensDelegate<GlobalReject>

    /**
     * `prisma.permissions`: Exposes CRUD operations for the **Permissions** model.
     * Example usage:
     * ```ts
     * // Fetch zero or more Permissions
     * const permissions = await prisma.permissions.findMany()
     * ```
     */
    get permissions(): Prisma.PermissionsDelegate<GlobalReject>

    /**
     * `prisma.personal_access_tokens`: Exposes CRUD operations for the **Personal_access_tokens** model.
     * Example usage:
     * ```ts
     * // Fetch zero or more Personal_access_tokens
     * const personal_access_tokens = await prisma.personal_access_tokens.findMany()
     * ```
     */
    get personal_access_tokens(): Prisma.Personal_access_tokensDelegate<GlobalReject>

    /**
     * `prisma.role_has_permissions`: Exposes CRUD operations for the **Role_has_permissions** model.
     * Example usage:
     * ```ts
     * // Fetch zero or more Role_has_permissions
     * const role_has_permissions = await prisma.role_has_permissions.findMany()
     * ```
     */
    get role_has_permissions(): Prisma.Role_has_permissionsDelegate<GlobalReject>

    /**
     * `prisma.roles`: Exposes CRUD operations for the **Roles** model.
     * Example usage:
     * ```ts
     * // Fetch zero or more Roles
     * const roles = await prisma.roles.findMany()
     * ```
     */
    get roles(): Prisma.RolesDelegate<GlobalReject>

    /**
     * `prisma.second_sponsors`: Exposes CRUD operations for the **Second_sponsors** model.
     * Example usage:
     * ```ts
     * // Fetch zero or more Second_sponsors
     * const second_sponsors = await prisma.second_sponsors.findMany()
     * ```
     */
    get second_sponsors(): Prisma.Second_sponsorsDelegate<GlobalReject>

    /**
     * `prisma.sessions`: Exposes CRUD operations for the **Sessions** model.
     * Example usage:
     * ```ts
     * // Fetch zero or more Sessions
     * const sessions = await prisma.sessions.findMany()
     * ```
     */
    get sessions(): Prisma.SessionsDelegate<GlobalReject>

    /**
     * `prisma.settings`: Exposes CRUD operations for the **Settings** model.
     * Example usage:
     * ```ts
     * // Fetch zero or more Settings
     * const settings = await prisma.settings.findMany()
     * ```
     */
    get settings(): Prisma.SettingsDelegate<GlobalReject>

    /**
     * `prisma.sponsor_sponsorship`: Exposes CRUD operations for the **Sponsor_sponsorship** model.
     * Example usage:
     * ```ts
     * // Fetch zero or more Sponsor_sponsorships
     * const sponsor_sponsorships = await prisma.sponsor_sponsorship.findMany()
     * ```
     */
    get sponsor_sponsorship(): Prisma.Sponsor_sponsorshipDelegate<GlobalReject>

    /**
     * `prisma.sponsors`: Exposes CRUD operations for the **Sponsors** model.
     * Example usage:
     * ```ts
     * // Fetch zero or more Sponsors
     * const sponsors = await prisma.sponsors.findMany()
     * ```
     */
    get sponsors(): Prisma.SponsorsDelegate<GlobalReject>

    /**
     * `prisma.sponsorships`: Exposes CRUD operations for the **Sponsorships** model.
     * Example usage:
     * ```ts
     * // Fetch zero or more Sponsorships
     * const sponsorships = await prisma.sponsorships.findMany()
     * ```
     */
    get sponsorships(): Prisma.SponsorshipsDelegate<GlobalReject>

    /**
     * `prisma.spouses`: Exposes CRUD operations for the **Spouses** model.
     * Example usage:
     * ```ts
     * // Fetch zero or more Spouses
     * const spouses = await prisma.spouses.findMany()
     * ```
     */
    get spouses(): Prisma.SpousesDelegate<GlobalReject>

    /**
     * `prisma.tenants`: Exposes CRUD operations for the **Tenants** model.
     * Example usage:
     * ```ts
     * // Fetch zero or more Tenants
     * const tenants = await prisma.tenants.findMany()
     * ```
     */
    get tenants(): Prisma.TenantsDelegate<GlobalReject>

    /**
     * `prisma.users`: Exposes CRUD operations for the **Users** model.
     * Example usage:
     * ```ts
     * // Fetch zero or more Users
     * const users = await prisma.users.findMany()
     * ```
     */
    get users(): Prisma.UsersDelegate<GlobalReject>
}

export namespace Prisma {
    export import DMMF = runtime.DMMF

    /**
     * Prisma Errors
     */
    export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
    export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
    export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
    export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
    export import PrismaClientValidationError = runtime.PrismaClientValidationError
    export import NotFoundError = runtime.NotFoundError

    /**
     * Re-export of sql-template-tag
     */
    export import sql = runtime.sqltag
    export import empty = runtime.empty
    export import join = runtime.join
    export import raw = runtime.raw
    export import Sql = runtime.Sql

    /**
     * Decimal.js
     */
    export import Decimal = runtime.Decimal

    export type DecimalJsLike = runtime.DecimalJsLike

    /**
     * Metrics
     */
    export type Metrics = runtime.Metrics
    export type Metric<T> = runtime.Metric<T>
    export type MetricHistogram = runtime.MetricHistogram
    export type MetricHistogramBucket = runtime.MetricHistogramBucket

    /**
     * Prisma Client JS version: 4.8.1
     * Query Engine version: d6e67a83f971b175a593ccc12e15c4a757f93ffe
     */
    export type PrismaVersion = {
        client: string
    }

    export const prismaVersion: PrismaVersion

    /**
     * Utility Types
     */

    /**
     * From https://github.com/sindresorhus/type-fest/
     * Matches a JSON object.
     * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from.
     */
    export type JsonObject = { [Key in string]?: JsonValue }

    /**
     * From https://github.com/sindresorhus/type-fest/
     * Matches a JSON array.
     */
    export interface JsonArray extends Array<JsonValue> {}

    /**
     * From https://github.com/sindresorhus/type-fest/
     * Matches any valid JSON value.
     */
    export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

    /**
     * Matches a JSON object.
     * Unlike `JsonObject`, this type allows undefined and read-only properties.
     */
    export type InputJsonObject = { readonly [Key in string]?: InputJsonValue | null }

    /**
     * Matches a JSON array.
     * Unlike `JsonArray`, readonly arrays are assignable to this type.
     */
    export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

    /**
     * Matches any valid value that can be used as an input for operations like
     * create and update as the value of a JSON field. Unlike `JsonValue`, this
     * type allows read-only arrays and read-only object properties and disallows
     * `null` at the top level.
     *
     * `null` cannot be used as the value of a JSON field because its meaning
     * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
     * `Prisma.DbNull` to clear the JSON value and set the field to the database
     * NULL value instead.
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
     */
    export type InputJsonValue = null | string | number | boolean | InputJsonObject | InputJsonArray

    /**
     * Types of the values used to represent different kinds of `null` values when working with JSON fields.
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    namespace NullTypes {
        /**
         * Type of `Prisma.DbNull`.
         *
         * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
         *
         * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
         */
        class DbNull {
            private DbNull: never
            private constructor()
        }

        /**
         * Type of `Prisma.JsonNull`.
         *
         * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
         *
         * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
         */
        class JsonNull {
            private JsonNull: never
            private constructor()
        }

        /**
         * Type of `Prisma.AnyNull`.
         *
         * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
         *
         * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
         */
        class AnyNull {
            private AnyNull: never
            private constructor()
        }
    }

    /**
     * Helper for filtering JSON entries that have `null` on the database (empty on the db)
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    export const DbNull: NullTypes.DbNull

    /**
     * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    export const JsonNull: NullTypes.JsonNull

    /**
     * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    export const AnyNull: NullTypes.AnyNull

    type SelectAndInclude = {
        select: any
        include: any
    }
    type HasSelect = {
        select: any
    }
    type HasInclude = {
        include: any
    }
    type CheckSelect<T, S, U> = T extends SelectAndInclude
        ? 'Please either choose `select` or `include`'
        : T extends HasSelect
          ? U
          : T extends HasInclude
            ? U
            : S

    /**
     * Get the type of the value, that the Promise holds.
     */
    export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T

    /**
     * Get the return type of a function which returns a Promise.
     */
    export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

    /**
     * From T, pick a set of properties whose keys are in the union K
     */
    type Prisma__Pick<T, K extends keyof T> = {
        [P in K]: T[P]
    }

    export type Enumerable<T> = T | Array<T>

    export type RequiredKeys<T> = {
        [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
    }[keyof T]

    export type TruthyKeys<T> = keyof {
        [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
    }

    export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

    /**
     * Subset
     * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
     */
    export type Subset<T, U> = {
        [key in keyof T]: key extends keyof U ? T[key] : never
    }

    /**
     * SelectSubset
     * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
     * Additionally, it validates, if both select and include are present. If the case, it errors.
     */
    export type SelectSubset<T, U> = {
        [key in keyof T]: key extends keyof U ? T[key] : never
    } & (T extends SelectAndInclude ? 'Please either choose `select` or `include`.' : {})

    /**
     * Subset + Intersection
     * @desc From `T` pick properties that exist in `U` and intersect `K`
     */
    export type SubsetIntersection<T, U, K> = {
        [key in keyof T]: key extends keyof U ? T[key] : never
    } & K

    type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never }

    /**
     * XOR is needed to have a real mutually exclusive union type
     * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
     */
    type XOR<T, U> = T extends object ? (U extends object ? (Without<T, U> & U) | (Without<U, T> & T) : U) : T

    /**
     * Is T a Record?
     */
    type IsObject<T extends any> =
        T extends Array<any>
            ? False
            : T extends Date
              ? False
              : T extends Uint8Array
                ? False
                : T extends BigInt
                  ? False
                  : T extends object
                    ? True
                    : False

    /**
     * If it's T[], return T
     */
    export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

    /**
     * From ts-toolbelt
     */

    type __Either<O extends object, K extends Key> = Omit<O, K> &
        {
            // Merge all but K
            [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
        }[K]

    type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

    type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

    type _Either<O extends object, K extends Key, strict extends Boolean> = {
        1: EitherStrict<O, K>
        0: EitherLoose<O, K>
    }[strict]

    type Either<O extends object, K extends Key, strict extends Boolean = 1> = O extends unknown
        ? _Either<O, K, strict>
        : never

    export type Union = any

    type PatchUndefined<O extends object, O1 extends object> = {
        [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
    } & {}

    /** Helper Types for "Merge" **/
    export type IntersectOf<U extends Union> = (U extends unknown ? (k: U) => void : never) extends (k: infer I) => void
        ? I
        : never

    export type Overwrite<O extends object, O1 extends object> = {
        [K in keyof O]: K extends keyof O1 ? O1[K] : O[K]
    } & {}

    type _Merge<U extends object> = IntersectOf<
        Overwrite<
            U,
            {
                [K in keyof U]-?: At<U, K>
            }
        >
    >

    type Key = string | number | symbol
    type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never
    type AtStrict<O extends object, K extends Key> = O[K & keyof O]
    type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never
    export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
        1: AtStrict<O, K>
        0: AtLoose<O, K>
    }[strict]

    export type ComputeRaw<A extends any> = A extends Function
        ? A
        : {
              [K in keyof A]: A[K]
          } & {}

    export type OptionalFlat<O> = {
        [K in keyof O]?: O[K]
    } & {}

    type _Record<K extends keyof any, T> = {
        [P in K]: T
    }

    // cause typescript not to expand types and preserve names
    type NoExpand<T> = T extends unknown ? T : never

    // this type assumes the passed object is entirely optional
    type AtLeast<O extends object, K extends string> = NoExpand<
        O extends unknown
            ?
                  | (K extends keyof O ? { [P in K]: O[P] } & O : O)
                  | ({ [P in keyof O as P extends K ? K : never]-?: O[P] } & O)
            : never
    >

    type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never

    export type Strict<U extends object> = ComputeRaw<_Strict<U>>
    /** End Helper Types for "Merge" **/

    export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>

    /**
  A [[Boolean]]
  */
    export type Boolean = True | False

    // /**
    // 1
    // */
    export type True = 1

    /**
  0
  */
    export type False = 0

    export type Not<B extends Boolean> = {
        0: 1
        1: 0
    }[B]

    export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
        ? 0 // anything `never` is false
        : A1 extends A2
          ? 1
          : 0

    export type Has<U extends Union, U1 extends Union> = Not<Extends<Exclude<U1, U>, U1>>

    export type Or<B1 extends Boolean, B2 extends Boolean> = {
        0: {
            0: 0
            1: 1
        }
        1: {
            0: 1
            1: 1
        }
    }[B1][B2]

    export type Keys<U extends Union> = U extends unknown ? keyof U : never

    type Exact<A, W = unknown> = W extends unknown
        ? A extends Narrowable
            ? Cast<A, W>
            : Cast<
                  { [K in keyof A]: K extends keyof W ? Exact<A[K], W[K]> : never },
                  { [K in keyof W]: K extends keyof A ? Exact<A[K], W[K]> : W[K] }
              >
        : never

    type Narrowable = string | number | boolean | bigint

    type Cast<A, B> = A extends B ? A : B

    export const type: unique symbol

    export function validator<V>(): <S>(select: Exact<S, V>) => S

    /**
     * Used by group by
     */

    export type GetScalarType<T, O> = O extends object
        ? {
              [P in keyof T]: P extends keyof O ? O[P] : never
          }
        : never

    type FieldPaths<T, U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>> = IsObject<T> extends True ? U : T

    type GetHavingFields<T> = {
        [K in keyof T]: Or<Or<Extends<'OR', K>, Extends<'AND', K>>, Extends<'NOT', K>> extends True
            ? // infer is only needed to not hit TS limit
              // based on the brilliant idea of Pierre-Antoine Mills
              // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
              T[K] extends infer TK
                ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
                : never
            : {} extends FieldPaths<T[K]>
              ? never
              : K
    }[keyof T]

    /**
     * Convert tuple to union
     */
    type _TupleToUnion<T> = T extends (infer E)[] ? E : never
    type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
    type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

    /**
     * Like `Pick`, but with an array
     */
    type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

    /**
     * Exclude all keys with underscores
     */
    type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T

    export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

    type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>

    class PrismaClientFetcher {
        private readonly prisma
        private readonly debug
        private readonly hooks?
        constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined)
        request<T>(
            document: any,
            dataPath?: string[],
            rootField?: string,
            typeName?: string,
            isList?: boolean,
            callsite?: string
        ): Promise<T>
        sanitizeMessage(message: string): string
        protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any
    }

    export const ModelName: {
        Benefactors: 'Benefactors'
        Cache: 'Cache'
        Cache_locks: 'Cache_locks'
        Domains: 'Domains'
        Families: 'Families'
        Family_furnishing: 'Family_furnishing'
        Family_housing: 'Family_housing'
        Family_sponsorship: 'Family_sponsorship'
        Furnishings: 'Furnishings'
        Housings: 'Housings'
        Income_sponsor: 'Income_sponsor'
        Incomes: 'Incomes'
        Media: 'Media'
        Model_has_permissions: 'Model_has_permissions'
        Model_has_roles: 'Model_has_roles'
        Orphan_sponsorship: 'Orphan_sponsorship'
        Orphans: 'Orphans'
        Password_reset_tokens: 'Password_reset_tokens'
        Permissions: 'Permissions'
        Personal_access_tokens: 'Personal_access_tokens'
        Role_has_permissions: 'Role_has_permissions'
        Roles: 'Roles'
        Second_sponsors: 'Second_sponsors'
        Sessions: 'Sessions'
        Settings: 'Settings'
        Sponsor_sponsorship: 'Sponsor_sponsorship'
        Sponsors: 'Sponsors'
        Sponsorships: 'Sponsorships'
        Spouses: 'Spouses'
        Tenants: 'Tenants'
        Users: 'Users'
    }

    export type ModelName = (typeof ModelName)[keyof typeof ModelName]

    export type Datasources = {
        db?: Datasource
    }

    export type DefaultPrismaClient = PrismaClient
    export type RejectOnNotFound = boolean | ((error: Error) => Error)
    export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
    export type RejectPerOperation = { [P in 'findUnique' | 'findFirst']?: RejectPerModel | RejectOnNotFound }
    type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
    export type HasReject<
        GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
        LocalRejectSettings,
        Action extends PrismaAction,
        Model extends ModelName
    > = LocalRejectSettings extends RejectOnNotFound
        ? IsReject<LocalRejectSettings>
        : GlobalRejectSettings extends RejectPerOperation
          ? Action extends keyof GlobalRejectSettings
              ? GlobalRejectSettings[Action] extends RejectOnNotFound
                  ? IsReject<GlobalRejectSettings[Action]>
                  : GlobalRejectSettings[Action] extends RejectPerModel
                    ? Model extends keyof GlobalRejectSettings[Action]
                        ? IsReject<GlobalRejectSettings[Action][Model]>
                        : False
                    : False
              : False
          : IsReject<GlobalRejectSettings>
    export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

    export interface PrismaClientOptions {
        /**
         * Configure findUnique/findFirst to throw an error if the query returns null.
         * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
         * @example
         * ```
         * // Reject on both findUnique/findFirst
         * rejectOnNotFound: true
         * // Reject only on findFirst with a custom error
         * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
         * // Reject on user.findUnique with a custom error
         * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
         * ```
         */
        rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
        /**
         * Overwrites the datasource url from your schema.prisma file
         */
        datasources?: Datasources

        /**
         * @default "colorless"
         */
        errorFormat?: ErrorFormat

        /**
         * @example
         * ```
         * // Defaults to stdout
         * log: ['query', 'info', 'warn', 'error']
         *
         * // Emit as events
         * log: [
         *  { emit: 'stdout', level: 'query' },
         *  { emit: 'stdout', level: 'info' },
         *  { emit: 'stdout', level: 'warn' }
         *  { emit: 'stdout', level: 'error' }
         * ]
         * ```
         * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
         */
        log?: Array<LogLevel | LogDefinition>
    }

    export type Hooks = {
        beforeRequest?: (options: {
            query: string
            path: string[]
            rootField?: string
            typeName?: string
            document: any
        }) => any
    }

    /* Types for Logging */
    export type LogLevel = 'info' | 'query' | 'warn' | 'error'
    export type LogDefinition = {
        level: LogLevel
        emit: 'stdout' | 'event'
    }

    export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition
        ? T['emit'] extends 'event'
            ? T['level']
            : never
        : never
    export type GetEvents<T extends any> =
        T extends Array<LogLevel | LogDefinition>
            ? GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
            : never

    export type QueryEvent = {
        timestamp: Date
        query: string
        params: string
        duration: number
        target: string
    }

    export type LogEvent = {
        timestamp: Date
        message: string
        target: string
    }
    /* End Types for Logging */

    export type PrismaAction =
        | 'findUnique'
        | 'findMany'
        | 'findFirst'
        | 'create'
        | 'createMany'
        | 'update'
        | 'updateMany'
        | 'upsert'
        | 'delete'
        | 'deleteMany'
        | 'executeRaw'
        | 'queryRaw'
        | 'aggregate'
        | 'count'
        | 'runCommandRaw'
        | 'findRaw'

    /**
     * These options are being passed into the middleware as "params"
     */
    export type MiddlewareParams = {
        model?: ModelName
        action: PrismaAction
        args: any
        dataPath: string[]
        runInTransaction: boolean
    }

    /**
     * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
     */
    export type Middleware<T = any> = (
        params: MiddlewareParams,
        next: (params: MiddlewareParams) => Promise<T>
    ) => Promise<T>

    // tested in getLogLevel.test.ts
    export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined

    /**
     * `PrismaClient` proxy available in interactive transactions.
     */
    export type TransactionClient = Omit<
        Prisma.DefaultPrismaClient,
        '$connect' | '$disconnect' | '$on' | '$transaction' | '$use'
    >

    export type Datasource = {
        url?: string
    }

    /**
     * Count Types
     */

    /**
     * Count Type FamiliesCountOutputType
     */

    export type FamiliesCountOutputType = {
        family_furnishing: number
        family_housing: number
        family_sponsorship: number
        orphans: number
        second_sponsors: number
        spouses: number
    }

    export type FamiliesCountOutputTypeSelect = {
        family_furnishing?: boolean
        family_housing?: boolean
        family_sponsorship?: boolean
        orphans?: boolean
        second_sponsors?: boolean
        spouses?: boolean
    }

    export type FamiliesCountOutputTypeGetPayload<S extends boolean | null | undefined | FamiliesCountOutputTypeArgs> =
        S extends { select: any; include: any }
            ? 'Please either choose `select` or `include`'
            : S extends true
              ? FamiliesCountOutputType
              : S extends undefined
                ? never
                : S extends { include: any } & FamiliesCountOutputTypeArgs
                  ? FamiliesCountOutputType
                  : S extends { select: any } & FamiliesCountOutputTypeArgs
                    ? {
                          [P in TruthyKeys<S['select']>]: P extends keyof FamiliesCountOutputType
                              ? FamiliesCountOutputType[P]
                              : never
                      }
                    : FamiliesCountOutputType

    // Custom InputTypes

    /**
     * FamiliesCountOutputType without action
     */
    export type FamiliesCountOutputTypeArgs = {
        /**
         * Select specific fields to fetch from the FamiliesCountOutputType
         *
         **/
        select?: FamiliesCountOutputTypeSelect | null
    }

    /**
     * Count Type FurnishingsCountOutputType
     */

    export type FurnishingsCountOutputType = {
        family_furnishing: number
    }

    export type FurnishingsCountOutputTypeSelect = {
        family_furnishing?: boolean
    }

    export type FurnishingsCountOutputTypeGetPayload<
        S extends boolean | null | undefined | FurnishingsCountOutputTypeArgs
    > = S extends { select: any; include: any }
        ? 'Please either choose `select` or `include`'
        : S extends true
          ? FurnishingsCountOutputType
          : S extends undefined
            ? never
            : S extends { include: any } & FurnishingsCountOutputTypeArgs
              ? FurnishingsCountOutputType
              : S extends { select: any } & FurnishingsCountOutputTypeArgs
                ? {
                      [P in TruthyKeys<S['select']>]: P extends keyof FurnishingsCountOutputType
                          ? FurnishingsCountOutputType[P]
                          : never
                  }
                : FurnishingsCountOutputType

    // Custom InputTypes

    /**
     * FurnishingsCountOutputType without action
     */
    export type FurnishingsCountOutputTypeArgs = {
        /**
         * Select specific fields to fetch from the FurnishingsCountOutputType
         *
         **/
        select?: FurnishingsCountOutputTypeSelect | null
    }

    /**
     * Count Type HousingsCountOutputType
     */

    export type HousingsCountOutputType = {
        family_housing: number
    }

    export type HousingsCountOutputTypeSelect = {
        family_housing?: boolean
    }

    export type HousingsCountOutputTypeGetPayload<S extends boolean | null | undefined | HousingsCountOutputTypeArgs> =
        S extends { select: any; include: any }
            ? 'Please either choose `select` or `include`'
            : S extends true
              ? HousingsCountOutputType
              : S extends undefined
                ? never
                : S extends { include: any } & HousingsCountOutputTypeArgs
                  ? HousingsCountOutputType
                  : S extends { select: any } & HousingsCountOutputTypeArgs
                    ? {
                          [P in TruthyKeys<S['select']>]: P extends keyof HousingsCountOutputType
                              ? HousingsCountOutputType[P]
                              : never
                      }
                    : HousingsCountOutputType

    // Custom InputTypes

    /**
     * HousingsCountOutputType without action
     */
    export type HousingsCountOutputTypeArgs = {
        /**
         * Select specific fields to fetch from the HousingsCountOutputType
         *
         **/
        select?: HousingsCountOutputTypeSelect | null
    }

    /**
     * Count Type IncomesCountOutputType
     */

    export type IncomesCountOutputType = {
        income_sponsor: number
    }

    export type IncomesCountOutputTypeSelect = {
        income_sponsor?: boolean
    }

    export type IncomesCountOutputTypeGetPayload<S extends boolean | null | undefined | IncomesCountOutputTypeArgs> =
        S extends { select: any; include: any }
            ? 'Please either choose `select` or `include`'
            : S extends true
              ? IncomesCountOutputType
              : S extends undefined
                ? never
                : S extends { include: any } & IncomesCountOutputTypeArgs
                  ? IncomesCountOutputType
                  : S extends { select: any } & IncomesCountOutputTypeArgs
                    ? {
                          [P in TruthyKeys<S['select']>]: P extends keyof IncomesCountOutputType
                              ? IncomesCountOutputType[P]
                              : never
                      }
                    : IncomesCountOutputType

    // Custom InputTypes

    /**
     * IncomesCountOutputType without action
     */
    export type IncomesCountOutputTypeArgs = {
        /**
         * Select specific fields to fetch from the IncomesCountOutputType
         *
         **/
        select?: IncomesCountOutputTypeSelect | null
    }

    /**
     * Count Type OrphansCountOutputType
     */

    export type OrphansCountOutputType = {
        orphan_sponsorship: number
    }

    export type OrphansCountOutputTypeSelect = {
        orphan_sponsorship?: boolean
    }

    export type OrphansCountOutputTypeGetPayload<S extends boolean | null | undefined | OrphansCountOutputTypeArgs> =
        S extends { select: any; include: any }
            ? 'Please either choose `select` or `include`'
            : S extends true
              ? OrphansCountOutputType
              : S extends undefined
                ? never
                : S extends { include: any } & OrphansCountOutputTypeArgs
                  ? OrphansCountOutputType
                  : S extends { select: any } & OrphansCountOutputTypeArgs
                    ? {
                          [P in TruthyKeys<S['select']>]: P extends keyof OrphansCountOutputType
                              ? OrphansCountOutputType[P]
                              : never
                      }
                    : OrphansCountOutputType

    // Custom InputTypes

    /**
     * OrphansCountOutputType without action
     */
    export type OrphansCountOutputTypeArgs = {
        /**
         * Select specific fields to fetch from the OrphansCountOutputType
         *
         **/
        select?: OrphansCountOutputTypeSelect | null
    }

    /**
     * Count Type PermissionsCountOutputType
     */

    export type PermissionsCountOutputType = {
        model_has_permissions: number
        role_has_permissions: number
    }

    export type PermissionsCountOutputTypeSelect = {
        model_has_permissions?: boolean
        role_has_permissions?: boolean
    }

    export type PermissionsCountOutputTypeGetPayload<
        S extends boolean | null | undefined | PermissionsCountOutputTypeArgs
    > = S extends { select: any; include: any }
        ? 'Please either choose `select` or `include`'
        : S extends true
          ? PermissionsCountOutputType
          : S extends undefined
            ? never
            : S extends { include: any } & PermissionsCountOutputTypeArgs
              ? PermissionsCountOutputType
              : S extends { select: any } & PermissionsCountOutputTypeArgs
                ? {
                      [P in TruthyKeys<S['select']>]: P extends keyof PermissionsCountOutputType
                          ? PermissionsCountOutputType[P]
                          : never
                  }
                : PermissionsCountOutputType

    // Custom InputTypes

    /**
     * PermissionsCountOutputType without action
     */
    export type PermissionsCountOutputTypeArgs = {
        /**
         * Select specific fields to fetch from the PermissionsCountOutputType
         *
         **/
        select?: PermissionsCountOutputTypeSelect | null
    }

    /**
     * Count Type RolesCountOutputType
     */

    export type RolesCountOutputType = {
        model_has_roles: number
        role_has_permissions: number
    }

    export type RolesCountOutputTypeSelect = {
        model_has_roles?: boolean
        role_has_permissions?: boolean
    }

    export type RolesCountOutputTypeGetPayload<S extends boolean | null | undefined | RolesCountOutputTypeArgs> =
        S extends { select: any; include: any }
            ? 'Please either choose `select` or `include`'
            : S extends true
              ? RolesCountOutputType
              : S extends undefined
                ? never
                : S extends { include: any } & RolesCountOutputTypeArgs
                  ? RolesCountOutputType
                  : S extends { select: any } & RolesCountOutputTypeArgs
                    ? {
                          [P in TruthyKeys<S['select']>]: P extends keyof RolesCountOutputType
                              ? RolesCountOutputType[P]
                              : never
                      }
                    : RolesCountOutputType

    // Custom InputTypes

    /**
     * RolesCountOutputType without action
     */
    export type RolesCountOutputTypeArgs = {
        /**
         * Select specific fields to fetch from the RolesCountOutputType
         *
         **/
        select?: RolesCountOutputTypeSelect | null
    }

    /**
     * Count Type SponsorsCountOutputType
     */

    export type SponsorsCountOutputType = {
        income_sponsor: number
        sponsor_sponsorship: number
    }

    export type SponsorsCountOutputTypeSelect = {
        income_sponsor?: boolean
        sponsor_sponsorship?: boolean
    }

    export type SponsorsCountOutputTypeGetPayload<S extends boolean | null | undefined | SponsorsCountOutputTypeArgs> =
        S extends { select: any; include: any }
            ? 'Please either choose `select` or `include`'
            : S extends true
              ? SponsorsCountOutputType
              : S extends undefined
                ? never
                : S extends { include: any } & SponsorsCountOutputTypeArgs
                  ? SponsorsCountOutputType
                  : S extends { select: any } & SponsorsCountOutputTypeArgs
                    ? {
                          [P in TruthyKeys<S['select']>]: P extends keyof SponsorsCountOutputType
                              ? SponsorsCountOutputType[P]
                              : never
                      }
                    : SponsorsCountOutputType

    // Custom InputTypes

    /**
     * SponsorsCountOutputType without action
     */
    export type SponsorsCountOutputTypeArgs = {
        /**
         * Select specific fields to fetch from the SponsorsCountOutputType
         *
         **/
        select?: SponsorsCountOutputTypeSelect | null
    }

    /**
     * Count Type TenantsCountOutputType
     */

    export type TenantsCountOutputType = {
        benefactors: number
        domains: number
        families: number
        family_sponsorship: number
        income_sponsor: number
        orphan_sponsorship: number
        orphans: number
        second_sponsors: number
        sponsor_sponsorship: number
        sponsors: number
        sponsorships: number
        spouses: number
        users: number
    }

    export type TenantsCountOutputTypeSelect = {
        benefactors?: boolean
        domains?: boolean
        families?: boolean
        family_sponsorship?: boolean
        income_sponsor?: boolean
        orphan_sponsorship?: boolean
        orphans?: boolean
        second_sponsors?: boolean
        sponsor_sponsorship?: boolean
        sponsors?: boolean
        sponsorships?: boolean
        spouses?: boolean
        users?: boolean
    }

    export type TenantsCountOutputTypeGetPayload<S extends boolean | null | undefined | TenantsCountOutputTypeArgs> =
        S extends { select: any; include: any }
            ? 'Please either choose `select` or `include`'
            : S extends true
              ? TenantsCountOutputType
              : S extends undefined
                ? never
                : S extends { include: any } & TenantsCountOutputTypeArgs
                  ? TenantsCountOutputType
                  : S extends { select: any } & TenantsCountOutputTypeArgs
                    ? {
                          [P in TruthyKeys<S['select']>]: P extends keyof TenantsCountOutputType
                              ? TenantsCountOutputType[P]
                              : never
                      }
                    : TenantsCountOutputType

    // Custom InputTypes

    /**
     * TenantsCountOutputType without action
     */
    export type TenantsCountOutputTypeArgs = {
        /**
         * Select specific fields to fetch from the TenantsCountOutputType
         *
         **/
        select?: TenantsCountOutputTypeSelect | null
    }

    /**
     * Count Type UsersCountOutputType
     */

    export type UsersCountOutputType = {
        orphans_orphans_created_byTousers: number
        orphans_orphans_deleted_byTousers: number
        sessions: number
        settings: number
        sponsors_sponsors_created_byTousers: number
        sponsors_sponsors_deleted_byTousers: number
    }

    export type UsersCountOutputTypeSelect = {
        orphans_orphans_created_byTousers?: boolean
        orphans_orphans_deleted_byTousers?: boolean
        sessions?: boolean
        settings?: boolean
        sponsors_sponsors_created_byTousers?: boolean
        sponsors_sponsors_deleted_byTousers?: boolean
    }

    export type UsersCountOutputTypeGetPayload<S extends boolean | null | undefined | UsersCountOutputTypeArgs> =
        S extends { select: any; include: any }
            ? 'Please either choose `select` or `include`'
            : S extends true
              ? UsersCountOutputType
              : S extends undefined
                ? never
                : S extends { include: any } & UsersCountOutputTypeArgs
                  ? UsersCountOutputType
                  : S extends { select: any } & UsersCountOutputTypeArgs
                    ? {
                          [P in TruthyKeys<S['select']>]: P extends keyof UsersCountOutputType
                              ? UsersCountOutputType[P]
                              : never
                      }
                    : UsersCountOutputType

    // Custom InputTypes

    /**
     * UsersCountOutputType without action
     */
    export type UsersCountOutputTypeArgs = {
        /**
         * Select specific fields to fetch from the UsersCountOutputType
         *
         **/
        select?: UsersCountOutputTypeSelect | null
    }

    /**
     * Models
     */

    /**
     * Model Benefactors
     */

    export type AggregateBenefactors = {
        _count: BenefactorsCountAggregateOutputType | null
        _min: BenefactorsMinAggregateOutputType | null
        _max: BenefactorsMaxAggregateOutputType | null
    }

    export type BenefactorsMinAggregateOutputType = {
        id: string | null
        tenant_id: string | null
        deleted_at: Date | null
        created_at: Date | null
        updated_at: Date | null
    }

    export type BenefactorsMaxAggregateOutputType = {
        id: string | null
        tenant_id: string | null
        deleted_at: Date | null
        created_at: Date | null
        updated_at: Date | null
    }

    export type BenefactorsCountAggregateOutputType = {
        id: number
        tenant_id: number
        deleted_at: number
        created_at: number
        updated_at: number
        _all: number
    }

    export type BenefactorsMinAggregateInputType = {
        id?: true
        tenant_id?: true
        deleted_at?: true
        created_at?: true
        updated_at?: true
    }

    export type BenefactorsMaxAggregateInputType = {
        id?: true
        tenant_id?: true
        deleted_at?: true
        created_at?: true
        updated_at?: true
    }

    export type BenefactorsCountAggregateInputType = {
        id?: true
        tenant_id?: true
        deleted_at?: true
        created_at?: true
        updated_at?: true
        _all?: true
    }

    export type BenefactorsAggregateArgs = {
        /**
         * Filter which Benefactors to aggregate.
         *
         **/
        where?: BenefactorsWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Benefactors to fetch.
         *
         **/
        orderBy?: Enumerable<BenefactorsOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the start position
         *
         **/
        cursor?: BenefactorsWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Benefactors from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Benefactors.
         *
         **/
        skip?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Count returned Benefactors
         **/
        _count?: true | BenefactorsCountAggregateInputType
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to find the minimum value
         **/
        _min?: BenefactorsMinAggregateInputType
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to find the maximum value
         **/
        _max?: BenefactorsMaxAggregateInputType
    }

    export type GetBenefactorsAggregateType<T extends BenefactorsAggregateArgs> = {
        [P in keyof T & keyof AggregateBenefactors]: P extends '_count' | 'count'
            ? T[P] extends true
                ? number
                : GetScalarType<T[P], AggregateBenefactors[P]>
            : GetScalarType<T[P], AggregateBenefactors[P]>
    }

    export type BenefactorsGroupByArgs = {
        where?: BenefactorsWhereInput
        orderBy?: Enumerable<BenefactorsOrderByWithAggregationInput>
        by: Array<BenefactorsScalarFieldEnum>
        having?: BenefactorsScalarWhereWithAggregatesInput
        take?: number
        skip?: number
        _count?: BenefactorsCountAggregateInputType | true
        _min?: BenefactorsMinAggregateInputType
        _max?: BenefactorsMaxAggregateInputType
    }

    export type BenefactorsGroupByOutputType = {
        id: string
        tenant_id: string
        deleted_at: Date | null
        created_at: Date | null
        updated_at: Date | null
        _count: BenefactorsCountAggregateOutputType | null
        _min: BenefactorsMinAggregateOutputType | null
        _max: BenefactorsMaxAggregateOutputType | null
    }

    type GetBenefactorsGroupByPayload<T extends BenefactorsGroupByArgs> = PrismaPromise<
        Array<
            PickArray<BenefactorsGroupByOutputType, T['by']> & {
                [P in keyof T & keyof BenefactorsGroupByOutputType]: P extends '_count'
                    ? T[P] extends boolean
                        ? number
                        : GetScalarType<T[P], BenefactorsGroupByOutputType[P]>
                    : GetScalarType<T[P], BenefactorsGroupByOutputType[P]>
            }
        >
    >

    export type BenefactorsSelect = {
        id?: boolean
        tenant_id?: boolean
        deleted_at?: boolean
        created_at?: boolean
        updated_at?: boolean
        tenants?: boolean | TenantsArgs
    }

    export type BenefactorsInclude = {
        tenants?: boolean | TenantsArgs
    }

    export type BenefactorsGetPayload<S extends boolean | null | undefined | BenefactorsArgs> = S extends {
        select: any
        include: any
    }
        ? 'Please either choose `select` or `include`'
        : S extends true
          ? Benefactors
          : S extends undefined
            ? never
            : S extends { include: any } & (BenefactorsArgs | BenefactorsFindManyArgs)
              ? Benefactors & {
                    [P in TruthyKeys<S['include']>]: P extends 'tenants' ? TenantsGetPayload<S['include'][P]> : never
                }
              : S extends { select: any } & (BenefactorsArgs | BenefactorsFindManyArgs)
                ? {
                      [P in TruthyKeys<S['select']>]: P extends 'tenants'
                          ? TenantsGetPayload<S['select'][P]>
                          : P extends keyof Benefactors
                            ? Benefactors[P]
                            : never
                  }
                : Benefactors

    type BenefactorsCountArgs = Merge<
        Omit<BenefactorsFindManyArgs, 'select' | 'include'> & {
            select?: BenefactorsCountAggregateInputType | true
        }
    >

    export interface BenefactorsDelegate<
        GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined
    > {
        /**
         * Find zero or one Benefactors that matches the filter.
         * @param {BenefactorsFindUniqueArgs} args - Arguments to find a Benefactors
         * @example
         * // Get one Benefactors
         * const benefactors = await prisma.benefactors.findUnique({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findUnique<
            T extends BenefactorsFindUniqueArgs,
            LocalRejectSettings = T['rejectOnNotFound'] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined
        >(
            args: SelectSubset<T, BenefactorsFindUniqueArgs>
        ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Benefactors'> extends True
            ? Prisma__BenefactorsClient<BenefactorsGetPayload<T>>
            : Prisma__BenefactorsClient<BenefactorsGetPayload<T> | null, null>

        /**
         * Find one Benefactors that matches the filter or throw an error  with `error.code='P2025'`
         *     if no matches were found.
         * @param {BenefactorsFindUniqueOrThrowArgs} args - Arguments to find a Benefactors
         * @example
         * // Get one Benefactors
         * const benefactors = await prisma.benefactors.findUniqueOrThrow({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findUniqueOrThrow<T extends BenefactorsFindUniqueOrThrowArgs>(
            args?: SelectSubset<T, BenefactorsFindUniqueOrThrowArgs>
        ): Prisma__BenefactorsClient<BenefactorsGetPayload<T>>

        /**
         * Find the first Benefactors that matches the filter.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {BenefactorsFindFirstArgs} args - Arguments to find a Benefactors
         * @example
         * // Get one Benefactors
         * const benefactors = await prisma.benefactors.findFirst({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findFirst<
            T extends BenefactorsFindFirstArgs,
            LocalRejectSettings = T['rejectOnNotFound'] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined
        >(
            args?: SelectSubset<T, BenefactorsFindFirstArgs>
        ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Benefactors'> extends True
            ? Prisma__BenefactorsClient<BenefactorsGetPayload<T>>
            : Prisma__BenefactorsClient<BenefactorsGetPayload<T> | null, null>

        /**
         * Find the first Benefactors that matches the filter or
         * throw `NotFoundError` if no matches were found.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {BenefactorsFindFirstOrThrowArgs} args - Arguments to find a Benefactors
         * @example
         * // Get one Benefactors
         * const benefactors = await prisma.benefactors.findFirstOrThrow({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findFirstOrThrow<T extends BenefactorsFindFirstOrThrowArgs>(
            args?: SelectSubset<T, BenefactorsFindFirstOrThrowArgs>
        ): Prisma__BenefactorsClient<BenefactorsGetPayload<T>>

        /**
         * Find zero or more Benefactors that matches the filter.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {BenefactorsFindManyArgs=} args - Arguments to filter and select certain fields only.
         * @example
         * // Get all Benefactors
         * const benefactors = await prisma.benefactors.findMany()
         *
         * // Get first 10 Benefactors
         * const benefactors = await prisma.benefactors.findMany({ take: 10 })
         *
         * // Only select the `id`
         * const benefactorsWithIdOnly = await prisma.benefactors.findMany({ select: { id: true } })
         *
         **/
        findMany<T extends BenefactorsFindManyArgs>(
            args?: SelectSubset<T, BenefactorsFindManyArgs>
        ): PrismaPromise<Array<BenefactorsGetPayload<T>>>

        /**
         * Create a Benefactors.
         * @param {BenefactorsCreateArgs} args - Arguments to create a Benefactors.
         * @example
         * // Create one Benefactors
         * const Benefactors = await prisma.benefactors.create({
         *   data: {
         *     // ... data to create a Benefactors
         *   }
         * })
         *
         **/
        create<T extends BenefactorsCreateArgs>(
            args: SelectSubset<T, BenefactorsCreateArgs>
        ): Prisma__BenefactorsClient<BenefactorsGetPayload<T>>

        /**
         * Create many Benefactors.
         *     @param {BenefactorsCreateManyArgs} args - Arguments to create many Benefactors.
         *     @example
         *     // Create many Benefactors
         *     const benefactors = await prisma.benefactors.createMany({
         *       data: {
         *         // ... provide data here
         *       }
         *     })
         *
         **/
        createMany<T extends BenefactorsCreateManyArgs>(
            args?: SelectSubset<T, BenefactorsCreateManyArgs>
        ): PrismaPromise<BatchPayload>

        /**
         * Delete a Benefactors.
         * @param {BenefactorsDeleteArgs} args - Arguments to delete one Benefactors.
         * @example
         * // Delete one Benefactors
         * const Benefactors = await prisma.benefactors.delete({
         *   where: {
         *     // ... filter to delete one Benefactors
         *   }
         * })
         *
         **/
        delete<T extends BenefactorsDeleteArgs>(
            args: SelectSubset<T, BenefactorsDeleteArgs>
        ): Prisma__BenefactorsClient<BenefactorsGetPayload<T>>

        /**
         * Update one Benefactors.
         * @param {BenefactorsUpdateArgs} args - Arguments to update one Benefactors.
         * @example
         * // Update one Benefactors
         * const benefactors = await prisma.benefactors.update({
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: {
         *     // ... provide data here
         *   }
         * })
         *
         **/
        update<T extends BenefactorsUpdateArgs>(
            args: SelectSubset<T, BenefactorsUpdateArgs>
        ): Prisma__BenefactorsClient<BenefactorsGetPayload<T>>

        /**
         * Delete zero or more Benefactors.
         * @param {BenefactorsDeleteManyArgs} args - Arguments to filter Benefactors to delete.
         * @example
         * // Delete a few Benefactors
         * const { count } = await prisma.benefactors.deleteMany({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         *
         **/
        deleteMany<T extends BenefactorsDeleteManyArgs>(
            args?: SelectSubset<T, BenefactorsDeleteManyArgs>
        ): PrismaPromise<BatchPayload>

        /**
         * Update zero or more Benefactors.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {BenefactorsUpdateManyArgs} args - Arguments to update one or more rows.
         * @example
         * // Update many Benefactors
         * const benefactors = await prisma.benefactors.updateMany({
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: {
         *     // ... provide data here
         *   }
         * })
         *
         **/
        updateMany<T extends BenefactorsUpdateManyArgs>(
            args: SelectSubset<T, BenefactorsUpdateManyArgs>
        ): PrismaPromise<BatchPayload>

        /**
         * Create or update one Benefactors.
         * @param {BenefactorsUpsertArgs} args - Arguments to update or create a Benefactors.
         * @example
         * // Update or create a Benefactors
         * const benefactors = await prisma.benefactors.upsert({
         *   create: {
         *     // ... data to create a Benefactors
         *   },
         *   update: {
         *     // ... in case it already exists, update
         *   },
         *   where: {
         *     // ... the filter for the Benefactors we want to update
         *   }
         * })
         **/
        upsert<T extends BenefactorsUpsertArgs>(
            args: SelectSubset<T, BenefactorsUpsertArgs>
        ): Prisma__BenefactorsClient<BenefactorsGetPayload<T>>

        /**
         * Count the number of Benefactors.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {BenefactorsCountArgs} args - Arguments to filter Benefactors to count.
         * @example
         * // Count the number of Benefactors
         * const count = await prisma.benefactors.count({
         *   where: {
         *     // ... the filter for the Benefactors we want to count
         *   }
         * })
         **/
        count<T extends BenefactorsCountArgs>(
            args?: Subset<T, BenefactorsCountArgs>
        ): PrismaPromise<
            T extends _Record<'select', any>
                ? T['select'] extends true
                    ? number
                    : GetScalarType<T['select'], BenefactorsCountAggregateOutputType>
                : number
        >

        /**
         * Allows you to perform aggregations operations on a Benefactors.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {BenefactorsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
         * @example
         * // Ordered by age ascending
         * // Where email contains prisma.io
         * // Limited to the 10 users
         * const aggregations = await prisma.user.aggregate({
         *   _avg: {
         *     age: true,
         *   },
         *   where: {
         *     email: {
         *       contains: "prisma.io",
         *     },
         *   },
         *   orderBy: {
         *     age: "asc",
         *   },
         *   take: 10,
         * })
         **/
        aggregate<T extends BenefactorsAggregateArgs>(
            args: Subset<T, BenefactorsAggregateArgs>
        ): PrismaPromise<GetBenefactorsAggregateType<T>>

        /**
         * Group by Benefactors.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {BenefactorsGroupByArgs} args - Group by arguments.
         * @example
         * // Group by city, order by createdAt, get count
         * const result = await prisma.user.groupBy({
         *   by: ['city', 'createdAt'],
         *   orderBy: {
         *     createdAt: true
         *   },
         *   _count: {
         *     _all: true
         *   },
         * })
         *
         **/
        groupBy<
            T extends BenefactorsGroupByArgs,
            HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
            OrderByArg extends True extends HasSelectOrTake
                ? { orderBy: BenefactorsGroupByArgs['orderBy'] }
                : { orderBy?: BenefactorsGroupByArgs['orderBy'] },
            OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
            ByFields extends TupleToUnion<T['by']>,
            ByValid extends Has<ByFields, OrderFields>,
            HavingFields extends GetHavingFields<T['having']>,
            HavingValid extends Has<ByFields, HavingFields>,
            ByEmpty extends T['by'] extends never[] ? True : False,
            InputErrors extends ByEmpty extends True
                ? `Error: "by" must not be empty.`
                : HavingValid extends False
                  ? {
                        [P in HavingFields]: P extends ByFields
                            ? never
                            : P extends string
                              ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                              : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`]
                    }[HavingFields]
                  : 'take' extends Keys<T>
                    ? 'orderBy' extends Keys<T>
                        ? ByValid extends True
                            ? {}
                            : {
                                  [P in OrderFields]: P extends ByFields
                                      ? never
                                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                              }[OrderFields]
                        : 'Error: If you provide "take", you also need to provide "orderBy"'
                    : 'skip' extends Keys<T>
                      ? 'orderBy' extends Keys<T>
                          ? ByValid extends True
                              ? {}
                              : {
                                    [P in OrderFields]: P extends ByFields
                                        ? never
                                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                                }[OrderFields]
                          : 'Error: If you provide "skip", you also need to provide "orderBy"'
                      : ByValid extends True
                        ? {}
                        : {
                              [P in OrderFields]: P extends ByFields
                                  ? never
                                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                          }[OrderFields]
        >(
            args: SubsetIntersection<T, BenefactorsGroupByArgs, OrderByArg> & InputErrors
        ): {} extends InputErrors ? GetBenefactorsGroupByPayload<T> : PrismaPromise<InputErrors>
    }

    /**
     * The delegate class that acts as a "Promise-like" for Benefactors.
     * Why is this prefixed with `Prisma__`?
     * Because we want to prevent naming conflicts as mentioned in
     * https://github.com/prisma/prisma-client-js/issues/707
     */
    export class Prisma__BenefactorsClient<T, Null = never> implements PrismaPromise<T> {
        [prisma]: true
        private readonly _dmmf
        private readonly _fetcher
        private readonly _queryType
        private readonly _rootField
        private readonly _clientMethod
        private readonly _args
        private readonly _dataPath
        private readonly _errorFormat
        private readonly _measurePerformance?
        private _isList
        private _callsite
        private _requestPromise?
        constructor(
            _dmmf: runtime.DMMFClass,
            _fetcher: PrismaClientFetcher,
            _queryType: 'query' | 'mutation',
            _rootField: string,
            _clientMethod: string,
            _args: any,
            _dataPath: string[],
            _errorFormat: ErrorFormat,
            _measurePerformance?: boolean | undefined,
            _isList?: boolean
        )
        readonly [Symbol.toStringTag]: 'PrismaClientPromise'

        tenants<T extends TenantsArgs = {}>(
            args?: Subset<T, TenantsArgs>
        ): Prisma__TenantsClient<TenantsGetPayload<T> | Null>

        private get _document()
        /**
         * Attaches callbacks for the resolution and/or rejection of the Promise.
         * @param onfulfilled The callback to execute when the Promise is resolved.
         * @param onrejected The callback to execute when the Promise is rejected.
         * @returns A Promise for the completion of which ever callback is executed.
         */
        then<TResult1 = T, TResult2 = never>(
            onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
            onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
        ): Promise<TResult1 | TResult2>
        /**
         * Attaches a callback for only the rejection of the Promise.
         * @param onrejected The callback to execute when the Promise is rejected.
         * @returns A Promise for the completion of the callback.
         */
        catch<TResult = never>(
            onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
        ): Promise<T | TResult>
        /**
         * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
         * resolved value cannot be modified from the callback.
         * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
         * @returns A Promise for the completion of the callback.
         */
        finally(onfinally?: (() => void) | undefined | null): Promise<T>
    }

    // Custom InputTypes

    /**
     * Benefactors base type for findUnique actions
     */
    export type BenefactorsFindUniqueArgsBase = {
        /**
         * Select specific fields to fetch from the Benefactors
         *
         **/
        select?: BenefactorsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: BenefactorsInclude | null
        /**
         * Filter, which Benefactors to fetch.
         *
         **/
        where: BenefactorsWhereUniqueInput
    }

    /**
     * Benefactors findUnique
     */
    export interface BenefactorsFindUniqueArgs extends BenefactorsFindUniqueArgsBase {
        /**
         * Throw an Error if query returns no results
         * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
         */
        rejectOnNotFound?: RejectOnNotFound
    }

    /**
     * Benefactors findUniqueOrThrow
     */
    export type BenefactorsFindUniqueOrThrowArgs = {
        /**
         * Select specific fields to fetch from the Benefactors
         *
         **/
        select?: BenefactorsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: BenefactorsInclude | null
        /**
         * Filter, which Benefactors to fetch.
         *
         **/
        where: BenefactorsWhereUniqueInput
    }

    /**
     * Benefactors base type for findFirst actions
     */
    export type BenefactorsFindFirstArgsBase = {
        /**
         * Select specific fields to fetch from the Benefactors
         *
         **/
        select?: BenefactorsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: BenefactorsInclude | null
        /**
         * Filter, which Benefactors to fetch.
         *
         **/
        where?: BenefactorsWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Benefactors to fetch.
         *
         **/
        orderBy?: Enumerable<BenefactorsOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for searching for Benefactors.
         *
         **/
        cursor?: BenefactorsWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Benefactors from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Benefactors.
         *
         **/
        skip?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
         *
         * Filter by unique combinations of Benefactors.
         *
         **/
        distinct?: Enumerable<BenefactorsScalarFieldEnum>
    }

    /**
     * Benefactors findFirst
     */
    export interface BenefactorsFindFirstArgs extends BenefactorsFindFirstArgsBase {
        /**
         * Throw an Error if query returns no results
         * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
         */
        rejectOnNotFound?: RejectOnNotFound
    }

    /**
     * Benefactors findFirstOrThrow
     */
    export type BenefactorsFindFirstOrThrowArgs = {
        /**
         * Select specific fields to fetch from the Benefactors
         *
         **/
        select?: BenefactorsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: BenefactorsInclude | null
        /**
         * Filter, which Benefactors to fetch.
         *
         **/
        where?: BenefactorsWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Benefactors to fetch.
         *
         **/
        orderBy?: Enumerable<BenefactorsOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for searching for Benefactors.
         *
         **/
        cursor?: BenefactorsWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Benefactors from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Benefactors.
         *
         **/
        skip?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
         *
         * Filter by unique combinations of Benefactors.
         *
         **/
        distinct?: Enumerable<BenefactorsScalarFieldEnum>
    }

    /**
     * Benefactors findMany
     */
    export type BenefactorsFindManyArgs = {
        /**
         * Select specific fields to fetch from the Benefactors
         *
         **/
        select?: BenefactorsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: BenefactorsInclude | null
        /**
         * Filter, which Benefactors to fetch.
         *
         **/
        where?: BenefactorsWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Benefactors to fetch.
         *
         **/
        orderBy?: Enumerable<BenefactorsOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for listing Benefactors.
         *
         **/
        cursor?: BenefactorsWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Benefactors from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Benefactors.
         *
         **/
        skip?: number
        distinct?: Enumerable<BenefactorsScalarFieldEnum>
    }

    /**
     * Benefactors create
     */
    export type BenefactorsCreateArgs = {
        /**
         * Select specific fields to fetch from the Benefactors
         *
         **/
        select?: BenefactorsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: BenefactorsInclude | null
        /**
         * The data needed to create a Benefactors.
         *
         **/
        data: XOR<BenefactorsCreateInput, BenefactorsUncheckedCreateInput>
    }

    /**
     * Benefactors createMany
     */
    export type BenefactorsCreateManyArgs = {
        /**
         * The data used to create many Benefactors.
         *
         **/
        data: Enumerable<BenefactorsCreateManyInput>
        skipDuplicates?: boolean
    }

    /**
     * Benefactors update
     */
    export type BenefactorsUpdateArgs = {
        /**
         * Select specific fields to fetch from the Benefactors
         *
         **/
        select?: BenefactorsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: BenefactorsInclude | null
        /**
         * The data needed to update a Benefactors.
         *
         **/
        data: XOR<BenefactorsUpdateInput, BenefactorsUncheckedUpdateInput>
        /**
         * Choose, which Benefactors to update.
         *
         **/
        where: BenefactorsWhereUniqueInput
    }

    /**
     * Benefactors updateMany
     */
    export type BenefactorsUpdateManyArgs = {
        /**
         * The data used to update Benefactors.
         *
         **/
        data: XOR<BenefactorsUpdateManyMutationInput, BenefactorsUncheckedUpdateManyInput>
        /**
         * Filter which Benefactors to update
         *
         **/
        where?: BenefactorsWhereInput
    }

    /**
     * Benefactors upsert
     */
    export type BenefactorsUpsertArgs = {
        /**
         * Select specific fields to fetch from the Benefactors
         *
         **/
        select?: BenefactorsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: BenefactorsInclude | null
        /**
         * The filter to search for the Benefactors to update in case it exists.
         *
         **/
        where: BenefactorsWhereUniqueInput
        /**
         * In case the Benefactors found by the `where` argument doesn't exist, create a new Benefactors with this data.
         *
         **/
        create: XOR<BenefactorsCreateInput, BenefactorsUncheckedCreateInput>
        /**
         * In case the Benefactors was found with the provided `where` argument, update it with this data.
         *
         **/
        update: XOR<BenefactorsUpdateInput, BenefactorsUncheckedUpdateInput>
    }

    /**
     * Benefactors delete
     */
    export type BenefactorsDeleteArgs = {
        /**
         * Select specific fields to fetch from the Benefactors
         *
         **/
        select?: BenefactorsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: BenefactorsInclude | null
        /**
         * Filter which Benefactors to delete.
         *
         **/
        where: BenefactorsWhereUniqueInput
    }

    /**
     * Benefactors deleteMany
     */
    export type BenefactorsDeleteManyArgs = {
        /**
         * Filter which Benefactors to delete
         *
         **/
        where?: BenefactorsWhereInput
    }

    /**
     * Benefactors without action
     */
    export type BenefactorsArgs = {
        /**
         * Select specific fields to fetch from the Benefactors
         *
         **/
        select?: BenefactorsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: BenefactorsInclude | null
    }

    /**
     * Model Cache
     */

    export type AggregateCache = {
        _count: CacheCountAggregateOutputType | null
        _avg: CacheAvgAggregateOutputType | null
        _sum: CacheSumAggregateOutputType | null
        _min: CacheMinAggregateOutputType | null
        _max: CacheMaxAggregateOutputType | null
    }

    export type CacheAvgAggregateOutputType = {
        expiration: number | null
    }

    export type CacheSumAggregateOutputType = {
        expiration: number | null
    }

    export type CacheMinAggregateOutputType = {
        key: string | null
        value: string | null
        expiration: number | null
    }

    export type CacheMaxAggregateOutputType = {
        key: string | null
        value: string | null
        expiration: number | null
    }

    export type CacheCountAggregateOutputType = {
        key: number
        value: number
        expiration: number
        _all: number
    }

    export type CacheAvgAggregateInputType = {
        expiration?: true
    }

    export type CacheSumAggregateInputType = {
        expiration?: true
    }

    export type CacheMinAggregateInputType = {
        key?: true
        value?: true
        expiration?: true
    }

    export type CacheMaxAggregateInputType = {
        key?: true
        value?: true
        expiration?: true
    }

    export type CacheCountAggregateInputType = {
        key?: true
        value?: true
        expiration?: true
        _all?: true
    }

    export type CacheAggregateArgs = {
        /**
         * Filter which Cache to aggregate.
         *
         **/
        where?: CacheWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Caches to fetch.
         *
         **/
        orderBy?: Enumerable<CacheOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the start position
         *
         **/
        cursor?: CacheWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Caches from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Caches.
         *
         **/
        skip?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Count returned Caches
         **/
        _count?: true | CacheCountAggregateInputType
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to average
         **/
        _avg?: CacheAvgAggregateInputType
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to sum
         **/
        _sum?: CacheSumAggregateInputType
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to find the minimum value
         **/
        _min?: CacheMinAggregateInputType
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to find the maximum value
         **/
        _max?: CacheMaxAggregateInputType
    }

    export type GetCacheAggregateType<T extends CacheAggregateArgs> = {
        [P in keyof T & keyof AggregateCache]: P extends '_count' | 'count'
            ? T[P] extends true
                ? number
                : GetScalarType<T[P], AggregateCache[P]>
            : GetScalarType<T[P], AggregateCache[P]>
    }

    export type CacheGroupByArgs = {
        where?: CacheWhereInput
        orderBy?: Enumerable<CacheOrderByWithAggregationInput>
        by: Array<CacheScalarFieldEnum>
        having?: CacheScalarWhereWithAggregatesInput
        take?: number
        skip?: number
        _count?: CacheCountAggregateInputType | true
        _avg?: CacheAvgAggregateInputType
        _sum?: CacheSumAggregateInputType
        _min?: CacheMinAggregateInputType
        _max?: CacheMaxAggregateInputType
    }

    export type CacheGroupByOutputType = {
        key: string
        value: string
        expiration: number
        _count: CacheCountAggregateOutputType | null
        _avg: CacheAvgAggregateOutputType | null
        _sum: CacheSumAggregateOutputType | null
        _min: CacheMinAggregateOutputType | null
        _max: CacheMaxAggregateOutputType | null
    }

    type GetCacheGroupByPayload<T extends CacheGroupByArgs> = PrismaPromise<
        Array<
            PickArray<CacheGroupByOutputType, T['by']> & {
                [P in keyof T & keyof CacheGroupByOutputType]: P extends '_count'
                    ? T[P] extends boolean
                        ? number
                        : GetScalarType<T[P], CacheGroupByOutputType[P]>
                    : GetScalarType<T[P], CacheGroupByOutputType[P]>
            }
        >
    >

    export type CacheSelect = {
        key?: boolean
        value?: boolean
        expiration?: boolean
    }

    export type CacheGetPayload<S extends boolean | null | undefined | CacheArgs> = S extends {
        select: any
        include: any
    }
        ? 'Please either choose `select` or `include`'
        : S extends true
          ? Cache
          : S extends undefined
            ? never
            : S extends { include: any } & (CacheArgs | CacheFindManyArgs)
              ? Cache
              : S extends { select: any } & (CacheArgs | CacheFindManyArgs)
                ? {
                      [P in TruthyKeys<S['select']>]: P extends keyof Cache ? Cache[P] : never
                  }
                : Cache

    type CacheCountArgs = Merge<
        Omit<CacheFindManyArgs, 'select' | 'include'> & {
            select?: CacheCountAggregateInputType | true
        }
    >

    export interface CacheDelegate<
        GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined
    > {
        /**
         * Find zero or one Cache that matches the filter.
         * @param {CacheFindUniqueArgs} args - Arguments to find a Cache
         * @example
         * // Get one Cache
         * const cache = await prisma.cache.findUnique({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findUnique<
            T extends CacheFindUniqueArgs,
            LocalRejectSettings = T['rejectOnNotFound'] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined
        >(
            args: SelectSubset<T, CacheFindUniqueArgs>
        ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Cache'> extends True
            ? Prisma__CacheClient<CacheGetPayload<T>>
            : Prisma__CacheClient<CacheGetPayload<T> | null, null>

        /**
         * Find one Cache that matches the filter or throw an error  with `error.code='P2025'`
         *     if no matches were found.
         * @param {CacheFindUniqueOrThrowArgs} args - Arguments to find a Cache
         * @example
         * // Get one Cache
         * const cache = await prisma.cache.findUniqueOrThrow({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findUniqueOrThrow<T extends CacheFindUniqueOrThrowArgs>(
            args?: SelectSubset<T, CacheFindUniqueOrThrowArgs>
        ): Prisma__CacheClient<CacheGetPayload<T>>

        /**
         * Find the first Cache that matches the filter.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {CacheFindFirstArgs} args - Arguments to find a Cache
         * @example
         * // Get one Cache
         * const cache = await prisma.cache.findFirst({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findFirst<
            T extends CacheFindFirstArgs,
            LocalRejectSettings = T['rejectOnNotFound'] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined
        >(
            args?: SelectSubset<T, CacheFindFirstArgs>
        ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Cache'> extends True
            ? Prisma__CacheClient<CacheGetPayload<T>>
            : Prisma__CacheClient<CacheGetPayload<T> | null, null>

        /**
         * Find the first Cache that matches the filter or
         * throw `NotFoundError` if no matches were found.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {CacheFindFirstOrThrowArgs} args - Arguments to find a Cache
         * @example
         * // Get one Cache
         * const cache = await prisma.cache.findFirstOrThrow({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findFirstOrThrow<T extends CacheFindFirstOrThrowArgs>(
            args?: SelectSubset<T, CacheFindFirstOrThrowArgs>
        ): Prisma__CacheClient<CacheGetPayload<T>>

        /**
         * Find zero or more Caches that matches the filter.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {CacheFindManyArgs=} args - Arguments to filter and select certain fields only.
         * @example
         * // Get all Caches
         * const caches = await prisma.cache.findMany()
         *
         * // Get first 10 Caches
         * const caches = await prisma.cache.findMany({ take: 10 })
         *
         * // Only select the `key`
         * const cacheWithKeyOnly = await prisma.cache.findMany({ select: { key: true } })
         *
         **/
        findMany<T extends CacheFindManyArgs>(
            args?: SelectSubset<T, CacheFindManyArgs>
        ): PrismaPromise<Array<CacheGetPayload<T>>>

        /**
         * Create a Cache.
         * @param {CacheCreateArgs} args - Arguments to create a Cache.
         * @example
         * // Create one Cache
         * const Cache = await prisma.cache.create({
         *   data: {
         *     // ... data to create a Cache
         *   }
         * })
         *
         **/
        create<T extends CacheCreateArgs>(
            args: SelectSubset<T, CacheCreateArgs>
        ): Prisma__CacheClient<CacheGetPayload<T>>

        /**
         * Create many Caches.
         *     @param {CacheCreateManyArgs} args - Arguments to create many Caches.
         *     @example
         *     // Create many Caches
         *     const cache = await prisma.cache.createMany({
         *       data: {
         *         // ... provide data here
         *       }
         *     })
         *
         **/
        createMany<T extends CacheCreateManyArgs>(
            args?: SelectSubset<T, CacheCreateManyArgs>
        ): PrismaPromise<BatchPayload>

        /**
         * Delete a Cache.
         * @param {CacheDeleteArgs} args - Arguments to delete one Cache.
         * @example
         * // Delete one Cache
         * const Cache = await prisma.cache.delete({
         *   where: {
         *     // ... filter to delete one Cache
         *   }
         * })
         *
         **/
        delete<T extends CacheDeleteArgs>(
            args: SelectSubset<T, CacheDeleteArgs>
        ): Prisma__CacheClient<CacheGetPayload<T>>

        /**
         * Update one Cache.
         * @param {CacheUpdateArgs} args - Arguments to update one Cache.
         * @example
         * // Update one Cache
         * const cache = await prisma.cache.update({
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: {
         *     // ... provide data here
         *   }
         * })
         *
         **/
        update<T extends CacheUpdateArgs>(
            args: SelectSubset<T, CacheUpdateArgs>
        ): Prisma__CacheClient<CacheGetPayload<T>>

        /**
         * Delete zero or more Caches.
         * @param {CacheDeleteManyArgs} args - Arguments to filter Caches to delete.
         * @example
         * // Delete a few Caches
         * const { count } = await prisma.cache.deleteMany({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         *
         **/
        deleteMany<T extends CacheDeleteManyArgs>(
            args?: SelectSubset<T, CacheDeleteManyArgs>
        ): PrismaPromise<BatchPayload>

        /**
         * Update zero or more Caches.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {CacheUpdateManyArgs} args - Arguments to update one or more rows.
         * @example
         * // Update many Caches
         * const cache = await prisma.cache.updateMany({
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: {
         *     // ... provide data here
         *   }
         * })
         *
         **/
        updateMany<T extends CacheUpdateManyArgs>(
            args: SelectSubset<T, CacheUpdateManyArgs>
        ): PrismaPromise<BatchPayload>

        /**
         * Create or update one Cache.
         * @param {CacheUpsertArgs} args - Arguments to update or create a Cache.
         * @example
         * // Update or create a Cache
         * const cache = await prisma.cache.upsert({
         *   create: {
         *     // ... data to create a Cache
         *   },
         *   update: {
         *     // ... in case it already exists, update
         *   },
         *   where: {
         *     // ... the filter for the Cache we want to update
         *   }
         * })
         **/
        upsert<T extends CacheUpsertArgs>(
            args: SelectSubset<T, CacheUpsertArgs>
        ): Prisma__CacheClient<CacheGetPayload<T>>

        /**
         * Count the number of Caches.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {CacheCountArgs} args - Arguments to filter Caches to count.
         * @example
         * // Count the number of Caches
         * const count = await prisma.cache.count({
         *   where: {
         *     // ... the filter for the Caches we want to count
         *   }
         * })
         **/
        count<T extends CacheCountArgs>(
            args?: Subset<T, CacheCountArgs>
        ): PrismaPromise<
            T extends _Record<'select', any>
                ? T['select'] extends true
                    ? number
                    : GetScalarType<T['select'], CacheCountAggregateOutputType>
                : number
        >

        /**
         * Allows you to perform aggregations operations on a Cache.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {CacheAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
         * @example
         * // Ordered by age ascending
         * // Where email contains prisma.io
         * // Limited to the 10 users
         * const aggregations = await prisma.user.aggregate({
         *   _avg: {
         *     age: true,
         *   },
         *   where: {
         *     email: {
         *       contains: "prisma.io",
         *     },
         *   },
         *   orderBy: {
         *     age: "asc",
         *   },
         *   take: 10,
         * })
         **/
        aggregate<T extends CacheAggregateArgs>(
            args: Subset<T, CacheAggregateArgs>
        ): PrismaPromise<GetCacheAggregateType<T>>

        /**
         * Group by Cache.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {CacheGroupByArgs} args - Group by arguments.
         * @example
         * // Group by city, order by createdAt, get count
         * const result = await prisma.user.groupBy({
         *   by: ['city', 'createdAt'],
         *   orderBy: {
         *     createdAt: true
         *   },
         *   _count: {
         *     _all: true
         *   },
         * })
         *
         **/
        groupBy<
            T extends CacheGroupByArgs,
            HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
            OrderByArg extends True extends HasSelectOrTake
                ? { orderBy: CacheGroupByArgs['orderBy'] }
                : { orderBy?: CacheGroupByArgs['orderBy'] },
            OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
            ByFields extends TupleToUnion<T['by']>,
            ByValid extends Has<ByFields, OrderFields>,
            HavingFields extends GetHavingFields<T['having']>,
            HavingValid extends Has<ByFields, HavingFields>,
            ByEmpty extends T['by'] extends never[] ? True : False,
            InputErrors extends ByEmpty extends True
                ? `Error: "by" must not be empty.`
                : HavingValid extends False
                  ? {
                        [P in HavingFields]: P extends ByFields
                            ? never
                            : P extends string
                              ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                              : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`]
                    }[HavingFields]
                  : 'take' extends Keys<T>
                    ? 'orderBy' extends Keys<T>
                        ? ByValid extends True
                            ? {}
                            : {
                                  [P in OrderFields]: P extends ByFields
                                      ? never
                                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                              }[OrderFields]
                        : 'Error: If you provide "take", you also need to provide "orderBy"'
                    : 'skip' extends Keys<T>
                      ? 'orderBy' extends Keys<T>
                          ? ByValid extends True
                              ? {}
                              : {
                                    [P in OrderFields]: P extends ByFields
                                        ? never
                                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                                }[OrderFields]
                          : 'Error: If you provide "skip", you also need to provide "orderBy"'
                      : ByValid extends True
                        ? {}
                        : {
                              [P in OrderFields]: P extends ByFields
                                  ? never
                                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                          }[OrderFields]
        >(
            args: SubsetIntersection<T, CacheGroupByArgs, OrderByArg> & InputErrors
        ): {} extends InputErrors ? GetCacheGroupByPayload<T> : PrismaPromise<InputErrors>
    }

    /**
     * The delegate class that acts as a "Promise-like" for Cache.
     * Why is this prefixed with `Prisma__`?
     * Because we want to prevent naming conflicts as mentioned in
     * https://github.com/prisma/prisma-client-js/issues/707
     */
    export class Prisma__CacheClient<T, Null = never> implements PrismaPromise<T> {
        [prisma]: true
        private readonly _dmmf
        private readonly _fetcher
        private readonly _queryType
        private readonly _rootField
        private readonly _clientMethod
        private readonly _args
        private readonly _dataPath
        private readonly _errorFormat
        private readonly _measurePerformance?
        private _isList
        private _callsite
        private _requestPromise?
        constructor(
            _dmmf: runtime.DMMFClass,
            _fetcher: PrismaClientFetcher,
            _queryType: 'query' | 'mutation',
            _rootField: string,
            _clientMethod: string,
            _args: any,
            _dataPath: string[],
            _errorFormat: ErrorFormat,
            _measurePerformance?: boolean | undefined,
            _isList?: boolean
        )
        readonly [Symbol.toStringTag]: 'PrismaClientPromise'

        private get _document()
        /**
         * Attaches callbacks for the resolution and/or rejection of the Promise.
         * @param onfulfilled The callback to execute when the Promise is resolved.
         * @param onrejected The callback to execute when the Promise is rejected.
         * @returns A Promise for the completion of which ever callback is executed.
         */
        then<TResult1 = T, TResult2 = never>(
            onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
            onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
        ): Promise<TResult1 | TResult2>
        /**
         * Attaches a callback for only the rejection of the Promise.
         * @param onrejected The callback to execute when the Promise is rejected.
         * @returns A Promise for the completion of the callback.
         */
        catch<TResult = never>(
            onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
        ): Promise<T | TResult>
        /**
         * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
         * resolved value cannot be modified from the callback.
         * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
         * @returns A Promise for the completion of the callback.
         */
        finally(onfinally?: (() => void) | undefined | null): Promise<T>
    }

    // Custom InputTypes

    /**
     * Cache base type for findUnique actions
     */
    export type CacheFindUniqueArgsBase = {
        /**
         * Select specific fields to fetch from the Cache
         *
         **/
        select?: CacheSelect | null
        /**
         * Filter, which Cache to fetch.
         *
         **/
        where: CacheWhereUniqueInput
    }

    /**
     * Cache findUnique
     */
    export interface CacheFindUniqueArgs extends CacheFindUniqueArgsBase {
        /**
         * Throw an Error if query returns no results
         * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
         */
        rejectOnNotFound?: RejectOnNotFound
    }

    /**
     * Cache findUniqueOrThrow
     */
    export type CacheFindUniqueOrThrowArgs = {
        /**
         * Select specific fields to fetch from the Cache
         *
         **/
        select?: CacheSelect | null
        /**
         * Filter, which Cache to fetch.
         *
         **/
        where: CacheWhereUniqueInput
    }

    /**
     * Cache base type for findFirst actions
     */
    export type CacheFindFirstArgsBase = {
        /**
         * Select specific fields to fetch from the Cache
         *
         **/
        select?: CacheSelect | null
        /**
         * Filter, which Cache to fetch.
         *
         **/
        where?: CacheWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Caches to fetch.
         *
         **/
        orderBy?: Enumerable<CacheOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for searching for Caches.
         *
         **/
        cursor?: CacheWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Caches from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Caches.
         *
         **/
        skip?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
         *
         * Filter by unique combinations of Caches.
         *
         **/
        distinct?: Enumerable<CacheScalarFieldEnum>
    }

    /**
     * Cache findFirst
     */
    export interface CacheFindFirstArgs extends CacheFindFirstArgsBase {
        /**
         * Throw an Error if query returns no results
         * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
         */
        rejectOnNotFound?: RejectOnNotFound
    }

    /**
     * Cache findFirstOrThrow
     */
    export type CacheFindFirstOrThrowArgs = {
        /**
         * Select specific fields to fetch from the Cache
         *
         **/
        select?: CacheSelect | null
        /**
         * Filter, which Cache to fetch.
         *
         **/
        where?: CacheWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Caches to fetch.
         *
         **/
        orderBy?: Enumerable<CacheOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for searching for Caches.
         *
         **/
        cursor?: CacheWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Caches from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Caches.
         *
         **/
        skip?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
         *
         * Filter by unique combinations of Caches.
         *
         **/
        distinct?: Enumerable<CacheScalarFieldEnum>
    }

    /**
     * Cache findMany
     */
    export type CacheFindManyArgs = {
        /**
         * Select specific fields to fetch from the Cache
         *
         **/
        select?: CacheSelect | null
        /**
         * Filter, which Caches to fetch.
         *
         **/
        where?: CacheWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Caches to fetch.
         *
         **/
        orderBy?: Enumerable<CacheOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for listing Caches.
         *
         **/
        cursor?: CacheWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Caches from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Caches.
         *
         **/
        skip?: number
        distinct?: Enumerable<CacheScalarFieldEnum>
    }

    /**
     * Cache create
     */
    export type CacheCreateArgs = {
        /**
         * Select specific fields to fetch from the Cache
         *
         **/
        select?: CacheSelect | null
        /**
         * The data needed to create a Cache.
         *
         **/
        data: XOR<CacheCreateInput, CacheUncheckedCreateInput>
    }

    /**
     * Cache createMany
     */
    export type CacheCreateManyArgs = {
        /**
         * The data used to create many Caches.
         *
         **/
        data: Enumerable<CacheCreateManyInput>
        skipDuplicates?: boolean
    }

    /**
     * Cache update
     */
    export type CacheUpdateArgs = {
        /**
         * Select specific fields to fetch from the Cache
         *
         **/
        select?: CacheSelect | null
        /**
         * The data needed to update a Cache.
         *
         **/
        data: XOR<CacheUpdateInput, CacheUncheckedUpdateInput>
        /**
         * Choose, which Cache to update.
         *
         **/
        where: CacheWhereUniqueInput
    }

    /**
     * Cache updateMany
     */
    export type CacheUpdateManyArgs = {
        /**
         * The data used to update Caches.
         *
         **/
        data: XOR<CacheUpdateManyMutationInput, CacheUncheckedUpdateManyInput>
        /**
         * Filter which Caches to update
         *
         **/
        where?: CacheWhereInput
    }

    /**
     * Cache upsert
     */
    export type CacheUpsertArgs = {
        /**
         * Select specific fields to fetch from the Cache
         *
         **/
        select?: CacheSelect | null
        /**
         * The filter to search for the Cache to update in case it exists.
         *
         **/
        where: CacheWhereUniqueInput
        /**
         * In case the Cache found by the `where` argument doesn't exist, create a new Cache with this data.
         *
         **/
        create: XOR<CacheCreateInput, CacheUncheckedCreateInput>
        /**
         * In case the Cache was found with the provided `where` argument, update it with this data.
         *
         **/
        update: XOR<CacheUpdateInput, CacheUncheckedUpdateInput>
    }

    /**
     * Cache delete
     */
    export type CacheDeleteArgs = {
        /**
         * Select specific fields to fetch from the Cache
         *
         **/
        select?: CacheSelect | null
        /**
         * Filter which Cache to delete.
         *
         **/
        where: CacheWhereUniqueInput
    }

    /**
     * Cache deleteMany
     */
    export type CacheDeleteManyArgs = {
        /**
         * Filter which Caches to delete
         *
         **/
        where?: CacheWhereInput
    }

    /**
     * Cache without action
     */
    export type CacheArgs = {
        /**
         * Select specific fields to fetch from the Cache
         *
         **/
        select?: CacheSelect | null
    }

    /**
     * Model Cache_locks
     */

    export type AggregateCache_locks = {
        _count: Cache_locksCountAggregateOutputType | null
        _avg: Cache_locksAvgAggregateOutputType | null
        _sum: Cache_locksSumAggregateOutputType | null
        _min: Cache_locksMinAggregateOutputType | null
        _max: Cache_locksMaxAggregateOutputType | null
    }

    export type Cache_locksAvgAggregateOutputType = {
        expiration: number | null
    }

    export type Cache_locksSumAggregateOutputType = {
        expiration: number | null
    }

    export type Cache_locksMinAggregateOutputType = {
        key: string | null
        owner: string | null
        expiration: number | null
    }

    export type Cache_locksMaxAggregateOutputType = {
        key: string | null
        owner: string | null
        expiration: number | null
    }

    export type Cache_locksCountAggregateOutputType = {
        key: number
        owner: number
        expiration: number
        _all: number
    }

    export type Cache_locksAvgAggregateInputType = {
        expiration?: true
    }

    export type Cache_locksSumAggregateInputType = {
        expiration?: true
    }

    export type Cache_locksMinAggregateInputType = {
        key?: true
        owner?: true
        expiration?: true
    }

    export type Cache_locksMaxAggregateInputType = {
        key?: true
        owner?: true
        expiration?: true
    }

    export type Cache_locksCountAggregateInputType = {
        key?: true
        owner?: true
        expiration?: true
        _all?: true
    }

    export type Cache_locksAggregateArgs = {
        /**
         * Filter which Cache_locks to aggregate.
         *
         **/
        where?: Cache_locksWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Cache_locks to fetch.
         *
         **/
        orderBy?: Enumerable<Cache_locksOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the start position
         *
         **/
        cursor?: Cache_locksWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Cache_locks from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Cache_locks.
         *
         **/
        skip?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Count returned Cache_locks
         **/
        _count?: true | Cache_locksCountAggregateInputType
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to average
         **/
        _avg?: Cache_locksAvgAggregateInputType
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to sum
         **/
        _sum?: Cache_locksSumAggregateInputType
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to find the minimum value
         **/
        _min?: Cache_locksMinAggregateInputType
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to find the maximum value
         **/
        _max?: Cache_locksMaxAggregateInputType
    }

    export type GetCache_locksAggregateType<T extends Cache_locksAggregateArgs> = {
        [P in keyof T & keyof AggregateCache_locks]: P extends '_count' | 'count'
            ? T[P] extends true
                ? number
                : GetScalarType<T[P], AggregateCache_locks[P]>
            : GetScalarType<T[P], AggregateCache_locks[P]>
    }

    export type Cache_locksGroupByArgs = {
        where?: Cache_locksWhereInput
        orderBy?: Enumerable<Cache_locksOrderByWithAggregationInput>
        by: Array<Cache_locksScalarFieldEnum>
        having?: Cache_locksScalarWhereWithAggregatesInput
        take?: number
        skip?: number
        _count?: Cache_locksCountAggregateInputType | true
        _avg?: Cache_locksAvgAggregateInputType
        _sum?: Cache_locksSumAggregateInputType
        _min?: Cache_locksMinAggregateInputType
        _max?: Cache_locksMaxAggregateInputType
    }

    export type Cache_locksGroupByOutputType = {
        key: string
        owner: string
        expiration: number
        _count: Cache_locksCountAggregateOutputType | null
        _avg: Cache_locksAvgAggregateOutputType | null
        _sum: Cache_locksSumAggregateOutputType | null
        _min: Cache_locksMinAggregateOutputType | null
        _max: Cache_locksMaxAggregateOutputType | null
    }

    type GetCache_locksGroupByPayload<T extends Cache_locksGroupByArgs> = PrismaPromise<
        Array<
            PickArray<Cache_locksGroupByOutputType, T['by']> & {
                [P in keyof T & keyof Cache_locksGroupByOutputType]: P extends '_count'
                    ? T[P] extends boolean
                        ? number
                        : GetScalarType<T[P], Cache_locksGroupByOutputType[P]>
                    : GetScalarType<T[P], Cache_locksGroupByOutputType[P]>
            }
        >
    >

    export type Cache_locksSelect = {
        key?: boolean
        owner?: boolean
        expiration?: boolean
    }

    export type Cache_locksGetPayload<S extends boolean | null | undefined | Cache_locksArgs> = S extends {
        select: any
        include: any
    }
        ? 'Please either choose `select` or `include`'
        : S extends true
          ? Cache_locks
          : S extends undefined
            ? never
            : S extends { include: any } & (Cache_locksArgs | Cache_locksFindManyArgs)
              ? Cache_locks
              : S extends { select: any } & (Cache_locksArgs | Cache_locksFindManyArgs)
                ? {
                      [P in TruthyKeys<S['select']>]: P extends keyof Cache_locks ? Cache_locks[P] : never
                  }
                : Cache_locks

    type Cache_locksCountArgs = Merge<
        Omit<Cache_locksFindManyArgs, 'select' | 'include'> & {
            select?: Cache_locksCountAggregateInputType | true
        }
    >

    export interface Cache_locksDelegate<
        GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined
    > {
        /**
         * Find zero or one Cache_locks that matches the filter.
         * @param {Cache_locksFindUniqueArgs} args - Arguments to find a Cache_locks
         * @example
         * // Get one Cache_locks
         * const cache_locks = await prisma.cache_locks.findUnique({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findUnique<
            T extends Cache_locksFindUniqueArgs,
            LocalRejectSettings = T['rejectOnNotFound'] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined
        >(
            args: SelectSubset<T, Cache_locksFindUniqueArgs>
        ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Cache_locks'> extends True
            ? Prisma__Cache_locksClient<Cache_locksGetPayload<T>>
            : Prisma__Cache_locksClient<Cache_locksGetPayload<T> | null, null>

        /**
         * Find one Cache_locks that matches the filter or throw an error  with `error.code='P2025'`
         *     if no matches were found.
         * @param {Cache_locksFindUniqueOrThrowArgs} args - Arguments to find a Cache_locks
         * @example
         * // Get one Cache_locks
         * const cache_locks = await prisma.cache_locks.findUniqueOrThrow({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findUniqueOrThrow<T extends Cache_locksFindUniqueOrThrowArgs>(
            args?: SelectSubset<T, Cache_locksFindUniqueOrThrowArgs>
        ): Prisma__Cache_locksClient<Cache_locksGetPayload<T>>

        /**
         * Find the first Cache_locks that matches the filter.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {Cache_locksFindFirstArgs} args - Arguments to find a Cache_locks
         * @example
         * // Get one Cache_locks
         * const cache_locks = await prisma.cache_locks.findFirst({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findFirst<
            T extends Cache_locksFindFirstArgs,
            LocalRejectSettings = T['rejectOnNotFound'] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined
        >(
            args?: SelectSubset<T, Cache_locksFindFirstArgs>
        ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Cache_locks'> extends True
            ? Prisma__Cache_locksClient<Cache_locksGetPayload<T>>
            : Prisma__Cache_locksClient<Cache_locksGetPayload<T> | null, null>

        /**
         * Find the first Cache_locks that matches the filter or
         * throw `NotFoundError` if no matches were found.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {Cache_locksFindFirstOrThrowArgs} args - Arguments to find a Cache_locks
         * @example
         * // Get one Cache_locks
         * const cache_locks = await prisma.cache_locks.findFirstOrThrow({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findFirstOrThrow<T extends Cache_locksFindFirstOrThrowArgs>(
            args?: SelectSubset<T, Cache_locksFindFirstOrThrowArgs>
        ): Prisma__Cache_locksClient<Cache_locksGetPayload<T>>

        /**
         * Find zero or more Cache_locks that matches the filter.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {Cache_locksFindManyArgs=} args - Arguments to filter and select certain fields only.
         * @example
         * // Get all Cache_locks
         * const cache_locks = await prisma.cache_locks.findMany()
         *
         * // Get first 10 Cache_locks
         * const cache_locks = await prisma.cache_locks.findMany({ take: 10 })
         *
         * // Only select the `key`
         * const cache_locksWithKeyOnly = await prisma.cache_locks.findMany({ select: { key: true } })
         *
         **/
        findMany<T extends Cache_locksFindManyArgs>(
            args?: SelectSubset<T, Cache_locksFindManyArgs>
        ): PrismaPromise<Array<Cache_locksGetPayload<T>>>

        /**
         * Create a Cache_locks.
         * @param {Cache_locksCreateArgs} args - Arguments to create a Cache_locks.
         * @example
         * // Create one Cache_locks
         * const Cache_locks = await prisma.cache_locks.create({
         *   data: {
         *     // ... data to create a Cache_locks
         *   }
         * })
         *
         **/
        create<T extends Cache_locksCreateArgs>(
            args: SelectSubset<T, Cache_locksCreateArgs>
        ): Prisma__Cache_locksClient<Cache_locksGetPayload<T>>

        /**
         * Create many Cache_locks.
         *     @param {Cache_locksCreateManyArgs} args - Arguments to create many Cache_locks.
         *     @example
         *     // Create many Cache_locks
         *     const cache_locks = await prisma.cache_locks.createMany({
         *       data: {
         *         // ... provide data here
         *       }
         *     })
         *
         **/
        createMany<T extends Cache_locksCreateManyArgs>(
            args?: SelectSubset<T, Cache_locksCreateManyArgs>
        ): PrismaPromise<BatchPayload>

        /**
         * Delete a Cache_locks.
         * @param {Cache_locksDeleteArgs} args - Arguments to delete one Cache_locks.
         * @example
         * // Delete one Cache_locks
         * const Cache_locks = await prisma.cache_locks.delete({
         *   where: {
         *     // ... filter to delete one Cache_locks
         *   }
         * })
         *
         **/
        delete<T extends Cache_locksDeleteArgs>(
            args: SelectSubset<T, Cache_locksDeleteArgs>
        ): Prisma__Cache_locksClient<Cache_locksGetPayload<T>>

        /**
         * Update one Cache_locks.
         * @param {Cache_locksUpdateArgs} args - Arguments to update one Cache_locks.
         * @example
         * // Update one Cache_locks
         * const cache_locks = await prisma.cache_locks.update({
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: {
         *     // ... provide data here
         *   }
         * })
         *
         **/
        update<T extends Cache_locksUpdateArgs>(
            args: SelectSubset<T, Cache_locksUpdateArgs>
        ): Prisma__Cache_locksClient<Cache_locksGetPayload<T>>

        /**
         * Delete zero or more Cache_locks.
         * @param {Cache_locksDeleteManyArgs} args - Arguments to filter Cache_locks to delete.
         * @example
         * // Delete a few Cache_locks
         * const { count } = await prisma.cache_locks.deleteMany({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         *
         **/
        deleteMany<T extends Cache_locksDeleteManyArgs>(
            args?: SelectSubset<T, Cache_locksDeleteManyArgs>
        ): PrismaPromise<BatchPayload>

        /**
         * Update zero or more Cache_locks.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {Cache_locksUpdateManyArgs} args - Arguments to update one or more rows.
         * @example
         * // Update many Cache_locks
         * const cache_locks = await prisma.cache_locks.updateMany({
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: {
         *     // ... provide data here
         *   }
         * })
         *
         **/
        updateMany<T extends Cache_locksUpdateManyArgs>(
            args: SelectSubset<T, Cache_locksUpdateManyArgs>
        ): PrismaPromise<BatchPayload>

        /**
         * Create or update one Cache_locks.
         * @param {Cache_locksUpsertArgs} args - Arguments to update or create a Cache_locks.
         * @example
         * // Update or create a Cache_locks
         * const cache_locks = await prisma.cache_locks.upsert({
         *   create: {
         *     // ... data to create a Cache_locks
         *   },
         *   update: {
         *     // ... in case it already exists, update
         *   },
         *   where: {
         *     // ... the filter for the Cache_locks we want to update
         *   }
         * })
         **/
        upsert<T extends Cache_locksUpsertArgs>(
            args: SelectSubset<T, Cache_locksUpsertArgs>
        ): Prisma__Cache_locksClient<Cache_locksGetPayload<T>>

        /**
         * Count the number of Cache_locks.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {Cache_locksCountArgs} args - Arguments to filter Cache_locks to count.
         * @example
         * // Count the number of Cache_locks
         * const count = await prisma.cache_locks.count({
         *   where: {
         *     // ... the filter for the Cache_locks we want to count
         *   }
         * })
         **/
        count<T extends Cache_locksCountArgs>(
            args?: Subset<T, Cache_locksCountArgs>
        ): PrismaPromise<
            T extends _Record<'select', any>
                ? T['select'] extends true
                    ? number
                    : GetScalarType<T['select'], Cache_locksCountAggregateOutputType>
                : number
        >

        /**
         * Allows you to perform aggregations operations on a Cache_locks.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {Cache_locksAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
         * @example
         * // Ordered by age ascending
         * // Where email contains prisma.io
         * // Limited to the 10 users
         * const aggregations = await prisma.user.aggregate({
         *   _avg: {
         *     age: true,
         *   },
         *   where: {
         *     email: {
         *       contains: "prisma.io",
         *     },
         *   },
         *   orderBy: {
         *     age: "asc",
         *   },
         *   take: 10,
         * })
         **/
        aggregate<T extends Cache_locksAggregateArgs>(
            args: Subset<T, Cache_locksAggregateArgs>
        ): PrismaPromise<GetCache_locksAggregateType<T>>

        /**
         * Group by Cache_locks.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {Cache_locksGroupByArgs} args - Group by arguments.
         * @example
         * // Group by city, order by createdAt, get count
         * const result = await prisma.user.groupBy({
         *   by: ['city', 'createdAt'],
         *   orderBy: {
         *     createdAt: true
         *   },
         *   _count: {
         *     _all: true
         *   },
         * })
         *
         **/
        groupBy<
            T extends Cache_locksGroupByArgs,
            HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
            OrderByArg extends True extends HasSelectOrTake
                ? { orderBy: Cache_locksGroupByArgs['orderBy'] }
                : { orderBy?: Cache_locksGroupByArgs['orderBy'] },
            OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
            ByFields extends TupleToUnion<T['by']>,
            ByValid extends Has<ByFields, OrderFields>,
            HavingFields extends GetHavingFields<T['having']>,
            HavingValid extends Has<ByFields, HavingFields>,
            ByEmpty extends T['by'] extends never[] ? True : False,
            InputErrors extends ByEmpty extends True
                ? `Error: "by" must not be empty.`
                : HavingValid extends False
                  ? {
                        [P in HavingFields]: P extends ByFields
                            ? never
                            : P extends string
                              ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                              : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`]
                    }[HavingFields]
                  : 'take' extends Keys<T>
                    ? 'orderBy' extends Keys<T>
                        ? ByValid extends True
                            ? {}
                            : {
                                  [P in OrderFields]: P extends ByFields
                                      ? never
                                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                              }[OrderFields]
                        : 'Error: If you provide "take", you also need to provide "orderBy"'
                    : 'skip' extends Keys<T>
                      ? 'orderBy' extends Keys<T>
                          ? ByValid extends True
                              ? {}
                              : {
                                    [P in OrderFields]: P extends ByFields
                                        ? never
                                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                                }[OrderFields]
                          : 'Error: If you provide "skip", you also need to provide "orderBy"'
                      : ByValid extends True
                        ? {}
                        : {
                              [P in OrderFields]: P extends ByFields
                                  ? never
                                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                          }[OrderFields]
        >(
            args: SubsetIntersection<T, Cache_locksGroupByArgs, OrderByArg> & InputErrors
        ): {} extends InputErrors ? GetCache_locksGroupByPayload<T> : PrismaPromise<InputErrors>
    }

    /**
     * The delegate class that acts as a "Promise-like" for Cache_locks.
     * Why is this prefixed with `Prisma__`?
     * Because we want to prevent naming conflicts as mentioned in
     * https://github.com/prisma/prisma-client-js/issues/707
     */
    export class Prisma__Cache_locksClient<T, Null = never> implements PrismaPromise<T> {
        [prisma]: true
        private readonly _dmmf
        private readonly _fetcher
        private readonly _queryType
        private readonly _rootField
        private readonly _clientMethod
        private readonly _args
        private readonly _dataPath
        private readonly _errorFormat
        private readonly _measurePerformance?
        private _isList
        private _callsite
        private _requestPromise?
        constructor(
            _dmmf: runtime.DMMFClass,
            _fetcher: PrismaClientFetcher,
            _queryType: 'query' | 'mutation',
            _rootField: string,
            _clientMethod: string,
            _args: any,
            _dataPath: string[],
            _errorFormat: ErrorFormat,
            _measurePerformance?: boolean | undefined,
            _isList?: boolean
        )
        readonly [Symbol.toStringTag]: 'PrismaClientPromise'

        private get _document()
        /**
         * Attaches callbacks for the resolution and/or rejection of the Promise.
         * @param onfulfilled The callback to execute when the Promise is resolved.
         * @param onrejected The callback to execute when the Promise is rejected.
         * @returns A Promise for the completion of which ever callback is executed.
         */
        then<TResult1 = T, TResult2 = never>(
            onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
            onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
        ): Promise<TResult1 | TResult2>
        /**
         * Attaches a callback for only the rejection of the Promise.
         * @param onrejected The callback to execute when the Promise is rejected.
         * @returns A Promise for the completion of the callback.
         */
        catch<TResult = never>(
            onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
        ): Promise<T | TResult>
        /**
         * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
         * resolved value cannot be modified from the callback.
         * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
         * @returns A Promise for the completion of the callback.
         */
        finally(onfinally?: (() => void) | undefined | null): Promise<T>
    }

    // Custom InputTypes

    /**
     * Cache_locks base type for findUnique actions
     */
    export type Cache_locksFindUniqueArgsBase = {
        /**
         * Select specific fields to fetch from the Cache_locks
         *
         **/
        select?: Cache_locksSelect | null
        /**
         * Filter, which Cache_locks to fetch.
         *
         **/
        where: Cache_locksWhereUniqueInput
    }

    /**
     * Cache_locks findUnique
     */
    export interface Cache_locksFindUniqueArgs extends Cache_locksFindUniqueArgsBase {
        /**
         * Throw an Error if query returns no results
         * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
         */
        rejectOnNotFound?: RejectOnNotFound
    }

    /**
     * Cache_locks findUniqueOrThrow
     */
    export type Cache_locksFindUniqueOrThrowArgs = {
        /**
         * Select specific fields to fetch from the Cache_locks
         *
         **/
        select?: Cache_locksSelect | null
        /**
         * Filter, which Cache_locks to fetch.
         *
         **/
        where: Cache_locksWhereUniqueInput
    }

    /**
     * Cache_locks base type for findFirst actions
     */
    export type Cache_locksFindFirstArgsBase = {
        /**
         * Select specific fields to fetch from the Cache_locks
         *
         **/
        select?: Cache_locksSelect | null
        /**
         * Filter, which Cache_locks to fetch.
         *
         **/
        where?: Cache_locksWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Cache_locks to fetch.
         *
         **/
        orderBy?: Enumerable<Cache_locksOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for searching for Cache_locks.
         *
         **/
        cursor?: Cache_locksWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Cache_locks from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Cache_locks.
         *
         **/
        skip?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
         *
         * Filter by unique combinations of Cache_locks.
         *
         **/
        distinct?: Enumerable<Cache_locksScalarFieldEnum>
    }

    /**
     * Cache_locks findFirst
     */
    export interface Cache_locksFindFirstArgs extends Cache_locksFindFirstArgsBase {
        /**
         * Throw an Error if query returns no results
         * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
         */
        rejectOnNotFound?: RejectOnNotFound
    }

    /**
     * Cache_locks findFirstOrThrow
     */
    export type Cache_locksFindFirstOrThrowArgs = {
        /**
         * Select specific fields to fetch from the Cache_locks
         *
         **/
        select?: Cache_locksSelect | null
        /**
         * Filter, which Cache_locks to fetch.
         *
         **/
        where?: Cache_locksWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Cache_locks to fetch.
         *
         **/
        orderBy?: Enumerable<Cache_locksOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for searching for Cache_locks.
         *
         **/
        cursor?: Cache_locksWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Cache_locks from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Cache_locks.
         *
         **/
        skip?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
         *
         * Filter by unique combinations of Cache_locks.
         *
         **/
        distinct?: Enumerable<Cache_locksScalarFieldEnum>
    }

    /**
     * Cache_locks findMany
     */
    export type Cache_locksFindManyArgs = {
        /**
         * Select specific fields to fetch from the Cache_locks
         *
         **/
        select?: Cache_locksSelect | null
        /**
         * Filter, which Cache_locks to fetch.
         *
         **/
        where?: Cache_locksWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Cache_locks to fetch.
         *
         **/
        orderBy?: Enumerable<Cache_locksOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for listing Cache_locks.
         *
         **/
        cursor?: Cache_locksWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Cache_locks from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Cache_locks.
         *
         **/
        skip?: number
        distinct?: Enumerable<Cache_locksScalarFieldEnum>
    }

    /**
     * Cache_locks create
     */
    export type Cache_locksCreateArgs = {
        /**
         * Select specific fields to fetch from the Cache_locks
         *
         **/
        select?: Cache_locksSelect | null
        /**
         * The data needed to create a Cache_locks.
         *
         **/
        data: XOR<Cache_locksCreateInput, Cache_locksUncheckedCreateInput>
    }

    /**
     * Cache_locks createMany
     */
    export type Cache_locksCreateManyArgs = {
        /**
         * The data used to create many Cache_locks.
         *
         **/
        data: Enumerable<Cache_locksCreateManyInput>
        skipDuplicates?: boolean
    }

    /**
     * Cache_locks update
     */
    export type Cache_locksUpdateArgs = {
        /**
         * Select specific fields to fetch from the Cache_locks
         *
         **/
        select?: Cache_locksSelect | null
        /**
         * The data needed to update a Cache_locks.
         *
         **/
        data: XOR<Cache_locksUpdateInput, Cache_locksUncheckedUpdateInput>
        /**
         * Choose, which Cache_locks to update.
         *
         **/
        where: Cache_locksWhereUniqueInput
    }

    /**
     * Cache_locks updateMany
     */
    export type Cache_locksUpdateManyArgs = {
        /**
         * The data used to update Cache_locks.
         *
         **/
        data: XOR<Cache_locksUpdateManyMutationInput, Cache_locksUncheckedUpdateManyInput>
        /**
         * Filter which Cache_locks to update
         *
         **/
        where?: Cache_locksWhereInput
    }

    /**
     * Cache_locks upsert
     */
    export type Cache_locksUpsertArgs = {
        /**
         * Select specific fields to fetch from the Cache_locks
         *
         **/
        select?: Cache_locksSelect | null
        /**
         * The filter to search for the Cache_locks to update in case it exists.
         *
         **/
        where: Cache_locksWhereUniqueInput
        /**
         * In case the Cache_locks found by the `where` argument doesn't exist, create a new Cache_locks with this data.
         *
         **/
        create: XOR<Cache_locksCreateInput, Cache_locksUncheckedCreateInput>
        /**
         * In case the Cache_locks was found with the provided `where` argument, update it with this data.
         *
         **/
        update: XOR<Cache_locksUpdateInput, Cache_locksUncheckedUpdateInput>
    }

    /**
     * Cache_locks delete
     */
    export type Cache_locksDeleteArgs = {
        /**
         * Select specific fields to fetch from the Cache_locks
         *
         **/
        select?: Cache_locksSelect | null
        /**
         * Filter which Cache_locks to delete.
         *
         **/
        where: Cache_locksWhereUniqueInput
    }

    /**
     * Cache_locks deleteMany
     */
    export type Cache_locksDeleteManyArgs = {
        /**
         * Filter which Cache_locks to delete
         *
         **/
        where?: Cache_locksWhereInput
    }

    /**
     * Cache_locks without action
     */
    export type Cache_locksArgs = {
        /**
         * Select specific fields to fetch from the Cache_locks
         *
         **/
        select?: Cache_locksSelect | null
    }

    /**
     * Model Domains
     */

    export type AggregateDomains = {
        _count: DomainsCountAggregateOutputType | null
        _min: DomainsMinAggregateOutputType | null
        _max: DomainsMaxAggregateOutputType | null
    }

    export type DomainsMinAggregateOutputType = {
        id: string | null
        domain: string | null
        tenant_id: string | null
        created_at: Date | null
        updated_at: Date | null
    }

    export type DomainsMaxAggregateOutputType = {
        id: string | null
        domain: string | null
        tenant_id: string | null
        created_at: Date | null
        updated_at: Date | null
    }

    export type DomainsCountAggregateOutputType = {
        id: number
        domain: number
        tenant_id: number
        created_at: number
        updated_at: number
        _all: number
    }

    export type DomainsMinAggregateInputType = {
        id?: true
        domain?: true
        tenant_id?: true
        created_at?: true
        updated_at?: true
    }

    export type DomainsMaxAggregateInputType = {
        id?: true
        domain?: true
        tenant_id?: true
        created_at?: true
        updated_at?: true
    }

    export type DomainsCountAggregateInputType = {
        id?: true
        domain?: true
        tenant_id?: true
        created_at?: true
        updated_at?: true
        _all?: true
    }

    export type DomainsAggregateArgs = {
        /**
         * Filter which Domains to aggregate.
         *
         **/
        where?: DomainsWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Domains to fetch.
         *
         **/
        orderBy?: Enumerable<DomainsOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the start position
         *
         **/
        cursor?: DomainsWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Domains from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Domains.
         *
         **/
        skip?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Count returned Domains
         **/
        _count?: true | DomainsCountAggregateInputType
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to find the minimum value
         **/
        _min?: DomainsMinAggregateInputType
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to find the maximum value
         **/
        _max?: DomainsMaxAggregateInputType
    }

    export type GetDomainsAggregateType<T extends DomainsAggregateArgs> = {
        [P in keyof T & keyof AggregateDomains]: P extends '_count' | 'count'
            ? T[P] extends true
                ? number
                : GetScalarType<T[P], AggregateDomains[P]>
            : GetScalarType<T[P], AggregateDomains[P]>
    }

    export type DomainsGroupByArgs = {
        where?: DomainsWhereInput
        orderBy?: Enumerable<DomainsOrderByWithAggregationInput>
        by: Array<DomainsScalarFieldEnum>
        having?: DomainsScalarWhereWithAggregatesInput
        take?: number
        skip?: number
        _count?: DomainsCountAggregateInputType | true
        _min?: DomainsMinAggregateInputType
        _max?: DomainsMaxAggregateInputType
    }

    export type DomainsGroupByOutputType = {
        id: string
        domain: string
        tenant_id: string
        created_at: Date | null
        updated_at: Date | null
        _count: DomainsCountAggregateOutputType | null
        _min: DomainsMinAggregateOutputType | null
        _max: DomainsMaxAggregateOutputType | null
    }

    type GetDomainsGroupByPayload<T extends DomainsGroupByArgs> = PrismaPromise<
        Array<
            PickArray<DomainsGroupByOutputType, T['by']> & {
                [P in keyof T & keyof DomainsGroupByOutputType]: P extends '_count'
                    ? T[P] extends boolean
                        ? number
                        : GetScalarType<T[P], DomainsGroupByOutputType[P]>
                    : GetScalarType<T[P], DomainsGroupByOutputType[P]>
            }
        >
    >

    export type DomainsSelect = {
        id?: boolean
        domain?: boolean
        tenant_id?: boolean
        created_at?: boolean
        updated_at?: boolean
        tenants?: boolean | TenantsArgs
    }

    export type DomainsInclude = {
        tenants?: boolean | TenantsArgs
    }

    export type DomainsGetPayload<S extends boolean | null | undefined | DomainsArgs> = S extends {
        select: any
        include: any
    }
        ? 'Please either choose `select` or `include`'
        : S extends true
          ? Domains
          : S extends undefined
            ? never
            : S extends { include: any } & (DomainsArgs | DomainsFindManyArgs)
              ? Domains & {
                    [P in TruthyKeys<S['include']>]: P extends 'tenants' ? TenantsGetPayload<S['include'][P]> : never
                }
              : S extends { select: any } & (DomainsArgs | DomainsFindManyArgs)
                ? {
                      [P in TruthyKeys<S['select']>]: P extends 'tenants'
                          ? TenantsGetPayload<S['select'][P]>
                          : P extends keyof Domains
                            ? Domains[P]
                            : never
                  }
                : Domains

    type DomainsCountArgs = Merge<
        Omit<DomainsFindManyArgs, 'select' | 'include'> & {
            select?: DomainsCountAggregateInputType | true
        }
    >

    export interface DomainsDelegate<
        GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined
    > {
        /**
         * Find zero or one Domains that matches the filter.
         * @param {DomainsFindUniqueArgs} args - Arguments to find a Domains
         * @example
         * // Get one Domains
         * const domains = await prisma.domains.findUnique({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findUnique<
            T extends DomainsFindUniqueArgs,
            LocalRejectSettings = T['rejectOnNotFound'] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined
        >(
            args: SelectSubset<T, DomainsFindUniqueArgs>
        ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Domains'> extends True
            ? Prisma__DomainsClient<DomainsGetPayload<T>>
            : Prisma__DomainsClient<DomainsGetPayload<T> | null, null>

        /**
         * Find one Domains that matches the filter or throw an error  with `error.code='P2025'`
         *     if no matches were found.
         * @param {DomainsFindUniqueOrThrowArgs} args - Arguments to find a Domains
         * @example
         * // Get one Domains
         * const domains = await prisma.domains.findUniqueOrThrow({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findUniqueOrThrow<T extends DomainsFindUniqueOrThrowArgs>(
            args?: SelectSubset<T, DomainsFindUniqueOrThrowArgs>
        ): Prisma__DomainsClient<DomainsGetPayload<T>>

        /**
         * Find the first Domains that matches the filter.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {DomainsFindFirstArgs} args - Arguments to find a Domains
         * @example
         * // Get one Domains
         * const domains = await prisma.domains.findFirst({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findFirst<
            T extends DomainsFindFirstArgs,
            LocalRejectSettings = T['rejectOnNotFound'] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined
        >(
            args?: SelectSubset<T, DomainsFindFirstArgs>
        ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Domains'> extends True
            ? Prisma__DomainsClient<DomainsGetPayload<T>>
            : Prisma__DomainsClient<DomainsGetPayload<T> | null, null>

        /**
         * Find the first Domains that matches the filter or
         * throw `NotFoundError` if no matches were found.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {DomainsFindFirstOrThrowArgs} args - Arguments to find a Domains
         * @example
         * // Get one Domains
         * const domains = await prisma.domains.findFirstOrThrow({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findFirstOrThrow<T extends DomainsFindFirstOrThrowArgs>(
            args?: SelectSubset<T, DomainsFindFirstOrThrowArgs>
        ): Prisma__DomainsClient<DomainsGetPayload<T>>

        /**
         * Find zero or more Domains that matches the filter.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {DomainsFindManyArgs=} args - Arguments to filter and select certain fields only.
         * @example
         * // Get all Domains
         * const domains = await prisma.domains.findMany()
         *
         * // Get first 10 Domains
         * const domains = await prisma.domains.findMany({ take: 10 })
         *
         * // Only select the `id`
         * const domainsWithIdOnly = await prisma.domains.findMany({ select: { id: true } })
         *
         **/
        findMany<T extends DomainsFindManyArgs>(
            args?: SelectSubset<T, DomainsFindManyArgs>
        ): PrismaPromise<Array<DomainsGetPayload<T>>>

        /**
         * Create a Domains.
         * @param {DomainsCreateArgs} args - Arguments to create a Domains.
         * @example
         * // Create one Domains
         * const Domains = await prisma.domains.create({
         *   data: {
         *     // ... data to create a Domains
         *   }
         * })
         *
         **/
        create<T extends DomainsCreateArgs>(
            args: SelectSubset<T, DomainsCreateArgs>
        ): Prisma__DomainsClient<DomainsGetPayload<T>>

        /**
         * Create many Domains.
         *     @param {DomainsCreateManyArgs} args - Arguments to create many Domains.
         *     @example
         *     // Create many Domains
         *     const domains = await prisma.domains.createMany({
         *       data: {
         *         // ... provide data here
         *       }
         *     })
         *
         **/
        createMany<T extends DomainsCreateManyArgs>(
            args?: SelectSubset<T, DomainsCreateManyArgs>
        ): PrismaPromise<BatchPayload>

        /**
         * Delete a Domains.
         * @param {DomainsDeleteArgs} args - Arguments to delete one Domains.
         * @example
         * // Delete one Domains
         * const Domains = await prisma.domains.delete({
         *   where: {
         *     // ... filter to delete one Domains
         *   }
         * })
         *
         **/
        delete<T extends DomainsDeleteArgs>(
            args: SelectSubset<T, DomainsDeleteArgs>
        ): Prisma__DomainsClient<DomainsGetPayload<T>>

        /**
         * Update one Domains.
         * @param {DomainsUpdateArgs} args - Arguments to update one Domains.
         * @example
         * // Update one Domains
         * const domains = await prisma.domains.update({
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: {
         *     // ... provide data here
         *   }
         * })
         *
         **/
        update<T extends DomainsUpdateArgs>(
            args: SelectSubset<T, DomainsUpdateArgs>
        ): Prisma__DomainsClient<DomainsGetPayload<T>>

        /**
         * Delete zero or more Domains.
         * @param {DomainsDeleteManyArgs} args - Arguments to filter Domains to delete.
         * @example
         * // Delete a few Domains
         * const { count } = await prisma.domains.deleteMany({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         *
         **/
        deleteMany<T extends DomainsDeleteManyArgs>(
            args?: SelectSubset<T, DomainsDeleteManyArgs>
        ): PrismaPromise<BatchPayload>

        /**
         * Update zero or more Domains.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {DomainsUpdateManyArgs} args - Arguments to update one or more rows.
         * @example
         * // Update many Domains
         * const domains = await prisma.domains.updateMany({
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: {
         *     // ... provide data here
         *   }
         * })
         *
         **/
        updateMany<T extends DomainsUpdateManyArgs>(
            args: SelectSubset<T, DomainsUpdateManyArgs>
        ): PrismaPromise<BatchPayload>

        /**
         * Create or update one Domains.
         * @param {DomainsUpsertArgs} args - Arguments to update or create a Domains.
         * @example
         * // Update or create a Domains
         * const domains = await prisma.domains.upsert({
         *   create: {
         *     // ... data to create a Domains
         *   },
         *   update: {
         *     // ... in case it already exists, update
         *   },
         *   where: {
         *     // ... the filter for the Domains we want to update
         *   }
         * })
         **/
        upsert<T extends DomainsUpsertArgs>(
            args: SelectSubset<T, DomainsUpsertArgs>
        ): Prisma__DomainsClient<DomainsGetPayload<T>>

        /**
         * Count the number of Domains.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {DomainsCountArgs} args - Arguments to filter Domains to count.
         * @example
         * // Count the number of Domains
         * const count = await prisma.domains.count({
         *   where: {
         *     // ... the filter for the Domains we want to count
         *   }
         * })
         **/
        count<T extends DomainsCountArgs>(
            args?: Subset<T, DomainsCountArgs>
        ): PrismaPromise<
            T extends _Record<'select', any>
                ? T['select'] extends true
                    ? number
                    : GetScalarType<T['select'], DomainsCountAggregateOutputType>
                : number
        >

        /**
         * Allows you to perform aggregations operations on a Domains.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {DomainsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
         * @example
         * // Ordered by age ascending
         * // Where email contains prisma.io
         * // Limited to the 10 users
         * const aggregations = await prisma.user.aggregate({
         *   _avg: {
         *     age: true,
         *   },
         *   where: {
         *     email: {
         *       contains: "prisma.io",
         *     },
         *   },
         *   orderBy: {
         *     age: "asc",
         *   },
         *   take: 10,
         * })
         **/
        aggregate<T extends DomainsAggregateArgs>(
            args: Subset<T, DomainsAggregateArgs>
        ): PrismaPromise<GetDomainsAggregateType<T>>

        /**
         * Group by Domains.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {DomainsGroupByArgs} args - Group by arguments.
         * @example
         * // Group by city, order by createdAt, get count
         * const result = await prisma.user.groupBy({
         *   by: ['city', 'createdAt'],
         *   orderBy: {
         *     createdAt: true
         *   },
         *   _count: {
         *     _all: true
         *   },
         * })
         *
         **/
        groupBy<
            T extends DomainsGroupByArgs,
            HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
            OrderByArg extends True extends HasSelectOrTake
                ? { orderBy: DomainsGroupByArgs['orderBy'] }
                : { orderBy?: DomainsGroupByArgs['orderBy'] },
            OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
            ByFields extends TupleToUnion<T['by']>,
            ByValid extends Has<ByFields, OrderFields>,
            HavingFields extends GetHavingFields<T['having']>,
            HavingValid extends Has<ByFields, HavingFields>,
            ByEmpty extends T['by'] extends never[] ? True : False,
            InputErrors extends ByEmpty extends True
                ? `Error: "by" must not be empty.`
                : HavingValid extends False
                  ? {
                        [P in HavingFields]: P extends ByFields
                            ? never
                            : P extends string
                              ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                              : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`]
                    }[HavingFields]
                  : 'take' extends Keys<T>
                    ? 'orderBy' extends Keys<T>
                        ? ByValid extends True
                            ? {}
                            : {
                                  [P in OrderFields]: P extends ByFields
                                      ? never
                                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                              }[OrderFields]
                        : 'Error: If you provide "take", you also need to provide "orderBy"'
                    : 'skip' extends Keys<T>
                      ? 'orderBy' extends Keys<T>
                          ? ByValid extends True
                              ? {}
                              : {
                                    [P in OrderFields]: P extends ByFields
                                        ? never
                                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                                }[OrderFields]
                          : 'Error: If you provide "skip", you also need to provide "orderBy"'
                      : ByValid extends True
                        ? {}
                        : {
                              [P in OrderFields]: P extends ByFields
                                  ? never
                                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                          }[OrderFields]
        >(
            args: SubsetIntersection<T, DomainsGroupByArgs, OrderByArg> & InputErrors
        ): {} extends InputErrors ? GetDomainsGroupByPayload<T> : PrismaPromise<InputErrors>
    }

    /**
     * The delegate class that acts as a "Promise-like" for Domains.
     * Why is this prefixed with `Prisma__`?
     * Because we want to prevent naming conflicts as mentioned in
     * https://github.com/prisma/prisma-client-js/issues/707
     */
    export class Prisma__DomainsClient<T, Null = never> implements PrismaPromise<T> {
        [prisma]: true
        private readonly _dmmf
        private readonly _fetcher
        private readonly _queryType
        private readonly _rootField
        private readonly _clientMethod
        private readonly _args
        private readonly _dataPath
        private readonly _errorFormat
        private readonly _measurePerformance?
        private _isList
        private _callsite
        private _requestPromise?
        constructor(
            _dmmf: runtime.DMMFClass,
            _fetcher: PrismaClientFetcher,
            _queryType: 'query' | 'mutation',
            _rootField: string,
            _clientMethod: string,
            _args: any,
            _dataPath: string[],
            _errorFormat: ErrorFormat,
            _measurePerformance?: boolean | undefined,
            _isList?: boolean
        )
        readonly [Symbol.toStringTag]: 'PrismaClientPromise'

        tenants<T extends TenantsArgs = {}>(
            args?: Subset<T, TenantsArgs>
        ): Prisma__TenantsClient<TenantsGetPayload<T> | Null>

        private get _document()
        /**
         * Attaches callbacks for the resolution and/or rejection of the Promise.
         * @param onfulfilled The callback to execute when the Promise is resolved.
         * @param onrejected The callback to execute when the Promise is rejected.
         * @returns A Promise for the completion of which ever callback is executed.
         */
        then<TResult1 = T, TResult2 = never>(
            onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
            onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
        ): Promise<TResult1 | TResult2>
        /**
         * Attaches a callback for only the rejection of the Promise.
         * @param onrejected The callback to execute when the Promise is rejected.
         * @returns A Promise for the completion of the callback.
         */
        catch<TResult = never>(
            onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
        ): Promise<T | TResult>
        /**
         * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
         * resolved value cannot be modified from the callback.
         * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
         * @returns A Promise for the completion of the callback.
         */
        finally(onfinally?: (() => void) | undefined | null): Promise<T>
    }

    // Custom InputTypes

    /**
     * Domains base type for findUnique actions
     */
    export type DomainsFindUniqueArgsBase = {
        /**
         * Select specific fields to fetch from the Domains
         *
         **/
        select?: DomainsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: DomainsInclude | null
        /**
         * Filter, which Domains to fetch.
         *
         **/
        where: DomainsWhereUniqueInput
    }

    /**
     * Domains findUnique
     */
    export interface DomainsFindUniqueArgs extends DomainsFindUniqueArgsBase {
        /**
         * Throw an Error if query returns no results
         * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
         */
        rejectOnNotFound?: RejectOnNotFound
    }

    /**
     * Domains findUniqueOrThrow
     */
    export type DomainsFindUniqueOrThrowArgs = {
        /**
         * Select specific fields to fetch from the Domains
         *
         **/
        select?: DomainsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: DomainsInclude | null
        /**
         * Filter, which Domains to fetch.
         *
         **/
        where: DomainsWhereUniqueInput
    }

    /**
     * Domains base type for findFirst actions
     */
    export type DomainsFindFirstArgsBase = {
        /**
         * Select specific fields to fetch from the Domains
         *
         **/
        select?: DomainsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: DomainsInclude | null
        /**
         * Filter, which Domains to fetch.
         *
         **/
        where?: DomainsWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Domains to fetch.
         *
         **/
        orderBy?: Enumerable<DomainsOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for searching for Domains.
         *
         **/
        cursor?: DomainsWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Domains from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Domains.
         *
         **/
        skip?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
         *
         * Filter by unique combinations of Domains.
         *
         **/
        distinct?: Enumerable<DomainsScalarFieldEnum>
    }

    /**
     * Domains findFirst
     */
    export interface DomainsFindFirstArgs extends DomainsFindFirstArgsBase {
        /**
         * Throw an Error if query returns no results
         * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
         */
        rejectOnNotFound?: RejectOnNotFound
    }

    /**
     * Domains findFirstOrThrow
     */
    export type DomainsFindFirstOrThrowArgs = {
        /**
         * Select specific fields to fetch from the Domains
         *
         **/
        select?: DomainsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: DomainsInclude | null
        /**
         * Filter, which Domains to fetch.
         *
         **/
        where?: DomainsWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Domains to fetch.
         *
         **/
        orderBy?: Enumerable<DomainsOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for searching for Domains.
         *
         **/
        cursor?: DomainsWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Domains from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Domains.
         *
         **/
        skip?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
         *
         * Filter by unique combinations of Domains.
         *
         **/
        distinct?: Enumerable<DomainsScalarFieldEnum>
    }

    /**
     * Domains findMany
     */
    export type DomainsFindManyArgs = {
        /**
         * Select specific fields to fetch from the Domains
         *
         **/
        select?: DomainsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: DomainsInclude | null
        /**
         * Filter, which Domains to fetch.
         *
         **/
        where?: DomainsWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Domains to fetch.
         *
         **/
        orderBy?: Enumerable<DomainsOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for listing Domains.
         *
         **/
        cursor?: DomainsWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Domains from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Domains.
         *
         **/
        skip?: number
        distinct?: Enumerable<DomainsScalarFieldEnum>
    }

    /**
     * Domains create
     */
    export type DomainsCreateArgs = {
        /**
         * Select specific fields to fetch from the Domains
         *
         **/
        select?: DomainsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: DomainsInclude | null
        /**
         * The data needed to create a Domains.
         *
         **/
        data: XOR<DomainsCreateInput, DomainsUncheckedCreateInput>
    }

    /**
     * Domains createMany
     */
    export type DomainsCreateManyArgs = {
        /**
         * The data used to create many Domains.
         *
         **/
        data: Enumerable<DomainsCreateManyInput>
        skipDuplicates?: boolean
    }

    /**
     * Domains update
     */
    export type DomainsUpdateArgs = {
        /**
         * Select specific fields to fetch from the Domains
         *
         **/
        select?: DomainsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: DomainsInclude | null
        /**
         * The data needed to update a Domains.
         *
         **/
        data: XOR<DomainsUpdateInput, DomainsUncheckedUpdateInput>
        /**
         * Choose, which Domains to update.
         *
         **/
        where: DomainsWhereUniqueInput
    }

    /**
     * Domains updateMany
     */
    export type DomainsUpdateManyArgs = {
        /**
         * The data used to update Domains.
         *
         **/
        data: XOR<DomainsUpdateManyMutationInput, DomainsUncheckedUpdateManyInput>
        /**
         * Filter which Domains to update
         *
         **/
        where?: DomainsWhereInput
    }

    /**
     * Domains upsert
     */
    export type DomainsUpsertArgs = {
        /**
         * Select specific fields to fetch from the Domains
         *
         **/
        select?: DomainsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: DomainsInclude | null
        /**
         * The filter to search for the Domains to update in case it exists.
         *
         **/
        where: DomainsWhereUniqueInput
        /**
         * In case the Domains found by the `where` argument doesn't exist, create a new Domains with this data.
         *
         **/
        create: XOR<DomainsCreateInput, DomainsUncheckedCreateInput>
        /**
         * In case the Domains was found with the provided `where` argument, update it with this data.
         *
         **/
        update: XOR<DomainsUpdateInput, DomainsUncheckedUpdateInput>
    }

    /**
     * Domains delete
     */
    export type DomainsDeleteArgs = {
        /**
         * Select specific fields to fetch from the Domains
         *
         **/
        select?: DomainsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: DomainsInclude | null
        /**
         * Filter which Domains to delete.
         *
         **/
        where: DomainsWhereUniqueInput
    }

    /**
     * Domains deleteMany
     */
    export type DomainsDeleteManyArgs = {
        /**
         * Filter which Domains to delete
         *
         **/
        where?: DomainsWhereInput
    }

    /**
     * Domains without action
     */
    export type DomainsArgs = {
        /**
         * Select specific fields to fetch from the Domains
         *
         **/
        select?: DomainsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: DomainsInclude | null
    }

    /**
     * Model Families
     */

    export type AggregateFamilies = {
        _count: FamiliesCountAggregateOutputType | null
        _min: FamiliesMinAggregateOutputType | null
        _max: FamiliesMaxAggregateOutputType | null
    }

    export type FamiliesMinAggregateOutputType = {
        id: string | null
        name: string | null
        report: string | null
        tenant_id: string | null
        created_at: Date | null
        updated_at: Date | null
    }

    export type FamiliesMaxAggregateOutputType = {
        id: string | null
        name: string | null
        report: string | null
        tenant_id: string | null
        created_at: Date | null
        updated_at: Date | null
    }

    export type FamiliesCountAggregateOutputType = {
        id: number
        name: number
        report: number
        tenant_id: number
        created_at: number
        updated_at: number
        _all: number
    }

    export type FamiliesMinAggregateInputType = {
        id?: true
        name?: true
        report?: true
        tenant_id?: true
        created_at?: true
        updated_at?: true
    }

    export type FamiliesMaxAggregateInputType = {
        id?: true
        name?: true
        report?: true
        tenant_id?: true
        created_at?: true
        updated_at?: true
    }

    export type FamiliesCountAggregateInputType = {
        id?: true
        name?: true
        report?: true
        tenant_id?: true
        created_at?: true
        updated_at?: true
        _all?: true
    }

    export type FamiliesAggregateArgs = {
        /**
         * Filter which Families to aggregate.
         *
         **/
        where?: FamiliesWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Families to fetch.
         *
         **/
        orderBy?: Enumerable<FamiliesOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the start position
         *
         **/
        cursor?: FamiliesWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Families from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Families.
         *
         **/
        skip?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Count returned Families
         **/
        _count?: true | FamiliesCountAggregateInputType
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to find the minimum value
         **/
        _min?: FamiliesMinAggregateInputType
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to find the maximum value
         **/
        _max?: FamiliesMaxAggregateInputType
    }

    export type GetFamiliesAggregateType<T extends FamiliesAggregateArgs> = {
        [P in keyof T & keyof AggregateFamilies]: P extends '_count' | 'count'
            ? T[P] extends true
                ? number
                : GetScalarType<T[P], AggregateFamilies[P]>
            : GetScalarType<T[P], AggregateFamilies[P]>
    }

    export type FamiliesGroupByArgs = {
        where?: FamiliesWhereInput
        orderBy?: Enumerable<FamiliesOrderByWithAggregationInput>
        by: Array<FamiliesScalarFieldEnum>
        having?: FamiliesScalarWhereWithAggregatesInput
        take?: number
        skip?: number
        _count?: FamiliesCountAggregateInputType | true
        _min?: FamiliesMinAggregateInputType
        _max?: FamiliesMaxAggregateInputType
    }

    export type FamiliesGroupByOutputType = {
        id: string
        name: string
        report: string
        tenant_id: string
        created_at: Date | null
        updated_at: Date | null
        _count: FamiliesCountAggregateOutputType | null
        _min: FamiliesMinAggregateOutputType | null
        _max: FamiliesMaxAggregateOutputType | null
    }

    type GetFamiliesGroupByPayload<T extends FamiliesGroupByArgs> = PrismaPromise<
        Array<
            PickArray<FamiliesGroupByOutputType, T['by']> & {
                [P in keyof T & keyof FamiliesGroupByOutputType]: P extends '_count'
                    ? T[P] extends boolean
                        ? number
                        : GetScalarType<T[P], FamiliesGroupByOutputType[P]>
                    : GetScalarType<T[P], FamiliesGroupByOutputType[P]>
            }
        >
    >

    export type FamiliesSelect = {
        id?: boolean
        name?: boolean
        report?: boolean
        tenant_id?: boolean
        created_at?: boolean
        updated_at?: boolean
        tenants?: boolean | TenantsArgs
        family_furnishing?: boolean | Families$family_furnishingArgs
        family_housing?: boolean | Families$family_housingArgs
        family_sponsorship?: boolean | Families$family_sponsorshipArgs
        orphans?: boolean | Families$orphansArgs
        second_sponsors?: boolean | Families$second_sponsorsArgs
        spouses?: boolean | Families$spousesArgs
        _count?: boolean | FamiliesCountOutputTypeArgs
    }

    export type FamiliesInclude = {
        tenants?: boolean | TenantsArgs
        family_furnishing?: boolean | Families$family_furnishingArgs
        family_housing?: boolean | Families$family_housingArgs
        family_sponsorship?: boolean | Families$family_sponsorshipArgs
        orphans?: boolean | Families$orphansArgs
        second_sponsors?: boolean | Families$second_sponsorsArgs
        spouses?: boolean | Families$spousesArgs
        _count?: boolean | FamiliesCountOutputTypeArgs
    }

    export type FamiliesGetPayload<S extends boolean | null | undefined | FamiliesArgs> = S extends {
        select: any
        include: any
    }
        ? 'Please either choose `select` or `include`'
        : S extends true
          ? Families
          : S extends undefined
            ? never
            : S extends { include: any } & (FamiliesArgs | FamiliesFindManyArgs)
              ? Families & {
                    [P in TruthyKeys<S['include']>]: P extends 'tenants'
                        ? TenantsGetPayload<S['include'][P]>
                        : P extends 'family_furnishing'
                          ? Array<Family_furnishingGetPayload<S['include'][P]>>
                          : P extends 'family_housing'
                            ? Array<Family_housingGetPayload<S['include'][P]>>
                            : P extends 'family_sponsorship'
                              ? Array<Family_sponsorshipGetPayload<S['include'][P]>>
                              : P extends 'orphans'
                                ? Array<OrphansGetPayload<S['include'][P]>>
                                : P extends 'second_sponsors'
                                  ? Array<Second_sponsorsGetPayload<S['include'][P]>>
                                  : P extends 'spouses'
                                    ? Array<SpousesGetPayload<S['include'][P]>>
                                    : P extends '_count'
                                      ? FamiliesCountOutputTypeGetPayload<S['include'][P]>
                                      : never
                }
              : S extends { select: any } & (FamiliesArgs | FamiliesFindManyArgs)
                ? {
                      [P in TruthyKeys<S['select']>]: P extends 'tenants'
                          ? TenantsGetPayload<S['select'][P]>
                          : P extends 'family_furnishing'
                            ? Array<Family_furnishingGetPayload<S['select'][P]>>
                            : P extends 'family_housing'
                              ? Array<Family_housingGetPayload<S['select'][P]>>
                              : P extends 'family_sponsorship'
                                ? Array<Family_sponsorshipGetPayload<S['select'][P]>>
                                : P extends 'orphans'
                                  ? Array<OrphansGetPayload<S['select'][P]>>
                                  : P extends 'second_sponsors'
                                    ? Array<Second_sponsorsGetPayload<S['select'][P]>>
                                    : P extends 'spouses'
                                      ? Array<SpousesGetPayload<S['select'][P]>>
                                      : P extends '_count'
                                        ? FamiliesCountOutputTypeGetPayload<S['select'][P]>
                                        : P extends keyof Families
                                          ? Families[P]
                                          : never
                  }
                : Families

    type FamiliesCountArgs = Merge<
        Omit<FamiliesFindManyArgs, 'select' | 'include'> & {
            select?: FamiliesCountAggregateInputType | true
        }
    >

    export interface FamiliesDelegate<
        GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined
    > {
        /**
         * Find zero or one Families that matches the filter.
         * @param {FamiliesFindUniqueArgs} args - Arguments to find a Families
         * @example
         * // Get one Families
         * const families = await prisma.families.findUnique({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findUnique<
            T extends FamiliesFindUniqueArgs,
            LocalRejectSettings = T['rejectOnNotFound'] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined
        >(
            args: SelectSubset<T, FamiliesFindUniqueArgs>
        ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Families'> extends True
            ? Prisma__FamiliesClient<FamiliesGetPayload<T>>
            : Prisma__FamiliesClient<FamiliesGetPayload<T> | null, null>

        /**
         * Find one Families that matches the filter or throw an error  with `error.code='P2025'`
         *     if no matches were found.
         * @param {FamiliesFindUniqueOrThrowArgs} args - Arguments to find a Families
         * @example
         * // Get one Families
         * const families = await prisma.families.findUniqueOrThrow({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findUniqueOrThrow<T extends FamiliesFindUniqueOrThrowArgs>(
            args?: SelectSubset<T, FamiliesFindUniqueOrThrowArgs>
        ): Prisma__FamiliesClient<FamiliesGetPayload<T>>

        /**
         * Find the first Families that matches the filter.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {FamiliesFindFirstArgs} args - Arguments to find a Families
         * @example
         * // Get one Families
         * const families = await prisma.families.findFirst({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findFirst<
            T extends FamiliesFindFirstArgs,
            LocalRejectSettings = T['rejectOnNotFound'] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined
        >(
            args?: SelectSubset<T, FamiliesFindFirstArgs>
        ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Families'> extends True
            ? Prisma__FamiliesClient<FamiliesGetPayload<T>>
            : Prisma__FamiliesClient<FamiliesGetPayload<T> | null, null>

        /**
         * Find the first Families that matches the filter or
         * throw `NotFoundError` if no matches were found.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {FamiliesFindFirstOrThrowArgs} args - Arguments to find a Families
         * @example
         * // Get one Families
         * const families = await prisma.families.findFirstOrThrow({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findFirstOrThrow<T extends FamiliesFindFirstOrThrowArgs>(
            args?: SelectSubset<T, FamiliesFindFirstOrThrowArgs>
        ): Prisma__FamiliesClient<FamiliesGetPayload<T>>

        /**
         * Find zero or more Families that matches the filter.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {FamiliesFindManyArgs=} args - Arguments to filter and select certain fields only.
         * @example
         * // Get all Families
         * const families = await prisma.families.findMany()
         *
         * // Get first 10 Families
         * const families = await prisma.families.findMany({ take: 10 })
         *
         * // Only select the `id`
         * const familiesWithIdOnly = await prisma.families.findMany({ select: { id: true } })
         *
         **/
        findMany<T extends FamiliesFindManyArgs>(
            args?: SelectSubset<T, FamiliesFindManyArgs>
        ): PrismaPromise<Array<FamiliesGetPayload<T>>>

        /**
         * Create a Families.
         * @param {FamiliesCreateArgs} args - Arguments to create a Families.
         * @example
         * // Create one Families
         * const Families = await prisma.families.create({
         *   data: {
         *     // ... data to create a Families
         *   }
         * })
         *
         **/
        create<T extends FamiliesCreateArgs>(
            args: SelectSubset<T, FamiliesCreateArgs>
        ): Prisma__FamiliesClient<FamiliesGetPayload<T>>

        /**
         * Create many Families.
         *     @param {FamiliesCreateManyArgs} args - Arguments to create many Families.
         *     @example
         *     // Create many Families
         *     const families = await prisma.families.createMany({
         *       data: {
         *         // ... provide data here
         *       }
         *     })
         *
         **/
        createMany<T extends FamiliesCreateManyArgs>(
            args?: SelectSubset<T, FamiliesCreateManyArgs>
        ): PrismaPromise<BatchPayload>

        /**
         * Delete a Families.
         * @param {FamiliesDeleteArgs} args - Arguments to delete one Families.
         * @example
         * // Delete one Families
         * const Families = await prisma.families.delete({
         *   where: {
         *     // ... filter to delete one Families
         *   }
         * })
         *
         **/
        delete<T extends FamiliesDeleteArgs>(
            args: SelectSubset<T, FamiliesDeleteArgs>
        ): Prisma__FamiliesClient<FamiliesGetPayload<T>>

        /**
         * Update one Families.
         * @param {FamiliesUpdateArgs} args - Arguments to update one Families.
         * @example
         * // Update one Families
         * const families = await prisma.families.update({
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: {
         *     // ... provide data here
         *   }
         * })
         *
         **/
        update<T extends FamiliesUpdateArgs>(
            args: SelectSubset<T, FamiliesUpdateArgs>
        ): Prisma__FamiliesClient<FamiliesGetPayload<T>>

        /**
         * Delete zero or more Families.
         * @param {FamiliesDeleteManyArgs} args - Arguments to filter Families to delete.
         * @example
         * // Delete a few Families
         * const { count } = await prisma.families.deleteMany({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         *
         **/
        deleteMany<T extends FamiliesDeleteManyArgs>(
            args?: SelectSubset<T, FamiliesDeleteManyArgs>
        ): PrismaPromise<BatchPayload>

        /**
         * Update zero or more Families.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {FamiliesUpdateManyArgs} args - Arguments to update one or more rows.
         * @example
         * // Update many Families
         * const families = await prisma.families.updateMany({
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: {
         *     // ... provide data here
         *   }
         * })
         *
         **/
        updateMany<T extends FamiliesUpdateManyArgs>(
            args: SelectSubset<T, FamiliesUpdateManyArgs>
        ): PrismaPromise<BatchPayload>

        /**
         * Create or update one Families.
         * @param {FamiliesUpsertArgs} args - Arguments to update or create a Families.
         * @example
         * // Update or create a Families
         * const families = await prisma.families.upsert({
         *   create: {
         *     // ... data to create a Families
         *   },
         *   update: {
         *     // ... in case it already exists, update
         *   },
         *   where: {
         *     // ... the filter for the Families we want to update
         *   }
         * })
         **/
        upsert<T extends FamiliesUpsertArgs>(
            args: SelectSubset<T, FamiliesUpsertArgs>
        ): Prisma__FamiliesClient<FamiliesGetPayload<T>>

        /**
         * Count the number of Families.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {FamiliesCountArgs} args - Arguments to filter Families to count.
         * @example
         * // Count the number of Families
         * const count = await prisma.families.count({
         *   where: {
         *     // ... the filter for the Families we want to count
         *   }
         * })
         **/
        count<T extends FamiliesCountArgs>(
            args?: Subset<T, FamiliesCountArgs>
        ): PrismaPromise<
            T extends _Record<'select', any>
                ? T['select'] extends true
                    ? number
                    : GetScalarType<T['select'], FamiliesCountAggregateOutputType>
                : number
        >

        /**
         * Allows you to perform aggregations operations on a Families.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {FamiliesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
         * @example
         * // Ordered by age ascending
         * // Where email contains prisma.io
         * // Limited to the 10 users
         * const aggregations = await prisma.user.aggregate({
         *   _avg: {
         *     age: true,
         *   },
         *   where: {
         *     email: {
         *       contains: "prisma.io",
         *     },
         *   },
         *   orderBy: {
         *     age: "asc",
         *   },
         *   take: 10,
         * })
         **/
        aggregate<T extends FamiliesAggregateArgs>(
            args: Subset<T, FamiliesAggregateArgs>
        ): PrismaPromise<GetFamiliesAggregateType<T>>

        /**
         * Group by Families.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {FamiliesGroupByArgs} args - Group by arguments.
         * @example
         * // Group by city, order by createdAt, get count
         * const result = await prisma.user.groupBy({
         *   by: ['city', 'createdAt'],
         *   orderBy: {
         *     createdAt: true
         *   },
         *   _count: {
         *     _all: true
         *   },
         * })
         *
         **/
        groupBy<
            T extends FamiliesGroupByArgs,
            HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
            OrderByArg extends True extends HasSelectOrTake
                ? { orderBy: FamiliesGroupByArgs['orderBy'] }
                : { orderBy?: FamiliesGroupByArgs['orderBy'] },
            OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
            ByFields extends TupleToUnion<T['by']>,
            ByValid extends Has<ByFields, OrderFields>,
            HavingFields extends GetHavingFields<T['having']>,
            HavingValid extends Has<ByFields, HavingFields>,
            ByEmpty extends T['by'] extends never[] ? True : False,
            InputErrors extends ByEmpty extends True
                ? `Error: "by" must not be empty.`
                : HavingValid extends False
                  ? {
                        [P in HavingFields]: P extends ByFields
                            ? never
                            : P extends string
                              ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                              : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`]
                    }[HavingFields]
                  : 'take' extends Keys<T>
                    ? 'orderBy' extends Keys<T>
                        ? ByValid extends True
                            ? {}
                            : {
                                  [P in OrderFields]: P extends ByFields
                                      ? never
                                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                              }[OrderFields]
                        : 'Error: If you provide "take", you also need to provide "orderBy"'
                    : 'skip' extends Keys<T>
                      ? 'orderBy' extends Keys<T>
                          ? ByValid extends True
                              ? {}
                              : {
                                    [P in OrderFields]: P extends ByFields
                                        ? never
                                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                                }[OrderFields]
                          : 'Error: If you provide "skip", you also need to provide "orderBy"'
                      : ByValid extends True
                        ? {}
                        : {
                              [P in OrderFields]: P extends ByFields
                                  ? never
                                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                          }[OrderFields]
        >(
            args: SubsetIntersection<T, FamiliesGroupByArgs, OrderByArg> & InputErrors
        ): {} extends InputErrors ? GetFamiliesGroupByPayload<T> : PrismaPromise<InputErrors>
    }

    /**
     * The delegate class that acts as a "Promise-like" for Families.
     * Why is this prefixed with `Prisma__`?
     * Because we want to prevent naming conflicts as mentioned in
     * https://github.com/prisma/prisma-client-js/issues/707
     */
    export class Prisma__FamiliesClient<T, Null = never> implements PrismaPromise<T> {
        [prisma]: true
        private readonly _dmmf
        private readonly _fetcher
        private readonly _queryType
        private readonly _rootField
        private readonly _clientMethod
        private readonly _args
        private readonly _dataPath
        private readonly _errorFormat
        private readonly _measurePerformance?
        private _isList
        private _callsite
        private _requestPromise?
        constructor(
            _dmmf: runtime.DMMFClass,
            _fetcher: PrismaClientFetcher,
            _queryType: 'query' | 'mutation',
            _rootField: string,
            _clientMethod: string,
            _args: any,
            _dataPath: string[],
            _errorFormat: ErrorFormat,
            _measurePerformance?: boolean | undefined,
            _isList?: boolean
        )
        readonly [Symbol.toStringTag]: 'PrismaClientPromise'

        tenants<T extends TenantsArgs = {}>(
            args?: Subset<T, TenantsArgs>
        ): Prisma__TenantsClient<TenantsGetPayload<T> | Null>

        family_furnishing<T extends Families$family_furnishingArgs = {}>(
            args?: Subset<T, Families$family_furnishingArgs>
        ): PrismaPromise<Array<Family_furnishingGetPayload<T>> | Null>

        family_housing<T extends Families$family_housingArgs = {}>(
            args?: Subset<T, Families$family_housingArgs>
        ): PrismaPromise<Array<Family_housingGetPayload<T>> | Null>

        family_sponsorship<T extends Families$family_sponsorshipArgs = {}>(
            args?: Subset<T, Families$family_sponsorshipArgs>
        ): PrismaPromise<Array<Family_sponsorshipGetPayload<T>> | Null>

        orphans<T extends Families$orphansArgs = {}>(
            args?: Subset<T, Families$orphansArgs>
        ): PrismaPromise<Array<OrphansGetPayload<T>> | Null>

        second_sponsors<T extends Families$second_sponsorsArgs = {}>(
            args?: Subset<T, Families$second_sponsorsArgs>
        ): PrismaPromise<Array<Second_sponsorsGetPayload<T>> | Null>

        spouses<T extends Families$spousesArgs = {}>(
            args?: Subset<T, Families$spousesArgs>
        ): PrismaPromise<Array<SpousesGetPayload<T>> | Null>

        private get _document()
        /**
         * Attaches callbacks for the resolution and/or rejection of the Promise.
         * @param onfulfilled The callback to execute when the Promise is resolved.
         * @param onrejected The callback to execute when the Promise is rejected.
         * @returns A Promise for the completion of which ever callback is executed.
         */
        then<TResult1 = T, TResult2 = never>(
            onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
            onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
        ): Promise<TResult1 | TResult2>
        /**
         * Attaches a callback for only the rejection of the Promise.
         * @param onrejected The callback to execute when the Promise is rejected.
         * @returns A Promise for the completion of the callback.
         */
        catch<TResult = never>(
            onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
        ): Promise<T | TResult>
        /**
         * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
         * resolved value cannot be modified from the callback.
         * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
         * @returns A Promise for the completion of the callback.
         */
        finally(onfinally?: (() => void) | undefined | null): Promise<T>
    }

    // Custom InputTypes

    /**
     * Families base type for findUnique actions
     */
    export type FamiliesFindUniqueArgsBase = {
        /**
         * Select specific fields to fetch from the Families
         *
         **/
        select?: FamiliesSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: FamiliesInclude | null
        /**
         * Filter, which Families to fetch.
         *
         **/
        where: FamiliesWhereUniqueInput
    }

    /**
     * Families findUnique
     */
    export interface FamiliesFindUniqueArgs extends FamiliesFindUniqueArgsBase {
        /**
         * Throw an Error if query returns no results
         * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
         */
        rejectOnNotFound?: RejectOnNotFound
    }

    /**
     * Families findUniqueOrThrow
     */
    export type FamiliesFindUniqueOrThrowArgs = {
        /**
         * Select specific fields to fetch from the Families
         *
         **/
        select?: FamiliesSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: FamiliesInclude | null
        /**
         * Filter, which Families to fetch.
         *
         **/
        where: FamiliesWhereUniqueInput
    }

    /**
     * Families base type for findFirst actions
     */
    export type FamiliesFindFirstArgsBase = {
        /**
         * Select specific fields to fetch from the Families
         *
         **/
        select?: FamiliesSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: FamiliesInclude | null
        /**
         * Filter, which Families to fetch.
         *
         **/
        where?: FamiliesWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Families to fetch.
         *
         **/
        orderBy?: Enumerable<FamiliesOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for searching for Families.
         *
         **/
        cursor?: FamiliesWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Families from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Families.
         *
         **/
        skip?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
         *
         * Filter by unique combinations of Families.
         *
         **/
        distinct?: Enumerable<FamiliesScalarFieldEnum>
    }

    /**
     * Families findFirst
     */
    export interface FamiliesFindFirstArgs extends FamiliesFindFirstArgsBase {
        /**
         * Throw an Error if query returns no results
         * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
         */
        rejectOnNotFound?: RejectOnNotFound
    }

    /**
     * Families findFirstOrThrow
     */
    export type FamiliesFindFirstOrThrowArgs = {
        /**
         * Select specific fields to fetch from the Families
         *
         **/
        select?: FamiliesSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: FamiliesInclude | null
        /**
         * Filter, which Families to fetch.
         *
         **/
        where?: FamiliesWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Families to fetch.
         *
         **/
        orderBy?: Enumerable<FamiliesOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for searching for Families.
         *
         **/
        cursor?: FamiliesWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Families from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Families.
         *
         **/
        skip?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
         *
         * Filter by unique combinations of Families.
         *
         **/
        distinct?: Enumerable<FamiliesScalarFieldEnum>
    }

    /**
     * Families findMany
     */
    export type FamiliesFindManyArgs = {
        /**
         * Select specific fields to fetch from the Families
         *
         **/
        select?: FamiliesSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: FamiliesInclude | null
        /**
         * Filter, which Families to fetch.
         *
         **/
        where?: FamiliesWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Families to fetch.
         *
         **/
        orderBy?: Enumerable<FamiliesOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for listing Families.
         *
         **/
        cursor?: FamiliesWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Families from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Families.
         *
         **/
        skip?: number
        distinct?: Enumerable<FamiliesScalarFieldEnum>
    }

    /**
     * Families create
     */
    export type FamiliesCreateArgs = {
        /**
         * Select specific fields to fetch from the Families
         *
         **/
        select?: FamiliesSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: FamiliesInclude | null
        /**
         * The data needed to create a Families.
         *
         **/
        data: XOR<FamiliesCreateInput, FamiliesUncheckedCreateInput>
    }

    /**
     * Families createMany
     */
    export type FamiliesCreateManyArgs = {
        /**
         * The data used to create many Families.
         *
         **/
        data: Enumerable<FamiliesCreateManyInput>
        skipDuplicates?: boolean
    }

    /**
     * Families update
     */
    export type FamiliesUpdateArgs = {
        /**
         * Select specific fields to fetch from the Families
         *
         **/
        select?: FamiliesSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: FamiliesInclude | null
        /**
         * The data needed to update a Families.
         *
         **/
        data: XOR<FamiliesUpdateInput, FamiliesUncheckedUpdateInput>
        /**
         * Choose, which Families to update.
         *
         **/
        where: FamiliesWhereUniqueInput
    }

    /**
     * Families updateMany
     */
    export type FamiliesUpdateManyArgs = {
        /**
         * The data used to update Families.
         *
         **/
        data: XOR<FamiliesUpdateManyMutationInput, FamiliesUncheckedUpdateManyInput>
        /**
         * Filter which Families to update
         *
         **/
        where?: FamiliesWhereInput
    }

    /**
     * Families upsert
     */
    export type FamiliesUpsertArgs = {
        /**
         * Select specific fields to fetch from the Families
         *
         **/
        select?: FamiliesSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: FamiliesInclude | null
        /**
         * The filter to search for the Families to update in case it exists.
         *
         **/
        where: FamiliesWhereUniqueInput
        /**
         * In case the Families found by the `where` argument doesn't exist, create a new Families with this data.
         *
         **/
        create: XOR<FamiliesCreateInput, FamiliesUncheckedCreateInput>
        /**
         * In case the Families was found with the provided `where` argument, update it with this data.
         *
         **/
        update: XOR<FamiliesUpdateInput, FamiliesUncheckedUpdateInput>
    }

    /**
     * Families delete
     */
    export type FamiliesDeleteArgs = {
        /**
         * Select specific fields to fetch from the Families
         *
         **/
        select?: FamiliesSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: FamiliesInclude | null
        /**
         * Filter which Families to delete.
         *
         **/
        where: FamiliesWhereUniqueInput
    }

    /**
     * Families deleteMany
     */
    export type FamiliesDeleteManyArgs = {
        /**
         * Filter which Families to delete
         *
         **/
        where?: FamiliesWhereInput
    }

    /**
     * Families.family_furnishing
     */
    export type Families$family_furnishingArgs = {
        /**
         * Select specific fields to fetch from the Family_furnishing
         *
         **/
        select?: Family_furnishingSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Family_furnishingInclude | null
        where?: Family_furnishingWhereInput
        orderBy?: Enumerable<Family_furnishingOrderByWithRelationInput>
        cursor?: Family_furnishingWhereUniqueInput
        take?: number
        skip?: number
        distinct?: Enumerable<Family_furnishingScalarFieldEnum>
    }

    /**
     * Families.family_housing
     */
    export type Families$family_housingArgs = {
        /**
         * Select specific fields to fetch from the Family_housing
         *
         **/
        select?: Family_housingSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Family_housingInclude | null
        where?: Family_housingWhereInput
        orderBy?: Enumerable<Family_housingOrderByWithRelationInput>
        cursor?: Family_housingWhereUniqueInput
        take?: number
        skip?: number
        distinct?: Enumerable<Family_housingScalarFieldEnum>
    }

    /**
     * Families.family_sponsorship
     */
    export type Families$family_sponsorshipArgs = {
        /**
         * Select specific fields to fetch from the Family_sponsorship
         *
         **/
        select?: Family_sponsorshipSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Family_sponsorshipInclude | null
        where?: Family_sponsorshipWhereInput
        orderBy?: Enumerable<Family_sponsorshipOrderByWithRelationInput>
        cursor?: Family_sponsorshipWhereUniqueInput
        take?: number
        skip?: number
        distinct?: Enumerable<Family_sponsorshipScalarFieldEnum>
    }

    /**
     * Families.orphans
     */
    export type Families$orphansArgs = {
        /**
         * Select specific fields to fetch from the Orphans
         *
         **/
        select?: OrphansSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: OrphansInclude | null
        where?: OrphansWhereInput
        orderBy?: Enumerable<OrphansOrderByWithRelationInput>
        cursor?: OrphansWhereUniqueInput
        take?: number
        skip?: number
        distinct?: Enumerable<OrphansScalarFieldEnum>
    }

    /**
     * Families.second_sponsors
     */
    export type Families$second_sponsorsArgs = {
        /**
         * Select specific fields to fetch from the Second_sponsors
         *
         **/
        select?: Second_sponsorsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Second_sponsorsInclude | null
        where?: Second_sponsorsWhereInput
        orderBy?: Enumerable<Second_sponsorsOrderByWithRelationInput>
        cursor?: Second_sponsorsWhereUniqueInput
        take?: number
        skip?: number
        distinct?: Enumerable<Second_sponsorsScalarFieldEnum>
    }

    /**
     * Families.spouses
     */
    export type Families$spousesArgs = {
        /**
         * Select specific fields to fetch from the Spouses
         *
         **/
        select?: SpousesSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: SpousesInclude | null
        where?: SpousesWhereInput
        orderBy?: Enumerable<SpousesOrderByWithRelationInput>
        cursor?: SpousesWhereUniqueInput
        take?: number
        skip?: number
        distinct?: Enumerable<SpousesScalarFieldEnum>
    }

    /**
     * Families without action
     */
    export type FamiliesArgs = {
        /**
         * Select specific fields to fetch from the Families
         *
         **/
        select?: FamiliesSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: FamiliesInclude | null
    }

    /**
     * Model Family_furnishing
     */

    export type AggregateFamily_furnishing = {
        _count: Family_furnishingCountAggregateOutputType | null
        _min: Family_furnishingMinAggregateOutputType | null
        _max: Family_furnishingMaxAggregateOutputType | null
    }

    export type Family_furnishingMinAggregateOutputType = {
        id: string | null
        family_id: string | null
        furnishing_id: string | null
        value: string | null
    }

    export type Family_furnishingMaxAggregateOutputType = {
        id: string | null
        family_id: string | null
        furnishing_id: string | null
        value: string | null
    }

    export type Family_furnishingCountAggregateOutputType = {
        id: number
        family_id: number
        furnishing_id: number
        value: number
        _all: number
    }

    export type Family_furnishingMinAggregateInputType = {
        id?: true
        family_id?: true
        furnishing_id?: true
        value?: true
    }

    export type Family_furnishingMaxAggregateInputType = {
        id?: true
        family_id?: true
        furnishing_id?: true
        value?: true
    }

    export type Family_furnishingCountAggregateInputType = {
        id?: true
        family_id?: true
        furnishing_id?: true
        value?: true
        _all?: true
    }

    export type Family_furnishingAggregateArgs = {
        /**
         * Filter which Family_furnishing to aggregate.
         *
         **/
        where?: Family_furnishingWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Family_furnishings to fetch.
         *
         **/
        orderBy?: Enumerable<Family_furnishingOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the start position
         *
         **/
        cursor?: Family_furnishingWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Family_furnishings from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Family_furnishings.
         *
         **/
        skip?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Count returned Family_furnishings
         **/
        _count?: true | Family_furnishingCountAggregateInputType
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to find the minimum value
         **/
        _min?: Family_furnishingMinAggregateInputType
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to find the maximum value
         **/
        _max?: Family_furnishingMaxAggregateInputType
    }

    export type GetFamily_furnishingAggregateType<T extends Family_furnishingAggregateArgs> = {
        [P in keyof T & keyof AggregateFamily_furnishing]: P extends '_count' | 'count'
            ? T[P] extends true
                ? number
                : GetScalarType<T[P], AggregateFamily_furnishing[P]>
            : GetScalarType<T[P], AggregateFamily_furnishing[P]>
    }

    export type Family_furnishingGroupByArgs = {
        where?: Family_furnishingWhereInput
        orderBy?: Enumerable<Family_furnishingOrderByWithAggregationInput>
        by: Array<Family_furnishingScalarFieldEnum>
        having?: Family_furnishingScalarWhereWithAggregatesInput
        take?: number
        skip?: number
        _count?: Family_furnishingCountAggregateInputType | true
        _min?: Family_furnishingMinAggregateInputType
        _max?: Family_furnishingMaxAggregateInputType
    }

    export type Family_furnishingGroupByOutputType = {
        id: string
        family_id: string
        furnishing_id: string
        value: string
        _count: Family_furnishingCountAggregateOutputType | null
        _min: Family_furnishingMinAggregateOutputType | null
        _max: Family_furnishingMaxAggregateOutputType | null
    }

    type GetFamily_furnishingGroupByPayload<T extends Family_furnishingGroupByArgs> = PrismaPromise<
        Array<
            PickArray<Family_furnishingGroupByOutputType, T['by']> & {
                [P in keyof T & keyof Family_furnishingGroupByOutputType]: P extends '_count'
                    ? T[P] extends boolean
                        ? number
                        : GetScalarType<T[P], Family_furnishingGroupByOutputType[P]>
                    : GetScalarType<T[P], Family_furnishingGroupByOutputType[P]>
            }
        >
    >

    export type Family_furnishingSelect = {
        id?: boolean
        family_id?: boolean
        furnishing_id?: boolean
        value?: boolean
        families?: boolean | FamiliesArgs
        furnishings?: boolean | FurnishingsArgs
    }

    export type Family_furnishingInclude = {
        families?: boolean | FamiliesArgs
        furnishings?: boolean | FurnishingsArgs
    }

    export type Family_furnishingGetPayload<S extends boolean | null | undefined | Family_furnishingArgs> = S extends {
        select: any
        include: any
    }
        ? 'Please either choose `select` or `include`'
        : S extends true
          ? Family_furnishing
          : S extends undefined
            ? never
            : S extends { include: any } & (Family_furnishingArgs | Family_furnishingFindManyArgs)
              ? Family_furnishing & {
                    [P in TruthyKeys<S['include']>]: P extends 'families'
                        ? FamiliesGetPayload<S['include'][P]>
                        : P extends 'furnishings'
                          ? FurnishingsGetPayload<S['include'][P]>
                          : never
                }
              : S extends { select: any } & (Family_furnishingArgs | Family_furnishingFindManyArgs)
                ? {
                      [P in TruthyKeys<S['select']>]: P extends 'families'
                          ? FamiliesGetPayload<S['select'][P]>
                          : P extends 'furnishings'
                            ? FurnishingsGetPayload<S['select'][P]>
                            : P extends keyof Family_furnishing
                              ? Family_furnishing[P]
                              : never
                  }
                : Family_furnishing

    type Family_furnishingCountArgs = Merge<
        Omit<Family_furnishingFindManyArgs, 'select' | 'include'> & {
            select?: Family_furnishingCountAggregateInputType | true
        }
    >

    export interface Family_furnishingDelegate<
        GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined
    > {
        /**
         * Find zero or one Family_furnishing that matches the filter.
         * @param {Family_furnishingFindUniqueArgs} args - Arguments to find a Family_furnishing
         * @example
         * // Get one Family_furnishing
         * const family_furnishing = await prisma.family_furnishing.findUnique({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findUnique<
            T extends Family_furnishingFindUniqueArgs,
            LocalRejectSettings = T['rejectOnNotFound'] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined
        >(
            args: SelectSubset<T, Family_furnishingFindUniqueArgs>
        ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Family_furnishing'> extends True
            ? Prisma__Family_furnishingClient<Family_furnishingGetPayload<T>>
            : Prisma__Family_furnishingClient<Family_furnishingGetPayload<T> | null, null>

        /**
         * Find one Family_furnishing that matches the filter or throw an error  with `error.code='P2025'`
         *     if no matches were found.
         * @param {Family_furnishingFindUniqueOrThrowArgs} args - Arguments to find a Family_furnishing
         * @example
         * // Get one Family_furnishing
         * const family_furnishing = await prisma.family_furnishing.findUniqueOrThrow({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findUniqueOrThrow<T extends Family_furnishingFindUniqueOrThrowArgs>(
            args?: SelectSubset<T, Family_furnishingFindUniqueOrThrowArgs>
        ): Prisma__Family_furnishingClient<Family_furnishingGetPayload<T>>

        /**
         * Find the first Family_furnishing that matches the filter.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {Family_furnishingFindFirstArgs} args - Arguments to find a Family_furnishing
         * @example
         * // Get one Family_furnishing
         * const family_furnishing = await prisma.family_furnishing.findFirst({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findFirst<
            T extends Family_furnishingFindFirstArgs,
            LocalRejectSettings = T['rejectOnNotFound'] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined
        >(
            args?: SelectSubset<T, Family_furnishingFindFirstArgs>
        ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Family_furnishing'> extends True
            ? Prisma__Family_furnishingClient<Family_furnishingGetPayload<T>>
            : Prisma__Family_furnishingClient<Family_furnishingGetPayload<T> | null, null>

        /**
         * Find the first Family_furnishing that matches the filter or
         * throw `NotFoundError` if no matches were found.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {Family_furnishingFindFirstOrThrowArgs} args - Arguments to find a Family_furnishing
         * @example
         * // Get one Family_furnishing
         * const family_furnishing = await prisma.family_furnishing.findFirstOrThrow({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findFirstOrThrow<T extends Family_furnishingFindFirstOrThrowArgs>(
            args?: SelectSubset<T, Family_furnishingFindFirstOrThrowArgs>
        ): Prisma__Family_furnishingClient<Family_furnishingGetPayload<T>>

        /**
         * Find zero or more Family_furnishings that matches the filter.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {Family_furnishingFindManyArgs=} args - Arguments to filter and select certain fields only.
         * @example
         * // Get all Family_furnishings
         * const family_furnishings = await prisma.family_furnishing.findMany()
         *
         * // Get first 10 Family_furnishings
         * const family_furnishings = await prisma.family_furnishing.findMany({ take: 10 })
         *
         * // Only select the `id`
         * const family_furnishingWithIdOnly = await prisma.family_furnishing.findMany({ select: { id: true } })
         *
         **/
        findMany<T extends Family_furnishingFindManyArgs>(
            args?: SelectSubset<T, Family_furnishingFindManyArgs>
        ): PrismaPromise<Array<Family_furnishingGetPayload<T>>>

        /**
         * Create a Family_furnishing.
         * @param {Family_furnishingCreateArgs} args - Arguments to create a Family_furnishing.
         * @example
         * // Create one Family_furnishing
         * const Family_furnishing = await prisma.family_furnishing.create({
         *   data: {
         *     // ... data to create a Family_furnishing
         *   }
         * })
         *
         **/
        create<T extends Family_furnishingCreateArgs>(
            args: SelectSubset<T, Family_furnishingCreateArgs>
        ): Prisma__Family_furnishingClient<Family_furnishingGetPayload<T>>

        /**
         * Create many Family_furnishings.
         *     @param {Family_furnishingCreateManyArgs} args - Arguments to create many Family_furnishings.
         *     @example
         *     // Create many Family_furnishings
         *     const family_furnishing = await prisma.family_furnishing.createMany({
         *       data: {
         *         // ... provide data here
         *       }
         *     })
         *
         **/
        createMany<T extends Family_furnishingCreateManyArgs>(
            args?: SelectSubset<T, Family_furnishingCreateManyArgs>
        ): PrismaPromise<BatchPayload>

        /**
         * Delete a Family_furnishing.
         * @param {Family_furnishingDeleteArgs} args - Arguments to delete one Family_furnishing.
         * @example
         * // Delete one Family_furnishing
         * const Family_furnishing = await prisma.family_furnishing.delete({
         *   where: {
         *     // ... filter to delete one Family_furnishing
         *   }
         * })
         *
         **/
        delete<T extends Family_furnishingDeleteArgs>(
            args: SelectSubset<T, Family_furnishingDeleteArgs>
        ): Prisma__Family_furnishingClient<Family_furnishingGetPayload<T>>

        /**
         * Update one Family_furnishing.
         * @param {Family_furnishingUpdateArgs} args - Arguments to update one Family_furnishing.
         * @example
         * // Update one Family_furnishing
         * const family_furnishing = await prisma.family_furnishing.update({
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: {
         *     // ... provide data here
         *   }
         * })
         *
         **/
        update<T extends Family_furnishingUpdateArgs>(
            args: SelectSubset<T, Family_furnishingUpdateArgs>
        ): Prisma__Family_furnishingClient<Family_furnishingGetPayload<T>>

        /**
         * Delete zero or more Family_furnishings.
         * @param {Family_furnishingDeleteManyArgs} args - Arguments to filter Family_furnishings to delete.
         * @example
         * // Delete a few Family_furnishings
         * const { count } = await prisma.family_furnishing.deleteMany({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         *
         **/
        deleteMany<T extends Family_furnishingDeleteManyArgs>(
            args?: SelectSubset<T, Family_furnishingDeleteManyArgs>
        ): PrismaPromise<BatchPayload>

        /**
         * Update zero or more Family_furnishings.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {Family_furnishingUpdateManyArgs} args - Arguments to update one or more rows.
         * @example
         * // Update many Family_furnishings
         * const family_furnishing = await prisma.family_furnishing.updateMany({
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: {
         *     // ... provide data here
         *   }
         * })
         *
         **/
        updateMany<T extends Family_furnishingUpdateManyArgs>(
            args: SelectSubset<T, Family_furnishingUpdateManyArgs>
        ): PrismaPromise<BatchPayload>

        /**
         * Create or update one Family_furnishing.
         * @param {Family_furnishingUpsertArgs} args - Arguments to update or create a Family_furnishing.
         * @example
         * // Update or create a Family_furnishing
         * const family_furnishing = await prisma.family_furnishing.upsert({
         *   create: {
         *     // ... data to create a Family_furnishing
         *   },
         *   update: {
         *     // ... in case it already exists, update
         *   },
         *   where: {
         *     // ... the filter for the Family_furnishing we want to update
         *   }
         * })
         **/
        upsert<T extends Family_furnishingUpsertArgs>(
            args: SelectSubset<T, Family_furnishingUpsertArgs>
        ): Prisma__Family_furnishingClient<Family_furnishingGetPayload<T>>

        /**
         * Count the number of Family_furnishings.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {Family_furnishingCountArgs} args - Arguments to filter Family_furnishings to count.
         * @example
         * // Count the number of Family_furnishings
         * const count = await prisma.family_furnishing.count({
         *   where: {
         *     // ... the filter for the Family_furnishings we want to count
         *   }
         * })
         **/
        count<T extends Family_furnishingCountArgs>(
            args?: Subset<T, Family_furnishingCountArgs>
        ): PrismaPromise<
            T extends _Record<'select', any>
                ? T['select'] extends true
                    ? number
                    : GetScalarType<T['select'], Family_furnishingCountAggregateOutputType>
                : number
        >

        /**
         * Allows you to perform aggregations operations on a Family_furnishing.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {Family_furnishingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
         * @example
         * // Ordered by age ascending
         * // Where email contains prisma.io
         * // Limited to the 10 users
         * const aggregations = await prisma.user.aggregate({
         *   _avg: {
         *     age: true,
         *   },
         *   where: {
         *     email: {
         *       contains: "prisma.io",
         *     },
         *   },
         *   orderBy: {
         *     age: "asc",
         *   },
         *   take: 10,
         * })
         **/
        aggregate<T extends Family_furnishingAggregateArgs>(
            args: Subset<T, Family_furnishingAggregateArgs>
        ): PrismaPromise<GetFamily_furnishingAggregateType<T>>

        /**
         * Group by Family_furnishing.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {Family_furnishingGroupByArgs} args - Group by arguments.
         * @example
         * // Group by city, order by createdAt, get count
         * const result = await prisma.user.groupBy({
         *   by: ['city', 'createdAt'],
         *   orderBy: {
         *     createdAt: true
         *   },
         *   _count: {
         *     _all: true
         *   },
         * })
         *
         **/
        groupBy<
            T extends Family_furnishingGroupByArgs,
            HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
            OrderByArg extends True extends HasSelectOrTake
                ? { orderBy: Family_furnishingGroupByArgs['orderBy'] }
                : { orderBy?: Family_furnishingGroupByArgs['orderBy'] },
            OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
            ByFields extends TupleToUnion<T['by']>,
            ByValid extends Has<ByFields, OrderFields>,
            HavingFields extends GetHavingFields<T['having']>,
            HavingValid extends Has<ByFields, HavingFields>,
            ByEmpty extends T['by'] extends never[] ? True : False,
            InputErrors extends ByEmpty extends True
                ? `Error: "by" must not be empty.`
                : HavingValid extends False
                  ? {
                        [P in HavingFields]: P extends ByFields
                            ? never
                            : P extends string
                              ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                              : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`]
                    }[HavingFields]
                  : 'take' extends Keys<T>
                    ? 'orderBy' extends Keys<T>
                        ? ByValid extends True
                            ? {}
                            : {
                                  [P in OrderFields]: P extends ByFields
                                      ? never
                                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                              }[OrderFields]
                        : 'Error: If you provide "take", you also need to provide "orderBy"'
                    : 'skip' extends Keys<T>
                      ? 'orderBy' extends Keys<T>
                          ? ByValid extends True
                              ? {}
                              : {
                                    [P in OrderFields]: P extends ByFields
                                        ? never
                                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                                }[OrderFields]
                          : 'Error: If you provide "skip", you also need to provide "orderBy"'
                      : ByValid extends True
                        ? {}
                        : {
                              [P in OrderFields]: P extends ByFields
                                  ? never
                                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                          }[OrderFields]
        >(
            args: SubsetIntersection<T, Family_furnishingGroupByArgs, OrderByArg> & InputErrors
        ): {} extends InputErrors ? GetFamily_furnishingGroupByPayload<T> : PrismaPromise<InputErrors>
    }

    /**
     * The delegate class that acts as a "Promise-like" for Family_furnishing.
     * Why is this prefixed with `Prisma__`?
     * Because we want to prevent naming conflicts as mentioned in
     * https://github.com/prisma/prisma-client-js/issues/707
     */
    export class Prisma__Family_furnishingClient<T, Null = never> implements PrismaPromise<T> {
        [prisma]: true
        private readonly _dmmf
        private readonly _fetcher
        private readonly _queryType
        private readonly _rootField
        private readonly _clientMethod
        private readonly _args
        private readonly _dataPath
        private readonly _errorFormat
        private readonly _measurePerformance?
        private _isList
        private _callsite
        private _requestPromise?
        constructor(
            _dmmf: runtime.DMMFClass,
            _fetcher: PrismaClientFetcher,
            _queryType: 'query' | 'mutation',
            _rootField: string,
            _clientMethod: string,
            _args: any,
            _dataPath: string[],
            _errorFormat: ErrorFormat,
            _measurePerformance?: boolean | undefined,
            _isList?: boolean
        )
        readonly [Symbol.toStringTag]: 'PrismaClientPromise'

        families<T extends FamiliesArgs = {}>(
            args?: Subset<T, FamiliesArgs>
        ): Prisma__FamiliesClient<FamiliesGetPayload<T> | Null>

        furnishings<T extends FurnishingsArgs = {}>(
            args?: Subset<T, FurnishingsArgs>
        ): Prisma__FurnishingsClient<FurnishingsGetPayload<T> | Null>

        private get _document()
        /**
         * Attaches callbacks for the resolution and/or rejection of the Promise.
         * @param onfulfilled The callback to execute when the Promise is resolved.
         * @param onrejected The callback to execute when the Promise is rejected.
         * @returns A Promise for the completion of which ever callback is executed.
         */
        then<TResult1 = T, TResult2 = never>(
            onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
            onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
        ): Promise<TResult1 | TResult2>
        /**
         * Attaches a callback for only the rejection of the Promise.
         * @param onrejected The callback to execute when the Promise is rejected.
         * @returns A Promise for the completion of the callback.
         */
        catch<TResult = never>(
            onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
        ): Promise<T | TResult>
        /**
         * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
         * resolved value cannot be modified from the callback.
         * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
         * @returns A Promise for the completion of the callback.
         */
        finally(onfinally?: (() => void) | undefined | null): Promise<T>
    }

    // Custom InputTypes

    /**
     * Family_furnishing base type for findUnique actions
     */
    export type Family_furnishingFindUniqueArgsBase = {
        /**
         * Select specific fields to fetch from the Family_furnishing
         *
         **/
        select?: Family_furnishingSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Family_furnishingInclude | null
        /**
         * Filter, which Family_furnishing to fetch.
         *
         **/
        where: Family_furnishingWhereUniqueInput
    }

    /**
     * Family_furnishing findUnique
     */
    export interface Family_furnishingFindUniqueArgs extends Family_furnishingFindUniqueArgsBase {
        /**
         * Throw an Error if query returns no results
         * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
         */
        rejectOnNotFound?: RejectOnNotFound
    }

    /**
     * Family_furnishing findUniqueOrThrow
     */
    export type Family_furnishingFindUniqueOrThrowArgs = {
        /**
         * Select specific fields to fetch from the Family_furnishing
         *
         **/
        select?: Family_furnishingSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Family_furnishingInclude | null
        /**
         * Filter, which Family_furnishing to fetch.
         *
         **/
        where: Family_furnishingWhereUniqueInput
    }

    /**
     * Family_furnishing base type for findFirst actions
     */
    export type Family_furnishingFindFirstArgsBase = {
        /**
         * Select specific fields to fetch from the Family_furnishing
         *
         **/
        select?: Family_furnishingSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Family_furnishingInclude | null
        /**
         * Filter, which Family_furnishing to fetch.
         *
         **/
        where?: Family_furnishingWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Family_furnishings to fetch.
         *
         **/
        orderBy?: Enumerable<Family_furnishingOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for searching for Family_furnishings.
         *
         **/
        cursor?: Family_furnishingWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Family_furnishings from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Family_furnishings.
         *
         **/
        skip?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
         *
         * Filter by unique combinations of Family_furnishings.
         *
         **/
        distinct?: Enumerable<Family_furnishingScalarFieldEnum>
    }

    /**
     * Family_furnishing findFirst
     */
    export interface Family_furnishingFindFirstArgs extends Family_furnishingFindFirstArgsBase {
        /**
         * Throw an Error if query returns no results
         * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
         */
        rejectOnNotFound?: RejectOnNotFound
    }

    /**
     * Family_furnishing findFirstOrThrow
     */
    export type Family_furnishingFindFirstOrThrowArgs = {
        /**
         * Select specific fields to fetch from the Family_furnishing
         *
         **/
        select?: Family_furnishingSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Family_furnishingInclude | null
        /**
         * Filter, which Family_furnishing to fetch.
         *
         **/
        where?: Family_furnishingWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Family_furnishings to fetch.
         *
         **/
        orderBy?: Enumerable<Family_furnishingOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for searching for Family_furnishings.
         *
         **/
        cursor?: Family_furnishingWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Family_furnishings from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Family_furnishings.
         *
         **/
        skip?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
         *
         * Filter by unique combinations of Family_furnishings.
         *
         **/
        distinct?: Enumerable<Family_furnishingScalarFieldEnum>
    }

    /**
     * Family_furnishing findMany
     */
    export type Family_furnishingFindManyArgs = {
        /**
         * Select specific fields to fetch from the Family_furnishing
         *
         **/
        select?: Family_furnishingSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Family_furnishingInclude | null
        /**
         * Filter, which Family_furnishings to fetch.
         *
         **/
        where?: Family_furnishingWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Family_furnishings to fetch.
         *
         **/
        orderBy?: Enumerable<Family_furnishingOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for listing Family_furnishings.
         *
         **/
        cursor?: Family_furnishingWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Family_furnishings from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Family_furnishings.
         *
         **/
        skip?: number
        distinct?: Enumerable<Family_furnishingScalarFieldEnum>
    }

    /**
     * Family_furnishing create
     */
    export type Family_furnishingCreateArgs = {
        /**
         * Select specific fields to fetch from the Family_furnishing
         *
         **/
        select?: Family_furnishingSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Family_furnishingInclude | null
        /**
         * The data needed to create a Family_furnishing.
         *
         **/
        data: XOR<Family_furnishingCreateInput, Family_furnishingUncheckedCreateInput>
    }

    /**
     * Family_furnishing createMany
     */
    export type Family_furnishingCreateManyArgs = {
        /**
         * The data used to create many Family_furnishings.
         *
         **/
        data: Enumerable<Family_furnishingCreateManyInput>
        skipDuplicates?: boolean
    }

    /**
     * Family_furnishing update
     */
    export type Family_furnishingUpdateArgs = {
        /**
         * Select specific fields to fetch from the Family_furnishing
         *
         **/
        select?: Family_furnishingSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Family_furnishingInclude | null
        /**
         * The data needed to update a Family_furnishing.
         *
         **/
        data: XOR<Family_furnishingUpdateInput, Family_furnishingUncheckedUpdateInput>
        /**
         * Choose, which Family_furnishing to update.
         *
         **/
        where: Family_furnishingWhereUniqueInput
    }

    /**
     * Family_furnishing updateMany
     */
    export type Family_furnishingUpdateManyArgs = {
        /**
         * The data used to update Family_furnishings.
         *
         **/
        data: XOR<Family_furnishingUpdateManyMutationInput, Family_furnishingUncheckedUpdateManyInput>
        /**
         * Filter which Family_furnishings to update
         *
         **/
        where?: Family_furnishingWhereInput
    }

    /**
     * Family_furnishing upsert
     */
    export type Family_furnishingUpsertArgs = {
        /**
         * Select specific fields to fetch from the Family_furnishing
         *
         **/
        select?: Family_furnishingSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Family_furnishingInclude | null
        /**
         * The filter to search for the Family_furnishing to update in case it exists.
         *
         **/
        where: Family_furnishingWhereUniqueInput
        /**
         * In case the Family_furnishing found by the `where` argument doesn't exist, create a new Family_furnishing with this data.
         *
         **/
        create: XOR<Family_furnishingCreateInput, Family_furnishingUncheckedCreateInput>
        /**
         * In case the Family_furnishing was found with the provided `where` argument, update it with this data.
         *
         **/
        update: XOR<Family_furnishingUpdateInput, Family_furnishingUncheckedUpdateInput>
    }

    /**
     * Family_furnishing delete
     */
    export type Family_furnishingDeleteArgs = {
        /**
         * Select specific fields to fetch from the Family_furnishing
         *
         **/
        select?: Family_furnishingSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Family_furnishingInclude | null
        /**
         * Filter which Family_furnishing to delete.
         *
         **/
        where: Family_furnishingWhereUniqueInput
    }

    /**
     * Family_furnishing deleteMany
     */
    export type Family_furnishingDeleteManyArgs = {
        /**
         * Filter which Family_furnishings to delete
         *
         **/
        where?: Family_furnishingWhereInput
    }

    /**
     * Family_furnishing without action
     */
    export type Family_furnishingArgs = {
        /**
         * Select specific fields to fetch from the Family_furnishing
         *
         **/
        select?: Family_furnishingSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Family_furnishingInclude | null
    }

    /**
     * Model Family_housing
     */

    export type AggregateFamily_housing = {
        _count: Family_housingCountAggregateOutputType | null
        _min: Family_housingMinAggregateOutputType | null
        _max: Family_housingMaxAggregateOutputType | null
    }

    export type Family_housingMinAggregateOutputType = {
        id: string | null
        family_id: string | null
        housing_id: string | null
        value: string | null
    }

    export type Family_housingMaxAggregateOutputType = {
        id: string | null
        family_id: string | null
        housing_id: string | null
        value: string | null
    }

    export type Family_housingCountAggregateOutputType = {
        id: number
        family_id: number
        housing_id: number
        value: number
        _all: number
    }

    export type Family_housingMinAggregateInputType = {
        id?: true
        family_id?: true
        housing_id?: true
        value?: true
    }

    export type Family_housingMaxAggregateInputType = {
        id?: true
        family_id?: true
        housing_id?: true
        value?: true
    }

    export type Family_housingCountAggregateInputType = {
        id?: true
        family_id?: true
        housing_id?: true
        value?: true
        _all?: true
    }

    export type Family_housingAggregateArgs = {
        /**
         * Filter which Family_housing to aggregate.
         *
         **/
        where?: Family_housingWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Family_housings to fetch.
         *
         **/
        orderBy?: Enumerable<Family_housingOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the start position
         *
         **/
        cursor?: Family_housingWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Family_housings from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Family_housings.
         *
         **/
        skip?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Count returned Family_housings
         **/
        _count?: true | Family_housingCountAggregateInputType
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to find the minimum value
         **/
        _min?: Family_housingMinAggregateInputType
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to find the maximum value
         **/
        _max?: Family_housingMaxAggregateInputType
    }

    export type GetFamily_housingAggregateType<T extends Family_housingAggregateArgs> = {
        [P in keyof T & keyof AggregateFamily_housing]: P extends '_count' | 'count'
            ? T[P] extends true
                ? number
                : GetScalarType<T[P], AggregateFamily_housing[P]>
            : GetScalarType<T[P], AggregateFamily_housing[P]>
    }

    export type Family_housingGroupByArgs = {
        where?: Family_housingWhereInput
        orderBy?: Enumerable<Family_housingOrderByWithAggregationInput>
        by: Array<Family_housingScalarFieldEnum>
        having?: Family_housingScalarWhereWithAggregatesInput
        take?: number
        skip?: number
        _count?: Family_housingCountAggregateInputType | true
        _min?: Family_housingMinAggregateInputType
        _max?: Family_housingMaxAggregateInputType
    }

    export type Family_housingGroupByOutputType = {
        id: string
        family_id: string
        housing_id: string
        value: string
        _count: Family_housingCountAggregateOutputType | null
        _min: Family_housingMinAggregateOutputType | null
        _max: Family_housingMaxAggregateOutputType | null
    }

    type GetFamily_housingGroupByPayload<T extends Family_housingGroupByArgs> = PrismaPromise<
        Array<
            PickArray<Family_housingGroupByOutputType, T['by']> & {
                [P in keyof T & keyof Family_housingGroupByOutputType]: P extends '_count'
                    ? T[P] extends boolean
                        ? number
                        : GetScalarType<T[P], Family_housingGroupByOutputType[P]>
                    : GetScalarType<T[P], Family_housingGroupByOutputType[P]>
            }
        >
    >

    export type Family_housingSelect = {
        id?: boolean
        family_id?: boolean
        housing_id?: boolean
        value?: boolean
        families?: boolean | FamiliesArgs
        housings?: boolean | HousingsArgs
    }

    export type Family_housingInclude = {
        families?: boolean | FamiliesArgs
        housings?: boolean | HousingsArgs
    }

    export type Family_housingGetPayload<S extends boolean | null | undefined | Family_housingArgs> = S extends {
        select: any
        include: any
    }
        ? 'Please either choose `select` or `include`'
        : S extends true
          ? Family_housing
          : S extends undefined
            ? never
            : S extends { include: any } & (Family_housingArgs | Family_housingFindManyArgs)
              ? Family_housing & {
                    [P in TruthyKeys<S['include']>]: P extends 'families'
                        ? FamiliesGetPayload<S['include'][P]>
                        : P extends 'housings'
                          ? HousingsGetPayload<S['include'][P]>
                          : never
                }
              : S extends { select: any } & (Family_housingArgs | Family_housingFindManyArgs)
                ? {
                      [P in TruthyKeys<S['select']>]: P extends 'families'
                          ? FamiliesGetPayload<S['select'][P]>
                          : P extends 'housings'
                            ? HousingsGetPayload<S['select'][P]>
                            : P extends keyof Family_housing
                              ? Family_housing[P]
                              : never
                  }
                : Family_housing

    type Family_housingCountArgs = Merge<
        Omit<Family_housingFindManyArgs, 'select' | 'include'> & {
            select?: Family_housingCountAggregateInputType | true
        }
    >

    export interface Family_housingDelegate<
        GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined
    > {
        /**
         * Find zero or one Family_housing that matches the filter.
         * @param {Family_housingFindUniqueArgs} args - Arguments to find a Family_housing
         * @example
         * // Get one Family_housing
         * const family_housing = await prisma.family_housing.findUnique({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findUnique<
            T extends Family_housingFindUniqueArgs,
            LocalRejectSettings = T['rejectOnNotFound'] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined
        >(
            args: SelectSubset<T, Family_housingFindUniqueArgs>
        ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Family_housing'> extends True
            ? Prisma__Family_housingClient<Family_housingGetPayload<T>>
            : Prisma__Family_housingClient<Family_housingGetPayload<T> | null, null>

        /**
         * Find one Family_housing that matches the filter or throw an error  with `error.code='P2025'`
         *     if no matches were found.
         * @param {Family_housingFindUniqueOrThrowArgs} args - Arguments to find a Family_housing
         * @example
         * // Get one Family_housing
         * const family_housing = await prisma.family_housing.findUniqueOrThrow({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findUniqueOrThrow<T extends Family_housingFindUniqueOrThrowArgs>(
            args?: SelectSubset<T, Family_housingFindUniqueOrThrowArgs>
        ): Prisma__Family_housingClient<Family_housingGetPayload<T>>

        /**
         * Find the first Family_housing that matches the filter.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {Family_housingFindFirstArgs} args - Arguments to find a Family_housing
         * @example
         * // Get one Family_housing
         * const family_housing = await prisma.family_housing.findFirst({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findFirst<
            T extends Family_housingFindFirstArgs,
            LocalRejectSettings = T['rejectOnNotFound'] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined
        >(
            args?: SelectSubset<T, Family_housingFindFirstArgs>
        ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Family_housing'> extends True
            ? Prisma__Family_housingClient<Family_housingGetPayload<T>>
            : Prisma__Family_housingClient<Family_housingGetPayload<T> | null, null>

        /**
         * Find the first Family_housing that matches the filter or
         * throw `NotFoundError` if no matches were found.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {Family_housingFindFirstOrThrowArgs} args - Arguments to find a Family_housing
         * @example
         * // Get one Family_housing
         * const family_housing = await prisma.family_housing.findFirstOrThrow({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findFirstOrThrow<T extends Family_housingFindFirstOrThrowArgs>(
            args?: SelectSubset<T, Family_housingFindFirstOrThrowArgs>
        ): Prisma__Family_housingClient<Family_housingGetPayload<T>>

        /**
         * Find zero or more Family_housings that matches the filter.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {Family_housingFindManyArgs=} args - Arguments to filter and select certain fields only.
         * @example
         * // Get all Family_housings
         * const family_housings = await prisma.family_housing.findMany()
         *
         * // Get first 10 Family_housings
         * const family_housings = await prisma.family_housing.findMany({ take: 10 })
         *
         * // Only select the `id`
         * const family_housingWithIdOnly = await prisma.family_housing.findMany({ select: { id: true } })
         *
         **/
        findMany<T extends Family_housingFindManyArgs>(
            args?: SelectSubset<T, Family_housingFindManyArgs>
        ): PrismaPromise<Array<Family_housingGetPayload<T>>>

        /**
         * Create a Family_housing.
         * @param {Family_housingCreateArgs} args - Arguments to create a Family_housing.
         * @example
         * // Create one Family_housing
         * const Family_housing = await prisma.family_housing.create({
         *   data: {
         *     // ... data to create a Family_housing
         *   }
         * })
         *
         **/
        create<T extends Family_housingCreateArgs>(
            args: SelectSubset<T, Family_housingCreateArgs>
        ): Prisma__Family_housingClient<Family_housingGetPayload<T>>

        /**
         * Create many Family_housings.
         *     @param {Family_housingCreateManyArgs} args - Arguments to create many Family_housings.
         *     @example
         *     // Create many Family_housings
         *     const family_housing = await prisma.family_housing.createMany({
         *       data: {
         *         // ... provide data here
         *       }
         *     })
         *
         **/
        createMany<T extends Family_housingCreateManyArgs>(
            args?: SelectSubset<T, Family_housingCreateManyArgs>
        ): PrismaPromise<BatchPayload>

        /**
         * Delete a Family_housing.
         * @param {Family_housingDeleteArgs} args - Arguments to delete one Family_housing.
         * @example
         * // Delete one Family_housing
         * const Family_housing = await prisma.family_housing.delete({
         *   where: {
         *     // ... filter to delete one Family_housing
         *   }
         * })
         *
         **/
        delete<T extends Family_housingDeleteArgs>(
            args: SelectSubset<T, Family_housingDeleteArgs>
        ): Prisma__Family_housingClient<Family_housingGetPayload<T>>

        /**
         * Update one Family_housing.
         * @param {Family_housingUpdateArgs} args - Arguments to update one Family_housing.
         * @example
         * // Update one Family_housing
         * const family_housing = await prisma.family_housing.update({
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: {
         *     // ... provide data here
         *   }
         * })
         *
         **/
        update<T extends Family_housingUpdateArgs>(
            args: SelectSubset<T, Family_housingUpdateArgs>
        ): Prisma__Family_housingClient<Family_housingGetPayload<T>>

        /**
         * Delete zero or more Family_housings.
         * @param {Family_housingDeleteManyArgs} args - Arguments to filter Family_housings to delete.
         * @example
         * // Delete a few Family_housings
         * const { count } = await prisma.family_housing.deleteMany({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         *
         **/
        deleteMany<T extends Family_housingDeleteManyArgs>(
            args?: SelectSubset<T, Family_housingDeleteManyArgs>
        ): PrismaPromise<BatchPayload>

        /**
         * Update zero or more Family_housings.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {Family_housingUpdateManyArgs} args - Arguments to update one or more rows.
         * @example
         * // Update many Family_housings
         * const family_housing = await prisma.family_housing.updateMany({
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: {
         *     // ... provide data here
         *   }
         * })
         *
         **/
        updateMany<T extends Family_housingUpdateManyArgs>(
            args: SelectSubset<T, Family_housingUpdateManyArgs>
        ): PrismaPromise<BatchPayload>

        /**
         * Create or update one Family_housing.
         * @param {Family_housingUpsertArgs} args - Arguments to update or create a Family_housing.
         * @example
         * // Update or create a Family_housing
         * const family_housing = await prisma.family_housing.upsert({
         *   create: {
         *     // ... data to create a Family_housing
         *   },
         *   update: {
         *     // ... in case it already exists, update
         *   },
         *   where: {
         *     // ... the filter for the Family_housing we want to update
         *   }
         * })
         **/
        upsert<T extends Family_housingUpsertArgs>(
            args: SelectSubset<T, Family_housingUpsertArgs>
        ): Prisma__Family_housingClient<Family_housingGetPayload<T>>

        /**
         * Count the number of Family_housings.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {Family_housingCountArgs} args - Arguments to filter Family_housings to count.
         * @example
         * // Count the number of Family_housings
         * const count = await prisma.family_housing.count({
         *   where: {
         *     // ... the filter for the Family_housings we want to count
         *   }
         * })
         **/
        count<T extends Family_housingCountArgs>(
            args?: Subset<T, Family_housingCountArgs>
        ): PrismaPromise<
            T extends _Record<'select', any>
                ? T['select'] extends true
                    ? number
                    : GetScalarType<T['select'], Family_housingCountAggregateOutputType>
                : number
        >

        /**
         * Allows you to perform aggregations operations on a Family_housing.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {Family_housingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
         * @example
         * // Ordered by age ascending
         * // Where email contains prisma.io
         * // Limited to the 10 users
         * const aggregations = await prisma.user.aggregate({
         *   _avg: {
         *     age: true,
         *   },
         *   where: {
         *     email: {
         *       contains: "prisma.io",
         *     },
         *   },
         *   orderBy: {
         *     age: "asc",
         *   },
         *   take: 10,
         * })
         **/
        aggregate<T extends Family_housingAggregateArgs>(
            args: Subset<T, Family_housingAggregateArgs>
        ): PrismaPromise<GetFamily_housingAggregateType<T>>

        /**
         * Group by Family_housing.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {Family_housingGroupByArgs} args - Group by arguments.
         * @example
         * // Group by city, order by createdAt, get count
         * const result = await prisma.user.groupBy({
         *   by: ['city', 'createdAt'],
         *   orderBy: {
         *     createdAt: true
         *   },
         *   _count: {
         *     _all: true
         *   },
         * })
         *
         **/
        groupBy<
            T extends Family_housingGroupByArgs,
            HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
            OrderByArg extends True extends HasSelectOrTake
                ? { orderBy: Family_housingGroupByArgs['orderBy'] }
                : { orderBy?: Family_housingGroupByArgs['orderBy'] },
            OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
            ByFields extends TupleToUnion<T['by']>,
            ByValid extends Has<ByFields, OrderFields>,
            HavingFields extends GetHavingFields<T['having']>,
            HavingValid extends Has<ByFields, HavingFields>,
            ByEmpty extends T['by'] extends never[] ? True : False,
            InputErrors extends ByEmpty extends True
                ? `Error: "by" must not be empty.`
                : HavingValid extends False
                  ? {
                        [P in HavingFields]: P extends ByFields
                            ? never
                            : P extends string
                              ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                              : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`]
                    }[HavingFields]
                  : 'take' extends Keys<T>
                    ? 'orderBy' extends Keys<T>
                        ? ByValid extends True
                            ? {}
                            : {
                                  [P in OrderFields]: P extends ByFields
                                      ? never
                                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                              }[OrderFields]
                        : 'Error: If you provide "take", you also need to provide "orderBy"'
                    : 'skip' extends Keys<T>
                      ? 'orderBy' extends Keys<T>
                          ? ByValid extends True
                              ? {}
                              : {
                                    [P in OrderFields]: P extends ByFields
                                        ? never
                                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                                }[OrderFields]
                          : 'Error: If you provide "skip", you also need to provide "orderBy"'
                      : ByValid extends True
                        ? {}
                        : {
                              [P in OrderFields]: P extends ByFields
                                  ? never
                                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                          }[OrderFields]
        >(
            args: SubsetIntersection<T, Family_housingGroupByArgs, OrderByArg> & InputErrors
        ): {} extends InputErrors ? GetFamily_housingGroupByPayload<T> : PrismaPromise<InputErrors>
    }

    /**
     * The delegate class that acts as a "Promise-like" for Family_housing.
     * Why is this prefixed with `Prisma__`?
     * Because we want to prevent naming conflicts as mentioned in
     * https://github.com/prisma/prisma-client-js/issues/707
     */
    export class Prisma__Family_housingClient<T, Null = never> implements PrismaPromise<T> {
        [prisma]: true
        private readonly _dmmf
        private readonly _fetcher
        private readonly _queryType
        private readonly _rootField
        private readonly _clientMethod
        private readonly _args
        private readonly _dataPath
        private readonly _errorFormat
        private readonly _measurePerformance?
        private _isList
        private _callsite
        private _requestPromise?
        constructor(
            _dmmf: runtime.DMMFClass,
            _fetcher: PrismaClientFetcher,
            _queryType: 'query' | 'mutation',
            _rootField: string,
            _clientMethod: string,
            _args: any,
            _dataPath: string[],
            _errorFormat: ErrorFormat,
            _measurePerformance?: boolean | undefined,
            _isList?: boolean
        )
        readonly [Symbol.toStringTag]: 'PrismaClientPromise'

        families<T extends FamiliesArgs = {}>(
            args?: Subset<T, FamiliesArgs>
        ): Prisma__FamiliesClient<FamiliesGetPayload<T> | Null>

        housings<T extends HousingsArgs = {}>(
            args?: Subset<T, HousingsArgs>
        ): Prisma__HousingsClient<HousingsGetPayload<T> | Null>

        private get _document()
        /**
         * Attaches callbacks for the resolution and/or rejection of the Promise.
         * @param onfulfilled The callback to execute when the Promise is resolved.
         * @param onrejected The callback to execute when the Promise is rejected.
         * @returns A Promise for the completion of which ever callback is executed.
         */
        then<TResult1 = T, TResult2 = never>(
            onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
            onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
        ): Promise<TResult1 | TResult2>
        /**
         * Attaches a callback for only the rejection of the Promise.
         * @param onrejected The callback to execute when the Promise is rejected.
         * @returns A Promise for the completion of the callback.
         */
        catch<TResult = never>(
            onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
        ): Promise<T | TResult>
        /**
         * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
         * resolved value cannot be modified from the callback.
         * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
         * @returns A Promise for the completion of the callback.
         */
        finally(onfinally?: (() => void) | undefined | null): Promise<T>
    }

    // Custom InputTypes

    /**
     * Family_housing base type for findUnique actions
     */
    export type Family_housingFindUniqueArgsBase = {
        /**
         * Select specific fields to fetch from the Family_housing
         *
         **/
        select?: Family_housingSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Family_housingInclude | null
        /**
         * Filter, which Family_housing to fetch.
         *
         **/
        where: Family_housingWhereUniqueInput
    }

    /**
     * Family_housing findUnique
     */
    export interface Family_housingFindUniqueArgs extends Family_housingFindUniqueArgsBase {
        /**
         * Throw an Error if query returns no results
         * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
         */
        rejectOnNotFound?: RejectOnNotFound
    }

    /**
     * Family_housing findUniqueOrThrow
     */
    export type Family_housingFindUniqueOrThrowArgs = {
        /**
         * Select specific fields to fetch from the Family_housing
         *
         **/
        select?: Family_housingSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Family_housingInclude | null
        /**
         * Filter, which Family_housing to fetch.
         *
         **/
        where: Family_housingWhereUniqueInput
    }

    /**
     * Family_housing base type for findFirst actions
     */
    export type Family_housingFindFirstArgsBase = {
        /**
         * Select specific fields to fetch from the Family_housing
         *
         **/
        select?: Family_housingSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Family_housingInclude | null
        /**
         * Filter, which Family_housing to fetch.
         *
         **/
        where?: Family_housingWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Family_housings to fetch.
         *
         **/
        orderBy?: Enumerable<Family_housingOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for searching for Family_housings.
         *
         **/
        cursor?: Family_housingWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Family_housings from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Family_housings.
         *
         **/
        skip?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
         *
         * Filter by unique combinations of Family_housings.
         *
         **/
        distinct?: Enumerable<Family_housingScalarFieldEnum>
    }

    /**
     * Family_housing findFirst
     */
    export interface Family_housingFindFirstArgs extends Family_housingFindFirstArgsBase {
        /**
         * Throw an Error if query returns no results
         * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
         */
        rejectOnNotFound?: RejectOnNotFound
    }

    /**
     * Family_housing findFirstOrThrow
     */
    export type Family_housingFindFirstOrThrowArgs = {
        /**
         * Select specific fields to fetch from the Family_housing
         *
         **/
        select?: Family_housingSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Family_housingInclude | null
        /**
         * Filter, which Family_housing to fetch.
         *
         **/
        where?: Family_housingWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Family_housings to fetch.
         *
         **/
        orderBy?: Enumerable<Family_housingOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for searching for Family_housings.
         *
         **/
        cursor?: Family_housingWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Family_housings from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Family_housings.
         *
         **/
        skip?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
         *
         * Filter by unique combinations of Family_housings.
         *
         **/
        distinct?: Enumerable<Family_housingScalarFieldEnum>
    }

    /**
     * Family_housing findMany
     */
    export type Family_housingFindManyArgs = {
        /**
         * Select specific fields to fetch from the Family_housing
         *
         **/
        select?: Family_housingSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Family_housingInclude | null
        /**
         * Filter, which Family_housings to fetch.
         *
         **/
        where?: Family_housingWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Family_housings to fetch.
         *
         **/
        orderBy?: Enumerable<Family_housingOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for listing Family_housings.
         *
         **/
        cursor?: Family_housingWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Family_housings from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Family_housings.
         *
         **/
        skip?: number
        distinct?: Enumerable<Family_housingScalarFieldEnum>
    }

    /**
     * Family_housing create
     */
    export type Family_housingCreateArgs = {
        /**
         * Select specific fields to fetch from the Family_housing
         *
         **/
        select?: Family_housingSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Family_housingInclude | null
        /**
         * The data needed to create a Family_housing.
         *
         **/
        data: XOR<Family_housingCreateInput, Family_housingUncheckedCreateInput>
    }

    /**
     * Family_housing createMany
     */
    export type Family_housingCreateManyArgs = {
        /**
         * The data used to create many Family_housings.
         *
         **/
        data: Enumerable<Family_housingCreateManyInput>
        skipDuplicates?: boolean
    }

    /**
     * Family_housing update
     */
    export type Family_housingUpdateArgs = {
        /**
         * Select specific fields to fetch from the Family_housing
         *
         **/
        select?: Family_housingSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Family_housingInclude | null
        /**
         * The data needed to update a Family_housing.
         *
         **/
        data: XOR<Family_housingUpdateInput, Family_housingUncheckedUpdateInput>
        /**
         * Choose, which Family_housing to update.
         *
         **/
        where: Family_housingWhereUniqueInput
    }

    /**
     * Family_housing updateMany
     */
    export type Family_housingUpdateManyArgs = {
        /**
         * The data used to update Family_housings.
         *
         **/
        data: XOR<Family_housingUpdateManyMutationInput, Family_housingUncheckedUpdateManyInput>
        /**
         * Filter which Family_housings to update
         *
         **/
        where?: Family_housingWhereInput
    }

    /**
     * Family_housing upsert
     */
    export type Family_housingUpsertArgs = {
        /**
         * Select specific fields to fetch from the Family_housing
         *
         **/
        select?: Family_housingSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Family_housingInclude | null
        /**
         * The filter to search for the Family_housing to update in case it exists.
         *
         **/
        where: Family_housingWhereUniqueInput
        /**
         * In case the Family_housing found by the `where` argument doesn't exist, create a new Family_housing with this data.
         *
         **/
        create: XOR<Family_housingCreateInput, Family_housingUncheckedCreateInput>
        /**
         * In case the Family_housing was found with the provided `where` argument, update it with this data.
         *
         **/
        update: XOR<Family_housingUpdateInput, Family_housingUncheckedUpdateInput>
    }

    /**
     * Family_housing delete
     */
    export type Family_housingDeleteArgs = {
        /**
         * Select specific fields to fetch from the Family_housing
         *
         **/
        select?: Family_housingSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Family_housingInclude | null
        /**
         * Filter which Family_housing to delete.
         *
         **/
        where: Family_housingWhereUniqueInput
    }

    /**
     * Family_housing deleteMany
     */
    export type Family_housingDeleteManyArgs = {
        /**
         * Filter which Family_housings to delete
         *
         **/
        where?: Family_housingWhereInput
    }

    /**
     * Family_housing without action
     */
    export type Family_housingArgs = {
        /**
         * Select specific fields to fetch from the Family_housing
         *
         **/
        select?: Family_housingSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Family_housingInclude | null
    }

    /**
     * Model Family_sponsorship
     */

    export type AggregateFamily_sponsorship = {
        _count: Family_sponsorshipCountAggregateOutputType | null
        _min: Family_sponsorshipMinAggregateOutputType | null
        _max: Family_sponsorshipMaxAggregateOutputType | null
    }

    export type Family_sponsorshipMinAggregateOutputType = {
        id: string | null
        family_id: string | null
        type: family_sponsorship_type | null
        value: string | null
        tenant_id: string | null
        created_at: Date | null
        updated_at: Date | null
    }

    export type Family_sponsorshipMaxAggregateOutputType = {
        id: string | null
        family_id: string | null
        type: family_sponsorship_type | null
        value: string | null
        tenant_id: string | null
        created_at: Date | null
        updated_at: Date | null
    }

    export type Family_sponsorshipCountAggregateOutputType = {
        id: number
        family_id: number
        type: number
        value: number
        tenant_id: number
        created_at: number
        updated_at: number
        _all: number
    }

    export type Family_sponsorshipMinAggregateInputType = {
        id?: true
        family_id?: true
        type?: true
        value?: true
        tenant_id?: true
        created_at?: true
        updated_at?: true
    }

    export type Family_sponsorshipMaxAggregateInputType = {
        id?: true
        family_id?: true
        type?: true
        value?: true
        tenant_id?: true
        created_at?: true
        updated_at?: true
    }

    export type Family_sponsorshipCountAggregateInputType = {
        id?: true
        family_id?: true
        type?: true
        value?: true
        tenant_id?: true
        created_at?: true
        updated_at?: true
        _all?: true
    }

    export type Family_sponsorshipAggregateArgs = {
        /**
         * Filter which Family_sponsorship to aggregate.
         *
         **/
        where?: Family_sponsorshipWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Family_sponsorships to fetch.
         *
         **/
        orderBy?: Enumerable<Family_sponsorshipOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the start position
         *
         **/
        cursor?: Family_sponsorshipWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Family_sponsorships from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Family_sponsorships.
         *
         **/
        skip?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Count returned Family_sponsorships
         **/
        _count?: true | Family_sponsorshipCountAggregateInputType
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to find the minimum value
         **/
        _min?: Family_sponsorshipMinAggregateInputType
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to find the maximum value
         **/
        _max?: Family_sponsorshipMaxAggregateInputType
    }

    export type GetFamily_sponsorshipAggregateType<T extends Family_sponsorshipAggregateArgs> = {
        [P in keyof T & keyof AggregateFamily_sponsorship]: P extends '_count' | 'count'
            ? T[P] extends true
                ? number
                : GetScalarType<T[P], AggregateFamily_sponsorship[P]>
            : GetScalarType<T[P], AggregateFamily_sponsorship[P]>
    }

    export type Family_sponsorshipGroupByArgs = {
        where?: Family_sponsorshipWhereInput
        orderBy?: Enumerable<Family_sponsorshipOrderByWithAggregationInput>
        by: Array<Family_sponsorshipScalarFieldEnum>
        having?: Family_sponsorshipScalarWhereWithAggregatesInput
        take?: number
        skip?: number
        _count?: Family_sponsorshipCountAggregateInputType | true
        _min?: Family_sponsorshipMinAggregateInputType
        _max?: Family_sponsorshipMaxAggregateInputType
    }

    export type Family_sponsorshipGroupByOutputType = {
        id: string
        family_id: string
        type: family_sponsorship_type
        value: string
        tenant_id: string
        created_at: Date | null
        updated_at: Date | null
        _count: Family_sponsorshipCountAggregateOutputType | null
        _min: Family_sponsorshipMinAggregateOutputType | null
        _max: Family_sponsorshipMaxAggregateOutputType | null
    }

    type GetFamily_sponsorshipGroupByPayload<T extends Family_sponsorshipGroupByArgs> = PrismaPromise<
        Array<
            PickArray<Family_sponsorshipGroupByOutputType, T['by']> & {
                [P in keyof T & keyof Family_sponsorshipGroupByOutputType]: P extends '_count'
                    ? T[P] extends boolean
                        ? number
                        : GetScalarType<T[P], Family_sponsorshipGroupByOutputType[P]>
                    : GetScalarType<T[P], Family_sponsorshipGroupByOutputType[P]>
            }
        >
    >

    export type Family_sponsorshipSelect = {
        id?: boolean
        family_id?: boolean
        type?: boolean
        value?: boolean
        tenant_id?: boolean
        created_at?: boolean
        updated_at?: boolean
        families?: boolean | FamiliesArgs
        tenants?: boolean | TenantsArgs
    }

    export type Family_sponsorshipInclude = {
        families?: boolean | FamiliesArgs
        tenants?: boolean | TenantsArgs
    }

    export type Family_sponsorshipGetPayload<S extends boolean | null | undefined | Family_sponsorshipArgs> =
        S extends { select: any; include: any }
            ? 'Please either choose `select` or `include`'
            : S extends true
              ? Family_sponsorship
              : S extends undefined
                ? never
                : S extends { include: any } & (Family_sponsorshipArgs | Family_sponsorshipFindManyArgs)
                  ? Family_sponsorship & {
                        [P in TruthyKeys<S['include']>]: P extends 'families'
                            ? FamiliesGetPayload<S['include'][P]>
                            : P extends 'tenants'
                              ? TenantsGetPayload<S['include'][P]>
                              : never
                    }
                  : S extends { select: any } & (Family_sponsorshipArgs | Family_sponsorshipFindManyArgs)
                    ? {
                          [P in TruthyKeys<S['select']>]: P extends 'families'
                              ? FamiliesGetPayload<S['select'][P]>
                              : P extends 'tenants'
                                ? TenantsGetPayload<S['select'][P]>
                                : P extends keyof Family_sponsorship
                                  ? Family_sponsorship[P]
                                  : never
                      }
                    : Family_sponsorship

    type Family_sponsorshipCountArgs = Merge<
        Omit<Family_sponsorshipFindManyArgs, 'select' | 'include'> & {
            select?: Family_sponsorshipCountAggregateInputType | true
        }
    >

    export interface Family_sponsorshipDelegate<
        GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined
    > {
        /**
         * Find zero or one Family_sponsorship that matches the filter.
         * @param {Family_sponsorshipFindUniqueArgs} args - Arguments to find a Family_sponsorship
         * @example
         * // Get one Family_sponsorship
         * const family_sponsorship = await prisma.family_sponsorship.findUnique({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findUnique<
            T extends Family_sponsorshipFindUniqueArgs,
            LocalRejectSettings = T['rejectOnNotFound'] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined
        >(
            args: SelectSubset<T, Family_sponsorshipFindUniqueArgs>
        ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Family_sponsorship'> extends True
            ? Prisma__Family_sponsorshipClient<Family_sponsorshipGetPayload<T>>
            : Prisma__Family_sponsorshipClient<Family_sponsorshipGetPayload<T> | null, null>

        /**
         * Find one Family_sponsorship that matches the filter or throw an error  with `error.code='P2025'`
         *     if no matches were found.
         * @param {Family_sponsorshipFindUniqueOrThrowArgs} args - Arguments to find a Family_sponsorship
         * @example
         * // Get one Family_sponsorship
         * const family_sponsorship = await prisma.family_sponsorship.findUniqueOrThrow({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findUniqueOrThrow<T extends Family_sponsorshipFindUniqueOrThrowArgs>(
            args?: SelectSubset<T, Family_sponsorshipFindUniqueOrThrowArgs>
        ): Prisma__Family_sponsorshipClient<Family_sponsorshipGetPayload<T>>

        /**
         * Find the first Family_sponsorship that matches the filter.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {Family_sponsorshipFindFirstArgs} args - Arguments to find a Family_sponsorship
         * @example
         * // Get one Family_sponsorship
         * const family_sponsorship = await prisma.family_sponsorship.findFirst({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findFirst<
            T extends Family_sponsorshipFindFirstArgs,
            LocalRejectSettings = T['rejectOnNotFound'] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined
        >(
            args?: SelectSubset<T, Family_sponsorshipFindFirstArgs>
        ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Family_sponsorship'> extends True
            ? Prisma__Family_sponsorshipClient<Family_sponsorshipGetPayload<T>>
            : Prisma__Family_sponsorshipClient<Family_sponsorshipGetPayload<T> | null, null>

        /**
         * Find the first Family_sponsorship that matches the filter or
         * throw `NotFoundError` if no matches were found.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {Family_sponsorshipFindFirstOrThrowArgs} args - Arguments to find a Family_sponsorship
         * @example
         * // Get one Family_sponsorship
         * const family_sponsorship = await prisma.family_sponsorship.findFirstOrThrow({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findFirstOrThrow<T extends Family_sponsorshipFindFirstOrThrowArgs>(
            args?: SelectSubset<T, Family_sponsorshipFindFirstOrThrowArgs>
        ): Prisma__Family_sponsorshipClient<Family_sponsorshipGetPayload<T>>

        /**
         * Find zero or more Family_sponsorships that matches the filter.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {Family_sponsorshipFindManyArgs=} args - Arguments to filter and select certain fields only.
         * @example
         * // Get all Family_sponsorships
         * const family_sponsorships = await prisma.family_sponsorship.findMany()
         *
         * // Get first 10 Family_sponsorships
         * const family_sponsorships = await prisma.family_sponsorship.findMany({ take: 10 })
         *
         * // Only select the `id`
         * const family_sponsorshipWithIdOnly = await prisma.family_sponsorship.findMany({ select: { id: true } })
         *
         **/
        findMany<T extends Family_sponsorshipFindManyArgs>(
            args?: SelectSubset<T, Family_sponsorshipFindManyArgs>
        ): PrismaPromise<Array<Family_sponsorshipGetPayload<T>>>

        /**
         * Create a Family_sponsorship.
         * @param {Family_sponsorshipCreateArgs} args - Arguments to create a Family_sponsorship.
         * @example
         * // Create one Family_sponsorship
         * const Family_sponsorship = await prisma.family_sponsorship.create({
         *   data: {
         *     // ... data to create a Family_sponsorship
         *   }
         * })
         *
         **/
        create<T extends Family_sponsorshipCreateArgs>(
            args: SelectSubset<T, Family_sponsorshipCreateArgs>
        ): Prisma__Family_sponsorshipClient<Family_sponsorshipGetPayload<T>>

        /**
         * Create many Family_sponsorships.
         *     @param {Family_sponsorshipCreateManyArgs} args - Arguments to create many Family_sponsorships.
         *     @example
         *     // Create many Family_sponsorships
         *     const family_sponsorship = await prisma.family_sponsorship.createMany({
         *       data: {
         *         // ... provide data here
         *       }
         *     })
         *
         **/
        createMany<T extends Family_sponsorshipCreateManyArgs>(
            args?: SelectSubset<T, Family_sponsorshipCreateManyArgs>
        ): PrismaPromise<BatchPayload>

        /**
         * Delete a Family_sponsorship.
         * @param {Family_sponsorshipDeleteArgs} args - Arguments to delete one Family_sponsorship.
         * @example
         * // Delete one Family_sponsorship
         * const Family_sponsorship = await prisma.family_sponsorship.delete({
         *   where: {
         *     // ... filter to delete one Family_sponsorship
         *   }
         * })
         *
         **/
        delete<T extends Family_sponsorshipDeleteArgs>(
            args: SelectSubset<T, Family_sponsorshipDeleteArgs>
        ): Prisma__Family_sponsorshipClient<Family_sponsorshipGetPayload<T>>

        /**
         * Update one Family_sponsorship.
         * @param {Family_sponsorshipUpdateArgs} args - Arguments to update one Family_sponsorship.
         * @example
         * // Update one Family_sponsorship
         * const family_sponsorship = await prisma.family_sponsorship.update({
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: {
         *     // ... provide data here
         *   }
         * })
         *
         **/
        update<T extends Family_sponsorshipUpdateArgs>(
            args: SelectSubset<T, Family_sponsorshipUpdateArgs>
        ): Prisma__Family_sponsorshipClient<Family_sponsorshipGetPayload<T>>

        /**
         * Delete zero or more Family_sponsorships.
         * @param {Family_sponsorshipDeleteManyArgs} args - Arguments to filter Family_sponsorships to delete.
         * @example
         * // Delete a few Family_sponsorships
         * const { count } = await prisma.family_sponsorship.deleteMany({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         *
         **/
        deleteMany<T extends Family_sponsorshipDeleteManyArgs>(
            args?: SelectSubset<T, Family_sponsorshipDeleteManyArgs>
        ): PrismaPromise<BatchPayload>

        /**
         * Update zero or more Family_sponsorships.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {Family_sponsorshipUpdateManyArgs} args - Arguments to update one or more rows.
         * @example
         * // Update many Family_sponsorships
         * const family_sponsorship = await prisma.family_sponsorship.updateMany({
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: {
         *     // ... provide data here
         *   }
         * })
         *
         **/
        updateMany<T extends Family_sponsorshipUpdateManyArgs>(
            args: SelectSubset<T, Family_sponsorshipUpdateManyArgs>
        ): PrismaPromise<BatchPayload>

        /**
         * Create or update one Family_sponsorship.
         * @param {Family_sponsorshipUpsertArgs} args - Arguments to update or create a Family_sponsorship.
         * @example
         * // Update or create a Family_sponsorship
         * const family_sponsorship = await prisma.family_sponsorship.upsert({
         *   create: {
         *     // ... data to create a Family_sponsorship
         *   },
         *   update: {
         *     // ... in case it already exists, update
         *   },
         *   where: {
         *     // ... the filter for the Family_sponsorship we want to update
         *   }
         * })
         **/
        upsert<T extends Family_sponsorshipUpsertArgs>(
            args: SelectSubset<T, Family_sponsorshipUpsertArgs>
        ): Prisma__Family_sponsorshipClient<Family_sponsorshipGetPayload<T>>

        /**
         * Count the number of Family_sponsorships.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {Family_sponsorshipCountArgs} args - Arguments to filter Family_sponsorships to count.
         * @example
         * // Count the number of Family_sponsorships
         * const count = await prisma.family_sponsorship.count({
         *   where: {
         *     // ... the filter for the Family_sponsorships we want to count
         *   }
         * })
         **/
        count<T extends Family_sponsorshipCountArgs>(
            args?: Subset<T, Family_sponsorshipCountArgs>
        ): PrismaPromise<
            T extends _Record<'select', any>
                ? T['select'] extends true
                    ? number
                    : GetScalarType<T['select'], Family_sponsorshipCountAggregateOutputType>
                : number
        >

        /**
         * Allows you to perform aggregations operations on a Family_sponsorship.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {Family_sponsorshipAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
         * @example
         * // Ordered by age ascending
         * // Where email contains prisma.io
         * // Limited to the 10 users
         * const aggregations = await prisma.user.aggregate({
         *   _avg: {
         *     age: true,
         *   },
         *   where: {
         *     email: {
         *       contains: "prisma.io",
         *     },
         *   },
         *   orderBy: {
         *     age: "asc",
         *   },
         *   take: 10,
         * })
         **/
        aggregate<T extends Family_sponsorshipAggregateArgs>(
            args: Subset<T, Family_sponsorshipAggregateArgs>
        ): PrismaPromise<GetFamily_sponsorshipAggregateType<T>>

        /**
         * Group by Family_sponsorship.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {Family_sponsorshipGroupByArgs} args - Group by arguments.
         * @example
         * // Group by city, order by createdAt, get count
         * const result = await prisma.user.groupBy({
         *   by: ['city', 'createdAt'],
         *   orderBy: {
         *     createdAt: true
         *   },
         *   _count: {
         *     _all: true
         *   },
         * })
         *
         **/
        groupBy<
            T extends Family_sponsorshipGroupByArgs,
            HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
            OrderByArg extends True extends HasSelectOrTake
                ? { orderBy: Family_sponsorshipGroupByArgs['orderBy'] }
                : { orderBy?: Family_sponsorshipGroupByArgs['orderBy'] },
            OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
            ByFields extends TupleToUnion<T['by']>,
            ByValid extends Has<ByFields, OrderFields>,
            HavingFields extends GetHavingFields<T['having']>,
            HavingValid extends Has<ByFields, HavingFields>,
            ByEmpty extends T['by'] extends never[] ? True : False,
            InputErrors extends ByEmpty extends True
                ? `Error: "by" must not be empty.`
                : HavingValid extends False
                  ? {
                        [P in HavingFields]: P extends ByFields
                            ? never
                            : P extends string
                              ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                              : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`]
                    }[HavingFields]
                  : 'take' extends Keys<T>
                    ? 'orderBy' extends Keys<T>
                        ? ByValid extends True
                            ? {}
                            : {
                                  [P in OrderFields]: P extends ByFields
                                      ? never
                                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                              }[OrderFields]
                        : 'Error: If you provide "take", you also need to provide "orderBy"'
                    : 'skip' extends Keys<T>
                      ? 'orderBy' extends Keys<T>
                          ? ByValid extends True
                              ? {}
                              : {
                                    [P in OrderFields]: P extends ByFields
                                        ? never
                                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                                }[OrderFields]
                          : 'Error: If you provide "skip", you also need to provide "orderBy"'
                      : ByValid extends True
                        ? {}
                        : {
                              [P in OrderFields]: P extends ByFields
                                  ? never
                                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                          }[OrderFields]
        >(
            args: SubsetIntersection<T, Family_sponsorshipGroupByArgs, OrderByArg> & InputErrors
        ): {} extends InputErrors ? GetFamily_sponsorshipGroupByPayload<T> : PrismaPromise<InputErrors>
    }

    /**
     * The delegate class that acts as a "Promise-like" for Family_sponsorship.
     * Why is this prefixed with `Prisma__`?
     * Because we want to prevent naming conflicts as mentioned in
     * https://github.com/prisma/prisma-client-js/issues/707
     */
    export class Prisma__Family_sponsorshipClient<T, Null = never> implements PrismaPromise<T> {
        [prisma]: true
        private readonly _dmmf
        private readonly _fetcher
        private readonly _queryType
        private readonly _rootField
        private readonly _clientMethod
        private readonly _args
        private readonly _dataPath
        private readonly _errorFormat
        private readonly _measurePerformance?
        private _isList
        private _callsite
        private _requestPromise?
        constructor(
            _dmmf: runtime.DMMFClass,
            _fetcher: PrismaClientFetcher,
            _queryType: 'query' | 'mutation',
            _rootField: string,
            _clientMethod: string,
            _args: any,
            _dataPath: string[],
            _errorFormat: ErrorFormat,
            _measurePerformance?: boolean | undefined,
            _isList?: boolean
        )
        readonly [Symbol.toStringTag]: 'PrismaClientPromise'

        families<T extends FamiliesArgs = {}>(
            args?: Subset<T, FamiliesArgs>
        ): Prisma__FamiliesClient<FamiliesGetPayload<T> | Null>

        tenants<T extends TenantsArgs = {}>(
            args?: Subset<T, TenantsArgs>
        ): Prisma__TenantsClient<TenantsGetPayload<T> | Null>

        private get _document()
        /**
         * Attaches callbacks for the resolution and/or rejection of the Promise.
         * @param onfulfilled The callback to execute when the Promise is resolved.
         * @param onrejected The callback to execute when the Promise is rejected.
         * @returns A Promise for the completion of which ever callback is executed.
         */
        then<TResult1 = T, TResult2 = never>(
            onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
            onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
        ): Promise<TResult1 | TResult2>
        /**
         * Attaches a callback for only the rejection of the Promise.
         * @param onrejected The callback to execute when the Promise is rejected.
         * @returns A Promise for the completion of the callback.
         */
        catch<TResult = never>(
            onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
        ): Promise<T | TResult>
        /**
         * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
         * resolved value cannot be modified from the callback.
         * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
         * @returns A Promise for the completion of the callback.
         */
        finally(onfinally?: (() => void) | undefined | null): Promise<T>
    }

    // Custom InputTypes

    /**
     * Family_sponsorship base type for findUnique actions
     */
    export type Family_sponsorshipFindUniqueArgsBase = {
        /**
         * Select specific fields to fetch from the Family_sponsorship
         *
         **/
        select?: Family_sponsorshipSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Family_sponsorshipInclude | null
        /**
         * Filter, which Family_sponsorship to fetch.
         *
         **/
        where: Family_sponsorshipWhereUniqueInput
    }

    /**
     * Family_sponsorship findUnique
     */
    export interface Family_sponsorshipFindUniqueArgs extends Family_sponsorshipFindUniqueArgsBase {
        /**
         * Throw an Error if query returns no results
         * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
         */
        rejectOnNotFound?: RejectOnNotFound
    }

    /**
     * Family_sponsorship findUniqueOrThrow
     */
    export type Family_sponsorshipFindUniqueOrThrowArgs = {
        /**
         * Select specific fields to fetch from the Family_sponsorship
         *
         **/
        select?: Family_sponsorshipSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Family_sponsorshipInclude | null
        /**
         * Filter, which Family_sponsorship to fetch.
         *
         **/
        where: Family_sponsorshipWhereUniqueInput
    }

    /**
     * Family_sponsorship base type for findFirst actions
     */
    export type Family_sponsorshipFindFirstArgsBase = {
        /**
         * Select specific fields to fetch from the Family_sponsorship
         *
         **/
        select?: Family_sponsorshipSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Family_sponsorshipInclude | null
        /**
         * Filter, which Family_sponsorship to fetch.
         *
         **/
        where?: Family_sponsorshipWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Family_sponsorships to fetch.
         *
         **/
        orderBy?: Enumerable<Family_sponsorshipOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for searching for Family_sponsorships.
         *
         **/
        cursor?: Family_sponsorshipWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Family_sponsorships from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Family_sponsorships.
         *
         **/
        skip?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
         *
         * Filter by unique combinations of Family_sponsorships.
         *
         **/
        distinct?: Enumerable<Family_sponsorshipScalarFieldEnum>
    }

    /**
     * Family_sponsorship findFirst
     */
    export interface Family_sponsorshipFindFirstArgs extends Family_sponsorshipFindFirstArgsBase {
        /**
         * Throw an Error if query returns no results
         * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
         */
        rejectOnNotFound?: RejectOnNotFound
    }

    /**
     * Family_sponsorship findFirstOrThrow
     */
    export type Family_sponsorshipFindFirstOrThrowArgs = {
        /**
         * Select specific fields to fetch from the Family_sponsorship
         *
         **/
        select?: Family_sponsorshipSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Family_sponsorshipInclude | null
        /**
         * Filter, which Family_sponsorship to fetch.
         *
         **/
        where?: Family_sponsorshipWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Family_sponsorships to fetch.
         *
         **/
        orderBy?: Enumerable<Family_sponsorshipOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for searching for Family_sponsorships.
         *
         **/
        cursor?: Family_sponsorshipWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Family_sponsorships from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Family_sponsorships.
         *
         **/
        skip?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
         *
         * Filter by unique combinations of Family_sponsorships.
         *
         **/
        distinct?: Enumerable<Family_sponsorshipScalarFieldEnum>
    }

    /**
     * Family_sponsorship findMany
     */
    export type Family_sponsorshipFindManyArgs = {
        /**
         * Select specific fields to fetch from the Family_sponsorship
         *
         **/
        select?: Family_sponsorshipSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Family_sponsorshipInclude | null
        /**
         * Filter, which Family_sponsorships to fetch.
         *
         **/
        where?: Family_sponsorshipWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Family_sponsorships to fetch.
         *
         **/
        orderBy?: Enumerable<Family_sponsorshipOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for listing Family_sponsorships.
         *
         **/
        cursor?: Family_sponsorshipWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Family_sponsorships from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Family_sponsorships.
         *
         **/
        skip?: number
        distinct?: Enumerable<Family_sponsorshipScalarFieldEnum>
    }

    /**
     * Family_sponsorship create
     */
    export type Family_sponsorshipCreateArgs = {
        /**
         * Select specific fields to fetch from the Family_sponsorship
         *
         **/
        select?: Family_sponsorshipSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Family_sponsorshipInclude | null
        /**
         * The data needed to create a Family_sponsorship.
         *
         **/
        data: XOR<Family_sponsorshipCreateInput, Family_sponsorshipUncheckedCreateInput>
    }

    /**
     * Family_sponsorship createMany
     */
    export type Family_sponsorshipCreateManyArgs = {
        /**
         * The data used to create many Family_sponsorships.
         *
         **/
        data: Enumerable<Family_sponsorshipCreateManyInput>
        skipDuplicates?: boolean
    }

    /**
     * Family_sponsorship update
     */
    export type Family_sponsorshipUpdateArgs = {
        /**
         * Select specific fields to fetch from the Family_sponsorship
         *
         **/
        select?: Family_sponsorshipSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Family_sponsorshipInclude | null
        /**
         * The data needed to update a Family_sponsorship.
         *
         **/
        data: XOR<Family_sponsorshipUpdateInput, Family_sponsorshipUncheckedUpdateInput>
        /**
         * Choose, which Family_sponsorship to update.
         *
         **/
        where: Family_sponsorshipWhereUniqueInput
    }

    /**
     * Family_sponsorship updateMany
     */
    export type Family_sponsorshipUpdateManyArgs = {
        /**
         * The data used to update Family_sponsorships.
         *
         **/
        data: XOR<Family_sponsorshipUpdateManyMutationInput, Family_sponsorshipUncheckedUpdateManyInput>
        /**
         * Filter which Family_sponsorships to update
         *
         **/
        where?: Family_sponsorshipWhereInput
    }

    /**
     * Family_sponsorship upsert
     */
    export type Family_sponsorshipUpsertArgs = {
        /**
         * Select specific fields to fetch from the Family_sponsorship
         *
         **/
        select?: Family_sponsorshipSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Family_sponsorshipInclude | null
        /**
         * The filter to search for the Family_sponsorship to update in case it exists.
         *
         **/
        where: Family_sponsorshipWhereUniqueInput
        /**
         * In case the Family_sponsorship found by the `where` argument doesn't exist, create a new Family_sponsorship with this data.
         *
         **/
        create: XOR<Family_sponsorshipCreateInput, Family_sponsorshipUncheckedCreateInput>
        /**
         * In case the Family_sponsorship was found with the provided `where` argument, update it with this data.
         *
         **/
        update: XOR<Family_sponsorshipUpdateInput, Family_sponsorshipUncheckedUpdateInput>
    }

    /**
     * Family_sponsorship delete
     */
    export type Family_sponsorshipDeleteArgs = {
        /**
         * Select specific fields to fetch from the Family_sponsorship
         *
         **/
        select?: Family_sponsorshipSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Family_sponsorshipInclude | null
        /**
         * Filter which Family_sponsorship to delete.
         *
         **/
        where: Family_sponsorshipWhereUniqueInput
    }

    /**
     * Family_sponsorship deleteMany
     */
    export type Family_sponsorshipDeleteManyArgs = {
        /**
         * Filter which Family_sponsorships to delete
         *
         **/
        where?: Family_sponsorshipWhereInput
    }

    /**
     * Family_sponsorship without action
     */
    export type Family_sponsorshipArgs = {
        /**
         * Select specific fields to fetch from the Family_sponsorship
         *
         **/
        select?: Family_sponsorshipSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Family_sponsorshipInclude | null
    }

    /**
     * Model Furnishings
     */

    export type AggregateFurnishings = {
        _count: FurnishingsCountAggregateOutputType | null
        _min: FurnishingsMinAggregateOutputType | null
        _max: FurnishingsMaxAggregateOutputType | null
    }

    export type FurnishingsMinAggregateOutputType = {
        id: string | null
        name: string | null
    }

    export type FurnishingsMaxAggregateOutputType = {
        id: string | null
        name: string | null
    }

    export type FurnishingsCountAggregateOutputType = {
        id: number
        name: number
        _all: number
    }

    export type FurnishingsMinAggregateInputType = {
        id?: true
        name?: true
    }

    export type FurnishingsMaxAggregateInputType = {
        id?: true
        name?: true
    }

    export type FurnishingsCountAggregateInputType = {
        id?: true
        name?: true
        _all?: true
    }

    export type FurnishingsAggregateArgs = {
        /**
         * Filter which Furnishings to aggregate.
         *
         **/
        where?: FurnishingsWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Furnishings to fetch.
         *
         **/
        orderBy?: Enumerable<FurnishingsOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the start position
         *
         **/
        cursor?: FurnishingsWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Furnishings from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Furnishings.
         *
         **/
        skip?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Count returned Furnishings
         **/
        _count?: true | FurnishingsCountAggregateInputType
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to find the minimum value
         **/
        _min?: FurnishingsMinAggregateInputType
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to find the maximum value
         **/
        _max?: FurnishingsMaxAggregateInputType
    }

    export type GetFurnishingsAggregateType<T extends FurnishingsAggregateArgs> = {
        [P in keyof T & keyof AggregateFurnishings]: P extends '_count' | 'count'
            ? T[P] extends true
                ? number
                : GetScalarType<T[P], AggregateFurnishings[P]>
            : GetScalarType<T[P], AggregateFurnishings[P]>
    }

    export type FurnishingsGroupByArgs = {
        where?: FurnishingsWhereInput
        orderBy?: Enumerable<FurnishingsOrderByWithAggregationInput>
        by: Array<FurnishingsScalarFieldEnum>
        having?: FurnishingsScalarWhereWithAggregatesInput
        take?: number
        skip?: number
        _count?: FurnishingsCountAggregateInputType | true
        _min?: FurnishingsMinAggregateInputType
        _max?: FurnishingsMaxAggregateInputType
    }

    export type FurnishingsGroupByOutputType = {
        id: string
        name: string
        _count: FurnishingsCountAggregateOutputType | null
        _min: FurnishingsMinAggregateOutputType | null
        _max: FurnishingsMaxAggregateOutputType | null
    }

    type GetFurnishingsGroupByPayload<T extends FurnishingsGroupByArgs> = PrismaPromise<
        Array<
            PickArray<FurnishingsGroupByOutputType, T['by']> & {
                [P in keyof T & keyof FurnishingsGroupByOutputType]: P extends '_count'
                    ? T[P] extends boolean
                        ? number
                        : GetScalarType<T[P], FurnishingsGroupByOutputType[P]>
                    : GetScalarType<T[P], FurnishingsGroupByOutputType[P]>
            }
        >
    >

    export type FurnishingsSelect = {
        id?: boolean
        name?: boolean
        family_furnishing?: boolean | Furnishings$family_furnishingArgs
        _count?: boolean | FurnishingsCountOutputTypeArgs
    }

    export type FurnishingsInclude = {
        family_furnishing?: boolean | Furnishings$family_furnishingArgs
        _count?: boolean | FurnishingsCountOutputTypeArgs
    }

    export type FurnishingsGetPayload<S extends boolean | null | undefined | FurnishingsArgs> = S extends {
        select: any
        include: any
    }
        ? 'Please either choose `select` or `include`'
        : S extends true
          ? Furnishings
          : S extends undefined
            ? never
            : S extends { include: any } & (FurnishingsArgs | FurnishingsFindManyArgs)
              ? Furnishings & {
                    [P in TruthyKeys<S['include']>]: P extends 'family_furnishing'
                        ? Array<Family_furnishingGetPayload<S['include'][P]>>
                        : P extends '_count'
                          ? FurnishingsCountOutputTypeGetPayload<S['include'][P]>
                          : never
                }
              : S extends { select: any } & (FurnishingsArgs | FurnishingsFindManyArgs)
                ? {
                      [P in TruthyKeys<S['select']>]: P extends 'family_furnishing'
                          ? Array<Family_furnishingGetPayload<S['select'][P]>>
                          : P extends '_count'
                            ? FurnishingsCountOutputTypeGetPayload<S['select'][P]>
                            : P extends keyof Furnishings
                              ? Furnishings[P]
                              : never
                  }
                : Furnishings

    type FurnishingsCountArgs = Merge<
        Omit<FurnishingsFindManyArgs, 'select' | 'include'> & {
            select?: FurnishingsCountAggregateInputType | true
        }
    >

    export interface FurnishingsDelegate<
        GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined
    > {
        /**
         * Find zero or one Furnishings that matches the filter.
         * @param {FurnishingsFindUniqueArgs} args - Arguments to find a Furnishings
         * @example
         * // Get one Furnishings
         * const furnishings = await prisma.furnishings.findUnique({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findUnique<
            T extends FurnishingsFindUniqueArgs,
            LocalRejectSettings = T['rejectOnNotFound'] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined
        >(
            args: SelectSubset<T, FurnishingsFindUniqueArgs>
        ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Furnishings'> extends True
            ? Prisma__FurnishingsClient<FurnishingsGetPayload<T>>
            : Prisma__FurnishingsClient<FurnishingsGetPayload<T> | null, null>

        /**
         * Find one Furnishings that matches the filter or throw an error  with `error.code='P2025'`
         *     if no matches were found.
         * @param {FurnishingsFindUniqueOrThrowArgs} args - Arguments to find a Furnishings
         * @example
         * // Get one Furnishings
         * const furnishings = await prisma.furnishings.findUniqueOrThrow({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findUniqueOrThrow<T extends FurnishingsFindUniqueOrThrowArgs>(
            args?: SelectSubset<T, FurnishingsFindUniqueOrThrowArgs>
        ): Prisma__FurnishingsClient<FurnishingsGetPayload<T>>

        /**
         * Find the first Furnishings that matches the filter.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {FurnishingsFindFirstArgs} args - Arguments to find a Furnishings
         * @example
         * // Get one Furnishings
         * const furnishings = await prisma.furnishings.findFirst({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findFirst<
            T extends FurnishingsFindFirstArgs,
            LocalRejectSettings = T['rejectOnNotFound'] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined
        >(
            args?: SelectSubset<T, FurnishingsFindFirstArgs>
        ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Furnishings'> extends True
            ? Prisma__FurnishingsClient<FurnishingsGetPayload<T>>
            : Prisma__FurnishingsClient<FurnishingsGetPayload<T> | null, null>

        /**
         * Find the first Furnishings that matches the filter or
         * throw `NotFoundError` if no matches were found.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {FurnishingsFindFirstOrThrowArgs} args - Arguments to find a Furnishings
         * @example
         * // Get one Furnishings
         * const furnishings = await prisma.furnishings.findFirstOrThrow({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findFirstOrThrow<T extends FurnishingsFindFirstOrThrowArgs>(
            args?: SelectSubset<T, FurnishingsFindFirstOrThrowArgs>
        ): Prisma__FurnishingsClient<FurnishingsGetPayload<T>>

        /**
         * Find zero or more Furnishings that matches the filter.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {FurnishingsFindManyArgs=} args - Arguments to filter and select certain fields only.
         * @example
         * // Get all Furnishings
         * const furnishings = await prisma.furnishings.findMany()
         *
         * // Get first 10 Furnishings
         * const furnishings = await prisma.furnishings.findMany({ take: 10 })
         *
         * // Only select the `id`
         * const furnishingsWithIdOnly = await prisma.furnishings.findMany({ select: { id: true } })
         *
         **/
        findMany<T extends FurnishingsFindManyArgs>(
            args?: SelectSubset<T, FurnishingsFindManyArgs>
        ): PrismaPromise<Array<FurnishingsGetPayload<T>>>

        /**
         * Create a Furnishings.
         * @param {FurnishingsCreateArgs} args - Arguments to create a Furnishings.
         * @example
         * // Create one Furnishings
         * const Furnishings = await prisma.furnishings.create({
         *   data: {
         *     // ... data to create a Furnishings
         *   }
         * })
         *
         **/
        create<T extends FurnishingsCreateArgs>(
            args: SelectSubset<T, FurnishingsCreateArgs>
        ): Prisma__FurnishingsClient<FurnishingsGetPayload<T>>

        /**
         * Create many Furnishings.
         *     @param {FurnishingsCreateManyArgs} args - Arguments to create many Furnishings.
         *     @example
         *     // Create many Furnishings
         *     const furnishings = await prisma.furnishings.createMany({
         *       data: {
         *         // ... provide data here
         *       }
         *     })
         *
         **/
        createMany<T extends FurnishingsCreateManyArgs>(
            args?: SelectSubset<T, FurnishingsCreateManyArgs>
        ): PrismaPromise<BatchPayload>

        /**
         * Delete a Furnishings.
         * @param {FurnishingsDeleteArgs} args - Arguments to delete one Furnishings.
         * @example
         * // Delete one Furnishings
         * const Furnishings = await prisma.furnishings.delete({
         *   where: {
         *     // ... filter to delete one Furnishings
         *   }
         * })
         *
         **/
        delete<T extends FurnishingsDeleteArgs>(
            args: SelectSubset<T, FurnishingsDeleteArgs>
        ): Prisma__FurnishingsClient<FurnishingsGetPayload<T>>

        /**
         * Update one Furnishings.
         * @param {FurnishingsUpdateArgs} args - Arguments to update one Furnishings.
         * @example
         * // Update one Furnishings
         * const furnishings = await prisma.furnishings.update({
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: {
         *     // ... provide data here
         *   }
         * })
         *
         **/
        update<T extends FurnishingsUpdateArgs>(
            args: SelectSubset<T, FurnishingsUpdateArgs>
        ): Prisma__FurnishingsClient<FurnishingsGetPayload<T>>

        /**
         * Delete zero or more Furnishings.
         * @param {FurnishingsDeleteManyArgs} args - Arguments to filter Furnishings to delete.
         * @example
         * // Delete a few Furnishings
         * const { count } = await prisma.furnishings.deleteMany({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         *
         **/
        deleteMany<T extends FurnishingsDeleteManyArgs>(
            args?: SelectSubset<T, FurnishingsDeleteManyArgs>
        ): PrismaPromise<BatchPayload>

        /**
         * Update zero or more Furnishings.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {FurnishingsUpdateManyArgs} args - Arguments to update one or more rows.
         * @example
         * // Update many Furnishings
         * const furnishings = await prisma.furnishings.updateMany({
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: {
         *     // ... provide data here
         *   }
         * })
         *
         **/
        updateMany<T extends FurnishingsUpdateManyArgs>(
            args: SelectSubset<T, FurnishingsUpdateManyArgs>
        ): PrismaPromise<BatchPayload>

        /**
         * Create or update one Furnishings.
         * @param {FurnishingsUpsertArgs} args - Arguments to update or create a Furnishings.
         * @example
         * // Update or create a Furnishings
         * const furnishings = await prisma.furnishings.upsert({
         *   create: {
         *     // ... data to create a Furnishings
         *   },
         *   update: {
         *     // ... in case it already exists, update
         *   },
         *   where: {
         *     // ... the filter for the Furnishings we want to update
         *   }
         * })
         **/
        upsert<T extends FurnishingsUpsertArgs>(
            args: SelectSubset<T, FurnishingsUpsertArgs>
        ): Prisma__FurnishingsClient<FurnishingsGetPayload<T>>

        /**
         * Count the number of Furnishings.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {FurnishingsCountArgs} args - Arguments to filter Furnishings to count.
         * @example
         * // Count the number of Furnishings
         * const count = await prisma.furnishings.count({
         *   where: {
         *     // ... the filter for the Furnishings we want to count
         *   }
         * })
         **/
        count<T extends FurnishingsCountArgs>(
            args?: Subset<T, FurnishingsCountArgs>
        ): PrismaPromise<
            T extends _Record<'select', any>
                ? T['select'] extends true
                    ? number
                    : GetScalarType<T['select'], FurnishingsCountAggregateOutputType>
                : number
        >

        /**
         * Allows you to perform aggregations operations on a Furnishings.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {FurnishingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
         * @example
         * // Ordered by age ascending
         * // Where email contains prisma.io
         * // Limited to the 10 users
         * const aggregations = await prisma.user.aggregate({
         *   _avg: {
         *     age: true,
         *   },
         *   where: {
         *     email: {
         *       contains: "prisma.io",
         *     },
         *   },
         *   orderBy: {
         *     age: "asc",
         *   },
         *   take: 10,
         * })
         **/
        aggregate<T extends FurnishingsAggregateArgs>(
            args: Subset<T, FurnishingsAggregateArgs>
        ): PrismaPromise<GetFurnishingsAggregateType<T>>

        /**
         * Group by Furnishings.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {FurnishingsGroupByArgs} args - Group by arguments.
         * @example
         * // Group by city, order by createdAt, get count
         * const result = await prisma.user.groupBy({
         *   by: ['city', 'createdAt'],
         *   orderBy: {
         *     createdAt: true
         *   },
         *   _count: {
         *     _all: true
         *   },
         * })
         *
         **/
        groupBy<
            T extends FurnishingsGroupByArgs,
            HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
            OrderByArg extends True extends HasSelectOrTake
                ? { orderBy: FurnishingsGroupByArgs['orderBy'] }
                : { orderBy?: FurnishingsGroupByArgs['orderBy'] },
            OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
            ByFields extends TupleToUnion<T['by']>,
            ByValid extends Has<ByFields, OrderFields>,
            HavingFields extends GetHavingFields<T['having']>,
            HavingValid extends Has<ByFields, HavingFields>,
            ByEmpty extends T['by'] extends never[] ? True : False,
            InputErrors extends ByEmpty extends True
                ? `Error: "by" must not be empty.`
                : HavingValid extends False
                  ? {
                        [P in HavingFields]: P extends ByFields
                            ? never
                            : P extends string
                              ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                              : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`]
                    }[HavingFields]
                  : 'take' extends Keys<T>
                    ? 'orderBy' extends Keys<T>
                        ? ByValid extends True
                            ? {}
                            : {
                                  [P in OrderFields]: P extends ByFields
                                      ? never
                                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                              }[OrderFields]
                        : 'Error: If you provide "take", you also need to provide "orderBy"'
                    : 'skip' extends Keys<T>
                      ? 'orderBy' extends Keys<T>
                          ? ByValid extends True
                              ? {}
                              : {
                                    [P in OrderFields]: P extends ByFields
                                        ? never
                                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                                }[OrderFields]
                          : 'Error: If you provide "skip", you also need to provide "orderBy"'
                      : ByValid extends True
                        ? {}
                        : {
                              [P in OrderFields]: P extends ByFields
                                  ? never
                                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                          }[OrderFields]
        >(
            args: SubsetIntersection<T, FurnishingsGroupByArgs, OrderByArg> & InputErrors
        ): {} extends InputErrors ? GetFurnishingsGroupByPayload<T> : PrismaPromise<InputErrors>
    }

    /**
     * The delegate class that acts as a "Promise-like" for Furnishings.
     * Why is this prefixed with `Prisma__`?
     * Because we want to prevent naming conflicts as mentioned in
     * https://github.com/prisma/prisma-client-js/issues/707
     */
    export class Prisma__FurnishingsClient<T, Null = never> implements PrismaPromise<T> {
        [prisma]: true
        private readonly _dmmf
        private readonly _fetcher
        private readonly _queryType
        private readonly _rootField
        private readonly _clientMethod
        private readonly _args
        private readonly _dataPath
        private readonly _errorFormat
        private readonly _measurePerformance?
        private _isList
        private _callsite
        private _requestPromise?
        constructor(
            _dmmf: runtime.DMMFClass,
            _fetcher: PrismaClientFetcher,
            _queryType: 'query' | 'mutation',
            _rootField: string,
            _clientMethod: string,
            _args: any,
            _dataPath: string[],
            _errorFormat: ErrorFormat,
            _measurePerformance?: boolean | undefined,
            _isList?: boolean
        )
        readonly [Symbol.toStringTag]: 'PrismaClientPromise'

        family_furnishing<T extends Furnishings$family_furnishingArgs = {}>(
            args?: Subset<T, Furnishings$family_furnishingArgs>
        ): PrismaPromise<Array<Family_furnishingGetPayload<T>> | Null>

        private get _document()
        /**
         * Attaches callbacks for the resolution and/or rejection of the Promise.
         * @param onfulfilled The callback to execute when the Promise is resolved.
         * @param onrejected The callback to execute when the Promise is rejected.
         * @returns A Promise for the completion of which ever callback is executed.
         */
        then<TResult1 = T, TResult2 = never>(
            onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
            onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
        ): Promise<TResult1 | TResult2>
        /**
         * Attaches a callback for only the rejection of the Promise.
         * @param onrejected The callback to execute when the Promise is rejected.
         * @returns A Promise for the completion of the callback.
         */
        catch<TResult = never>(
            onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
        ): Promise<T | TResult>
        /**
         * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
         * resolved value cannot be modified from the callback.
         * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
         * @returns A Promise for the completion of the callback.
         */
        finally(onfinally?: (() => void) | undefined | null): Promise<T>
    }

    // Custom InputTypes

    /**
     * Furnishings base type for findUnique actions
     */
    export type FurnishingsFindUniqueArgsBase = {
        /**
         * Select specific fields to fetch from the Furnishings
         *
         **/
        select?: FurnishingsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: FurnishingsInclude | null
        /**
         * Filter, which Furnishings to fetch.
         *
         **/
        where: FurnishingsWhereUniqueInput
    }

    /**
     * Furnishings findUnique
     */
    export interface FurnishingsFindUniqueArgs extends FurnishingsFindUniqueArgsBase {
        /**
         * Throw an Error if query returns no results
         * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
         */
        rejectOnNotFound?: RejectOnNotFound
    }

    /**
     * Furnishings findUniqueOrThrow
     */
    export type FurnishingsFindUniqueOrThrowArgs = {
        /**
         * Select specific fields to fetch from the Furnishings
         *
         **/
        select?: FurnishingsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: FurnishingsInclude | null
        /**
         * Filter, which Furnishings to fetch.
         *
         **/
        where: FurnishingsWhereUniqueInput
    }

    /**
     * Furnishings base type for findFirst actions
     */
    export type FurnishingsFindFirstArgsBase = {
        /**
         * Select specific fields to fetch from the Furnishings
         *
         **/
        select?: FurnishingsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: FurnishingsInclude | null
        /**
         * Filter, which Furnishings to fetch.
         *
         **/
        where?: FurnishingsWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Furnishings to fetch.
         *
         **/
        orderBy?: Enumerable<FurnishingsOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for searching for Furnishings.
         *
         **/
        cursor?: FurnishingsWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Furnishings from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Furnishings.
         *
         **/
        skip?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
         *
         * Filter by unique combinations of Furnishings.
         *
         **/
        distinct?: Enumerable<FurnishingsScalarFieldEnum>
    }

    /**
     * Furnishings findFirst
     */
    export interface FurnishingsFindFirstArgs extends FurnishingsFindFirstArgsBase {
        /**
         * Throw an Error if query returns no results
         * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
         */
        rejectOnNotFound?: RejectOnNotFound
    }

    /**
     * Furnishings findFirstOrThrow
     */
    export type FurnishingsFindFirstOrThrowArgs = {
        /**
         * Select specific fields to fetch from the Furnishings
         *
         **/
        select?: FurnishingsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: FurnishingsInclude | null
        /**
         * Filter, which Furnishings to fetch.
         *
         **/
        where?: FurnishingsWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Furnishings to fetch.
         *
         **/
        orderBy?: Enumerable<FurnishingsOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for searching for Furnishings.
         *
         **/
        cursor?: FurnishingsWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Furnishings from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Furnishings.
         *
         **/
        skip?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
         *
         * Filter by unique combinations of Furnishings.
         *
         **/
        distinct?: Enumerable<FurnishingsScalarFieldEnum>
    }

    /**
     * Furnishings findMany
     */
    export type FurnishingsFindManyArgs = {
        /**
         * Select specific fields to fetch from the Furnishings
         *
         **/
        select?: FurnishingsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: FurnishingsInclude | null
        /**
         * Filter, which Furnishings to fetch.
         *
         **/
        where?: FurnishingsWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Furnishings to fetch.
         *
         **/
        orderBy?: Enumerable<FurnishingsOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for listing Furnishings.
         *
         **/
        cursor?: FurnishingsWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Furnishings from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Furnishings.
         *
         **/
        skip?: number
        distinct?: Enumerable<FurnishingsScalarFieldEnum>
    }

    /**
     * Furnishings create
     */
    export type FurnishingsCreateArgs = {
        /**
         * Select specific fields to fetch from the Furnishings
         *
         **/
        select?: FurnishingsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: FurnishingsInclude | null
        /**
         * The data needed to create a Furnishings.
         *
         **/
        data: XOR<FurnishingsCreateInput, FurnishingsUncheckedCreateInput>
    }

    /**
     * Furnishings createMany
     */
    export type FurnishingsCreateManyArgs = {
        /**
         * The data used to create many Furnishings.
         *
         **/
        data: Enumerable<FurnishingsCreateManyInput>
        skipDuplicates?: boolean
    }

    /**
     * Furnishings update
     */
    export type FurnishingsUpdateArgs = {
        /**
         * Select specific fields to fetch from the Furnishings
         *
         **/
        select?: FurnishingsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: FurnishingsInclude | null
        /**
         * The data needed to update a Furnishings.
         *
         **/
        data: XOR<FurnishingsUpdateInput, FurnishingsUncheckedUpdateInput>
        /**
         * Choose, which Furnishings to update.
         *
         **/
        where: FurnishingsWhereUniqueInput
    }

    /**
     * Furnishings updateMany
     */
    export type FurnishingsUpdateManyArgs = {
        /**
         * The data used to update Furnishings.
         *
         **/
        data: XOR<FurnishingsUpdateManyMutationInput, FurnishingsUncheckedUpdateManyInput>
        /**
         * Filter which Furnishings to update
         *
         **/
        where?: FurnishingsWhereInput
    }

    /**
     * Furnishings upsert
     */
    export type FurnishingsUpsertArgs = {
        /**
         * Select specific fields to fetch from the Furnishings
         *
         **/
        select?: FurnishingsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: FurnishingsInclude | null
        /**
         * The filter to search for the Furnishings to update in case it exists.
         *
         **/
        where: FurnishingsWhereUniqueInput
        /**
         * In case the Furnishings found by the `where` argument doesn't exist, create a new Furnishings with this data.
         *
         **/
        create: XOR<FurnishingsCreateInput, FurnishingsUncheckedCreateInput>
        /**
         * In case the Furnishings was found with the provided `where` argument, update it with this data.
         *
         **/
        update: XOR<FurnishingsUpdateInput, FurnishingsUncheckedUpdateInput>
    }

    /**
     * Furnishings delete
     */
    export type FurnishingsDeleteArgs = {
        /**
         * Select specific fields to fetch from the Furnishings
         *
         **/
        select?: FurnishingsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: FurnishingsInclude | null
        /**
         * Filter which Furnishings to delete.
         *
         **/
        where: FurnishingsWhereUniqueInput
    }

    /**
     * Furnishings deleteMany
     */
    export type FurnishingsDeleteManyArgs = {
        /**
         * Filter which Furnishings to delete
         *
         **/
        where?: FurnishingsWhereInput
    }

    /**
     * Furnishings.family_furnishing
     */
    export type Furnishings$family_furnishingArgs = {
        /**
         * Select specific fields to fetch from the Family_furnishing
         *
         **/
        select?: Family_furnishingSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Family_furnishingInclude | null
        where?: Family_furnishingWhereInput
        orderBy?: Enumerable<Family_furnishingOrderByWithRelationInput>
        cursor?: Family_furnishingWhereUniqueInput
        take?: number
        skip?: number
        distinct?: Enumerable<Family_furnishingScalarFieldEnum>
    }

    /**
     * Furnishings without action
     */
    export type FurnishingsArgs = {
        /**
         * Select specific fields to fetch from the Furnishings
         *
         **/
        select?: FurnishingsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: FurnishingsInclude | null
    }

    /**
     * Model Housings
     */

    export type AggregateHousings = {
        _count: HousingsCountAggregateOutputType | null
        _min: HousingsMinAggregateOutputType | null
        _max: HousingsMaxAggregateOutputType | null
    }

    export type HousingsMinAggregateOutputType = {
        id: string | null
        name: string | null
    }

    export type HousingsMaxAggregateOutputType = {
        id: string | null
        name: string | null
    }

    export type HousingsCountAggregateOutputType = {
        id: number
        name: number
        _all: number
    }

    export type HousingsMinAggregateInputType = {
        id?: true
        name?: true
    }

    export type HousingsMaxAggregateInputType = {
        id?: true
        name?: true
    }

    export type HousingsCountAggregateInputType = {
        id?: true
        name?: true
        _all?: true
    }

    export type HousingsAggregateArgs = {
        /**
         * Filter which Housings to aggregate.
         *
         **/
        where?: HousingsWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Housings to fetch.
         *
         **/
        orderBy?: Enumerable<HousingsOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the start position
         *
         **/
        cursor?: HousingsWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Housings from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Housings.
         *
         **/
        skip?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Count returned Housings
         **/
        _count?: true | HousingsCountAggregateInputType
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to find the minimum value
         **/
        _min?: HousingsMinAggregateInputType
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to find the maximum value
         **/
        _max?: HousingsMaxAggregateInputType
    }

    export type GetHousingsAggregateType<T extends HousingsAggregateArgs> = {
        [P in keyof T & keyof AggregateHousings]: P extends '_count' | 'count'
            ? T[P] extends true
                ? number
                : GetScalarType<T[P], AggregateHousings[P]>
            : GetScalarType<T[P], AggregateHousings[P]>
    }

    export type HousingsGroupByArgs = {
        where?: HousingsWhereInput
        orderBy?: Enumerable<HousingsOrderByWithAggregationInput>
        by: Array<HousingsScalarFieldEnum>
        having?: HousingsScalarWhereWithAggregatesInput
        take?: number
        skip?: number
        _count?: HousingsCountAggregateInputType | true
        _min?: HousingsMinAggregateInputType
        _max?: HousingsMaxAggregateInputType
    }

    export type HousingsGroupByOutputType = {
        id: string
        name: string
        _count: HousingsCountAggregateOutputType | null
        _min: HousingsMinAggregateOutputType | null
        _max: HousingsMaxAggregateOutputType | null
    }

    type GetHousingsGroupByPayload<T extends HousingsGroupByArgs> = PrismaPromise<
        Array<
            PickArray<HousingsGroupByOutputType, T['by']> & {
                [P in keyof T & keyof HousingsGroupByOutputType]: P extends '_count'
                    ? T[P] extends boolean
                        ? number
                        : GetScalarType<T[P], HousingsGroupByOutputType[P]>
                    : GetScalarType<T[P], HousingsGroupByOutputType[P]>
            }
        >
    >

    export type HousingsSelect = {
        id?: boolean
        name?: boolean
        family_housing?: boolean | Housings$family_housingArgs
        _count?: boolean | HousingsCountOutputTypeArgs
    }

    export type HousingsInclude = {
        family_housing?: boolean | Housings$family_housingArgs
        _count?: boolean | HousingsCountOutputTypeArgs
    }

    export type HousingsGetPayload<S extends boolean | null | undefined | HousingsArgs> = S extends {
        select: any
        include: any
    }
        ? 'Please either choose `select` or `include`'
        : S extends true
          ? Housings
          : S extends undefined
            ? never
            : S extends { include: any } & (HousingsArgs | HousingsFindManyArgs)
              ? Housings & {
                    [P in TruthyKeys<S['include']>]: P extends 'family_housing'
                        ? Array<Family_housingGetPayload<S['include'][P]>>
                        : P extends '_count'
                          ? HousingsCountOutputTypeGetPayload<S['include'][P]>
                          : never
                }
              : S extends { select: any } & (HousingsArgs | HousingsFindManyArgs)
                ? {
                      [P in TruthyKeys<S['select']>]: P extends 'family_housing'
                          ? Array<Family_housingGetPayload<S['select'][P]>>
                          : P extends '_count'
                            ? HousingsCountOutputTypeGetPayload<S['select'][P]>
                            : P extends keyof Housings
                              ? Housings[P]
                              : never
                  }
                : Housings

    type HousingsCountArgs = Merge<
        Omit<HousingsFindManyArgs, 'select' | 'include'> & {
            select?: HousingsCountAggregateInputType | true
        }
    >

    export interface HousingsDelegate<
        GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined
    > {
        /**
         * Find zero or one Housings that matches the filter.
         * @param {HousingsFindUniqueArgs} args - Arguments to find a Housings
         * @example
         * // Get one Housings
         * const housings = await prisma.housings.findUnique({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findUnique<
            T extends HousingsFindUniqueArgs,
            LocalRejectSettings = T['rejectOnNotFound'] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined
        >(
            args: SelectSubset<T, HousingsFindUniqueArgs>
        ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Housings'> extends True
            ? Prisma__HousingsClient<HousingsGetPayload<T>>
            : Prisma__HousingsClient<HousingsGetPayload<T> | null, null>

        /**
         * Find one Housings that matches the filter or throw an error  with `error.code='P2025'`
         *     if no matches were found.
         * @param {HousingsFindUniqueOrThrowArgs} args - Arguments to find a Housings
         * @example
         * // Get one Housings
         * const housings = await prisma.housings.findUniqueOrThrow({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findUniqueOrThrow<T extends HousingsFindUniqueOrThrowArgs>(
            args?: SelectSubset<T, HousingsFindUniqueOrThrowArgs>
        ): Prisma__HousingsClient<HousingsGetPayload<T>>

        /**
         * Find the first Housings that matches the filter.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {HousingsFindFirstArgs} args - Arguments to find a Housings
         * @example
         * // Get one Housings
         * const housings = await prisma.housings.findFirst({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findFirst<
            T extends HousingsFindFirstArgs,
            LocalRejectSettings = T['rejectOnNotFound'] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined
        >(
            args?: SelectSubset<T, HousingsFindFirstArgs>
        ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Housings'> extends True
            ? Prisma__HousingsClient<HousingsGetPayload<T>>
            : Prisma__HousingsClient<HousingsGetPayload<T> | null, null>

        /**
         * Find the first Housings that matches the filter or
         * throw `NotFoundError` if no matches were found.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {HousingsFindFirstOrThrowArgs} args - Arguments to find a Housings
         * @example
         * // Get one Housings
         * const housings = await prisma.housings.findFirstOrThrow({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findFirstOrThrow<T extends HousingsFindFirstOrThrowArgs>(
            args?: SelectSubset<T, HousingsFindFirstOrThrowArgs>
        ): Prisma__HousingsClient<HousingsGetPayload<T>>

        /**
         * Find zero or more Housings that matches the filter.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {HousingsFindManyArgs=} args - Arguments to filter and select certain fields only.
         * @example
         * // Get all Housings
         * const housings = await prisma.housings.findMany()
         *
         * // Get first 10 Housings
         * const housings = await prisma.housings.findMany({ take: 10 })
         *
         * // Only select the `id`
         * const housingsWithIdOnly = await prisma.housings.findMany({ select: { id: true } })
         *
         **/
        findMany<T extends HousingsFindManyArgs>(
            args?: SelectSubset<T, HousingsFindManyArgs>
        ): PrismaPromise<Array<HousingsGetPayload<T>>>

        /**
         * Create a Housings.
         * @param {HousingsCreateArgs} args - Arguments to create a Housings.
         * @example
         * // Create one Housings
         * const Housings = await prisma.housings.create({
         *   data: {
         *     // ... data to create a Housings
         *   }
         * })
         *
         **/
        create<T extends HousingsCreateArgs>(
            args: SelectSubset<T, HousingsCreateArgs>
        ): Prisma__HousingsClient<HousingsGetPayload<T>>

        /**
         * Create many Housings.
         *     @param {HousingsCreateManyArgs} args - Arguments to create many Housings.
         *     @example
         *     // Create many Housings
         *     const housings = await prisma.housings.createMany({
         *       data: {
         *         // ... provide data here
         *       }
         *     })
         *
         **/
        createMany<T extends HousingsCreateManyArgs>(
            args?: SelectSubset<T, HousingsCreateManyArgs>
        ): PrismaPromise<BatchPayload>

        /**
         * Delete a Housings.
         * @param {HousingsDeleteArgs} args - Arguments to delete one Housings.
         * @example
         * // Delete one Housings
         * const Housings = await prisma.housings.delete({
         *   where: {
         *     // ... filter to delete one Housings
         *   }
         * })
         *
         **/
        delete<T extends HousingsDeleteArgs>(
            args: SelectSubset<T, HousingsDeleteArgs>
        ): Prisma__HousingsClient<HousingsGetPayload<T>>

        /**
         * Update one Housings.
         * @param {HousingsUpdateArgs} args - Arguments to update one Housings.
         * @example
         * // Update one Housings
         * const housings = await prisma.housings.update({
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: {
         *     // ... provide data here
         *   }
         * })
         *
         **/
        update<T extends HousingsUpdateArgs>(
            args: SelectSubset<T, HousingsUpdateArgs>
        ): Prisma__HousingsClient<HousingsGetPayload<T>>

        /**
         * Delete zero or more Housings.
         * @param {HousingsDeleteManyArgs} args - Arguments to filter Housings to delete.
         * @example
         * // Delete a few Housings
         * const { count } = await prisma.housings.deleteMany({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         *
         **/
        deleteMany<T extends HousingsDeleteManyArgs>(
            args?: SelectSubset<T, HousingsDeleteManyArgs>
        ): PrismaPromise<BatchPayload>

        /**
         * Update zero or more Housings.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {HousingsUpdateManyArgs} args - Arguments to update one or more rows.
         * @example
         * // Update many Housings
         * const housings = await prisma.housings.updateMany({
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: {
         *     // ... provide data here
         *   }
         * })
         *
         **/
        updateMany<T extends HousingsUpdateManyArgs>(
            args: SelectSubset<T, HousingsUpdateManyArgs>
        ): PrismaPromise<BatchPayload>

        /**
         * Create or update one Housings.
         * @param {HousingsUpsertArgs} args - Arguments to update or create a Housings.
         * @example
         * // Update or create a Housings
         * const housings = await prisma.housings.upsert({
         *   create: {
         *     // ... data to create a Housings
         *   },
         *   update: {
         *     // ... in case it already exists, update
         *   },
         *   where: {
         *     // ... the filter for the Housings we want to update
         *   }
         * })
         **/
        upsert<T extends HousingsUpsertArgs>(
            args: SelectSubset<T, HousingsUpsertArgs>
        ): Prisma__HousingsClient<HousingsGetPayload<T>>

        /**
         * Count the number of Housings.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {HousingsCountArgs} args - Arguments to filter Housings to count.
         * @example
         * // Count the number of Housings
         * const count = await prisma.housings.count({
         *   where: {
         *     // ... the filter for the Housings we want to count
         *   }
         * })
         **/
        count<T extends HousingsCountArgs>(
            args?: Subset<T, HousingsCountArgs>
        ): PrismaPromise<
            T extends _Record<'select', any>
                ? T['select'] extends true
                    ? number
                    : GetScalarType<T['select'], HousingsCountAggregateOutputType>
                : number
        >

        /**
         * Allows you to perform aggregations operations on a Housings.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {HousingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
         * @example
         * // Ordered by age ascending
         * // Where email contains prisma.io
         * // Limited to the 10 users
         * const aggregations = await prisma.user.aggregate({
         *   _avg: {
         *     age: true,
         *   },
         *   where: {
         *     email: {
         *       contains: "prisma.io",
         *     },
         *   },
         *   orderBy: {
         *     age: "asc",
         *   },
         *   take: 10,
         * })
         **/
        aggregate<T extends HousingsAggregateArgs>(
            args: Subset<T, HousingsAggregateArgs>
        ): PrismaPromise<GetHousingsAggregateType<T>>

        /**
         * Group by Housings.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {HousingsGroupByArgs} args - Group by arguments.
         * @example
         * // Group by city, order by createdAt, get count
         * const result = await prisma.user.groupBy({
         *   by: ['city', 'createdAt'],
         *   orderBy: {
         *     createdAt: true
         *   },
         *   _count: {
         *     _all: true
         *   },
         * })
         *
         **/
        groupBy<
            T extends HousingsGroupByArgs,
            HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
            OrderByArg extends True extends HasSelectOrTake
                ? { orderBy: HousingsGroupByArgs['orderBy'] }
                : { orderBy?: HousingsGroupByArgs['orderBy'] },
            OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
            ByFields extends TupleToUnion<T['by']>,
            ByValid extends Has<ByFields, OrderFields>,
            HavingFields extends GetHavingFields<T['having']>,
            HavingValid extends Has<ByFields, HavingFields>,
            ByEmpty extends T['by'] extends never[] ? True : False,
            InputErrors extends ByEmpty extends True
                ? `Error: "by" must not be empty.`
                : HavingValid extends False
                  ? {
                        [P in HavingFields]: P extends ByFields
                            ? never
                            : P extends string
                              ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                              : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`]
                    }[HavingFields]
                  : 'take' extends Keys<T>
                    ? 'orderBy' extends Keys<T>
                        ? ByValid extends True
                            ? {}
                            : {
                                  [P in OrderFields]: P extends ByFields
                                      ? never
                                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                              }[OrderFields]
                        : 'Error: If you provide "take", you also need to provide "orderBy"'
                    : 'skip' extends Keys<T>
                      ? 'orderBy' extends Keys<T>
                          ? ByValid extends True
                              ? {}
                              : {
                                    [P in OrderFields]: P extends ByFields
                                        ? never
                                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                                }[OrderFields]
                          : 'Error: If you provide "skip", you also need to provide "orderBy"'
                      : ByValid extends True
                        ? {}
                        : {
                              [P in OrderFields]: P extends ByFields
                                  ? never
                                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                          }[OrderFields]
        >(
            args: SubsetIntersection<T, HousingsGroupByArgs, OrderByArg> & InputErrors
        ): {} extends InputErrors ? GetHousingsGroupByPayload<T> : PrismaPromise<InputErrors>
    }

    /**
     * The delegate class that acts as a "Promise-like" for Housings.
     * Why is this prefixed with `Prisma__`?
     * Because we want to prevent naming conflicts as mentioned in
     * https://github.com/prisma/prisma-client-js/issues/707
     */
    export class Prisma__HousingsClient<T, Null = never> implements PrismaPromise<T> {
        [prisma]: true
        private readonly _dmmf
        private readonly _fetcher
        private readonly _queryType
        private readonly _rootField
        private readonly _clientMethod
        private readonly _args
        private readonly _dataPath
        private readonly _errorFormat
        private readonly _measurePerformance?
        private _isList
        private _callsite
        private _requestPromise?
        constructor(
            _dmmf: runtime.DMMFClass,
            _fetcher: PrismaClientFetcher,
            _queryType: 'query' | 'mutation',
            _rootField: string,
            _clientMethod: string,
            _args: any,
            _dataPath: string[],
            _errorFormat: ErrorFormat,
            _measurePerformance?: boolean | undefined,
            _isList?: boolean
        )
        readonly [Symbol.toStringTag]: 'PrismaClientPromise'

        family_housing<T extends Housings$family_housingArgs = {}>(
            args?: Subset<T, Housings$family_housingArgs>
        ): PrismaPromise<Array<Family_housingGetPayload<T>> | Null>

        private get _document()
        /**
         * Attaches callbacks for the resolution and/or rejection of the Promise.
         * @param onfulfilled The callback to execute when the Promise is resolved.
         * @param onrejected The callback to execute when the Promise is rejected.
         * @returns A Promise for the completion of which ever callback is executed.
         */
        then<TResult1 = T, TResult2 = never>(
            onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
            onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
        ): Promise<TResult1 | TResult2>
        /**
         * Attaches a callback for only the rejection of the Promise.
         * @param onrejected The callback to execute when the Promise is rejected.
         * @returns A Promise for the completion of the callback.
         */
        catch<TResult = never>(
            onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
        ): Promise<T | TResult>
        /**
         * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
         * resolved value cannot be modified from the callback.
         * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
         * @returns A Promise for the completion of the callback.
         */
        finally(onfinally?: (() => void) | undefined | null): Promise<T>
    }

    // Custom InputTypes

    /**
     * Housings base type for findUnique actions
     */
    export type HousingsFindUniqueArgsBase = {
        /**
         * Select specific fields to fetch from the Housings
         *
         **/
        select?: HousingsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: HousingsInclude | null
        /**
         * Filter, which Housings to fetch.
         *
         **/
        where: HousingsWhereUniqueInput
    }

    /**
     * Housings findUnique
     */
    export interface HousingsFindUniqueArgs extends HousingsFindUniqueArgsBase {
        /**
         * Throw an Error if query returns no results
         * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
         */
        rejectOnNotFound?: RejectOnNotFound
    }

    /**
     * Housings findUniqueOrThrow
     */
    export type HousingsFindUniqueOrThrowArgs = {
        /**
         * Select specific fields to fetch from the Housings
         *
         **/
        select?: HousingsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: HousingsInclude | null
        /**
         * Filter, which Housings to fetch.
         *
         **/
        where: HousingsWhereUniqueInput
    }

    /**
     * Housings base type for findFirst actions
     */
    export type HousingsFindFirstArgsBase = {
        /**
         * Select specific fields to fetch from the Housings
         *
         **/
        select?: HousingsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: HousingsInclude | null
        /**
         * Filter, which Housings to fetch.
         *
         **/
        where?: HousingsWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Housings to fetch.
         *
         **/
        orderBy?: Enumerable<HousingsOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for searching for Housings.
         *
         **/
        cursor?: HousingsWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Housings from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Housings.
         *
         **/
        skip?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
         *
         * Filter by unique combinations of Housings.
         *
         **/
        distinct?: Enumerable<HousingsScalarFieldEnum>
    }

    /**
     * Housings findFirst
     */
    export interface HousingsFindFirstArgs extends HousingsFindFirstArgsBase {
        /**
         * Throw an Error if query returns no results
         * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
         */
        rejectOnNotFound?: RejectOnNotFound
    }

    /**
     * Housings findFirstOrThrow
     */
    export type HousingsFindFirstOrThrowArgs = {
        /**
         * Select specific fields to fetch from the Housings
         *
         **/
        select?: HousingsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: HousingsInclude | null
        /**
         * Filter, which Housings to fetch.
         *
         **/
        where?: HousingsWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Housings to fetch.
         *
         **/
        orderBy?: Enumerable<HousingsOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for searching for Housings.
         *
         **/
        cursor?: HousingsWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Housings from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Housings.
         *
         **/
        skip?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
         *
         * Filter by unique combinations of Housings.
         *
         **/
        distinct?: Enumerable<HousingsScalarFieldEnum>
    }

    /**
     * Housings findMany
     */
    export type HousingsFindManyArgs = {
        /**
         * Select specific fields to fetch from the Housings
         *
         **/
        select?: HousingsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: HousingsInclude | null
        /**
         * Filter, which Housings to fetch.
         *
         **/
        where?: HousingsWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Housings to fetch.
         *
         **/
        orderBy?: Enumerable<HousingsOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for listing Housings.
         *
         **/
        cursor?: HousingsWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Housings from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Housings.
         *
         **/
        skip?: number
        distinct?: Enumerable<HousingsScalarFieldEnum>
    }

    /**
     * Housings create
     */
    export type HousingsCreateArgs = {
        /**
         * Select specific fields to fetch from the Housings
         *
         **/
        select?: HousingsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: HousingsInclude | null
        /**
         * The data needed to create a Housings.
         *
         **/
        data: XOR<HousingsCreateInput, HousingsUncheckedCreateInput>
    }

    /**
     * Housings createMany
     */
    export type HousingsCreateManyArgs = {
        /**
         * The data used to create many Housings.
         *
         **/
        data: Enumerable<HousingsCreateManyInput>
        skipDuplicates?: boolean
    }

    /**
     * Housings update
     */
    export type HousingsUpdateArgs = {
        /**
         * Select specific fields to fetch from the Housings
         *
         **/
        select?: HousingsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: HousingsInclude | null
        /**
         * The data needed to update a Housings.
         *
         **/
        data: XOR<HousingsUpdateInput, HousingsUncheckedUpdateInput>
        /**
         * Choose, which Housings to update.
         *
         **/
        where: HousingsWhereUniqueInput
    }

    /**
     * Housings updateMany
     */
    export type HousingsUpdateManyArgs = {
        /**
         * The data used to update Housings.
         *
         **/
        data: XOR<HousingsUpdateManyMutationInput, HousingsUncheckedUpdateManyInput>
        /**
         * Filter which Housings to update
         *
         **/
        where?: HousingsWhereInput
    }

    /**
     * Housings upsert
     */
    export type HousingsUpsertArgs = {
        /**
         * Select specific fields to fetch from the Housings
         *
         **/
        select?: HousingsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: HousingsInclude | null
        /**
         * The filter to search for the Housings to update in case it exists.
         *
         **/
        where: HousingsWhereUniqueInput
        /**
         * In case the Housings found by the `where` argument doesn't exist, create a new Housings with this data.
         *
         **/
        create: XOR<HousingsCreateInput, HousingsUncheckedCreateInput>
        /**
         * In case the Housings was found with the provided `where` argument, update it with this data.
         *
         **/
        update: XOR<HousingsUpdateInput, HousingsUncheckedUpdateInput>
    }

    /**
     * Housings delete
     */
    export type HousingsDeleteArgs = {
        /**
         * Select specific fields to fetch from the Housings
         *
         **/
        select?: HousingsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: HousingsInclude | null
        /**
         * Filter which Housings to delete.
         *
         **/
        where: HousingsWhereUniqueInput
    }

    /**
     * Housings deleteMany
     */
    export type HousingsDeleteManyArgs = {
        /**
         * Filter which Housings to delete
         *
         **/
        where?: HousingsWhereInput
    }

    /**
     * Housings.family_housing
     */
    export type Housings$family_housingArgs = {
        /**
         * Select specific fields to fetch from the Family_housing
         *
         **/
        select?: Family_housingSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Family_housingInclude | null
        where?: Family_housingWhereInput
        orderBy?: Enumerable<Family_housingOrderByWithRelationInput>
        cursor?: Family_housingWhereUniqueInput
        take?: number
        skip?: number
        distinct?: Enumerable<Family_housingScalarFieldEnum>
    }

    /**
     * Housings without action
     */
    export type HousingsArgs = {
        /**
         * Select specific fields to fetch from the Housings
         *
         **/
        select?: HousingsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: HousingsInclude | null
    }

    /**
     * Model Income_sponsor
     */

    export type AggregateIncome_sponsor = {
        _count: Income_sponsorCountAggregateOutputType | null
        _avg: Income_sponsorAvgAggregateOutputType | null
        _sum: Income_sponsorSumAggregateOutputType | null
        _min: Income_sponsorMinAggregateOutputType | null
        _max: Income_sponsorMaxAggregateOutputType | null
    }

    export type Income_sponsorAvgAggregateOutputType = {
        value: number | null
    }

    export type Income_sponsorSumAggregateOutputType = {
        value: number | null
    }

    export type Income_sponsorMinAggregateOutputType = {
        id: string | null
        income_id: string | null
        sponsor_id: string | null
        tenant_id: string | null
        value: number | null
        created_at: Date | null
        updated_at: Date | null
    }

    export type Income_sponsorMaxAggregateOutputType = {
        id: string | null
        income_id: string | null
        sponsor_id: string | null
        tenant_id: string | null
        value: number | null
        created_at: Date | null
        updated_at: Date | null
    }

    export type Income_sponsorCountAggregateOutputType = {
        id: number
        income_id: number
        sponsor_id: number
        tenant_id: number
        value: number
        created_at: number
        updated_at: number
        _all: number
    }

    export type Income_sponsorAvgAggregateInputType = {
        value?: true
    }

    export type Income_sponsorSumAggregateInputType = {
        value?: true
    }

    export type Income_sponsorMinAggregateInputType = {
        id?: true
        income_id?: true
        sponsor_id?: true
        tenant_id?: true
        value?: true
        created_at?: true
        updated_at?: true
    }

    export type Income_sponsorMaxAggregateInputType = {
        id?: true
        income_id?: true
        sponsor_id?: true
        tenant_id?: true
        value?: true
        created_at?: true
        updated_at?: true
    }

    export type Income_sponsorCountAggregateInputType = {
        id?: true
        income_id?: true
        sponsor_id?: true
        tenant_id?: true
        value?: true
        created_at?: true
        updated_at?: true
        _all?: true
    }

    export type Income_sponsorAggregateArgs = {
        /**
         * Filter which Income_sponsor to aggregate.
         *
         **/
        where?: Income_sponsorWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Income_sponsors to fetch.
         *
         **/
        orderBy?: Enumerable<Income_sponsorOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the start position
         *
         **/
        cursor?: Income_sponsorWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Income_sponsors from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Income_sponsors.
         *
         **/
        skip?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Count returned Income_sponsors
         **/
        _count?: true | Income_sponsorCountAggregateInputType
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to average
         **/
        _avg?: Income_sponsorAvgAggregateInputType
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to sum
         **/
        _sum?: Income_sponsorSumAggregateInputType
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to find the minimum value
         **/
        _min?: Income_sponsorMinAggregateInputType
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to find the maximum value
         **/
        _max?: Income_sponsorMaxAggregateInputType
    }

    export type GetIncome_sponsorAggregateType<T extends Income_sponsorAggregateArgs> = {
        [P in keyof T & keyof AggregateIncome_sponsor]: P extends '_count' | 'count'
            ? T[P] extends true
                ? number
                : GetScalarType<T[P], AggregateIncome_sponsor[P]>
            : GetScalarType<T[P], AggregateIncome_sponsor[P]>
    }

    export type Income_sponsorGroupByArgs = {
        where?: Income_sponsorWhereInput
        orderBy?: Enumerable<Income_sponsorOrderByWithAggregationInput>
        by: Array<Income_sponsorScalarFieldEnum>
        having?: Income_sponsorScalarWhereWithAggregatesInput
        take?: number
        skip?: number
        _count?: Income_sponsorCountAggregateInputType | true
        _avg?: Income_sponsorAvgAggregateInputType
        _sum?: Income_sponsorSumAggregateInputType
        _min?: Income_sponsorMinAggregateInputType
        _max?: Income_sponsorMaxAggregateInputType
    }

    export type Income_sponsorGroupByOutputType = {
        id: string
        income_id: string
        sponsor_id: string
        tenant_id: string
        value: number
        created_at: Date | null
        updated_at: Date | null
        _count: Income_sponsorCountAggregateOutputType | null
        _avg: Income_sponsorAvgAggregateOutputType | null
        _sum: Income_sponsorSumAggregateOutputType | null
        _min: Income_sponsorMinAggregateOutputType | null
        _max: Income_sponsorMaxAggregateOutputType | null
    }

    type GetIncome_sponsorGroupByPayload<T extends Income_sponsorGroupByArgs> = PrismaPromise<
        Array<
            PickArray<Income_sponsorGroupByOutputType, T['by']> & {
                [P in keyof T & keyof Income_sponsorGroupByOutputType]: P extends '_count'
                    ? T[P] extends boolean
                        ? number
                        : GetScalarType<T[P], Income_sponsorGroupByOutputType[P]>
                    : GetScalarType<T[P], Income_sponsorGroupByOutputType[P]>
            }
        >
    >

    export type Income_sponsorSelect = {
        id?: boolean
        income_id?: boolean
        sponsor_id?: boolean
        tenant_id?: boolean
        value?: boolean
        created_at?: boolean
        updated_at?: boolean
        incomes?: boolean | IncomesArgs
        sponsors?: boolean | SponsorsArgs
        tenants?: boolean | TenantsArgs
    }

    export type Income_sponsorInclude = {
        incomes?: boolean | IncomesArgs
        sponsors?: boolean | SponsorsArgs
        tenants?: boolean | TenantsArgs
    }

    export type Income_sponsorGetPayload<S extends boolean | null | undefined | Income_sponsorArgs> = S extends {
        select: any
        include: any
    }
        ? 'Please either choose `select` or `include`'
        : S extends true
          ? Income_sponsor
          : S extends undefined
            ? never
            : S extends { include: any } & (Income_sponsorArgs | Income_sponsorFindManyArgs)
              ? Income_sponsor & {
                    [P in TruthyKeys<S['include']>]: P extends 'incomes'
                        ? IncomesGetPayload<S['include'][P]>
                        : P extends 'sponsors'
                          ? SponsorsGetPayload<S['include'][P]>
                          : P extends 'tenants'
                            ? TenantsGetPayload<S['include'][P]>
                            : never
                }
              : S extends { select: any } & (Income_sponsorArgs | Income_sponsorFindManyArgs)
                ? {
                      [P in TruthyKeys<S['select']>]: P extends 'incomes'
                          ? IncomesGetPayload<S['select'][P]>
                          : P extends 'sponsors'
                            ? SponsorsGetPayload<S['select'][P]>
                            : P extends 'tenants'
                              ? TenantsGetPayload<S['select'][P]>
                              : P extends keyof Income_sponsor
                                ? Income_sponsor[P]
                                : never
                  }
                : Income_sponsor

    type Income_sponsorCountArgs = Merge<
        Omit<Income_sponsorFindManyArgs, 'select' | 'include'> & {
            select?: Income_sponsorCountAggregateInputType | true
        }
    >

    export interface Income_sponsorDelegate<
        GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined
    > {
        /**
         * Find zero or one Income_sponsor that matches the filter.
         * @param {Income_sponsorFindUniqueArgs} args - Arguments to find a Income_sponsor
         * @example
         * // Get one Income_sponsor
         * const income_sponsor = await prisma.income_sponsor.findUnique({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findUnique<
            T extends Income_sponsorFindUniqueArgs,
            LocalRejectSettings = T['rejectOnNotFound'] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined
        >(
            args: SelectSubset<T, Income_sponsorFindUniqueArgs>
        ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Income_sponsor'> extends True
            ? Prisma__Income_sponsorClient<Income_sponsorGetPayload<T>>
            : Prisma__Income_sponsorClient<Income_sponsorGetPayload<T> | null, null>

        /**
         * Find one Income_sponsor that matches the filter or throw an error  with `error.code='P2025'`
         *     if no matches were found.
         * @param {Income_sponsorFindUniqueOrThrowArgs} args - Arguments to find a Income_sponsor
         * @example
         * // Get one Income_sponsor
         * const income_sponsor = await prisma.income_sponsor.findUniqueOrThrow({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findUniqueOrThrow<T extends Income_sponsorFindUniqueOrThrowArgs>(
            args?: SelectSubset<T, Income_sponsorFindUniqueOrThrowArgs>
        ): Prisma__Income_sponsorClient<Income_sponsorGetPayload<T>>

        /**
         * Find the first Income_sponsor that matches the filter.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {Income_sponsorFindFirstArgs} args - Arguments to find a Income_sponsor
         * @example
         * // Get one Income_sponsor
         * const income_sponsor = await prisma.income_sponsor.findFirst({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findFirst<
            T extends Income_sponsorFindFirstArgs,
            LocalRejectSettings = T['rejectOnNotFound'] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined
        >(
            args?: SelectSubset<T, Income_sponsorFindFirstArgs>
        ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Income_sponsor'> extends True
            ? Prisma__Income_sponsorClient<Income_sponsorGetPayload<T>>
            : Prisma__Income_sponsorClient<Income_sponsorGetPayload<T> | null, null>

        /**
         * Find the first Income_sponsor that matches the filter or
         * throw `NotFoundError` if no matches were found.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {Income_sponsorFindFirstOrThrowArgs} args - Arguments to find a Income_sponsor
         * @example
         * // Get one Income_sponsor
         * const income_sponsor = await prisma.income_sponsor.findFirstOrThrow({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findFirstOrThrow<T extends Income_sponsorFindFirstOrThrowArgs>(
            args?: SelectSubset<T, Income_sponsorFindFirstOrThrowArgs>
        ): Prisma__Income_sponsorClient<Income_sponsorGetPayload<T>>

        /**
         * Find zero or more Income_sponsors that matches the filter.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {Income_sponsorFindManyArgs=} args - Arguments to filter and select certain fields only.
         * @example
         * // Get all Income_sponsors
         * const income_sponsors = await prisma.income_sponsor.findMany()
         *
         * // Get first 10 Income_sponsors
         * const income_sponsors = await prisma.income_sponsor.findMany({ take: 10 })
         *
         * // Only select the `id`
         * const income_sponsorWithIdOnly = await prisma.income_sponsor.findMany({ select: { id: true } })
         *
         **/
        findMany<T extends Income_sponsorFindManyArgs>(
            args?: SelectSubset<T, Income_sponsorFindManyArgs>
        ): PrismaPromise<Array<Income_sponsorGetPayload<T>>>

        /**
         * Create a Income_sponsor.
         * @param {Income_sponsorCreateArgs} args - Arguments to create a Income_sponsor.
         * @example
         * // Create one Income_sponsor
         * const Income_sponsor = await prisma.income_sponsor.create({
         *   data: {
         *     // ... data to create a Income_sponsor
         *   }
         * })
         *
         **/
        create<T extends Income_sponsorCreateArgs>(
            args: SelectSubset<T, Income_sponsorCreateArgs>
        ): Prisma__Income_sponsorClient<Income_sponsorGetPayload<T>>

        /**
         * Create many Income_sponsors.
         *     @param {Income_sponsorCreateManyArgs} args - Arguments to create many Income_sponsors.
         *     @example
         *     // Create many Income_sponsors
         *     const income_sponsor = await prisma.income_sponsor.createMany({
         *       data: {
         *         // ... provide data here
         *       }
         *     })
         *
         **/
        createMany<T extends Income_sponsorCreateManyArgs>(
            args?: SelectSubset<T, Income_sponsorCreateManyArgs>
        ): PrismaPromise<BatchPayload>

        /**
         * Delete a Income_sponsor.
         * @param {Income_sponsorDeleteArgs} args - Arguments to delete one Income_sponsor.
         * @example
         * // Delete one Income_sponsor
         * const Income_sponsor = await prisma.income_sponsor.delete({
         *   where: {
         *     // ... filter to delete one Income_sponsor
         *   }
         * })
         *
         **/
        delete<T extends Income_sponsorDeleteArgs>(
            args: SelectSubset<T, Income_sponsorDeleteArgs>
        ): Prisma__Income_sponsorClient<Income_sponsorGetPayload<T>>

        /**
         * Update one Income_sponsor.
         * @param {Income_sponsorUpdateArgs} args - Arguments to update one Income_sponsor.
         * @example
         * // Update one Income_sponsor
         * const income_sponsor = await prisma.income_sponsor.update({
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: {
         *     // ... provide data here
         *   }
         * })
         *
         **/
        update<T extends Income_sponsorUpdateArgs>(
            args: SelectSubset<T, Income_sponsorUpdateArgs>
        ): Prisma__Income_sponsorClient<Income_sponsorGetPayload<T>>

        /**
         * Delete zero or more Income_sponsors.
         * @param {Income_sponsorDeleteManyArgs} args - Arguments to filter Income_sponsors to delete.
         * @example
         * // Delete a few Income_sponsors
         * const { count } = await prisma.income_sponsor.deleteMany({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         *
         **/
        deleteMany<T extends Income_sponsorDeleteManyArgs>(
            args?: SelectSubset<T, Income_sponsorDeleteManyArgs>
        ): PrismaPromise<BatchPayload>

        /**
         * Update zero or more Income_sponsors.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {Income_sponsorUpdateManyArgs} args - Arguments to update one or more rows.
         * @example
         * // Update many Income_sponsors
         * const income_sponsor = await prisma.income_sponsor.updateMany({
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: {
         *     // ... provide data here
         *   }
         * })
         *
         **/
        updateMany<T extends Income_sponsorUpdateManyArgs>(
            args: SelectSubset<T, Income_sponsorUpdateManyArgs>
        ): PrismaPromise<BatchPayload>

        /**
         * Create or update one Income_sponsor.
         * @param {Income_sponsorUpsertArgs} args - Arguments to update or create a Income_sponsor.
         * @example
         * // Update or create a Income_sponsor
         * const income_sponsor = await prisma.income_sponsor.upsert({
         *   create: {
         *     // ... data to create a Income_sponsor
         *   },
         *   update: {
         *     // ... in case it already exists, update
         *   },
         *   where: {
         *     // ... the filter for the Income_sponsor we want to update
         *   }
         * })
         **/
        upsert<T extends Income_sponsorUpsertArgs>(
            args: SelectSubset<T, Income_sponsorUpsertArgs>
        ): Prisma__Income_sponsorClient<Income_sponsorGetPayload<T>>

        /**
         * Count the number of Income_sponsors.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {Income_sponsorCountArgs} args - Arguments to filter Income_sponsors to count.
         * @example
         * // Count the number of Income_sponsors
         * const count = await prisma.income_sponsor.count({
         *   where: {
         *     // ... the filter for the Income_sponsors we want to count
         *   }
         * })
         **/
        count<T extends Income_sponsorCountArgs>(
            args?: Subset<T, Income_sponsorCountArgs>
        ): PrismaPromise<
            T extends _Record<'select', any>
                ? T['select'] extends true
                    ? number
                    : GetScalarType<T['select'], Income_sponsorCountAggregateOutputType>
                : number
        >

        /**
         * Allows you to perform aggregations operations on a Income_sponsor.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {Income_sponsorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
         * @example
         * // Ordered by age ascending
         * // Where email contains prisma.io
         * // Limited to the 10 users
         * const aggregations = await prisma.user.aggregate({
         *   _avg: {
         *     age: true,
         *   },
         *   where: {
         *     email: {
         *       contains: "prisma.io",
         *     },
         *   },
         *   orderBy: {
         *     age: "asc",
         *   },
         *   take: 10,
         * })
         **/
        aggregate<T extends Income_sponsorAggregateArgs>(
            args: Subset<T, Income_sponsorAggregateArgs>
        ): PrismaPromise<GetIncome_sponsorAggregateType<T>>

        /**
         * Group by Income_sponsor.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {Income_sponsorGroupByArgs} args - Group by arguments.
         * @example
         * // Group by city, order by createdAt, get count
         * const result = await prisma.user.groupBy({
         *   by: ['city', 'createdAt'],
         *   orderBy: {
         *     createdAt: true
         *   },
         *   _count: {
         *     _all: true
         *   },
         * })
         *
         **/
        groupBy<
            T extends Income_sponsorGroupByArgs,
            HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
            OrderByArg extends True extends HasSelectOrTake
                ? { orderBy: Income_sponsorGroupByArgs['orderBy'] }
                : { orderBy?: Income_sponsorGroupByArgs['orderBy'] },
            OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
            ByFields extends TupleToUnion<T['by']>,
            ByValid extends Has<ByFields, OrderFields>,
            HavingFields extends GetHavingFields<T['having']>,
            HavingValid extends Has<ByFields, HavingFields>,
            ByEmpty extends T['by'] extends never[] ? True : False,
            InputErrors extends ByEmpty extends True
                ? `Error: "by" must not be empty.`
                : HavingValid extends False
                  ? {
                        [P in HavingFields]: P extends ByFields
                            ? never
                            : P extends string
                              ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                              : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`]
                    }[HavingFields]
                  : 'take' extends Keys<T>
                    ? 'orderBy' extends Keys<T>
                        ? ByValid extends True
                            ? {}
                            : {
                                  [P in OrderFields]: P extends ByFields
                                      ? never
                                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                              }[OrderFields]
                        : 'Error: If you provide "take", you also need to provide "orderBy"'
                    : 'skip' extends Keys<T>
                      ? 'orderBy' extends Keys<T>
                          ? ByValid extends True
                              ? {}
                              : {
                                    [P in OrderFields]: P extends ByFields
                                        ? never
                                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                                }[OrderFields]
                          : 'Error: If you provide "skip", you also need to provide "orderBy"'
                      : ByValid extends True
                        ? {}
                        : {
                              [P in OrderFields]: P extends ByFields
                                  ? never
                                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                          }[OrderFields]
        >(
            args: SubsetIntersection<T, Income_sponsorGroupByArgs, OrderByArg> & InputErrors
        ): {} extends InputErrors ? GetIncome_sponsorGroupByPayload<T> : PrismaPromise<InputErrors>
    }

    /**
     * The delegate class that acts as a "Promise-like" for Income_sponsor.
     * Why is this prefixed with `Prisma__`?
     * Because we want to prevent naming conflicts as mentioned in
     * https://github.com/prisma/prisma-client-js/issues/707
     */
    export class Prisma__Income_sponsorClient<T, Null = never> implements PrismaPromise<T> {
        [prisma]: true
        private readonly _dmmf
        private readonly _fetcher
        private readonly _queryType
        private readonly _rootField
        private readonly _clientMethod
        private readonly _args
        private readonly _dataPath
        private readonly _errorFormat
        private readonly _measurePerformance?
        private _isList
        private _callsite
        private _requestPromise?
        constructor(
            _dmmf: runtime.DMMFClass,
            _fetcher: PrismaClientFetcher,
            _queryType: 'query' | 'mutation',
            _rootField: string,
            _clientMethod: string,
            _args: any,
            _dataPath: string[],
            _errorFormat: ErrorFormat,
            _measurePerformance?: boolean | undefined,
            _isList?: boolean
        )
        readonly [Symbol.toStringTag]: 'PrismaClientPromise'

        incomes<T extends IncomesArgs = {}>(
            args?: Subset<T, IncomesArgs>
        ): Prisma__IncomesClient<IncomesGetPayload<T> | Null>

        sponsors<T extends SponsorsArgs = {}>(
            args?: Subset<T, SponsorsArgs>
        ): Prisma__SponsorsClient<SponsorsGetPayload<T> | Null>

        tenants<T extends TenantsArgs = {}>(
            args?: Subset<T, TenantsArgs>
        ): Prisma__TenantsClient<TenantsGetPayload<T> | Null>

        private get _document()
        /**
         * Attaches callbacks for the resolution and/or rejection of the Promise.
         * @param onfulfilled The callback to execute when the Promise is resolved.
         * @param onrejected The callback to execute when the Promise is rejected.
         * @returns A Promise for the completion of which ever callback is executed.
         */
        then<TResult1 = T, TResult2 = never>(
            onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
            onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
        ): Promise<TResult1 | TResult2>
        /**
         * Attaches a callback for only the rejection of the Promise.
         * @param onrejected The callback to execute when the Promise is rejected.
         * @returns A Promise for the completion of the callback.
         */
        catch<TResult = never>(
            onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
        ): Promise<T | TResult>
        /**
         * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
         * resolved value cannot be modified from the callback.
         * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
         * @returns A Promise for the completion of the callback.
         */
        finally(onfinally?: (() => void) | undefined | null): Promise<T>
    }

    // Custom InputTypes

    /**
     * Income_sponsor base type for findUnique actions
     */
    export type Income_sponsorFindUniqueArgsBase = {
        /**
         * Select specific fields to fetch from the Income_sponsor
         *
         **/
        select?: Income_sponsorSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Income_sponsorInclude | null
        /**
         * Filter, which Income_sponsor to fetch.
         *
         **/
        where: Income_sponsorWhereUniqueInput
    }

    /**
     * Income_sponsor findUnique
     */
    export interface Income_sponsorFindUniqueArgs extends Income_sponsorFindUniqueArgsBase {
        /**
         * Throw an Error if query returns no results
         * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
         */
        rejectOnNotFound?: RejectOnNotFound
    }

    /**
     * Income_sponsor findUniqueOrThrow
     */
    export type Income_sponsorFindUniqueOrThrowArgs = {
        /**
         * Select specific fields to fetch from the Income_sponsor
         *
         **/
        select?: Income_sponsorSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Income_sponsorInclude | null
        /**
         * Filter, which Income_sponsor to fetch.
         *
         **/
        where: Income_sponsorWhereUniqueInput
    }

    /**
     * Income_sponsor base type for findFirst actions
     */
    export type Income_sponsorFindFirstArgsBase = {
        /**
         * Select specific fields to fetch from the Income_sponsor
         *
         **/
        select?: Income_sponsorSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Income_sponsorInclude | null
        /**
         * Filter, which Income_sponsor to fetch.
         *
         **/
        where?: Income_sponsorWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Income_sponsors to fetch.
         *
         **/
        orderBy?: Enumerable<Income_sponsorOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for searching for Income_sponsors.
         *
         **/
        cursor?: Income_sponsorWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Income_sponsors from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Income_sponsors.
         *
         **/
        skip?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
         *
         * Filter by unique combinations of Income_sponsors.
         *
         **/
        distinct?: Enumerable<Income_sponsorScalarFieldEnum>
    }

    /**
     * Income_sponsor findFirst
     */
    export interface Income_sponsorFindFirstArgs extends Income_sponsorFindFirstArgsBase {
        /**
         * Throw an Error if query returns no results
         * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
         */
        rejectOnNotFound?: RejectOnNotFound
    }

    /**
     * Income_sponsor findFirstOrThrow
     */
    export type Income_sponsorFindFirstOrThrowArgs = {
        /**
         * Select specific fields to fetch from the Income_sponsor
         *
         **/
        select?: Income_sponsorSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Income_sponsorInclude | null
        /**
         * Filter, which Income_sponsor to fetch.
         *
         **/
        where?: Income_sponsorWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Income_sponsors to fetch.
         *
         **/
        orderBy?: Enumerable<Income_sponsorOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for searching for Income_sponsors.
         *
         **/
        cursor?: Income_sponsorWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Income_sponsors from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Income_sponsors.
         *
         **/
        skip?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
         *
         * Filter by unique combinations of Income_sponsors.
         *
         **/
        distinct?: Enumerable<Income_sponsorScalarFieldEnum>
    }

    /**
     * Income_sponsor findMany
     */
    export type Income_sponsorFindManyArgs = {
        /**
         * Select specific fields to fetch from the Income_sponsor
         *
         **/
        select?: Income_sponsorSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Income_sponsorInclude | null
        /**
         * Filter, which Income_sponsors to fetch.
         *
         **/
        where?: Income_sponsorWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Income_sponsors to fetch.
         *
         **/
        orderBy?: Enumerable<Income_sponsorOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for listing Income_sponsors.
         *
         **/
        cursor?: Income_sponsorWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Income_sponsors from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Income_sponsors.
         *
         **/
        skip?: number
        distinct?: Enumerable<Income_sponsorScalarFieldEnum>
    }

    /**
     * Income_sponsor create
     */
    export type Income_sponsorCreateArgs = {
        /**
         * Select specific fields to fetch from the Income_sponsor
         *
         **/
        select?: Income_sponsorSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Income_sponsorInclude | null
        /**
         * The data needed to create a Income_sponsor.
         *
         **/
        data: XOR<Income_sponsorCreateInput, Income_sponsorUncheckedCreateInput>
    }

    /**
     * Income_sponsor createMany
     */
    export type Income_sponsorCreateManyArgs = {
        /**
         * The data used to create many Income_sponsors.
         *
         **/
        data: Enumerable<Income_sponsorCreateManyInput>
        skipDuplicates?: boolean
    }

    /**
     * Income_sponsor update
     */
    export type Income_sponsorUpdateArgs = {
        /**
         * Select specific fields to fetch from the Income_sponsor
         *
         **/
        select?: Income_sponsorSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Income_sponsorInclude | null
        /**
         * The data needed to update a Income_sponsor.
         *
         **/
        data: XOR<Income_sponsorUpdateInput, Income_sponsorUncheckedUpdateInput>
        /**
         * Choose, which Income_sponsor to update.
         *
         **/
        where: Income_sponsorWhereUniqueInput
    }

    /**
     * Income_sponsor updateMany
     */
    export type Income_sponsorUpdateManyArgs = {
        /**
         * The data used to update Income_sponsors.
         *
         **/
        data: XOR<Income_sponsorUpdateManyMutationInput, Income_sponsorUncheckedUpdateManyInput>
        /**
         * Filter which Income_sponsors to update
         *
         **/
        where?: Income_sponsorWhereInput
    }

    /**
     * Income_sponsor upsert
     */
    export type Income_sponsorUpsertArgs = {
        /**
         * Select specific fields to fetch from the Income_sponsor
         *
         **/
        select?: Income_sponsorSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Income_sponsorInclude | null
        /**
         * The filter to search for the Income_sponsor to update in case it exists.
         *
         **/
        where: Income_sponsorWhereUniqueInput
        /**
         * In case the Income_sponsor found by the `where` argument doesn't exist, create a new Income_sponsor with this data.
         *
         **/
        create: XOR<Income_sponsorCreateInput, Income_sponsorUncheckedCreateInput>
        /**
         * In case the Income_sponsor was found with the provided `where` argument, update it with this data.
         *
         **/
        update: XOR<Income_sponsorUpdateInput, Income_sponsorUncheckedUpdateInput>
    }

    /**
     * Income_sponsor delete
     */
    export type Income_sponsorDeleteArgs = {
        /**
         * Select specific fields to fetch from the Income_sponsor
         *
         **/
        select?: Income_sponsorSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Income_sponsorInclude | null
        /**
         * Filter which Income_sponsor to delete.
         *
         **/
        where: Income_sponsorWhereUniqueInput
    }

    /**
     * Income_sponsor deleteMany
     */
    export type Income_sponsorDeleteManyArgs = {
        /**
         * Filter which Income_sponsors to delete
         *
         **/
        where?: Income_sponsorWhereInput
    }

    /**
     * Income_sponsor without action
     */
    export type Income_sponsorArgs = {
        /**
         * Select specific fields to fetch from the Income_sponsor
         *
         **/
        select?: Income_sponsorSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Income_sponsorInclude | null
    }

    /**
     * Model Incomes
     */

    export type AggregateIncomes = {
        _count: IncomesCountAggregateOutputType | null
        _min: IncomesMinAggregateOutputType | null
        _max: IncomesMaxAggregateOutputType | null
    }

    export type IncomesMinAggregateOutputType = {
        id: string | null
        name: string | null
    }

    export type IncomesMaxAggregateOutputType = {
        id: string | null
        name: string | null
    }

    export type IncomesCountAggregateOutputType = {
        id: number
        name: number
        _all: number
    }

    export type IncomesMinAggregateInputType = {
        id?: true
        name?: true
    }

    export type IncomesMaxAggregateInputType = {
        id?: true
        name?: true
    }

    export type IncomesCountAggregateInputType = {
        id?: true
        name?: true
        _all?: true
    }

    export type IncomesAggregateArgs = {
        /**
         * Filter which Incomes to aggregate.
         *
         **/
        where?: IncomesWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Incomes to fetch.
         *
         **/
        orderBy?: Enumerable<IncomesOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the start position
         *
         **/
        cursor?: IncomesWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Incomes from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Incomes.
         *
         **/
        skip?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Count returned Incomes
         **/
        _count?: true | IncomesCountAggregateInputType
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to find the minimum value
         **/
        _min?: IncomesMinAggregateInputType
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to find the maximum value
         **/
        _max?: IncomesMaxAggregateInputType
    }

    export type GetIncomesAggregateType<T extends IncomesAggregateArgs> = {
        [P in keyof T & keyof AggregateIncomes]: P extends '_count' | 'count'
            ? T[P] extends true
                ? number
                : GetScalarType<T[P], AggregateIncomes[P]>
            : GetScalarType<T[P], AggregateIncomes[P]>
    }

    export type IncomesGroupByArgs = {
        where?: IncomesWhereInput
        orderBy?: Enumerable<IncomesOrderByWithAggregationInput>
        by: Array<IncomesScalarFieldEnum>
        having?: IncomesScalarWhereWithAggregatesInput
        take?: number
        skip?: number
        _count?: IncomesCountAggregateInputType | true
        _min?: IncomesMinAggregateInputType
        _max?: IncomesMaxAggregateInputType
    }

    export type IncomesGroupByOutputType = {
        id: string
        name: string
        _count: IncomesCountAggregateOutputType | null
        _min: IncomesMinAggregateOutputType | null
        _max: IncomesMaxAggregateOutputType | null
    }

    type GetIncomesGroupByPayload<T extends IncomesGroupByArgs> = PrismaPromise<
        Array<
            PickArray<IncomesGroupByOutputType, T['by']> & {
                [P in keyof T & keyof IncomesGroupByOutputType]: P extends '_count'
                    ? T[P] extends boolean
                        ? number
                        : GetScalarType<T[P], IncomesGroupByOutputType[P]>
                    : GetScalarType<T[P], IncomesGroupByOutputType[P]>
            }
        >
    >

    export type IncomesSelect = {
        id?: boolean
        name?: boolean
        income_sponsor?: boolean | Incomes$income_sponsorArgs
        _count?: boolean | IncomesCountOutputTypeArgs
    }

    export type IncomesInclude = {
        income_sponsor?: boolean | Incomes$income_sponsorArgs
        _count?: boolean | IncomesCountOutputTypeArgs
    }

    export type IncomesGetPayload<S extends boolean | null | undefined | IncomesArgs> = S extends {
        select: any
        include: any
    }
        ? 'Please either choose `select` or `include`'
        : S extends true
          ? Incomes
          : S extends undefined
            ? never
            : S extends { include: any } & (IncomesArgs | IncomesFindManyArgs)
              ? Incomes & {
                    [P in TruthyKeys<S['include']>]: P extends 'income_sponsor'
                        ? Array<Income_sponsorGetPayload<S['include'][P]>>
                        : P extends '_count'
                          ? IncomesCountOutputTypeGetPayload<S['include'][P]>
                          : never
                }
              : S extends { select: any } & (IncomesArgs | IncomesFindManyArgs)
                ? {
                      [P in TruthyKeys<S['select']>]: P extends 'income_sponsor'
                          ? Array<Income_sponsorGetPayload<S['select'][P]>>
                          : P extends '_count'
                            ? IncomesCountOutputTypeGetPayload<S['select'][P]>
                            : P extends keyof Incomes
                              ? Incomes[P]
                              : never
                  }
                : Incomes

    type IncomesCountArgs = Merge<
        Omit<IncomesFindManyArgs, 'select' | 'include'> & {
            select?: IncomesCountAggregateInputType | true
        }
    >

    export interface IncomesDelegate<
        GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined
    > {
        /**
         * Find zero or one Incomes that matches the filter.
         * @param {IncomesFindUniqueArgs} args - Arguments to find a Incomes
         * @example
         * // Get one Incomes
         * const incomes = await prisma.incomes.findUnique({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findUnique<
            T extends IncomesFindUniqueArgs,
            LocalRejectSettings = T['rejectOnNotFound'] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined
        >(
            args: SelectSubset<T, IncomesFindUniqueArgs>
        ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Incomes'> extends True
            ? Prisma__IncomesClient<IncomesGetPayload<T>>
            : Prisma__IncomesClient<IncomesGetPayload<T> | null, null>

        /**
         * Find one Incomes that matches the filter or throw an error  with `error.code='P2025'`
         *     if no matches were found.
         * @param {IncomesFindUniqueOrThrowArgs} args - Arguments to find a Incomes
         * @example
         * // Get one Incomes
         * const incomes = await prisma.incomes.findUniqueOrThrow({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findUniqueOrThrow<T extends IncomesFindUniqueOrThrowArgs>(
            args?: SelectSubset<T, IncomesFindUniqueOrThrowArgs>
        ): Prisma__IncomesClient<IncomesGetPayload<T>>

        /**
         * Find the first Incomes that matches the filter.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {IncomesFindFirstArgs} args - Arguments to find a Incomes
         * @example
         * // Get one Incomes
         * const incomes = await prisma.incomes.findFirst({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findFirst<
            T extends IncomesFindFirstArgs,
            LocalRejectSettings = T['rejectOnNotFound'] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined
        >(
            args?: SelectSubset<T, IncomesFindFirstArgs>
        ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Incomes'> extends True
            ? Prisma__IncomesClient<IncomesGetPayload<T>>
            : Prisma__IncomesClient<IncomesGetPayload<T> | null, null>

        /**
         * Find the first Incomes that matches the filter or
         * throw `NotFoundError` if no matches were found.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {IncomesFindFirstOrThrowArgs} args - Arguments to find a Incomes
         * @example
         * // Get one Incomes
         * const incomes = await prisma.incomes.findFirstOrThrow({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findFirstOrThrow<T extends IncomesFindFirstOrThrowArgs>(
            args?: SelectSubset<T, IncomesFindFirstOrThrowArgs>
        ): Prisma__IncomesClient<IncomesGetPayload<T>>

        /**
         * Find zero or more Incomes that matches the filter.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {IncomesFindManyArgs=} args - Arguments to filter and select certain fields only.
         * @example
         * // Get all Incomes
         * const incomes = await prisma.incomes.findMany()
         *
         * // Get first 10 Incomes
         * const incomes = await prisma.incomes.findMany({ take: 10 })
         *
         * // Only select the `id`
         * const incomesWithIdOnly = await prisma.incomes.findMany({ select: { id: true } })
         *
         **/
        findMany<T extends IncomesFindManyArgs>(
            args?: SelectSubset<T, IncomesFindManyArgs>
        ): PrismaPromise<Array<IncomesGetPayload<T>>>

        /**
         * Create a Incomes.
         * @param {IncomesCreateArgs} args - Arguments to create a Incomes.
         * @example
         * // Create one Incomes
         * const Incomes = await prisma.incomes.create({
         *   data: {
         *     // ... data to create a Incomes
         *   }
         * })
         *
         **/
        create<T extends IncomesCreateArgs>(
            args: SelectSubset<T, IncomesCreateArgs>
        ): Prisma__IncomesClient<IncomesGetPayload<T>>

        /**
         * Create many Incomes.
         *     @param {IncomesCreateManyArgs} args - Arguments to create many Incomes.
         *     @example
         *     // Create many Incomes
         *     const incomes = await prisma.incomes.createMany({
         *       data: {
         *         // ... provide data here
         *       }
         *     })
         *
         **/
        createMany<T extends IncomesCreateManyArgs>(
            args?: SelectSubset<T, IncomesCreateManyArgs>
        ): PrismaPromise<BatchPayload>

        /**
         * Delete a Incomes.
         * @param {IncomesDeleteArgs} args - Arguments to delete one Incomes.
         * @example
         * // Delete one Incomes
         * const Incomes = await prisma.incomes.delete({
         *   where: {
         *     // ... filter to delete one Incomes
         *   }
         * })
         *
         **/
        delete<T extends IncomesDeleteArgs>(
            args: SelectSubset<T, IncomesDeleteArgs>
        ): Prisma__IncomesClient<IncomesGetPayload<T>>

        /**
         * Update one Incomes.
         * @param {IncomesUpdateArgs} args - Arguments to update one Incomes.
         * @example
         * // Update one Incomes
         * const incomes = await prisma.incomes.update({
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: {
         *     // ... provide data here
         *   }
         * })
         *
         **/
        update<T extends IncomesUpdateArgs>(
            args: SelectSubset<T, IncomesUpdateArgs>
        ): Prisma__IncomesClient<IncomesGetPayload<T>>

        /**
         * Delete zero or more Incomes.
         * @param {IncomesDeleteManyArgs} args - Arguments to filter Incomes to delete.
         * @example
         * // Delete a few Incomes
         * const { count } = await prisma.incomes.deleteMany({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         *
         **/
        deleteMany<T extends IncomesDeleteManyArgs>(
            args?: SelectSubset<T, IncomesDeleteManyArgs>
        ): PrismaPromise<BatchPayload>

        /**
         * Update zero or more Incomes.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {IncomesUpdateManyArgs} args - Arguments to update one or more rows.
         * @example
         * // Update many Incomes
         * const incomes = await prisma.incomes.updateMany({
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: {
         *     // ... provide data here
         *   }
         * })
         *
         **/
        updateMany<T extends IncomesUpdateManyArgs>(
            args: SelectSubset<T, IncomesUpdateManyArgs>
        ): PrismaPromise<BatchPayload>

        /**
         * Create or update one Incomes.
         * @param {IncomesUpsertArgs} args - Arguments to update or create a Incomes.
         * @example
         * // Update or create a Incomes
         * const incomes = await prisma.incomes.upsert({
         *   create: {
         *     // ... data to create a Incomes
         *   },
         *   update: {
         *     // ... in case it already exists, update
         *   },
         *   where: {
         *     // ... the filter for the Incomes we want to update
         *   }
         * })
         **/
        upsert<T extends IncomesUpsertArgs>(
            args: SelectSubset<T, IncomesUpsertArgs>
        ): Prisma__IncomesClient<IncomesGetPayload<T>>

        /**
         * Count the number of Incomes.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {IncomesCountArgs} args - Arguments to filter Incomes to count.
         * @example
         * // Count the number of Incomes
         * const count = await prisma.incomes.count({
         *   where: {
         *     // ... the filter for the Incomes we want to count
         *   }
         * })
         **/
        count<T extends IncomesCountArgs>(
            args?: Subset<T, IncomesCountArgs>
        ): PrismaPromise<
            T extends _Record<'select', any>
                ? T['select'] extends true
                    ? number
                    : GetScalarType<T['select'], IncomesCountAggregateOutputType>
                : number
        >

        /**
         * Allows you to perform aggregations operations on a Incomes.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {IncomesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
         * @example
         * // Ordered by age ascending
         * // Where email contains prisma.io
         * // Limited to the 10 users
         * const aggregations = await prisma.user.aggregate({
         *   _avg: {
         *     age: true,
         *   },
         *   where: {
         *     email: {
         *       contains: "prisma.io",
         *     },
         *   },
         *   orderBy: {
         *     age: "asc",
         *   },
         *   take: 10,
         * })
         **/
        aggregate<T extends IncomesAggregateArgs>(
            args: Subset<T, IncomesAggregateArgs>
        ): PrismaPromise<GetIncomesAggregateType<T>>

        /**
         * Group by Incomes.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {IncomesGroupByArgs} args - Group by arguments.
         * @example
         * // Group by city, order by createdAt, get count
         * const result = await prisma.user.groupBy({
         *   by: ['city', 'createdAt'],
         *   orderBy: {
         *     createdAt: true
         *   },
         *   _count: {
         *     _all: true
         *   },
         * })
         *
         **/
        groupBy<
            T extends IncomesGroupByArgs,
            HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
            OrderByArg extends True extends HasSelectOrTake
                ? { orderBy: IncomesGroupByArgs['orderBy'] }
                : { orderBy?: IncomesGroupByArgs['orderBy'] },
            OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
            ByFields extends TupleToUnion<T['by']>,
            ByValid extends Has<ByFields, OrderFields>,
            HavingFields extends GetHavingFields<T['having']>,
            HavingValid extends Has<ByFields, HavingFields>,
            ByEmpty extends T['by'] extends never[] ? True : False,
            InputErrors extends ByEmpty extends True
                ? `Error: "by" must not be empty.`
                : HavingValid extends False
                  ? {
                        [P in HavingFields]: P extends ByFields
                            ? never
                            : P extends string
                              ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                              : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`]
                    }[HavingFields]
                  : 'take' extends Keys<T>
                    ? 'orderBy' extends Keys<T>
                        ? ByValid extends True
                            ? {}
                            : {
                                  [P in OrderFields]: P extends ByFields
                                      ? never
                                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                              }[OrderFields]
                        : 'Error: If you provide "take", you also need to provide "orderBy"'
                    : 'skip' extends Keys<T>
                      ? 'orderBy' extends Keys<T>
                          ? ByValid extends True
                              ? {}
                              : {
                                    [P in OrderFields]: P extends ByFields
                                        ? never
                                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                                }[OrderFields]
                          : 'Error: If you provide "skip", you also need to provide "orderBy"'
                      : ByValid extends True
                        ? {}
                        : {
                              [P in OrderFields]: P extends ByFields
                                  ? never
                                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                          }[OrderFields]
        >(
            args: SubsetIntersection<T, IncomesGroupByArgs, OrderByArg> & InputErrors
        ): {} extends InputErrors ? GetIncomesGroupByPayload<T> : PrismaPromise<InputErrors>
    }

    /**
     * The delegate class that acts as a "Promise-like" for Incomes.
     * Why is this prefixed with `Prisma__`?
     * Because we want to prevent naming conflicts as mentioned in
     * https://github.com/prisma/prisma-client-js/issues/707
     */
    export class Prisma__IncomesClient<T, Null = never> implements PrismaPromise<T> {
        [prisma]: true
        private readonly _dmmf
        private readonly _fetcher
        private readonly _queryType
        private readonly _rootField
        private readonly _clientMethod
        private readonly _args
        private readonly _dataPath
        private readonly _errorFormat
        private readonly _measurePerformance?
        private _isList
        private _callsite
        private _requestPromise?
        constructor(
            _dmmf: runtime.DMMFClass,
            _fetcher: PrismaClientFetcher,
            _queryType: 'query' | 'mutation',
            _rootField: string,
            _clientMethod: string,
            _args: any,
            _dataPath: string[],
            _errorFormat: ErrorFormat,
            _measurePerformance?: boolean | undefined,
            _isList?: boolean
        )
        readonly [Symbol.toStringTag]: 'PrismaClientPromise'

        income_sponsor<T extends Incomes$income_sponsorArgs = {}>(
            args?: Subset<T, Incomes$income_sponsorArgs>
        ): PrismaPromise<Array<Income_sponsorGetPayload<T>> | Null>

        private get _document()
        /**
         * Attaches callbacks for the resolution and/or rejection of the Promise.
         * @param onfulfilled The callback to execute when the Promise is resolved.
         * @param onrejected The callback to execute when the Promise is rejected.
         * @returns A Promise for the completion of which ever callback is executed.
         */
        then<TResult1 = T, TResult2 = never>(
            onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
            onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
        ): Promise<TResult1 | TResult2>
        /**
         * Attaches a callback for only the rejection of the Promise.
         * @param onrejected The callback to execute when the Promise is rejected.
         * @returns A Promise for the completion of the callback.
         */
        catch<TResult = never>(
            onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
        ): Promise<T | TResult>
        /**
         * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
         * resolved value cannot be modified from the callback.
         * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
         * @returns A Promise for the completion of the callback.
         */
        finally(onfinally?: (() => void) | undefined | null): Promise<T>
    }

    // Custom InputTypes

    /**
     * Incomes base type for findUnique actions
     */
    export type IncomesFindUniqueArgsBase = {
        /**
         * Select specific fields to fetch from the Incomes
         *
         **/
        select?: IncomesSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: IncomesInclude | null
        /**
         * Filter, which Incomes to fetch.
         *
         **/
        where: IncomesWhereUniqueInput
    }

    /**
     * Incomes findUnique
     */
    export interface IncomesFindUniqueArgs extends IncomesFindUniqueArgsBase {
        /**
         * Throw an Error if query returns no results
         * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
         */
        rejectOnNotFound?: RejectOnNotFound
    }

    /**
     * Incomes findUniqueOrThrow
     */
    export type IncomesFindUniqueOrThrowArgs = {
        /**
         * Select specific fields to fetch from the Incomes
         *
         **/
        select?: IncomesSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: IncomesInclude | null
        /**
         * Filter, which Incomes to fetch.
         *
         **/
        where: IncomesWhereUniqueInput
    }

    /**
     * Incomes base type for findFirst actions
     */
    export type IncomesFindFirstArgsBase = {
        /**
         * Select specific fields to fetch from the Incomes
         *
         **/
        select?: IncomesSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: IncomesInclude | null
        /**
         * Filter, which Incomes to fetch.
         *
         **/
        where?: IncomesWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Incomes to fetch.
         *
         **/
        orderBy?: Enumerable<IncomesOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for searching for Incomes.
         *
         **/
        cursor?: IncomesWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Incomes from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Incomes.
         *
         **/
        skip?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
         *
         * Filter by unique combinations of Incomes.
         *
         **/
        distinct?: Enumerable<IncomesScalarFieldEnum>
    }

    /**
     * Incomes findFirst
     */
    export interface IncomesFindFirstArgs extends IncomesFindFirstArgsBase {
        /**
         * Throw an Error if query returns no results
         * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
         */
        rejectOnNotFound?: RejectOnNotFound
    }

    /**
     * Incomes findFirstOrThrow
     */
    export type IncomesFindFirstOrThrowArgs = {
        /**
         * Select specific fields to fetch from the Incomes
         *
         **/
        select?: IncomesSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: IncomesInclude | null
        /**
         * Filter, which Incomes to fetch.
         *
         **/
        where?: IncomesWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Incomes to fetch.
         *
         **/
        orderBy?: Enumerable<IncomesOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for searching for Incomes.
         *
         **/
        cursor?: IncomesWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Incomes from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Incomes.
         *
         **/
        skip?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
         *
         * Filter by unique combinations of Incomes.
         *
         **/
        distinct?: Enumerable<IncomesScalarFieldEnum>
    }

    /**
     * Incomes findMany
     */
    export type IncomesFindManyArgs = {
        /**
         * Select specific fields to fetch from the Incomes
         *
         **/
        select?: IncomesSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: IncomesInclude | null
        /**
         * Filter, which Incomes to fetch.
         *
         **/
        where?: IncomesWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Incomes to fetch.
         *
         **/
        orderBy?: Enumerable<IncomesOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for listing Incomes.
         *
         **/
        cursor?: IncomesWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Incomes from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Incomes.
         *
         **/
        skip?: number
        distinct?: Enumerable<IncomesScalarFieldEnum>
    }

    /**
     * Incomes create
     */
    export type IncomesCreateArgs = {
        /**
         * Select specific fields to fetch from the Incomes
         *
         **/
        select?: IncomesSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: IncomesInclude | null
        /**
         * The data needed to create a Incomes.
         *
         **/
        data: XOR<IncomesCreateInput, IncomesUncheckedCreateInput>
    }

    /**
     * Incomes createMany
     */
    export type IncomesCreateManyArgs = {
        /**
         * The data used to create many Incomes.
         *
         **/
        data: Enumerable<IncomesCreateManyInput>
        skipDuplicates?: boolean
    }

    /**
     * Incomes update
     */
    export type IncomesUpdateArgs = {
        /**
         * Select specific fields to fetch from the Incomes
         *
         **/
        select?: IncomesSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: IncomesInclude | null
        /**
         * The data needed to update a Incomes.
         *
         **/
        data: XOR<IncomesUpdateInput, IncomesUncheckedUpdateInput>
        /**
         * Choose, which Incomes to update.
         *
         **/
        where: IncomesWhereUniqueInput
    }

    /**
     * Incomes updateMany
     */
    export type IncomesUpdateManyArgs = {
        /**
         * The data used to update Incomes.
         *
         **/
        data: XOR<IncomesUpdateManyMutationInput, IncomesUncheckedUpdateManyInput>
        /**
         * Filter which Incomes to update
         *
         **/
        where?: IncomesWhereInput
    }

    /**
     * Incomes upsert
     */
    export type IncomesUpsertArgs = {
        /**
         * Select specific fields to fetch from the Incomes
         *
         **/
        select?: IncomesSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: IncomesInclude | null
        /**
         * The filter to search for the Incomes to update in case it exists.
         *
         **/
        where: IncomesWhereUniqueInput
        /**
         * In case the Incomes found by the `where` argument doesn't exist, create a new Incomes with this data.
         *
         **/
        create: XOR<IncomesCreateInput, IncomesUncheckedCreateInput>
        /**
         * In case the Incomes was found with the provided `where` argument, update it with this data.
         *
         **/
        update: XOR<IncomesUpdateInput, IncomesUncheckedUpdateInput>
    }

    /**
     * Incomes delete
     */
    export type IncomesDeleteArgs = {
        /**
         * Select specific fields to fetch from the Incomes
         *
         **/
        select?: IncomesSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: IncomesInclude | null
        /**
         * Filter which Incomes to delete.
         *
         **/
        where: IncomesWhereUniqueInput
    }

    /**
     * Incomes deleteMany
     */
    export type IncomesDeleteManyArgs = {
        /**
         * Filter which Incomes to delete
         *
         **/
        where?: IncomesWhereInput
    }

    /**
     * Incomes.income_sponsor
     */
    export type Incomes$income_sponsorArgs = {
        /**
         * Select specific fields to fetch from the Income_sponsor
         *
         **/
        select?: Income_sponsorSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Income_sponsorInclude | null
        where?: Income_sponsorWhereInput
        orderBy?: Enumerable<Income_sponsorOrderByWithRelationInput>
        cursor?: Income_sponsorWhereUniqueInput
        take?: number
        skip?: number
        distinct?: Enumerable<Income_sponsorScalarFieldEnum>
    }

    /**
     * Incomes without action
     */
    export type IncomesArgs = {
        /**
         * Select specific fields to fetch from the Incomes
         *
         **/
        select?: IncomesSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: IncomesInclude | null
    }

    /**
     * Model Media
     */

    export type AggregateMedia = {
        _count: MediaCountAggregateOutputType | null
        _avg: MediaAvgAggregateOutputType | null
        _sum: MediaSumAggregateOutputType | null
        _min: MediaMinAggregateOutputType | null
        _max: MediaMaxAggregateOutputType | null
    }

    export type MediaAvgAggregateOutputType = {
        model_id: number | null
        size: number | null
        order_column: number | null
    }

    export type MediaSumAggregateOutputType = {
        model_id: bigint | null
        size: bigint | null
        order_column: number | null
    }

    export type MediaMinAggregateOutputType = {
        id: string | null
        model_type: string | null
        model_id: bigint | null
        uuid: string | null
        collection_name: string | null
        name: string | null
        file_name: string | null
        mime_type: string | null
        disk: string | null
        conversions_disk: string | null
        size: bigint | null
        order_column: number | null
        created_at: Date | null
        updated_at: Date | null
    }

    export type MediaMaxAggregateOutputType = {
        id: string | null
        model_type: string | null
        model_id: bigint | null
        uuid: string | null
        collection_name: string | null
        name: string | null
        file_name: string | null
        mime_type: string | null
        disk: string | null
        conversions_disk: string | null
        size: bigint | null
        order_column: number | null
        created_at: Date | null
        updated_at: Date | null
    }

    export type MediaCountAggregateOutputType = {
        id: number
        model_type: number
        model_id: number
        uuid: number
        collection_name: number
        name: number
        file_name: number
        mime_type: number
        disk: number
        conversions_disk: number
        size: number
        manipulations: number
        custom_properties: number
        generated_conversions: number
        responsive_images: number
        order_column: number
        created_at: number
        updated_at: number
        _all: number
    }

    export type MediaAvgAggregateInputType = {
        model_id?: true
        size?: true
        order_column?: true
    }

    export type MediaSumAggregateInputType = {
        model_id?: true
        size?: true
        order_column?: true
    }

    export type MediaMinAggregateInputType = {
        id?: true
        model_type?: true
        model_id?: true
        uuid?: true
        collection_name?: true
        name?: true
        file_name?: true
        mime_type?: true
        disk?: true
        conversions_disk?: true
        size?: true
        order_column?: true
        created_at?: true
        updated_at?: true
    }

    export type MediaMaxAggregateInputType = {
        id?: true
        model_type?: true
        model_id?: true
        uuid?: true
        collection_name?: true
        name?: true
        file_name?: true
        mime_type?: true
        disk?: true
        conversions_disk?: true
        size?: true
        order_column?: true
        created_at?: true
        updated_at?: true
    }

    export type MediaCountAggregateInputType = {
        id?: true
        model_type?: true
        model_id?: true
        uuid?: true
        collection_name?: true
        name?: true
        file_name?: true
        mime_type?: true
        disk?: true
        conversions_disk?: true
        size?: true
        manipulations?: true
        custom_properties?: true
        generated_conversions?: true
        responsive_images?: true
        order_column?: true
        created_at?: true
        updated_at?: true
        _all?: true
    }

    export type MediaAggregateArgs = {
        /**
         * Filter which Media to aggregate.
         *
         **/
        where?: MediaWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Media to fetch.
         *
         **/
        orderBy?: Enumerable<MediaOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the start position
         *
         **/
        cursor?: MediaWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Media from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Media.
         *
         **/
        skip?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Count returned Media
         **/
        _count?: true | MediaCountAggregateInputType
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to average
         **/
        _avg?: MediaAvgAggregateInputType
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to sum
         **/
        _sum?: MediaSumAggregateInputType
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to find the minimum value
         **/
        _min?: MediaMinAggregateInputType
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to find the maximum value
         **/
        _max?: MediaMaxAggregateInputType
    }

    export type GetMediaAggregateType<T extends MediaAggregateArgs> = {
        [P in keyof T & keyof AggregateMedia]: P extends '_count' | 'count'
            ? T[P] extends true
                ? number
                : GetScalarType<T[P], AggregateMedia[P]>
            : GetScalarType<T[P], AggregateMedia[P]>
    }

    export type MediaGroupByArgs = {
        where?: MediaWhereInput
        orderBy?: Enumerable<MediaOrderByWithAggregationInput>
        by: Array<MediaScalarFieldEnum>
        having?: MediaScalarWhereWithAggregatesInput
        take?: number
        skip?: number
        _count?: MediaCountAggregateInputType | true
        _avg?: MediaAvgAggregateInputType
        _sum?: MediaSumAggregateInputType
        _min?: MediaMinAggregateInputType
        _max?: MediaMaxAggregateInputType
    }

    export type MediaGroupByOutputType = {
        id: string
        model_type: string
        model_id: bigint
        uuid: string | null
        collection_name: string
        name: string
        file_name: string
        mime_type: string | null
        disk: string
        conversions_disk: string | null
        size: bigint
        manipulations: JsonValue
        custom_properties: JsonValue
        generated_conversions: JsonValue
        responsive_images: JsonValue
        order_column: number | null
        created_at: Date | null
        updated_at: Date | null
        _count: MediaCountAggregateOutputType | null
        _avg: MediaAvgAggregateOutputType | null
        _sum: MediaSumAggregateOutputType | null
        _min: MediaMinAggregateOutputType | null
        _max: MediaMaxAggregateOutputType | null
    }

    type GetMediaGroupByPayload<T extends MediaGroupByArgs> = PrismaPromise<
        Array<
            PickArray<MediaGroupByOutputType, T['by']> & {
                [P in keyof T & keyof MediaGroupByOutputType]: P extends '_count'
                    ? T[P] extends boolean
                        ? number
                        : GetScalarType<T[P], MediaGroupByOutputType[P]>
                    : GetScalarType<T[P], MediaGroupByOutputType[P]>
            }
        >
    >

    export type MediaSelect = {
        id?: boolean
        model_type?: boolean
        model_id?: boolean
        uuid?: boolean
        collection_name?: boolean
        name?: boolean
        file_name?: boolean
        mime_type?: boolean
        disk?: boolean
        conversions_disk?: boolean
        size?: boolean
        manipulations?: boolean
        custom_properties?: boolean
        generated_conversions?: boolean
        responsive_images?: boolean
        order_column?: boolean
        created_at?: boolean
        updated_at?: boolean
    }

    export type MediaGetPayload<S extends boolean | null | undefined | MediaArgs> = S extends {
        select: any
        include: any
    }
        ? 'Please either choose `select` or `include`'
        : S extends true
          ? Media
          : S extends undefined
            ? never
            : S extends { include: any } & (MediaArgs | MediaFindManyArgs)
              ? Media
              : S extends { select: any } & (MediaArgs | MediaFindManyArgs)
                ? {
                      [P in TruthyKeys<S['select']>]: P extends keyof Media ? Media[P] : never
                  }
                : Media

    type MediaCountArgs = Merge<
        Omit<MediaFindManyArgs, 'select' | 'include'> & {
            select?: MediaCountAggregateInputType | true
        }
    >

    export interface MediaDelegate<
        GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined
    > {
        /**
         * Find zero or one Media that matches the filter.
         * @param {MediaFindUniqueArgs} args - Arguments to find a Media
         * @example
         * // Get one Media
         * const media = await prisma.media.findUnique({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findUnique<
            T extends MediaFindUniqueArgs,
            LocalRejectSettings = T['rejectOnNotFound'] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined
        >(
            args: SelectSubset<T, MediaFindUniqueArgs>
        ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Media'> extends True
            ? Prisma__MediaClient<MediaGetPayload<T>>
            : Prisma__MediaClient<MediaGetPayload<T> | null, null>

        /**
         * Find one Media that matches the filter or throw an error  with `error.code='P2025'`
         *     if no matches were found.
         * @param {MediaFindUniqueOrThrowArgs} args - Arguments to find a Media
         * @example
         * // Get one Media
         * const media = await prisma.media.findUniqueOrThrow({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findUniqueOrThrow<T extends MediaFindUniqueOrThrowArgs>(
            args?: SelectSubset<T, MediaFindUniqueOrThrowArgs>
        ): Prisma__MediaClient<MediaGetPayload<T>>

        /**
         * Find the first Media that matches the filter.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {MediaFindFirstArgs} args - Arguments to find a Media
         * @example
         * // Get one Media
         * const media = await prisma.media.findFirst({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findFirst<
            T extends MediaFindFirstArgs,
            LocalRejectSettings = T['rejectOnNotFound'] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined
        >(
            args?: SelectSubset<T, MediaFindFirstArgs>
        ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Media'> extends True
            ? Prisma__MediaClient<MediaGetPayload<T>>
            : Prisma__MediaClient<MediaGetPayload<T> | null, null>

        /**
         * Find the first Media that matches the filter or
         * throw `NotFoundError` if no matches were found.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {MediaFindFirstOrThrowArgs} args - Arguments to find a Media
         * @example
         * // Get one Media
         * const media = await prisma.media.findFirstOrThrow({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findFirstOrThrow<T extends MediaFindFirstOrThrowArgs>(
            args?: SelectSubset<T, MediaFindFirstOrThrowArgs>
        ): Prisma__MediaClient<MediaGetPayload<T>>

        /**
         * Find zero or more Media that matches the filter.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {MediaFindManyArgs=} args - Arguments to filter and select certain fields only.
         * @example
         * // Get all Media
         * const media = await prisma.media.findMany()
         *
         * // Get first 10 Media
         * const media = await prisma.media.findMany({ take: 10 })
         *
         * // Only select the `id`
         * const mediaWithIdOnly = await prisma.media.findMany({ select: { id: true } })
         *
         **/
        findMany<T extends MediaFindManyArgs>(
            args?: SelectSubset<T, MediaFindManyArgs>
        ): PrismaPromise<Array<MediaGetPayload<T>>>

        /**
         * Create a Media.
         * @param {MediaCreateArgs} args - Arguments to create a Media.
         * @example
         * // Create one Media
         * const Media = await prisma.media.create({
         *   data: {
         *     // ... data to create a Media
         *   }
         * })
         *
         **/
        create<T extends MediaCreateArgs>(
            args: SelectSubset<T, MediaCreateArgs>
        ): Prisma__MediaClient<MediaGetPayload<T>>

        /**
         * Create many Media.
         *     @param {MediaCreateManyArgs} args - Arguments to create many Media.
         *     @example
         *     // Create many Media
         *     const media = await prisma.media.createMany({
         *       data: {
         *         // ... provide data here
         *       }
         *     })
         *
         **/
        createMany<T extends MediaCreateManyArgs>(
            args?: SelectSubset<T, MediaCreateManyArgs>
        ): PrismaPromise<BatchPayload>

        /**
         * Delete a Media.
         * @param {MediaDeleteArgs} args - Arguments to delete one Media.
         * @example
         * // Delete one Media
         * const Media = await prisma.media.delete({
         *   where: {
         *     // ... filter to delete one Media
         *   }
         * })
         *
         **/
        delete<T extends MediaDeleteArgs>(
            args: SelectSubset<T, MediaDeleteArgs>
        ): Prisma__MediaClient<MediaGetPayload<T>>

        /**
         * Update one Media.
         * @param {MediaUpdateArgs} args - Arguments to update one Media.
         * @example
         * // Update one Media
         * const media = await prisma.media.update({
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: {
         *     // ... provide data here
         *   }
         * })
         *
         **/
        update<T extends MediaUpdateArgs>(
            args: SelectSubset<T, MediaUpdateArgs>
        ): Prisma__MediaClient<MediaGetPayload<T>>

        /**
         * Delete zero or more Media.
         * @param {MediaDeleteManyArgs} args - Arguments to filter Media to delete.
         * @example
         * // Delete a few Media
         * const { count } = await prisma.media.deleteMany({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         *
         **/
        deleteMany<T extends MediaDeleteManyArgs>(
            args?: SelectSubset<T, MediaDeleteManyArgs>
        ): PrismaPromise<BatchPayload>

        /**
         * Update zero or more Media.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {MediaUpdateManyArgs} args - Arguments to update one or more rows.
         * @example
         * // Update many Media
         * const media = await prisma.media.updateMany({
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: {
         *     // ... provide data here
         *   }
         * })
         *
         **/
        updateMany<T extends MediaUpdateManyArgs>(
            args: SelectSubset<T, MediaUpdateManyArgs>
        ): PrismaPromise<BatchPayload>

        /**
         * Create or update one Media.
         * @param {MediaUpsertArgs} args - Arguments to update or create a Media.
         * @example
         * // Update or create a Media
         * const media = await prisma.media.upsert({
         *   create: {
         *     // ... data to create a Media
         *   },
         *   update: {
         *     // ... in case it already exists, update
         *   },
         *   where: {
         *     // ... the filter for the Media we want to update
         *   }
         * })
         **/
        upsert<T extends MediaUpsertArgs>(
            args: SelectSubset<T, MediaUpsertArgs>
        ): Prisma__MediaClient<MediaGetPayload<T>>

        /**
         * Count the number of Media.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {MediaCountArgs} args - Arguments to filter Media to count.
         * @example
         * // Count the number of Media
         * const count = await prisma.media.count({
         *   where: {
         *     // ... the filter for the Media we want to count
         *   }
         * })
         **/
        count<T extends MediaCountArgs>(
            args?: Subset<T, MediaCountArgs>
        ): PrismaPromise<
            T extends _Record<'select', any>
                ? T['select'] extends true
                    ? number
                    : GetScalarType<T['select'], MediaCountAggregateOutputType>
                : number
        >

        /**
         * Allows you to perform aggregations operations on a Media.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {MediaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
         * @example
         * // Ordered by age ascending
         * // Where email contains prisma.io
         * // Limited to the 10 users
         * const aggregations = await prisma.user.aggregate({
         *   _avg: {
         *     age: true,
         *   },
         *   where: {
         *     email: {
         *       contains: "prisma.io",
         *     },
         *   },
         *   orderBy: {
         *     age: "asc",
         *   },
         *   take: 10,
         * })
         **/
        aggregate<T extends MediaAggregateArgs>(
            args: Subset<T, MediaAggregateArgs>
        ): PrismaPromise<GetMediaAggregateType<T>>

        /**
         * Group by Media.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {MediaGroupByArgs} args - Group by arguments.
         * @example
         * // Group by city, order by createdAt, get count
         * const result = await prisma.user.groupBy({
         *   by: ['city', 'createdAt'],
         *   orderBy: {
         *     createdAt: true
         *   },
         *   _count: {
         *     _all: true
         *   },
         * })
         *
         **/
        groupBy<
            T extends MediaGroupByArgs,
            HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
            OrderByArg extends True extends HasSelectOrTake
                ? { orderBy: MediaGroupByArgs['orderBy'] }
                : { orderBy?: MediaGroupByArgs['orderBy'] },
            OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
            ByFields extends TupleToUnion<T['by']>,
            ByValid extends Has<ByFields, OrderFields>,
            HavingFields extends GetHavingFields<T['having']>,
            HavingValid extends Has<ByFields, HavingFields>,
            ByEmpty extends T['by'] extends never[] ? True : False,
            InputErrors extends ByEmpty extends True
                ? `Error: "by" must not be empty.`
                : HavingValid extends False
                  ? {
                        [P in HavingFields]: P extends ByFields
                            ? never
                            : P extends string
                              ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                              : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`]
                    }[HavingFields]
                  : 'take' extends Keys<T>
                    ? 'orderBy' extends Keys<T>
                        ? ByValid extends True
                            ? {}
                            : {
                                  [P in OrderFields]: P extends ByFields
                                      ? never
                                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                              }[OrderFields]
                        : 'Error: If you provide "take", you also need to provide "orderBy"'
                    : 'skip' extends Keys<T>
                      ? 'orderBy' extends Keys<T>
                          ? ByValid extends True
                              ? {}
                              : {
                                    [P in OrderFields]: P extends ByFields
                                        ? never
                                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                                }[OrderFields]
                          : 'Error: If you provide "skip", you also need to provide "orderBy"'
                      : ByValid extends True
                        ? {}
                        : {
                              [P in OrderFields]: P extends ByFields
                                  ? never
                                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                          }[OrderFields]
        >(
            args: SubsetIntersection<T, MediaGroupByArgs, OrderByArg> & InputErrors
        ): {} extends InputErrors ? GetMediaGroupByPayload<T> : PrismaPromise<InputErrors>
    }

    /**
     * The delegate class that acts as a "Promise-like" for Media.
     * Why is this prefixed with `Prisma__`?
     * Because we want to prevent naming conflicts as mentioned in
     * https://github.com/prisma/prisma-client-js/issues/707
     */
    export class Prisma__MediaClient<T, Null = never> implements PrismaPromise<T> {
        [prisma]: true
        private readonly _dmmf
        private readonly _fetcher
        private readonly _queryType
        private readonly _rootField
        private readonly _clientMethod
        private readonly _args
        private readonly _dataPath
        private readonly _errorFormat
        private readonly _measurePerformance?
        private _isList
        private _callsite
        private _requestPromise?
        constructor(
            _dmmf: runtime.DMMFClass,
            _fetcher: PrismaClientFetcher,
            _queryType: 'query' | 'mutation',
            _rootField: string,
            _clientMethod: string,
            _args: any,
            _dataPath: string[],
            _errorFormat: ErrorFormat,
            _measurePerformance?: boolean | undefined,
            _isList?: boolean
        )
        readonly [Symbol.toStringTag]: 'PrismaClientPromise'

        private get _document()
        /**
         * Attaches callbacks for the resolution and/or rejection of the Promise.
         * @param onfulfilled The callback to execute when the Promise is resolved.
         * @param onrejected The callback to execute when the Promise is rejected.
         * @returns A Promise for the completion of which ever callback is executed.
         */
        then<TResult1 = T, TResult2 = never>(
            onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
            onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
        ): Promise<TResult1 | TResult2>
        /**
         * Attaches a callback for only the rejection of the Promise.
         * @param onrejected The callback to execute when the Promise is rejected.
         * @returns A Promise for the completion of the callback.
         */
        catch<TResult = never>(
            onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
        ): Promise<T | TResult>
        /**
         * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
         * resolved value cannot be modified from the callback.
         * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
         * @returns A Promise for the completion of the callback.
         */
        finally(onfinally?: (() => void) | undefined | null): Promise<T>
    }

    // Custom InputTypes

    /**
     * Media base type for findUnique actions
     */
    export type MediaFindUniqueArgsBase = {
        /**
         * Select specific fields to fetch from the Media
         *
         **/
        select?: MediaSelect | null
        /**
         * Filter, which Media to fetch.
         *
         **/
        where: MediaWhereUniqueInput
    }

    /**
     * Media findUnique
     */
    export interface MediaFindUniqueArgs extends MediaFindUniqueArgsBase {
        /**
         * Throw an Error if query returns no results
         * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
         */
        rejectOnNotFound?: RejectOnNotFound
    }

    /**
     * Media findUniqueOrThrow
     */
    export type MediaFindUniqueOrThrowArgs = {
        /**
         * Select specific fields to fetch from the Media
         *
         **/
        select?: MediaSelect | null
        /**
         * Filter, which Media to fetch.
         *
         **/
        where: MediaWhereUniqueInput
    }

    /**
     * Media base type for findFirst actions
     */
    export type MediaFindFirstArgsBase = {
        /**
         * Select specific fields to fetch from the Media
         *
         **/
        select?: MediaSelect | null
        /**
         * Filter, which Media to fetch.
         *
         **/
        where?: MediaWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Media to fetch.
         *
         **/
        orderBy?: Enumerable<MediaOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for searching for Media.
         *
         **/
        cursor?: MediaWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Media from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Media.
         *
         **/
        skip?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
         *
         * Filter by unique combinations of Media.
         *
         **/
        distinct?: Enumerable<MediaScalarFieldEnum>
    }

    /**
     * Media findFirst
     */
    export interface MediaFindFirstArgs extends MediaFindFirstArgsBase {
        /**
         * Throw an Error if query returns no results
         * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
         */
        rejectOnNotFound?: RejectOnNotFound
    }

    /**
     * Media findFirstOrThrow
     */
    export type MediaFindFirstOrThrowArgs = {
        /**
         * Select specific fields to fetch from the Media
         *
         **/
        select?: MediaSelect | null
        /**
         * Filter, which Media to fetch.
         *
         **/
        where?: MediaWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Media to fetch.
         *
         **/
        orderBy?: Enumerable<MediaOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for searching for Media.
         *
         **/
        cursor?: MediaWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Media from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Media.
         *
         **/
        skip?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
         *
         * Filter by unique combinations of Media.
         *
         **/
        distinct?: Enumerable<MediaScalarFieldEnum>
    }

    /**
     * Media findMany
     */
    export type MediaFindManyArgs = {
        /**
         * Select specific fields to fetch from the Media
         *
         **/
        select?: MediaSelect | null
        /**
         * Filter, which Media to fetch.
         *
         **/
        where?: MediaWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Media to fetch.
         *
         **/
        orderBy?: Enumerable<MediaOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for listing Media.
         *
         **/
        cursor?: MediaWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Media from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Media.
         *
         **/
        skip?: number
        distinct?: Enumerable<MediaScalarFieldEnum>
    }

    /**
     * Media create
     */
    export type MediaCreateArgs = {
        /**
         * Select specific fields to fetch from the Media
         *
         **/
        select?: MediaSelect | null
        /**
         * The data needed to create a Media.
         *
         **/
        data: XOR<MediaCreateInput, MediaUncheckedCreateInput>
    }

    /**
     * Media createMany
     */
    export type MediaCreateManyArgs = {
        /**
         * The data used to create many Media.
         *
         **/
        data: Enumerable<MediaCreateManyInput>
        skipDuplicates?: boolean
    }

    /**
     * Media update
     */
    export type MediaUpdateArgs = {
        /**
         * Select specific fields to fetch from the Media
         *
         **/
        select?: MediaSelect | null
        /**
         * The data needed to update a Media.
         *
         **/
        data: XOR<MediaUpdateInput, MediaUncheckedUpdateInput>
        /**
         * Choose, which Media to update.
         *
         **/
        where: MediaWhereUniqueInput
    }

    /**
     * Media updateMany
     */
    export type MediaUpdateManyArgs = {
        /**
         * The data used to update Media.
         *
         **/
        data: XOR<MediaUpdateManyMutationInput, MediaUncheckedUpdateManyInput>
        /**
         * Filter which Media to update
         *
         **/
        where?: MediaWhereInput
    }

    /**
     * Media upsert
     */
    export type MediaUpsertArgs = {
        /**
         * Select specific fields to fetch from the Media
         *
         **/
        select?: MediaSelect | null
        /**
         * The filter to search for the Media to update in case it exists.
         *
         **/
        where: MediaWhereUniqueInput
        /**
         * In case the Media found by the `where` argument doesn't exist, create a new Media with this data.
         *
         **/
        create: XOR<MediaCreateInput, MediaUncheckedCreateInput>
        /**
         * In case the Media was found with the provided `where` argument, update it with this data.
         *
         **/
        update: XOR<MediaUpdateInput, MediaUncheckedUpdateInput>
    }

    /**
     * Media delete
     */
    export type MediaDeleteArgs = {
        /**
         * Select specific fields to fetch from the Media
         *
         **/
        select?: MediaSelect | null
        /**
         * Filter which Media to delete.
         *
         **/
        where: MediaWhereUniqueInput
    }

    /**
     * Media deleteMany
     */
    export type MediaDeleteManyArgs = {
        /**
         * Filter which Media to delete
         *
         **/
        where?: MediaWhereInput
    }

    /**
     * Media without action
     */
    export type MediaArgs = {
        /**
         * Select specific fields to fetch from the Media
         *
         **/
        select?: MediaSelect | null
    }

    /**
     * Model Model_has_permissions
     */

    export type AggregateModel_has_permissions = {
        _count: Model_has_permissionsCountAggregateOutputType | null
        _min: Model_has_permissionsMinAggregateOutputType | null
        _max: Model_has_permissionsMaxAggregateOutputType | null
    }

    export type Model_has_permissionsMinAggregateOutputType = {
        permission_id: string | null
        model_type: string | null
        model_uuid: string | null
    }

    export type Model_has_permissionsMaxAggregateOutputType = {
        permission_id: string | null
        model_type: string | null
        model_uuid: string | null
    }

    export type Model_has_permissionsCountAggregateOutputType = {
        permission_id: number
        model_type: number
        model_uuid: number
        _all: number
    }

    export type Model_has_permissionsMinAggregateInputType = {
        permission_id?: true
        model_type?: true
        model_uuid?: true
    }

    export type Model_has_permissionsMaxAggregateInputType = {
        permission_id?: true
        model_type?: true
        model_uuid?: true
    }

    export type Model_has_permissionsCountAggregateInputType = {
        permission_id?: true
        model_type?: true
        model_uuid?: true
        _all?: true
    }

    export type Model_has_permissionsAggregateArgs = {
        /**
         * Filter which Model_has_permissions to aggregate.
         *
         **/
        where?: Model_has_permissionsWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Model_has_permissions to fetch.
         *
         **/
        orderBy?: Enumerable<Model_has_permissionsOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the start position
         *
         **/
        cursor?: Model_has_permissionsWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Model_has_permissions from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Model_has_permissions.
         *
         **/
        skip?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Count returned Model_has_permissions
         **/
        _count?: true | Model_has_permissionsCountAggregateInputType
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to find the minimum value
         **/
        _min?: Model_has_permissionsMinAggregateInputType
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to find the maximum value
         **/
        _max?: Model_has_permissionsMaxAggregateInputType
    }

    export type GetModel_has_permissionsAggregateType<T extends Model_has_permissionsAggregateArgs> = {
        [P in keyof T & keyof AggregateModel_has_permissions]: P extends '_count' | 'count'
            ? T[P] extends true
                ? number
                : GetScalarType<T[P], AggregateModel_has_permissions[P]>
            : GetScalarType<T[P], AggregateModel_has_permissions[P]>
    }

    export type Model_has_permissionsGroupByArgs = {
        where?: Model_has_permissionsWhereInput
        orderBy?: Enumerable<Model_has_permissionsOrderByWithAggregationInput>
        by: Array<Model_has_permissionsScalarFieldEnum>
        having?: Model_has_permissionsScalarWhereWithAggregatesInput
        take?: number
        skip?: number
        _count?: Model_has_permissionsCountAggregateInputType | true
        _min?: Model_has_permissionsMinAggregateInputType
        _max?: Model_has_permissionsMaxAggregateInputType
    }

    export type Model_has_permissionsGroupByOutputType = {
        permission_id: string
        model_type: string
        model_uuid: string
        _count: Model_has_permissionsCountAggregateOutputType | null
        _min: Model_has_permissionsMinAggregateOutputType | null
        _max: Model_has_permissionsMaxAggregateOutputType | null
    }

    type GetModel_has_permissionsGroupByPayload<T extends Model_has_permissionsGroupByArgs> = PrismaPromise<
        Array<
            PickArray<Model_has_permissionsGroupByOutputType, T['by']> & {
                [P in keyof T & keyof Model_has_permissionsGroupByOutputType]: P extends '_count'
                    ? T[P] extends boolean
                        ? number
                        : GetScalarType<T[P], Model_has_permissionsGroupByOutputType[P]>
                    : GetScalarType<T[P], Model_has_permissionsGroupByOutputType[P]>
            }
        >
    >

    export type Model_has_permissionsSelect = {
        permission_id?: boolean
        model_type?: boolean
        model_uuid?: boolean
        permissions?: boolean | PermissionsArgs
    }

    export type Model_has_permissionsInclude = {
        permissions?: boolean | PermissionsArgs
    }

    export type Model_has_permissionsGetPayload<S extends boolean | null | undefined | Model_has_permissionsArgs> =
        S extends { select: any; include: any }
            ? 'Please either choose `select` or `include`'
            : S extends true
              ? Model_has_permissions
              : S extends undefined
                ? never
                : S extends { include: any } & (Model_has_permissionsArgs | Model_has_permissionsFindManyArgs)
                  ? Model_has_permissions & {
                        [P in TruthyKeys<S['include']>]: P extends 'permissions'
                            ? PermissionsGetPayload<S['include'][P]>
                            : never
                    }
                  : S extends { select: any } & (Model_has_permissionsArgs | Model_has_permissionsFindManyArgs)
                    ? {
                          [P in TruthyKeys<S['select']>]: P extends 'permissions'
                              ? PermissionsGetPayload<S['select'][P]>
                              : P extends keyof Model_has_permissions
                                ? Model_has_permissions[P]
                                : never
                      }
                    : Model_has_permissions

    type Model_has_permissionsCountArgs = Merge<
        Omit<Model_has_permissionsFindManyArgs, 'select' | 'include'> & {
            select?: Model_has_permissionsCountAggregateInputType | true
        }
    >

    export interface Model_has_permissionsDelegate<
        GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined
    > {
        /**
         * Find zero or one Model_has_permissions that matches the filter.
         * @param {Model_has_permissionsFindUniqueArgs} args - Arguments to find a Model_has_permissions
         * @example
         * // Get one Model_has_permissions
         * const model_has_permissions = await prisma.model_has_permissions.findUnique({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findUnique<
            T extends Model_has_permissionsFindUniqueArgs,
            LocalRejectSettings = T['rejectOnNotFound'] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined
        >(
            args: SelectSubset<T, Model_has_permissionsFindUniqueArgs>
        ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Model_has_permissions'> extends True
            ? Prisma__Model_has_permissionsClient<Model_has_permissionsGetPayload<T>>
            : Prisma__Model_has_permissionsClient<Model_has_permissionsGetPayload<T> | null, null>

        /**
         * Find one Model_has_permissions that matches the filter or throw an error  with `error.code='P2025'`
         *     if no matches were found.
         * @param {Model_has_permissionsFindUniqueOrThrowArgs} args - Arguments to find a Model_has_permissions
         * @example
         * // Get one Model_has_permissions
         * const model_has_permissions = await prisma.model_has_permissions.findUniqueOrThrow({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findUniqueOrThrow<T extends Model_has_permissionsFindUniqueOrThrowArgs>(
            args?: SelectSubset<T, Model_has_permissionsFindUniqueOrThrowArgs>
        ): Prisma__Model_has_permissionsClient<Model_has_permissionsGetPayload<T>>

        /**
         * Find the first Model_has_permissions that matches the filter.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {Model_has_permissionsFindFirstArgs} args - Arguments to find a Model_has_permissions
         * @example
         * // Get one Model_has_permissions
         * const model_has_permissions = await prisma.model_has_permissions.findFirst({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findFirst<
            T extends Model_has_permissionsFindFirstArgs,
            LocalRejectSettings = T['rejectOnNotFound'] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined
        >(
            args?: SelectSubset<T, Model_has_permissionsFindFirstArgs>
        ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Model_has_permissions'> extends True
            ? Prisma__Model_has_permissionsClient<Model_has_permissionsGetPayload<T>>
            : Prisma__Model_has_permissionsClient<Model_has_permissionsGetPayload<T> | null, null>

        /**
         * Find the first Model_has_permissions that matches the filter or
         * throw `NotFoundError` if no matches were found.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {Model_has_permissionsFindFirstOrThrowArgs} args - Arguments to find a Model_has_permissions
         * @example
         * // Get one Model_has_permissions
         * const model_has_permissions = await prisma.model_has_permissions.findFirstOrThrow({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findFirstOrThrow<T extends Model_has_permissionsFindFirstOrThrowArgs>(
            args?: SelectSubset<T, Model_has_permissionsFindFirstOrThrowArgs>
        ): Prisma__Model_has_permissionsClient<Model_has_permissionsGetPayload<T>>

        /**
         * Find zero or more Model_has_permissions that matches the filter.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {Model_has_permissionsFindManyArgs=} args - Arguments to filter and select certain fields only.
         * @example
         * // Get all Model_has_permissions
         * const model_has_permissions = await prisma.model_has_permissions.findMany()
         *
         * // Get first 10 Model_has_permissions
         * const model_has_permissions = await prisma.model_has_permissions.findMany({ take: 10 })
         *
         * // Only select the `permission_id`
         * const model_has_permissionsWithPermission_idOnly = await prisma.model_has_permissions.findMany({ select: { permission_id: true } })
         *
         **/
        findMany<T extends Model_has_permissionsFindManyArgs>(
            args?: SelectSubset<T, Model_has_permissionsFindManyArgs>
        ): PrismaPromise<Array<Model_has_permissionsGetPayload<T>>>

        /**
         * Create a Model_has_permissions.
         * @param {Model_has_permissionsCreateArgs} args - Arguments to create a Model_has_permissions.
         * @example
         * // Create one Model_has_permissions
         * const Model_has_permissions = await prisma.model_has_permissions.create({
         *   data: {
         *     // ... data to create a Model_has_permissions
         *   }
         * })
         *
         **/
        create<T extends Model_has_permissionsCreateArgs>(
            args: SelectSubset<T, Model_has_permissionsCreateArgs>
        ): Prisma__Model_has_permissionsClient<Model_has_permissionsGetPayload<T>>

        /**
         * Create many Model_has_permissions.
         *     @param {Model_has_permissionsCreateManyArgs} args - Arguments to create many Model_has_permissions.
         *     @example
         *     // Create many Model_has_permissions
         *     const model_has_permissions = await prisma.model_has_permissions.createMany({
         *       data: {
         *         // ... provide data here
         *       }
         *     })
         *
         **/
        createMany<T extends Model_has_permissionsCreateManyArgs>(
            args?: SelectSubset<T, Model_has_permissionsCreateManyArgs>
        ): PrismaPromise<BatchPayload>

        /**
         * Delete a Model_has_permissions.
         * @param {Model_has_permissionsDeleteArgs} args - Arguments to delete one Model_has_permissions.
         * @example
         * // Delete one Model_has_permissions
         * const Model_has_permissions = await prisma.model_has_permissions.delete({
         *   where: {
         *     // ... filter to delete one Model_has_permissions
         *   }
         * })
         *
         **/
        delete<T extends Model_has_permissionsDeleteArgs>(
            args: SelectSubset<T, Model_has_permissionsDeleteArgs>
        ): Prisma__Model_has_permissionsClient<Model_has_permissionsGetPayload<T>>

        /**
         * Update one Model_has_permissions.
         * @param {Model_has_permissionsUpdateArgs} args - Arguments to update one Model_has_permissions.
         * @example
         * // Update one Model_has_permissions
         * const model_has_permissions = await prisma.model_has_permissions.update({
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: {
         *     // ... provide data here
         *   }
         * })
         *
         **/
        update<T extends Model_has_permissionsUpdateArgs>(
            args: SelectSubset<T, Model_has_permissionsUpdateArgs>
        ): Prisma__Model_has_permissionsClient<Model_has_permissionsGetPayload<T>>

        /**
         * Delete zero or more Model_has_permissions.
         * @param {Model_has_permissionsDeleteManyArgs} args - Arguments to filter Model_has_permissions to delete.
         * @example
         * // Delete a few Model_has_permissions
         * const { count } = await prisma.model_has_permissions.deleteMany({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         *
         **/
        deleteMany<T extends Model_has_permissionsDeleteManyArgs>(
            args?: SelectSubset<T, Model_has_permissionsDeleteManyArgs>
        ): PrismaPromise<BatchPayload>

        /**
         * Update zero or more Model_has_permissions.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {Model_has_permissionsUpdateManyArgs} args - Arguments to update one or more rows.
         * @example
         * // Update many Model_has_permissions
         * const model_has_permissions = await prisma.model_has_permissions.updateMany({
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: {
         *     // ... provide data here
         *   }
         * })
         *
         **/
        updateMany<T extends Model_has_permissionsUpdateManyArgs>(
            args: SelectSubset<T, Model_has_permissionsUpdateManyArgs>
        ): PrismaPromise<BatchPayload>

        /**
         * Create or update one Model_has_permissions.
         * @param {Model_has_permissionsUpsertArgs} args - Arguments to update or create a Model_has_permissions.
         * @example
         * // Update or create a Model_has_permissions
         * const model_has_permissions = await prisma.model_has_permissions.upsert({
         *   create: {
         *     // ... data to create a Model_has_permissions
         *   },
         *   update: {
         *     // ... in case it already exists, update
         *   },
         *   where: {
         *     // ... the filter for the Model_has_permissions we want to update
         *   }
         * })
         **/
        upsert<T extends Model_has_permissionsUpsertArgs>(
            args: SelectSubset<T, Model_has_permissionsUpsertArgs>
        ): Prisma__Model_has_permissionsClient<Model_has_permissionsGetPayload<T>>

        /**
         * Count the number of Model_has_permissions.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {Model_has_permissionsCountArgs} args - Arguments to filter Model_has_permissions to count.
         * @example
         * // Count the number of Model_has_permissions
         * const count = await prisma.model_has_permissions.count({
         *   where: {
         *     // ... the filter for the Model_has_permissions we want to count
         *   }
         * })
         **/
        count<T extends Model_has_permissionsCountArgs>(
            args?: Subset<T, Model_has_permissionsCountArgs>
        ): PrismaPromise<
            T extends _Record<'select', any>
                ? T['select'] extends true
                    ? number
                    : GetScalarType<T['select'], Model_has_permissionsCountAggregateOutputType>
                : number
        >

        /**
         * Allows you to perform aggregations operations on a Model_has_permissions.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {Model_has_permissionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
         * @example
         * // Ordered by age ascending
         * // Where email contains prisma.io
         * // Limited to the 10 users
         * const aggregations = await prisma.user.aggregate({
         *   _avg: {
         *     age: true,
         *   },
         *   where: {
         *     email: {
         *       contains: "prisma.io",
         *     },
         *   },
         *   orderBy: {
         *     age: "asc",
         *   },
         *   take: 10,
         * })
         **/
        aggregate<T extends Model_has_permissionsAggregateArgs>(
            args: Subset<T, Model_has_permissionsAggregateArgs>
        ): PrismaPromise<GetModel_has_permissionsAggregateType<T>>

        /**
         * Group by Model_has_permissions.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {Model_has_permissionsGroupByArgs} args - Group by arguments.
         * @example
         * // Group by city, order by createdAt, get count
         * const result = await prisma.user.groupBy({
         *   by: ['city', 'createdAt'],
         *   orderBy: {
         *     createdAt: true
         *   },
         *   _count: {
         *     _all: true
         *   },
         * })
         *
         **/
        groupBy<
            T extends Model_has_permissionsGroupByArgs,
            HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
            OrderByArg extends True extends HasSelectOrTake
                ? { orderBy: Model_has_permissionsGroupByArgs['orderBy'] }
                : { orderBy?: Model_has_permissionsGroupByArgs['orderBy'] },
            OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
            ByFields extends TupleToUnion<T['by']>,
            ByValid extends Has<ByFields, OrderFields>,
            HavingFields extends GetHavingFields<T['having']>,
            HavingValid extends Has<ByFields, HavingFields>,
            ByEmpty extends T['by'] extends never[] ? True : False,
            InputErrors extends ByEmpty extends True
                ? `Error: "by" must not be empty.`
                : HavingValid extends False
                  ? {
                        [P in HavingFields]: P extends ByFields
                            ? never
                            : P extends string
                              ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                              : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`]
                    }[HavingFields]
                  : 'take' extends Keys<T>
                    ? 'orderBy' extends Keys<T>
                        ? ByValid extends True
                            ? {}
                            : {
                                  [P in OrderFields]: P extends ByFields
                                      ? never
                                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                              }[OrderFields]
                        : 'Error: If you provide "take", you also need to provide "orderBy"'
                    : 'skip' extends Keys<T>
                      ? 'orderBy' extends Keys<T>
                          ? ByValid extends True
                              ? {}
                              : {
                                    [P in OrderFields]: P extends ByFields
                                        ? never
                                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                                }[OrderFields]
                          : 'Error: If you provide "skip", you also need to provide "orderBy"'
                      : ByValid extends True
                        ? {}
                        : {
                              [P in OrderFields]: P extends ByFields
                                  ? never
                                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                          }[OrderFields]
        >(
            args: SubsetIntersection<T, Model_has_permissionsGroupByArgs, OrderByArg> & InputErrors
        ): {} extends InputErrors ? GetModel_has_permissionsGroupByPayload<T> : PrismaPromise<InputErrors>
    }

    /**
     * The delegate class that acts as a "Promise-like" for Model_has_permissions.
     * Why is this prefixed with `Prisma__`?
     * Because we want to prevent naming conflicts as mentioned in
     * https://github.com/prisma/prisma-client-js/issues/707
     */
    export class Prisma__Model_has_permissionsClient<T, Null = never> implements PrismaPromise<T> {
        [prisma]: true
        private readonly _dmmf
        private readonly _fetcher
        private readonly _queryType
        private readonly _rootField
        private readonly _clientMethod
        private readonly _args
        private readonly _dataPath
        private readonly _errorFormat
        private readonly _measurePerformance?
        private _isList
        private _callsite
        private _requestPromise?
        constructor(
            _dmmf: runtime.DMMFClass,
            _fetcher: PrismaClientFetcher,
            _queryType: 'query' | 'mutation',
            _rootField: string,
            _clientMethod: string,
            _args: any,
            _dataPath: string[],
            _errorFormat: ErrorFormat,
            _measurePerformance?: boolean | undefined,
            _isList?: boolean
        )
        readonly [Symbol.toStringTag]: 'PrismaClientPromise'

        permissions<T extends PermissionsArgs = {}>(
            args?: Subset<T, PermissionsArgs>
        ): Prisma__PermissionsClient<PermissionsGetPayload<T> | Null>

        private get _document()
        /**
         * Attaches callbacks for the resolution and/or rejection of the Promise.
         * @param onfulfilled The callback to execute when the Promise is resolved.
         * @param onrejected The callback to execute when the Promise is rejected.
         * @returns A Promise for the completion of which ever callback is executed.
         */
        then<TResult1 = T, TResult2 = never>(
            onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
            onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
        ): Promise<TResult1 | TResult2>
        /**
         * Attaches a callback for only the rejection of the Promise.
         * @param onrejected The callback to execute when the Promise is rejected.
         * @returns A Promise for the completion of the callback.
         */
        catch<TResult = never>(
            onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
        ): Promise<T | TResult>
        /**
         * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
         * resolved value cannot be modified from the callback.
         * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
         * @returns A Promise for the completion of the callback.
         */
        finally(onfinally?: (() => void) | undefined | null): Promise<T>
    }

    // Custom InputTypes

    /**
     * Model_has_permissions base type for findUnique actions
     */
    export type Model_has_permissionsFindUniqueArgsBase = {
        /**
         * Select specific fields to fetch from the Model_has_permissions
         *
         **/
        select?: Model_has_permissionsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Model_has_permissionsInclude | null
        /**
         * Filter, which Model_has_permissions to fetch.
         *
         **/
        where: Model_has_permissionsWhereUniqueInput
    }

    /**
     * Model_has_permissions findUnique
     */
    export interface Model_has_permissionsFindUniqueArgs extends Model_has_permissionsFindUniqueArgsBase {
        /**
         * Throw an Error if query returns no results
         * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
         */
        rejectOnNotFound?: RejectOnNotFound
    }

    /**
     * Model_has_permissions findUniqueOrThrow
     */
    export type Model_has_permissionsFindUniqueOrThrowArgs = {
        /**
         * Select specific fields to fetch from the Model_has_permissions
         *
         **/
        select?: Model_has_permissionsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Model_has_permissionsInclude | null
        /**
         * Filter, which Model_has_permissions to fetch.
         *
         **/
        where: Model_has_permissionsWhereUniqueInput
    }

    /**
     * Model_has_permissions base type for findFirst actions
     */
    export type Model_has_permissionsFindFirstArgsBase = {
        /**
         * Select specific fields to fetch from the Model_has_permissions
         *
         **/
        select?: Model_has_permissionsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Model_has_permissionsInclude | null
        /**
         * Filter, which Model_has_permissions to fetch.
         *
         **/
        where?: Model_has_permissionsWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Model_has_permissions to fetch.
         *
         **/
        orderBy?: Enumerable<Model_has_permissionsOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for searching for Model_has_permissions.
         *
         **/
        cursor?: Model_has_permissionsWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Model_has_permissions from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Model_has_permissions.
         *
         **/
        skip?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
         *
         * Filter by unique combinations of Model_has_permissions.
         *
         **/
        distinct?: Enumerable<Model_has_permissionsScalarFieldEnum>
    }

    /**
     * Model_has_permissions findFirst
     */
    export interface Model_has_permissionsFindFirstArgs extends Model_has_permissionsFindFirstArgsBase {
        /**
         * Throw an Error if query returns no results
         * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
         */
        rejectOnNotFound?: RejectOnNotFound
    }

    /**
     * Model_has_permissions findFirstOrThrow
     */
    export type Model_has_permissionsFindFirstOrThrowArgs = {
        /**
         * Select specific fields to fetch from the Model_has_permissions
         *
         **/
        select?: Model_has_permissionsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Model_has_permissionsInclude | null
        /**
         * Filter, which Model_has_permissions to fetch.
         *
         **/
        where?: Model_has_permissionsWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Model_has_permissions to fetch.
         *
         **/
        orderBy?: Enumerable<Model_has_permissionsOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for searching for Model_has_permissions.
         *
         **/
        cursor?: Model_has_permissionsWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Model_has_permissions from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Model_has_permissions.
         *
         **/
        skip?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
         *
         * Filter by unique combinations of Model_has_permissions.
         *
         **/
        distinct?: Enumerable<Model_has_permissionsScalarFieldEnum>
    }

    /**
     * Model_has_permissions findMany
     */
    export type Model_has_permissionsFindManyArgs = {
        /**
         * Select specific fields to fetch from the Model_has_permissions
         *
         **/
        select?: Model_has_permissionsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Model_has_permissionsInclude | null
        /**
         * Filter, which Model_has_permissions to fetch.
         *
         **/
        where?: Model_has_permissionsWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Model_has_permissions to fetch.
         *
         **/
        orderBy?: Enumerable<Model_has_permissionsOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for listing Model_has_permissions.
         *
         **/
        cursor?: Model_has_permissionsWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Model_has_permissions from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Model_has_permissions.
         *
         **/
        skip?: number
        distinct?: Enumerable<Model_has_permissionsScalarFieldEnum>
    }

    /**
     * Model_has_permissions create
     */
    export type Model_has_permissionsCreateArgs = {
        /**
         * Select specific fields to fetch from the Model_has_permissions
         *
         **/
        select?: Model_has_permissionsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Model_has_permissionsInclude | null
        /**
         * The data needed to create a Model_has_permissions.
         *
         **/
        data: XOR<Model_has_permissionsCreateInput, Model_has_permissionsUncheckedCreateInput>
    }

    /**
     * Model_has_permissions createMany
     */
    export type Model_has_permissionsCreateManyArgs = {
        /**
         * The data used to create many Model_has_permissions.
         *
         **/
        data: Enumerable<Model_has_permissionsCreateManyInput>
        skipDuplicates?: boolean
    }

    /**
     * Model_has_permissions update
     */
    export type Model_has_permissionsUpdateArgs = {
        /**
         * Select specific fields to fetch from the Model_has_permissions
         *
         **/
        select?: Model_has_permissionsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Model_has_permissionsInclude | null
        /**
         * The data needed to update a Model_has_permissions.
         *
         **/
        data: XOR<Model_has_permissionsUpdateInput, Model_has_permissionsUncheckedUpdateInput>
        /**
         * Choose, which Model_has_permissions to update.
         *
         **/
        where: Model_has_permissionsWhereUniqueInput
    }

    /**
     * Model_has_permissions updateMany
     */
    export type Model_has_permissionsUpdateManyArgs = {
        /**
         * The data used to update Model_has_permissions.
         *
         **/
        data: XOR<Model_has_permissionsUpdateManyMutationInput, Model_has_permissionsUncheckedUpdateManyInput>
        /**
         * Filter which Model_has_permissions to update
         *
         **/
        where?: Model_has_permissionsWhereInput
    }

    /**
     * Model_has_permissions upsert
     */
    export type Model_has_permissionsUpsertArgs = {
        /**
         * Select specific fields to fetch from the Model_has_permissions
         *
         **/
        select?: Model_has_permissionsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Model_has_permissionsInclude | null
        /**
         * The filter to search for the Model_has_permissions to update in case it exists.
         *
         **/
        where: Model_has_permissionsWhereUniqueInput
        /**
         * In case the Model_has_permissions found by the `where` argument doesn't exist, create a new Model_has_permissions with this data.
         *
         **/
        create: XOR<Model_has_permissionsCreateInput, Model_has_permissionsUncheckedCreateInput>
        /**
         * In case the Model_has_permissions was found with the provided `where` argument, update it with this data.
         *
         **/
        update: XOR<Model_has_permissionsUpdateInput, Model_has_permissionsUncheckedUpdateInput>
    }

    /**
     * Model_has_permissions delete
     */
    export type Model_has_permissionsDeleteArgs = {
        /**
         * Select specific fields to fetch from the Model_has_permissions
         *
         **/
        select?: Model_has_permissionsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Model_has_permissionsInclude | null
        /**
         * Filter which Model_has_permissions to delete.
         *
         **/
        where: Model_has_permissionsWhereUniqueInput
    }

    /**
     * Model_has_permissions deleteMany
     */
    export type Model_has_permissionsDeleteManyArgs = {
        /**
         * Filter which Model_has_permissions to delete
         *
         **/
        where?: Model_has_permissionsWhereInput
    }

    /**
     * Model_has_permissions without action
     */
    export type Model_has_permissionsArgs = {
        /**
         * Select specific fields to fetch from the Model_has_permissions
         *
         **/
        select?: Model_has_permissionsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Model_has_permissionsInclude | null
    }

    /**
     * Model Model_has_roles
     */

    export type AggregateModel_has_roles = {
        _count: Model_has_rolesCountAggregateOutputType | null
        _min: Model_has_rolesMinAggregateOutputType | null
        _max: Model_has_rolesMaxAggregateOutputType | null
    }

    export type Model_has_rolesMinAggregateOutputType = {
        role_id: string | null
        model_type: string | null
        model_uuid: string | null
    }

    export type Model_has_rolesMaxAggregateOutputType = {
        role_id: string | null
        model_type: string | null
        model_uuid: string | null
    }

    export type Model_has_rolesCountAggregateOutputType = {
        role_id: number
        model_type: number
        model_uuid: number
        _all: number
    }

    export type Model_has_rolesMinAggregateInputType = {
        role_id?: true
        model_type?: true
        model_uuid?: true
    }

    export type Model_has_rolesMaxAggregateInputType = {
        role_id?: true
        model_type?: true
        model_uuid?: true
    }

    export type Model_has_rolesCountAggregateInputType = {
        role_id?: true
        model_type?: true
        model_uuid?: true
        _all?: true
    }

    export type Model_has_rolesAggregateArgs = {
        /**
         * Filter which Model_has_roles to aggregate.
         *
         **/
        where?: Model_has_rolesWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Model_has_roles to fetch.
         *
         **/
        orderBy?: Enumerable<Model_has_rolesOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the start position
         *
         **/
        cursor?: Model_has_rolesWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Model_has_roles from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Model_has_roles.
         *
         **/
        skip?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Count returned Model_has_roles
         **/
        _count?: true | Model_has_rolesCountAggregateInputType
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to find the minimum value
         **/
        _min?: Model_has_rolesMinAggregateInputType
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to find the maximum value
         **/
        _max?: Model_has_rolesMaxAggregateInputType
    }

    export type GetModel_has_rolesAggregateType<T extends Model_has_rolesAggregateArgs> = {
        [P in keyof T & keyof AggregateModel_has_roles]: P extends '_count' | 'count'
            ? T[P] extends true
                ? number
                : GetScalarType<T[P], AggregateModel_has_roles[P]>
            : GetScalarType<T[P], AggregateModel_has_roles[P]>
    }

    export type Model_has_rolesGroupByArgs = {
        where?: Model_has_rolesWhereInput
        orderBy?: Enumerable<Model_has_rolesOrderByWithAggregationInput>
        by: Array<Model_has_rolesScalarFieldEnum>
        having?: Model_has_rolesScalarWhereWithAggregatesInput
        take?: number
        skip?: number
        _count?: Model_has_rolesCountAggregateInputType | true
        _min?: Model_has_rolesMinAggregateInputType
        _max?: Model_has_rolesMaxAggregateInputType
    }

    export type Model_has_rolesGroupByOutputType = {
        role_id: string
        model_type: string
        model_uuid: string
        _count: Model_has_rolesCountAggregateOutputType | null
        _min: Model_has_rolesMinAggregateOutputType | null
        _max: Model_has_rolesMaxAggregateOutputType | null
    }

    type GetModel_has_rolesGroupByPayload<T extends Model_has_rolesGroupByArgs> = PrismaPromise<
        Array<
            PickArray<Model_has_rolesGroupByOutputType, T['by']> & {
                [P in keyof T & keyof Model_has_rolesGroupByOutputType]: P extends '_count'
                    ? T[P] extends boolean
                        ? number
                        : GetScalarType<T[P], Model_has_rolesGroupByOutputType[P]>
                    : GetScalarType<T[P], Model_has_rolesGroupByOutputType[P]>
            }
        >
    >

    export type Model_has_rolesSelect = {
        role_id?: boolean
        model_type?: boolean
        model_uuid?: boolean
        roles?: boolean | RolesArgs
    }

    export type Model_has_rolesInclude = {
        roles?: boolean | RolesArgs
    }

    export type Model_has_rolesGetPayload<S extends boolean | null | undefined | Model_has_rolesArgs> = S extends {
        select: any
        include: any
    }
        ? 'Please either choose `select` or `include`'
        : S extends true
          ? Model_has_roles
          : S extends undefined
            ? never
            : S extends { include: any } & (Model_has_rolesArgs | Model_has_rolesFindManyArgs)
              ? Model_has_roles & {
                    [P in TruthyKeys<S['include']>]: P extends 'roles' ? RolesGetPayload<S['include'][P]> : never
                }
              : S extends { select: any } & (Model_has_rolesArgs | Model_has_rolesFindManyArgs)
                ? {
                      [P in TruthyKeys<S['select']>]: P extends 'roles'
                          ? RolesGetPayload<S['select'][P]>
                          : P extends keyof Model_has_roles
                            ? Model_has_roles[P]
                            : never
                  }
                : Model_has_roles

    type Model_has_rolesCountArgs = Merge<
        Omit<Model_has_rolesFindManyArgs, 'select' | 'include'> & {
            select?: Model_has_rolesCountAggregateInputType | true
        }
    >

    export interface Model_has_rolesDelegate<
        GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined
    > {
        /**
         * Find zero or one Model_has_roles that matches the filter.
         * @param {Model_has_rolesFindUniqueArgs} args - Arguments to find a Model_has_roles
         * @example
         * // Get one Model_has_roles
         * const model_has_roles = await prisma.model_has_roles.findUnique({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findUnique<
            T extends Model_has_rolesFindUniqueArgs,
            LocalRejectSettings = T['rejectOnNotFound'] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined
        >(
            args: SelectSubset<T, Model_has_rolesFindUniqueArgs>
        ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Model_has_roles'> extends True
            ? Prisma__Model_has_rolesClient<Model_has_rolesGetPayload<T>>
            : Prisma__Model_has_rolesClient<Model_has_rolesGetPayload<T> | null, null>

        /**
         * Find one Model_has_roles that matches the filter or throw an error  with `error.code='P2025'`
         *     if no matches were found.
         * @param {Model_has_rolesFindUniqueOrThrowArgs} args - Arguments to find a Model_has_roles
         * @example
         * // Get one Model_has_roles
         * const model_has_roles = await prisma.model_has_roles.findUniqueOrThrow({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findUniqueOrThrow<T extends Model_has_rolesFindUniqueOrThrowArgs>(
            args?: SelectSubset<T, Model_has_rolesFindUniqueOrThrowArgs>
        ): Prisma__Model_has_rolesClient<Model_has_rolesGetPayload<T>>

        /**
         * Find the first Model_has_roles that matches the filter.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {Model_has_rolesFindFirstArgs} args - Arguments to find a Model_has_roles
         * @example
         * // Get one Model_has_roles
         * const model_has_roles = await prisma.model_has_roles.findFirst({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findFirst<
            T extends Model_has_rolesFindFirstArgs,
            LocalRejectSettings = T['rejectOnNotFound'] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined
        >(
            args?: SelectSubset<T, Model_has_rolesFindFirstArgs>
        ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Model_has_roles'> extends True
            ? Prisma__Model_has_rolesClient<Model_has_rolesGetPayload<T>>
            : Prisma__Model_has_rolesClient<Model_has_rolesGetPayload<T> | null, null>

        /**
         * Find the first Model_has_roles that matches the filter or
         * throw `NotFoundError` if no matches were found.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {Model_has_rolesFindFirstOrThrowArgs} args - Arguments to find a Model_has_roles
         * @example
         * // Get one Model_has_roles
         * const model_has_roles = await prisma.model_has_roles.findFirstOrThrow({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findFirstOrThrow<T extends Model_has_rolesFindFirstOrThrowArgs>(
            args?: SelectSubset<T, Model_has_rolesFindFirstOrThrowArgs>
        ): Prisma__Model_has_rolesClient<Model_has_rolesGetPayload<T>>

        /**
         * Find zero or more Model_has_roles that matches the filter.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {Model_has_rolesFindManyArgs=} args - Arguments to filter and select certain fields only.
         * @example
         * // Get all Model_has_roles
         * const model_has_roles = await prisma.model_has_roles.findMany()
         *
         * // Get first 10 Model_has_roles
         * const model_has_roles = await prisma.model_has_roles.findMany({ take: 10 })
         *
         * // Only select the `role_id`
         * const model_has_rolesWithRole_idOnly = await prisma.model_has_roles.findMany({ select: { role_id: true } })
         *
         **/
        findMany<T extends Model_has_rolesFindManyArgs>(
            args?: SelectSubset<T, Model_has_rolesFindManyArgs>
        ): PrismaPromise<Array<Model_has_rolesGetPayload<T>>>

        /**
         * Create a Model_has_roles.
         * @param {Model_has_rolesCreateArgs} args - Arguments to create a Model_has_roles.
         * @example
         * // Create one Model_has_roles
         * const Model_has_roles = await prisma.model_has_roles.create({
         *   data: {
         *     // ... data to create a Model_has_roles
         *   }
         * })
         *
         **/
        create<T extends Model_has_rolesCreateArgs>(
            args: SelectSubset<T, Model_has_rolesCreateArgs>
        ): Prisma__Model_has_rolesClient<Model_has_rolesGetPayload<T>>

        /**
         * Create many Model_has_roles.
         *     @param {Model_has_rolesCreateManyArgs} args - Arguments to create many Model_has_roles.
         *     @example
         *     // Create many Model_has_roles
         *     const model_has_roles = await prisma.model_has_roles.createMany({
         *       data: {
         *         // ... provide data here
         *       }
         *     })
         *
         **/
        createMany<T extends Model_has_rolesCreateManyArgs>(
            args?: SelectSubset<T, Model_has_rolesCreateManyArgs>
        ): PrismaPromise<BatchPayload>

        /**
         * Delete a Model_has_roles.
         * @param {Model_has_rolesDeleteArgs} args - Arguments to delete one Model_has_roles.
         * @example
         * // Delete one Model_has_roles
         * const Model_has_roles = await prisma.model_has_roles.delete({
         *   where: {
         *     // ... filter to delete one Model_has_roles
         *   }
         * })
         *
         **/
        delete<T extends Model_has_rolesDeleteArgs>(
            args: SelectSubset<T, Model_has_rolesDeleteArgs>
        ): Prisma__Model_has_rolesClient<Model_has_rolesGetPayload<T>>

        /**
         * Update one Model_has_roles.
         * @param {Model_has_rolesUpdateArgs} args - Arguments to update one Model_has_roles.
         * @example
         * // Update one Model_has_roles
         * const model_has_roles = await prisma.model_has_roles.update({
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: {
         *     // ... provide data here
         *   }
         * })
         *
         **/
        update<T extends Model_has_rolesUpdateArgs>(
            args: SelectSubset<T, Model_has_rolesUpdateArgs>
        ): Prisma__Model_has_rolesClient<Model_has_rolesGetPayload<T>>

        /**
         * Delete zero or more Model_has_roles.
         * @param {Model_has_rolesDeleteManyArgs} args - Arguments to filter Model_has_roles to delete.
         * @example
         * // Delete a few Model_has_roles
         * const { count } = await prisma.model_has_roles.deleteMany({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         *
         **/
        deleteMany<T extends Model_has_rolesDeleteManyArgs>(
            args?: SelectSubset<T, Model_has_rolesDeleteManyArgs>
        ): PrismaPromise<BatchPayload>

        /**
         * Update zero or more Model_has_roles.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {Model_has_rolesUpdateManyArgs} args - Arguments to update one or more rows.
         * @example
         * // Update many Model_has_roles
         * const model_has_roles = await prisma.model_has_roles.updateMany({
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: {
         *     // ... provide data here
         *   }
         * })
         *
         **/
        updateMany<T extends Model_has_rolesUpdateManyArgs>(
            args: SelectSubset<T, Model_has_rolesUpdateManyArgs>
        ): PrismaPromise<BatchPayload>

        /**
         * Create or update one Model_has_roles.
         * @param {Model_has_rolesUpsertArgs} args - Arguments to update or create a Model_has_roles.
         * @example
         * // Update or create a Model_has_roles
         * const model_has_roles = await prisma.model_has_roles.upsert({
         *   create: {
         *     // ... data to create a Model_has_roles
         *   },
         *   update: {
         *     // ... in case it already exists, update
         *   },
         *   where: {
         *     // ... the filter for the Model_has_roles we want to update
         *   }
         * })
         **/
        upsert<T extends Model_has_rolesUpsertArgs>(
            args: SelectSubset<T, Model_has_rolesUpsertArgs>
        ): Prisma__Model_has_rolesClient<Model_has_rolesGetPayload<T>>

        /**
         * Count the number of Model_has_roles.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {Model_has_rolesCountArgs} args - Arguments to filter Model_has_roles to count.
         * @example
         * // Count the number of Model_has_roles
         * const count = await prisma.model_has_roles.count({
         *   where: {
         *     // ... the filter for the Model_has_roles we want to count
         *   }
         * })
         **/
        count<T extends Model_has_rolesCountArgs>(
            args?: Subset<T, Model_has_rolesCountArgs>
        ): PrismaPromise<
            T extends _Record<'select', any>
                ? T['select'] extends true
                    ? number
                    : GetScalarType<T['select'], Model_has_rolesCountAggregateOutputType>
                : number
        >

        /**
         * Allows you to perform aggregations operations on a Model_has_roles.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {Model_has_rolesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
         * @example
         * // Ordered by age ascending
         * // Where email contains prisma.io
         * // Limited to the 10 users
         * const aggregations = await prisma.user.aggregate({
         *   _avg: {
         *     age: true,
         *   },
         *   where: {
         *     email: {
         *       contains: "prisma.io",
         *     },
         *   },
         *   orderBy: {
         *     age: "asc",
         *   },
         *   take: 10,
         * })
         **/
        aggregate<T extends Model_has_rolesAggregateArgs>(
            args: Subset<T, Model_has_rolesAggregateArgs>
        ): PrismaPromise<GetModel_has_rolesAggregateType<T>>

        /**
         * Group by Model_has_roles.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {Model_has_rolesGroupByArgs} args - Group by arguments.
         * @example
         * // Group by city, order by createdAt, get count
         * const result = await prisma.user.groupBy({
         *   by: ['city', 'createdAt'],
         *   orderBy: {
         *     createdAt: true
         *   },
         *   _count: {
         *     _all: true
         *   },
         * })
         *
         **/
        groupBy<
            T extends Model_has_rolesGroupByArgs,
            HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
            OrderByArg extends True extends HasSelectOrTake
                ? { orderBy: Model_has_rolesGroupByArgs['orderBy'] }
                : { orderBy?: Model_has_rolesGroupByArgs['orderBy'] },
            OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
            ByFields extends TupleToUnion<T['by']>,
            ByValid extends Has<ByFields, OrderFields>,
            HavingFields extends GetHavingFields<T['having']>,
            HavingValid extends Has<ByFields, HavingFields>,
            ByEmpty extends T['by'] extends never[] ? True : False,
            InputErrors extends ByEmpty extends True
                ? `Error: "by" must not be empty.`
                : HavingValid extends False
                  ? {
                        [P in HavingFields]: P extends ByFields
                            ? never
                            : P extends string
                              ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                              : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`]
                    }[HavingFields]
                  : 'take' extends Keys<T>
                    ? 'orderBy' extends Keys<T>
                        ? ByValid extends True
                            ? {}
                            : {
                                  [P in OrderFields]: P extends ByFields
                                      ? never
                                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                              }[OrderFields]
                        : 'Error: If you provide "take", you also need to provide "orderBy"'
                    : 'skip' extends Keys<T>
                      ? 'orderBy' extends Keys<T>
                          ? ByValid extends True
                              ? {}
                              : {
                                    [P in OrderFields]: P extends ByFields
                                        ? never
                                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                                }[OrderFields]
                          : 'Error: If you provide "skip", you also need to provide "orderBy"'
                      : ByValid extends True
                        ? {}
                        : {
                              [P in OrderFields]: P extends ByFields
                                  ? never
                                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                          }[OrderFields]
        >(
            args: SubsetIntersection<T, Model_has_rolesGroupByArgs, OrderByArg> & InputErrors
        ): {} extends InputErrors ? GetModel_has_rolesGroupByPayload<T> : PrismaPromise<InputErrors>
    }

    /**
     * The delegate class that acts as a "Promise-like" for Model_has_roles.
     * Why is this prefixed with `Prisma__`?
     * Because we want to prevent naming conflicts as mentioned in
     * https://github.com/prisma/prisma-client-js/issues/707
     */
    export class Prisma__Model_has_rolesClient<T, Null = never> implements PrismaPromise<T> {
        [prisma]: true
        private readonly _dmmf
        private readonly _fetcher
        private readonly _queryType
        private readonly _rootField
        private readonly _clientMethod
        private readonly _args
        private readonly _dataPath
        private readonly _errorFormat
        private readonly _measurePerformance?
        private _isList
        private _callsite
        private _requestPromise?
        constructor(
            _dmmf: runtime.DMMFClass,
            _fetcher: PrismaClientFetcher,
            _queryType: 'query' | 'mutation',
            _rootField: string,
            _clientMethod: string,
            _args: any,
            _dataPath: string[],
            _errorFormat: ErrorFormat,
            _measurePerformance?: boolean | undefined,
            _isList?: boolean
        )
        readonly [Symbol.toStringTag]: 'PrismaClientPromise'

        roles<T extends RolesArgs = {}>(args?: Subset<T, RolesArgs>): Prisma__RolesClient<RolesGetPayload<T> | Null>

        private get _document()
        /**
         * Attaches callbacks for the resolution and/or rejection of the Promise.
         * @param onfulfilled The callback to execute when the Promise is resolved.
         * @param onrejected The callback to execute when the Promise is rejected.
         * @returns A Promise for the completion of which ever callback is executed.
         */
        then<TResult1 = T, TResult2 = never>(
            onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
            onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
        ): Promise<TResult1 | TResult2>
        /**
         * Attaches a callback for only the rejection of the Promise.
         * @param onrejected The callback to execute when the Promise is rejected.
         * @returns A Promise for the completion of the callback.
         */
        catch<TResult = never>(
            onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
        ): Promise<T | TResult>
        /**
         * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
         * resolved value cannot be modified from the callback.
         * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
         * @returns A Promise for the completion of the callback.
         */
        finally(onfinally?: (() => void) | undefined | null): Promise<T>
    }

    // Custom InputTypes

    /**
     * Model_has_roles base type for findUnique actions
     */
    export type Model_has_rolesFindUniqueArgsBase = {
        /**
         * Select specific fields to fetch from the Model_has_roles
         *
         **/
        select?: Model_has_rolesSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Model_has_rolesInclude | null
        /**
         * Filter, which Model_has_roles to fetch.
         *
         **/
        where: Model_has_rolesWhereUniqueInput
    }

    /**
     * Model_has_roles findUnique
     */
    export interface Model_has_rolesFindUniqueArgs extends Model_has_rolesFindUniqueArgsBase {
        /**
         * Throw an Error if query returns no results
         * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
         */
        rejectOnNotFound?: RejectOnNotFound
    }

    /**
     * Model_has_roles findUniqueOrThrow
     */
    export type Model_has_rolesFindUniqueOrThrowArgs = {
        /**
         * Select specific fields to fetch from the Model_has_roles
         *
         **/
        select?: Model_has_rolesSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Model_has_rolesInclude | null
        /**
         * Filter, which Model_has_roles to fetch.
         *
         **/
        where: Model_has_rolesWhereUniqueInput
    }

    /**
     * Model_has_roles base type for findFirst actions
     */
    export type Model_has_rolesFindFirstArgsBase = {
        /**
         * Select specific fields to fetch from the Model_has_roles
         *
         **/
        select?: Model_has_rolesSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Model_has_rolesInclude | null
        /**
         * Filter, which Model_has_roles to fetch.
         *
         **/
        where?: Model_has_rolesWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Model_has_roles to fetch.
         *
         **/
        orderBy?: Enumerable<Model_has_rolesOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for searching for Model_has_roles.
         *
         **/
        cursor?: Model_has_rolesWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Model_has_roles from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Model_has_roles.
         *
         **/
        skip?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
         *
         * Filter by unique combinations of Model_has_roles.
         *
         **/
        distinct?: Enumerable<Model_has_rolesScalarFieldEnum>
    }

    /**
     * Model_has_roles findFirst
     */
    export interface Model_has_rolesFindFirstArgs extends Model_has_rolesFindFirstArgsBase {
        /**
         * Throw an Error if query returns no results
         * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
         */
        rejectOnNotFound?: RejectOnNotFound
    }

    /**
     * Model_has_roles findFirstOrThrow
     */
    export type Model_has_rolesFindFirstOrThrowArgs = {
        /**
         * Select specific fields to fetch from the Model_has_roles
         *
         **/
        select?: Model_has_rolesSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Model_has_rolesInclude | null
        /**
         * Filter, which Model_has_roles to fetch.
         *
         **/
        where?: Model_has_rolesWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Model_has_roles to fetch.
         *
         **/
        orderBy?: Enumerable<Model_has_rolesOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for searching for Model_has_roles.
         *
         **/
        cursor?: Model_has_rolesWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Model_has_roles from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Model_has_roles.
         *
         **/
        skip?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
         *
         * Filter by unique combinations of Model_has_roles.
         *
         **/
        distinct?: Enumerable<Model_has_rolesScalarFieldEnum>
    }

    /**
     * Model_has_roles findMany
     */
    export type Model_has_rolesFindManyArgs = {
        /**
         * Select specific fields to fetch from the Model_has_roles
         *
         **/
        select?: Model_has_rolesSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Model_has_rolesInclude | null
        /**
         * Filter, which Model_has_roles to fetch.
         *
         **/
        where?: Model_has_rolesWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Model_has_roles to fetch.
         *
         **/
        orderBy?: Enumerable<Model_has_rolesOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for listing Model_has_roles.
         *
         **/
        cursor?: Model_has_rolesWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Model_has_roles from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Model_has_roles.
         *
         **/
        skip?: number
        distinct?: Enumerable<Model_has_rolesScalarFieldEnum>
    }

    /**
     * Model_has_roles create
     */
    export type Model_has_rolesCreateArgs = {
        /**
         * Select specific fields to fetch from the Model_has_roles
         *
         **/
        select?: Model_has_rolesSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Model_has_rolesInclude | null
        /**
         * The data needed to create a Model_has_roles.
         *
         **/
        data: XOR<Model_has_rolesCreateInput, Model_has_rolesUncheckedCreateInput>
    }

    /**
     * Model_has_roles createMany
     */
    export type Model_has_rolesCreateManyArgs = {
        /**
         * The data used to create many Model_has_roles.
         *
         **/
        data: Enumerable<Model_has_rolesCreateManyInput>
        skipDuplicates?: boolean
    }

    /**
     * Model_has_roles update
     */
    export type Model_has_rolesUpdateArgs = {
        /**
         * Select specific fields to fetch from the Model_has_roles
         *
         **/
        select?: Model_has_rolesSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Model_has_rolesInclude | null
        /**
         * The data needed to update a Model_has_roles.
         *
         **/
        data: XOR<Model_has_rolesUpdateInput, Model_has_rolesUncheckedUpdateInput>
        /**
         * Choose, which Model_has_roles to update.
         *
         **/
        where: Model_has_rolesWhereUniqueInput
    }

    /**
     * Model_has_roles updateMany
     */
    export type Model_has_rolesUpdateManyArgs = {
        /**
         * The data used to update Model_has_roles.
         *
         **/
        data: XOR<Model_has_rolesUpdateManyMutationInput, Model_has_rolesUncheckedUpdateManyInput>
        /**
         * Filter which Model_has_roles to update
         *
         **/
        where?: Model_has_rolesWhereInput
    }

    /**
     * Model_has_roles upsert
     */
    export type Model_has_rolesUpsertArgs = {
        /**
         * Select specific fields to fetch from the Model_has_roles
         *
         **/
        select?: Model_has_rolesSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Model_has_rolesInclude | null
        /**
         * The filter to search for the Model_has_roles to update in case it exists.
         *
         **/
        where: Model_has_rolesWhereUniqueInput
        /**
         * In case the Model_has_roles found by the `where` argument doesn't exist, create a new Model_has_roles with this data.
         *
         **/
        create: XOR<Model_has_rolesCreateInput, Model_has_rolesUncheckedCreateInput>
        /**
         * In case the Model_has_roles was found with the provided `where` argument, update it with this data.
         *
         **/
        update: XOR<Model_has_rolesUpdateInput, Model_has_rolesUncheckedUpdateInput>
    }

    /**
     * Model_has_roles delete
     */
    export type Model_has_rolesDeleteArgs = {
        /**
         * Select specific fields to fetch from the Model_has_roles
         *
         **/
        select?: Model_has_rolesSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Model_has_rolesInclude | null
        /**
         * Filter which Model_has_roles to delete.
         *
         **/
        where: Model_has_rolesWhereUniqueInput
    }

    /**
     * Model_has_roles deleteMany
     */
    export type Model_has_rolesDeleteManyArgs = {
        /**
         * Filter which Model_has_roles to delete
         *
         **/
        where?: Model_has_rolesWhereInput
    }

    /**
     * Model_has_roles without action
     */
    export type Model_has_rolesArgs = {
        /**
         * Select specific fields to fetch from the Model_has_roles
         *
         **/
        select?: Model_has_rolesSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Model_has_rolesInclude | null
    }

    /**
     * Model Orphan_sponsorship
     */

    export type AggregateOrphan_sponsorship = {
        _count: Orphan_sponsorshipCountAggregateOutputType | null
        _min: Orphan_sponsorshipMinAggregateOutputType | null
        _max: Orphan_sponsorshipMaxAggregateOutputType | null
    }

    export type Orphan_sponsorshipMinAggregateOutputType = {
        id: string | null
        orphan_id: string | null
        type: orphan_sponsorship_type | null
        value: string | null
        tenant_id: string | null
        created_at: Date | null
        updated_at: Date | null
    }

    export type Orphan_sponsorshipMaxAggregateOutputType = {
        id: string | null
        orphan_id: string | null
        type: orphan_sponsorship_type | null
        value: string | null
        tenant_id: string | null
        created_at: Date | null
        updated_at: Date | null
    }

    export type Orphan_sponsorshipCountAggregateOutputType = {
        id: number
        orphan_id: number
        type: number
        value: number
        tenant_id: number
        created_at: number
        updated_at: number
        _all: number
    }

    export type Orphan_sponsorshipMinAggregateInputType = {
        id?: true
        orphan_id?: true
        type?: true
        value?: true
        tenant_id?: true
        created_at?: true
        updated_at?: true
    }

    export type Orphan_sponsorshipMaxAggregateInputType = {
        id?: true
        orphan_id?: true
        type?: true
        value?: true
        tenant_id?: true
        created_at?: true
        updated_at?: true
    }

    export type Orphan_sponsorshipCountAggregateInputType = {
        id?: true
        orphan_id?: true
        type?: true
        value?: true
        tenant_id?: true
        created_at?: true
        updated_at?: true
        _all?: true
    }

    export type Orphan_sponsorshipAggregateArgs = {
        /**
         * Filter which Orphan_sponsorship to aggregate.
         *
         **/
        where?: Orphan_sponsorshipWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Orphan_sponsorships to fetch.
         *
         **/
        orderBy?: Enumerable<Orphan_sponsorshipOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the start position
         *
         **/
        cursor?: Orphan_sponsorshipWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Orphan_sponsorships from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Orphan_sponsorships.
         *
         **/
        skip?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Count returned Orphan_sponsorships
         **/
        _count?: true | Orphan_sponsorshipCountAggregateInputType
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to find the minimum value
         **/
        _min?: Orphan_sponsorshipMinAggregateInputType
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to find the maximum value
         **/
        _max?: Orphan_sponsorshipMaxAggregateInputType
    }

    export type GetOrphan_sponsorshipAggregateType<T extends Orphan_sponsorshipAggregateArgs> = {
        [P in keyof T & keyof AggregateOrphan_sponsorship]: P extends '_count' | 'count'
            ? T[P] extends true
                ? number
                : GetScalarType<T[P], AggregateOrphan_sponsorship[P]>
            : GetScalarType<T[P], AggregateOrphan_sponsorship[P]>
    }

    export type Orphan_sponsorshipGroupByArgs = {
        where?: Orphan_sponsorshipWhereInput
        orderBy?: Enumerable<Orphan_sponsorshipOrderByWithAggregationInput>
        by: Array<Orphan_sponsorshipScalarFieldEnum>
        having?: Orphan_sponsorshipScalarWhereWithAggregatesInput
        take?: number
        skip?: number
        _count?: Orphan_sponsorshipCountAggregateInputType | true
        _min?: Orphan_sponsorshipMinAggregateInputType
        _max?: Orphan_sponsorshipMaxAggregateInputType
    }

    export type Orphan_sponsorshipGroupByOutputType = {
        id: string
        orphan_id: string
        type: orphan_sponsorship_type
        value: string | null
        tenant_id: string
        created_at: Date | null
        updated_at: Date | null
        _count: Orphan_sponsorshipCountAggregateOutputType | null
        _min: Orphan_sponsorshipMinAggregateOutputType | null
        _max: Orphan_sponsorshipMaxAggregateOutputType | null
    }

    type GetOrphan_sponsorshipGroupByPayload<T extends Orphan_sponsorshipGroupByArgs> = PrismaPromise<
        Array<
            PickArray<Orphan_sponsorshipGroupByOutputType, T['by']> & {
                [P in keyof T & keyof Orphan_sponsorshipGroupByOutputType]: P extends '_count'
                    ? T[P] extends boolean
                        ? number
                        : GetScalarType<T[P], Orphan_sponsorshipGroupByOutputType[P]>
                    : GetScalarType<T[P], Orphan_sponsorshipGroupByOutputType[P]>
            }
        >
    >

    export type Orphan_sponsorshipSelect = {
        id?: boolean
        orphan_id?: boolean
        type?: boolean
        value?: boolean
        tenant_id?: boolean
        created_at?: boolean
        updated_at?: boolean
        orphans?: boolean | OrphansArgs
        tenants?: boolean | TenantsArgs
    }

    export type Orphan_sponsorshipInclude = {
        orphans?: boolean | OrphansArgs
        tenants?: boolean | TenantsArgs
    }

    export type Orphan_sponsorshipGetPayload<S extends boolean | null | undefined | Orphan_sponsorshipArgs> =
        S extends { select: any; include: any }
            ? 'Please either choose `select` or `include`'
            : S extends true
              ? Orphan_sponsorship
              : S extends undefined
                ? never
                : S extends { include: any } & (Orphan_sponsorshipArgs | Orphan_sponsorshipFindManyArgs)
                  ? Orphan_sponsorship & {
                        [P in TruthyKeys<S['include']>]: P extends 'orphans'
                            ? OrphansGetPayload<S['include'][P]>
                            : P extends 'tenants'
                              ? TenantsGetPayload<S['include'][P]>
                              : never
                    }
                  : S extends { select: any } & (Orphan_sponsorshipArgs | Orphan_sponsorshipFindManyArgs)
                    ? {
                          [P in TruthyKeys<S['select']>]: P extends 'orphans'
                              ? OrphansGetPayload<S['select'][P]>
                              : P extends 'tenants'
                                ? TenantsGetPayload<S['select'][P]>
                                : P extends keyof Orphan_sponsorship
                                  ? Orphan_sponsorship[P]
                                  : never
                      }
                    : Orphan_sponsorship

    type Orphan_sponsorshipCountArgs = Merge<
        Omit<Orphan_sponsorshipFindManyArgs, 'select' | 'include'> & {
            select?: Orphan_sponsorshipCountAggregateInputType | true
        }
    >

    export interface Orphan_sponsorshipDelegate<
        GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined
    > {
        /**
         * Find zero or one Orphan_sponsorship that matches the filter.
         * @param {Orphan_sponsorshipFindUniqueArgs} args - Arguments to find a Orphan_sponsorship
         * @example
         * // Get one Orphan_sponsorship
         * const orphan_sponsorship = await prisma.orphan_sponsorship.findUnique({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findUnique<
            T extends Orphan_sponsorshipFindUniqueArgs,
            LocalRejectSettings = T['rejectOnNotFound'] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined
        >(
            args: SelectSubset<T, Orphan_sponsorshipFindUniqueArgs>
        ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Orphan_sponsorship'> extends True
            ? Prisma__Orphan_sponsorshipClient<Orphan_sponsorshipGetPayload<T>>
            : Prisma__Orphan_sponsorshipClient<Orphan_sponsorshipGetPayload<T> | null, null>

        /**
         * Find one Orphan_sponsorship that matches the filter or throw an error  with `error.code='P2025'`
         *     if no matches were found.
         * @param {Orphan_sponsorshipFindUniqueOrThrowArgs} args - Arguments to find a Orphan_sponsorship
         * @example
         * // Get one Orphan_sponsorship
         * const orphan_sponsorship = await prisma.orphan_sponsorship.findUniqueOrThrow({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findUniqueOrThrow<T extends Orphan_sponsorshipFindUniqueOrThrowArgs>(
            args?: SelectSubset<T, Orphan_sponsorshipFindUniqueOrThrowArgs>
        ): Prisma__Orphan_sponsorshipClient<Orphan_sponsorshipGetPayload<T>>

        /**
         * Find the first Orphan_sponsorship that matches the filter.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {Orphan_sponsorshipFindFirstArgs} args - Arguments to find a Orphan_sponsorship
         * @example
         * // Get one Orphan_sponsorship
         * const orphan_sponsorship = await prisma.orphan_sponsorship.findFirst({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findFirst<
            T extends Orphan_sponsorshipFindFirstArgs,
            LocalRejectSettings = T['rejectOnNotFound'] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined
        >(
            args?: SelectSubset<T, Orphan_sponsorshipFindFirstArgs>
        ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Orphan_sponsorship'> extends True
            ? Prisma__Orphan_sponsorshipClient<Orphan_sponsorshipGetPayload<T>>
            : Prisma__Orphan_sponsorshipClient<Orphan_sponsorshipGetPayload<T> | null, null>

        /**
         * Find the first Orphan_sponsorship that matches the filter or
         * throw `NotFoundError` if no matches were found.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {Orphan_sponsorshipFindFirstOrThrowArgs} args - Arguments to find a Orphan_sponsorship
         * @example
         * // Get one Orphan_sponsorship
         * const orphan_sponsorship = await prisma.orphan_sponsorship.findFirstOrThrow({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findFirstOrThrow<T extends Orphan_sponsorshipFindFirstOrThrowArgs>(
            args?: SelectSubset<T, Orphan_sponsorshipFindFirstOrThrowArgs>
        ): Prisma__Orphan_sponsorshipClient<Orphan_sponsorshipGetPayload<T>>

        /**
         * Find zero or more Orphan_sponsorships that matches the filter.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {Orphan_sponsorshipFindManyArgs=} args - Arguments to filter and select certain fields only.
         * @example
         * // Get all Orphan_sponsorships
         * const orphan_sponsorships = await prisma.orphan_sponsorship.findMany()
         *
         * // Get first 10 Orphan_sponsorships
         * const orphan_sponsorships = await prisma.orphan_sponsorship.findMany({ take: 10 })
         *
         * // Only select the `id`
         * const orphan_sponsorshipWithIdOnly = await prisma.orphan_sponsorship.findMany({ select: { id: true } })
         *
         **/
        findMany<T extends Orphan_sponsorshipFindManyArgs>(
            args?: SelectSubset<T, Orphan_sponsorshipFindManyArgs>
        ): PrismaPromise<Array<Orphan_sponsorshipGetPayload<T>>>

        /**
         * Create a Orphan_sponsorship.
         * @param {Orphan_sponsorshipCreateArgs} args - Arguments to create a Orphan_sponsorship.
         * @example
         * // Create one Orphan_sponsorship
         * const Orphan_sponsorship = await prisma.orphan_sponsorship.create({
         *   data: {
         *     // ... data to create a Orphan_sponsorship
         *   }
         * })
         *
         **/
        create<T extends Orphan_sponsorshipCreateArgs>(
            args: SelectSubset<T, Orphan_sponsorshipCreateArgs>
        ): Prisma__Orphan_sponsorshipClient<Orphan_sponsorshipGetPayload<T>>

        /**
         * Create many Orphan_sponsorships.
         *     @param {Orphan_sponsorshipCreateManyArgs} args - Arguments to create many Orphan_sponsorships.
         *     @example
         *     // Create many Orphan_sponsorships
         *     const orphan_sponsorship = await prisma.orphan_sponsorship.createMany({
         *       data: {
         *         // ... provide data here
         *       }
         *     })
         *
         **/
        createMany<T extends Orphan_sponsorshipCreateManyArgs>(
            args?: SelectSubset<T, Orphan_sponsorshipCreateManyArgs>
        ): PrismaPromise<BatchPayload>

        /**
         * Delete a Orphan_sponsorship.
         * @param {Orphan_sponsorshipDeleteArgs} args - Arguments to delete one Orphan_sponsorship.
         * @example
         * // Delete one Orphan_sponsorship
         * const Orphan_sponsorship = await prisma.orphan_sponsorship.delete({
         *   where: {
         *     // ... filter to delete one Orphan_sponsorship
         *   }
         * })
         *
         **/
        delete<T extends Orphan_sponsorshipDeleteArgs>(
            args: SelectSubset<T, Orphan_sponsorshipDeleteArgs>
        ): Prisma__Orphan_sponsorshipClient<Orphan_sponsorshipGetPayload<T>>

        /**
         * Update one Orphan_sponsorship.
         * @param {Orphan_sponsorshipUpdateArgs} args - Arguments to update one Orphan_sponsorship.
         * @example
         * // Update one Orphan_sponsorship
         * const orphan_sponsorship = await prisma.orphan_sponsorship.update({
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: {
         *     // ... provide data here
         *   }
         * })
         *
         **/
        update<T extends Orphan_sponsorshipUpdateArgs>(
            args: SelectSubset<T, Orphan_sponsorshipUpdateArgs>
        ): Prisma__Orphan_sponsorshipClient<Orphan_sponsorshipGetPayload<T>>

        /**
         * Delete zero or more Orphan_sponsorships.
         * @param {Orphan_sponsorshipDeleteManyArgs} args - Arguments to filter Orphan_sponsorships to delete.
         * @example
         * // Delete a few Orphan_sponsorships
         * const { count } = await prisma.orphan_sponsorship.deleteMany({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         *
         **/
        deleteMany<T extends Orphan_sponsorshipDeleteManyArgs>(
            args?: SelectSubset<T, Orphan_sponsorshipDeleteManyArgs>
        ): PrismaPromise<BatchPayload>

        /**
         * Update zero or more Orphan_sponsorships.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {Orphan_sponsorshipUpdateManyArgs} args - Arguments to update one or more rows.
         * @example
         * // Update many Orphan_sponsorships
         * const orphan_sponsorship = await prisma.orphan_sponsorship.updateMany({
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: {
         *     // ... provide data here
         *   }
         * })
         *
         **/
        updateMany<T extends Orphan_sponsorshipUpdateManyArgs>(
            args: SelectSubset<T, Orphan_sponsorshipUpdateManyArgs>
        ): PrismaPromise<BatchPayload>

        /**
         * Create or update one Orphan_sponsorship.
         * @param {Orphan_sponsorshipUpsertArgs} args - Arguments to update or create a Orphan_sponsorship.
         * @example
         * // Update or create a Orphan_sponsorship
         * const orphan_sponsorship = await prisma.orphan_sponsorship.upsert({
         *   create: {
         *     // ... data to create a Orphan_sponsorship
         *   },
         *   update: {
         *     // ... in case it already exists, update
         *   },
         *   where: {
         *     // ... the filter for the Orphan_sponsorship we want to update
         *   }
         * })
         **/
        upsert<T extends Orphan_sponsorshipUpsertArgs>(
            args: SelectSubset<T, Orphan_sponsorshipUpsertArgs>
        ): Prisma__Orphan_sponsorshipClient<Orphan_sponsorshipGetPayload<T>>

        /**
         * Count the number of Orphan_sponsorships.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {Orphan_sponsorshipCountArgs} args - Arguments to filter Orphan_sponsorships to count.
         * @example
         * // Count the number of Orphan_sponsorships
         * const count = await prisma.orphan_sponsorship.count({
         *   where: {
         *     // ... the filter for the Orphan_sponsorships we want to count
         *   }
         * })
         **/
        count<T extends Orphan_sponsorshipCountArgs>(
            args?: Subset<T, Orphan_sponsorshipCountArgs>
        ): PrismaPromise<
            T extends _Record<'select', any>
                ? T['select'] extends true
                    ? number
                    : GetScalarType<T['select'], Orphan_sponsorshipCountAggregateOutputType>
                : number
        >

        /**
         * Allows you to perform aggregations operations on a Orphan_sponsorship.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {Orphan_sponsorshipAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
         * @example
         * // Ordered by age ascending
         * // Where email contains prisma.io
         * // Limited to the 10 users
         * const aggregations = await prisma.user.aggregate({
         *   _avg: {
         *     age: true,
         *   },
         *   where: {
         *     email: {
         *       contains: "prisma.io",
         *     },
         *   },
         *   orderBy: {
         *     age: "asc",
         *   },
         *   take: 10,
         * })
         **/
        aggregate<T extends Orphan_sponsorshipAggregateArgs>(
            args: Subset<T, Orphan_sponsorshipAggregateArgs>
        ): PrismaPromise<GetOrphan_sponsorshipAggregateType<T>>

        /**
         * Group by Orphan_sponsorship.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {Orphan_sponsorshipGroupByArgs} args - Group by arguments.
         * @example
         * // Group by city, order by createdAt, get count
         * const result = await prisma.user.groupBy({
         *   by: ['city', 'createdAt'],
         *   orderBy: {
         *     createdAt: true
         *   },
         *   _count: {
         *     _all: true
         *   },
         * })
         *
         **/
        groupBy<
            T extends Orphan_sponsorshipGroupByArgs,
            HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
            OrderByArg extends True extends HasSelectOrTake
                ? { orderBy: Orphan_sponsorshipGroupByArgs['orderBy'] }
                : { orderBy?: Orphan_sponsorshipGroupByArgs['orderBy'] },
            OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
            ByFields extends TupleToUnion<T['by']>,
            ByValid extends Has<ByFields, OrderFields>,
            HavingFields extends GetHavingFields<T['having']>,
            HavingValid extends Has<ByFields, HavingFields>,
            ByEmpty extends T['by'] extends never[] ? True : False,
            InputErrors extends ByEmpty extends True
                ? `Error: "by" must not be empty.`
                : HavingValid extends False
                  ? {
                        [P in HavingFields]: P extends ByFields
                            ? never
                            : P extends string
                              ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                              : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`]
                    }[HavingFields]
                  : 'take' extends Keys<T>
                    ? 'orderBy' extends Keys<T>
                        ? ByValid extends True
                            ? {}
                            : {
                                  [P in OrderFields]: P extends ByFields
                                      ? never
                                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                              }[OrderFields]
                        : 'Error: If you provide "take", you also need to provide "orderBy"'
                    : 'skip' extends Keys<T>
                      ? 'orderBy' extends Keys<T>
                          ? ByValid extends True
                              ? {}
                              : {
                                    [P in OrderFields]: P extends ByFields
                                        ? never
                                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                                }[OrderFields]
                          : 'Error: If you provide "skip", you also need to provide "orderBy"'
                      : ByValid extends True
                        ? {}
                        : {
                              [P in OrderFields]: P extends ByFields
                                  ? never
                                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                          }[OrderFields]
        >(
            args: SubsetIntersection<T, Orphan_sponsorshipGroupByArgs, OrderByArg> & InputErrors
        ): {} extends InputErrors ? GetOrphan_sponsorshipGroupByPayload<T> : PrismaPromise<InputErrors>
    }

    /**
     * The delegate class that acts as a "Promise-like" for Orphan_sponsorship.
     * Why is this prefixed with `Prisma__`?
     * Because we want to prevent naming conflicts as mentioned in
     * https://github.com/prisma/prisma-client-js/issues/707
     */
    export class Prisma__Orphan_sponsorshipClient<T, Null = never> implements PrismaPromise<T> {
        [prisma]: true
        private readonly _dmmf
        private readonly _fetcher
        private readonly _queryType
        private readonly _rootField
        private readonly _clientMethod
        private readonly _args
        private readonly _dataPath
        private readonly _errorFormat
        private readonly _measurePerformance?
        private _isList
        private _callsite
        private _requestPromise?
        constructor(
            _dmmf: runtime.DMMFClass,
            _fetcher: PrismaClientFetcher,
            _queryType: 'query' | 'mutation',
            _rootField: string,
            _clientMethod: string,
            _args: any,
            _dataPath: string[],
            _errorFormat: ErrorFormat,
            _measurePerformance?: boolean | undefined,
            _isList?: boolean
        )
        readonly [Symbol.toStringTag]: 'PrismaClientPromise'

        orphans<T extends OrphansArgs = {}>(
            args?: Subset<T, OrphansArgs>
        ): Prisma__OrphansClient<OrphansGetPayload<T> | Null>

        tenants<T extends TenantsArgs = {}>(
            args?: Subset<T, TenantsArgs>
        ): Prisma__TenantsClient<TenantsGetPayload<T> | Null>

        private get _document()
        /**
         * Attaches callbacks for the resolution and/or rejection of the Promise.
         * @param onfulfilled The callback to execute when the Promise is resolved.
         * @param onrejected The callback to execute when the Promise is rejected.
         * @returns A Promise for the completion of which ever callback is executed.
         */
        then<TResult1 = T, TResult2 = never>(
            onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
            onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
        ): Promise<TResult1 | TResult2>
        /**
         * Attaches a callback for only the rejection of the Promise.
         * @param onrejected The callback to execute when the Promise is rejected.
         * @returns A Promise for the completion of the callback.
         */
        catch<TResult = never>(
            onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
        ): Promise<T | TResult>
        /**
         * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
         * resolved value cannot be modified from the callback.
         * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
         * @returns A Promise for the completion of the callback.
         */
        finally(onfinally?: (() => void) | undefined | null): Promise<T>
    }

    // Custom InputTypes

    /**
     * Orphan_sponsorship base type for findUnique actions
     */
    export type Orphan_sponsorshipFindUniqueArgsBase = {
        /**
         * Select specific fields to fetch from the Orphan_sponsorship
         *
         **/
        select?: Orphan_sponsorshipSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Orphan_sponsorshipInclude | null
        /**
         * Filter, which Orphan_sponsorship to fetch.
         *
         **/
        where: Orphan_sponsorshipWhereUniqueInput
    }

    /**
     * Orphan_sponsorship findUnique
     */
    export interface Orphan_sponsorshipFindUniqueArgs extends Orphan_sponsorshipFindUniqueArgsBase {
        /**
         * Throw an Error if query returns no results
         * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
         */
        rejectOnNotFound?: RejectOnNotFound
    }

    /**
     * Orphan_sponsorship findUniqueOrThrow
     */
    export type Orphan_sponsorshipFindUniqueOrThrowArgs = {
        /**
         * Select specific fields to fetch from the Orphan_sponsorship
         *
         **/
        select?: Orphan_sponsorshipSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Orphan_sponsorshipInclude | null
        /**
         * Filter, which Orphan_sponsorship to fetch.
         *
         **/
        where: Orphan_sponsorshipWhereUniqueInput
    }

    /**
     * Orphan_sponsorship base type for findFirst actions
     */
    export type Orphan_sponsorshipFindFirstArgsBase = {
        /**
         * Select specific fields to fetch from the Orphan_sponsorship
         *
         **/
        select?: Orphan_sponsorshipSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Orphan_sponsorshipInclude | null
        /**
         * Filter, which Orphan_sponsorship to fetch.
         *
         **/
        where?: Orphan_sponsorshipWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Orphan_sponsorships to fetch.
         *
         **/
        orderBy?: Enumerable<Orphan_sponsorshipOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for searching for Orphan_sponsorships.
         *
         **/
        cursor?: Orphan_sponsorshipWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Orphan_sponsorships from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Orphan_sponsorships.
         *
         **/
        skip?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
         *
         * Filter by unique combinations of Orphan_sponsorships.
         *
         **/
        distinct?: Enumerable<Orphan_sponsorshipScalarFieldEnum>
    }

    /**
     * Orphan_sponsorship findFirst
     */
    export interface Orphan_sponsorshipFindFirstArgs extends Orphan_sponsorshipFindFirstArgsBase {
        /**
         * Throw an Error if query returns no results
         * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
         */
        rejectOnNotFound?: RejectOnNotFound
    }

    /**
     * Orphan_sponsorship findFirstOrThrow
     */
    export type Orphan_sponsorshipFindFirstOrThrowArgs = {
        /**
         * Select specific fields to fetch from the Orphan_sponsorship
         *
         **/
        select?: Orphan_sponsorshipSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Orphan_sponsorshipInclude | null
        /**
         * Filter, which Orphan_sponsorship to fetch.
         *
         **/
        where?: Orphan_sponsorshipWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Orphan_sponsorships to fetch.
         *
         **/
        orderBy?: Enumerable<Orphan_sponsorshipOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for searching for Orphan_sponsorships.
         *
         **/
        cursor?: Orphan_sponsorshipWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Orphan_sponsorships from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Orphan_sponsorships.
         *
         **/
        skip?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
         *
         * Filter by unique combinations of Orphan_sponsorships.
         *
         **/
        distinct?: Enumerable<Orphan_sponsorshipScalarFieldEnum>
    }

    /**
     * Orphan_sponsorship findMany
     */
    export type Orphan_sponsorshipFindManyArgs = {
        /**
         * Select specific fields to fetch from the Orphan_sponsorship
         *
         **/
        select?: Orphan_sponsorshipSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Orphan_sponsorshipInclude | null
        /**
         * Filter, which Orphan_sponsorships to fetch.
         *
         **/
        where?: Orphan_sponsorshipWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Orphan_sponsorships to fetch.
         *
         **/
        orderBy?: Enumerable<Orphan_sponsorshipOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for listing Orphan_sponsorships.
         *
         **/
        cursor?: Orphan_sponsorshipWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Orphan_sponsorships from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Orphan_sponsorships.
         *
         **/
        skip?: number
        distinct?: Enumerable<Orphan_sponsorshipScalarFieldEnum>
    }

    /**
     * Orphan_sponsorship create
     */
    export type Orphan_sponsorshipCreateArgs = {
        /**
         * Select specific fields to fetch from the Orphan_sponsorship
         *
         **/
        select?: Orphan_sponsorshipSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Orphan_sponsorshipInclude | null
        /**
         * The data needed to create a Orphan_sponsorship.
         *
         **/
        data: XOR<Orphan_sponsorshipCreateInput, Orphan_sponsorshipUncheckedCreateInput>
    }

    /**
     * Orphan_sponsorship createMany
     */
    export type Orphan_sponsorshipCreateManyArgs = {
        /**
         * The data used to create many Orphan_sponsorships.
         *
         **/
        data: Enumerable<Orphan_sponsorshipCreateManyInput>
        skipDuplicates?: boolean
    }

    /**
     * Orphan_sponsorship update
     */
    export type Orphan_sponsorshipUpdateArgs = {
        /**
         * Select specific fields to fetch from the Orphan_sponsorship
         *
         **/
        select?: Orphan_sponsorshipSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Orphan_sponsorshipInclude | null
        /**
         * The data needed to update a Orphan_sponsorship.
         *
         **/
        data: XOR<Orphan_sponsorshipUpdateInput, Orphan_sponsorshipUncheckedUpdateInput>
        /**
         * Choose, which Orphan_sponsorship to update.
         *
         **/
        where: Orphan_sponsorshipWhereUniqueInput
    }

    /**
     * Orphan_sponsorship updateMany
     */
    export type Orphan_sponsorshipUpdateManyArgs = {
        /**
         * The data used to update Orphan_sponsorships.
         *
         **/
        data: XOR<Orphan_sponsorshipUpdateManyMutationInput, Orphan_sponsorshipUncheckedUpdateManyInput>
        /**
         * Filter which Orphan_sponsorships to update
         *
         **/
        where?: Orphan_sponsorshipWhereInput
    }

    /**
     * Orphan_sponsorship upsert
     */
    export type Orphan_sponsorshipUpsertArgs = {
        /**
         * Select specific fields to fetch from the Orphan_sponsorship
         *
         **/
        select?: Orphan_sponsorshipSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Orphan_sponsorshipInclude | null
        /**
         * The filter to search for the Orphan_sponsorship to update in case it exists.
         *
         **/
        where: Orphan_sponsorshipWhereUniqueInput
        /**
         * In case the Orphan_sponsorship found by the `where` argument doesn't exist, create a new Orphan_sponsorship with this data.
         *
         **/
        create: XOR<Orphan_sponsorshipCreateInput, Orphan_sponsorshipUncheckedCreateInput>
        /**
         * In case the Orphan_sponsorship was found with the provided `where` argument, update it with this data.
         *
         **/
        update: XOR<Orphan_sponsorshipUpdateInput, Orphan_sponsorshipUncheckedUpdateInput>
    }

    /**
     * Orphan_sponsorship delete
     */
    export type Orphan_sponsorshipDeleteArgs = {
        /**
         * Select specific fields to fetch from the Orphan_sponsorship
         *
         **/
        select?: Orphan_sponsorshipSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Orphan_sponsorshipInclude | null
        /**
         * Filter which Orphan_sponsorship to delete.
         *
         **/
        where: Orphan_sponsorshipWhereUniqueInput
    }

    /**
     * Orphan_sponsorship deleteMany
     */
    export type Orphan_sponsorshipDeleteManyArgs = {
        /**
         * Filter which Orphan_sponsorships to delete
         *
         **/
        where?: Orphan_sponsorshipWhereInput
    }

    /**
     * Orphan_sponsorship without action
     */
    export type Orphan_sponsorshipArgs = {
        /**
         * Select specific fields to fetch from the Orphan_sponsorship
         *
         **/
        select?: Orphan_sponsorshipSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Orphan_sponsorshipInclude | null
    }

    /**
     * Model Orphans
     */

    export type AggregateOrphans = {
        _count: OrphansCountAggregateOutputType | null
        _min: OrphansMinAggregateOutputType | null
        _max: OrphansMaxAggregateOutputType | null
    }

    export type OrphansMinAggregateOutputType = {
        id: string | null
        first_name: string | null
        last_name: string | null
        birth_date: Date | null
        family_status: string | null
        health_status: string | null
        academic_level: string | null
        shoes_size: string | null
        pants_size: string | null
        shirt_size: string | null
        note: string | null
        tenant_id: string | null
        family_id: string | null
        created_by: string | null
        deleted_by: string | null
        created_at: Date | null
        updated_at: Date | null
    }

    export type OrphansMaxAggregateOutputType = {
        id: string | null
        first_name: string | null
        last_name: string | null
        birth_date: Date | null
        family_status: string | null
        health_status: string | null
        academic_level: string | null
        shoes_size: string | null
        pants_size: string | null
        shirt_size: string | null
        note: string | null
        tenant_id: string | null
        family_id: string | null
        created_by: string | null
        deleted_by: string | null
        created_at: Date | null
        updated_at: Date | null
    }

    export type OrphansCountAggregateOutputType = {
        id: number
        first_name: number
        last_name: number
        birth_date: number
        family_status: number
        health_status: number
        academic_level: number
        shoes_size: number
        pants_size: number
        shirt_size: number
        note: number
        tenant_id: number
        family_id: number
        created_by: number
        deleted_by: number
        created_at: number
        updated_at: number
        _all: number
    }

    export type OrphansMinAggregateInputType = {
        id?: true
        first_name?: true
        last_name?: true
        birth_date?: true
        family_status?: true
        health_status?: true
        academic_level?: true
        shoes_size?: true
        pants_size?: true
        shirt_size?: true
        note?: true
        tenant_id?: true
        family_id?: true
        created_by?: true
        deleted_by?: true
        created_at?: true
        updated_at?: true
    }

    export type OrphansMaxAggregateInputType = {
        id?: true
        first_name?: true
        last_name?: true
        birth_date?: true
        family_status?: true
        health_status?: true
        academic_level?: true
        shoes_size?: true
        pants_size?: true
        shirt_size?: true
        note?: true
        tenant_id?: true
        family_id?: true
        created_by?: true
        deleted_by?: true
        created_at?: true
        updated_at?: true
    }

    export type OrphansCountAggregateInputType = {
        id?: true
        first_name?: true
        last_name?: true
        birth_date?: true
        family_status?: true
        health_status?: true
        academic_level?: true
        shoes_size?: true
        pants_size?: true
        shirt_size?: true
        note?: true
        tenant_id?: true
        family_id?: true
        created_by?: true
        deleted_by?: true
        created_at?: true
        updated_at?: true
        _all?: true
    }

    export type OrphansAggregateArgs = {
        /**
         * Filter which Orphans to aggregate.
         *
         **/
        where?: OrphansWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Orphans to fetch.
         *
         **/
        orderBy?: Enumerable<OrphansOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the start position
         *
         **/
        cursor?: OrphansWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Orphans from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Orphans.
         *
         **/
        skip?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Count returned Orphans
         **/
        _count?: true | OrphansCountAggregateInputType
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to find the minimum value
         **/
        _min?: OrphansMinAggregateInputType
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to find the maximum value
         **/
        _max?: OrphansMaxAggregateInputType
    }

    export type GetOrphansAggregateType<T extends OrphansAggregateArgs> = {
        [P in keyof T & keyof AggregateOrphans]: P extends '_count' | 'count'
            ? T[P] extends true
                ? number
                : GetScalarType<T[P], AggregateOrphans[P]>
            : GetScalarType<T[P], AggregateOrphans[P]>
    }

    export type OrphansGroupByArgs = {
        where?: OrphansWhereInput
        orderBy?: Enumerable<OrphansOrderByWithAggregationInput>
        by: Array<OrphansScalarFieldEnum>
        having?: OrphansScalarWhereWithAggregatesInput
        take?: number
        skip?: number
        _count?: OrphansCountAggregateInputType | true
        _min?: OrphansMinAggregateInputType
        _max?: OrphansMaxAggregateInputType
    }

    export type OrphansGroupByOutputType = {
        id: string
        first_name: string
        last_name: string
        birth_date: Date
        family_status: string
        health_status: string
        academic_level: string
        shoes_size: string
        pants_size: string
        shirt_size: string
        note: string
        tenant_id: string
        family_id: string
        created_by: string
        deleted_by: string | null
        created_at: Date | null
        updated_at: Date | null
        _count: OrphansCountAggregateOutputType | null
        _min: OrphansMinAggregateOutputType | null
        _max: OrphansMaxAggregateOutputType | null
    }

    type GetOrphansGroupByPayload<T extends OrphansGroupByArgs> = PrismaPromise<
        Array<
            PickArray<OrphansGroupByOutputType, T['by']> & {
                [P in keyof T & keyof OrphansGroupByOutputType]: P extends '_count'
                    ? T[P] extends boolean
                        ? number
                        : GetScalarType<T[P], OrphansGroupByOutputType[P]>
                    : GetScalarType<T[P], OrphansGroupByOutputType[P]>
            }
        >
    >

    export type OrphansSelect = {
        id?: boolean
        first_name?: boolean
        last_name?: boolean
        birth_date?: boolean
        family_status?: boolean
        health_status?: boolean
        academic_level?: boolean
        shoes_size?: boolean
        pants_size?: boolean
        shirt_size?: boolean
        note?: boolean
        tenant_id?: boolean
        family_id?: boolean
        created_by?: boolean
        deleted_by?: boolean
        created_at?: boolean
        updated_at?: boolean
        orphan_sponsorship?: boolean | Orphans$orphan_sponsorshipArgs
        users_orphans_created_byTousers?: boolean | UsersArgs
        users_orphans_deleted_byTousers?: boolean | UsersArgs
        families?: boolean | FamiliesArgs
        tenants?: boolean | TenantsArgs
        _count?: boolean | OrphansCountOutputTypeArgs
    }

    export type OrphansInclude = {
        orphan_sponsorship?: boolean | Orphans$orphan_sponsorshipArgs
        users_orphans_created_byTousers?: boolean | UsersArgs
        users_orphans_deleted_byTousers?: boolean | UsersArgs
        families?: boolean | FamiliesArgs
        tenants?: boolean | TenantsArgs
        _count?: boolean | OrphansCountOutputTypeArgs
    }

    export type OrphansGetPayload<S extends boolean | null | undefined | OrphansArgs> = S extends {
        select: any
        include: any
    }
        ? 'Please either choose `select` or `include`'
        : S extends true
          ? Orphans
          : S extends undefined
            ? never
            : S extends { include: any } & (OrphansArgs | OrphansFindManyArgs)
              ? Orphans & {
                    [P in TruthyKeys<S['include']>]: P extends 'orphan_sponsorship'
                        ? Array<Orphan_sponsorshipGetPayload<S['include'][P]>>
                        : P extends 'users_orphans_created_byTousers'
                          ? UsersGetPayload<S['include'][P]>
                          : P extends 'users_orphans_deleted_byTousers'
                            ? UsersGetPayload<S['include'][P]> | null
                            : P extends 'families'
                              ? FamiliesGetPayload<S['include'][P]>
                              : P extends 'tenants'
                                ? TenantsGetPayload<S['include'][P]>
                                : P extends '_count'
                                  ? OrphansCountOutputTypeGetPayload<S['include'][P]>
                                  : never
                }
              : S extends { select: any } & (OrphansArgs | OrphansFindManyArgs)
                ? {
                      [P in TruthyKeys<S['select']>]: P extends 'orphan_sponsorship'
                          ? Array<Orphan_sponsorshipGetPayload<S['select'][P]>>
                          : P extends 'users_orphans_created_byTousers'
                            ? UsersGetPayload<S['select'][P]>
                            : P extends 'users_orphans_deleted_byTousers'
                              ? UsersGetPayload<S['select'][P]> | null
                              : P extends 'families'
                                ? FamiliesGetPayload<S['select'][P]>
                                : P extends 'tenants'
                                  ? TenantsGetPayload<S['select'][P]>
                                  : P extends '_count'
                                    ? OrphansCountOutputTypeGetPayload<S['select'][P]>
                                    : P extends keyof Orphans
                                      ? Orphans[P]
                                      : never
                  }
                : Orphans

    type OrphansCountArgs = Merge<
        Omit<OrphansFindManyArgs, 'select' | 'include'> & {
            select?: OrphansCountAggregateInputType | true
        }
    >

    export interface OrphansDelegate<
        GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined
    > {
        /**
         * Find zero or one Orphans that matches the filter.
         * @param {OrphansFindUniqueArgs} args - Arguments to find a Orphans
         * @example
         * // Get one Orphans
         * const orphans = await prisma.orphans.findUnique({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findUnique<
            T extends OrphansFindUniqueArgs,
            LocalRejectSettings = T['rejectOnNotFound'] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined
        >(
            args: SelectSubset<T, OrphansFindUniqueArgs>
        ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Orphans'> extends True
            ? Prisma__OrphansClient<OrphansGetPayload<T>>
            : Prisma__OrphansClient<OrphansGetPayload<T> | null, null>

        /**
         * Find one Orphans that matches the filter or throw an error  with `error.code='P2025'`
         *     if no matches were found.
         * @param {OrphansFindUniqueOrThrowArgs} args - Arguments to find a Orphans
         * @example
         * // Get one Orphans
         * const orphans = await prisma.orphans.findUniqueOrThrow({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findUniqueOrThrow<T extends OrphansFindUniqueOrThrowArgs>(
            args?: SelectSubset<T, OrphansFindUniqueOrThrowArgs>
        ): Prisma__OrphansClient<OrphansGetPayload<T>>

        /**
         * Find the first Orphans that matches the filter.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {OrphansFindFirstArgs} args - Arguments to find a Orphans
         * @example
         * // Get one Orphans
         * const orphans = await prisma.orphans.findFirst({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findFirst<
            T extends OrphansFindFirstArgs,
            LocalRejectSettings = T['rejectOnNotFound'] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined
        >(
            args?: SelectSubset<T, OrphansFindFirstArgs>
        ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Orphans'> extends True
            ? Prisma__OrphansClient<OrphansGetPayload<T>>
            : Prisma__OrphansClient<OrphansGetPayload<T> | null, null>

        /**
         * Find the first Orphans that matches the filter or
         * throw `NotFoundError` if no matches were found.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {OrphansFindFirstOrThrowArgs} args - Arguments to find a Orphans
         * @example
         * // Get one Orphans
         * const orphans = await prisma.orphans.findFirstOrThrow({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findFirstOrThrow<T extends OrphansFindFirstOrThrowArgs>(
            args?: SelectSubset<T, OrphansFindFirstOrThrowArgs>
        ): Prisma__OrphansClient<OrphansGetPayload<T>>

        /**
         * Find zero or more Orphans that matches the filter.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {OrphansFindManyArgs=} args - Arguments to filter and select certain fields only.
         * @example
         * // Get all Orphans
         * const orphans = await prisma.orphans.findMany()
         *
         * // Get first 10 Orphans
         * const orphans = await prisma.orphans.findMany({ take: 10 })
         *
         * // Only select the `id`
         * const orphansWithIdOnly = await prisma.orphans.findMany({ select: { id: true } })
         *
         **/
        findMany<T extends OrphansFindManyArgs>(
            args?: SelectSubset<T, OrphansFindManyArgs>
        ): PrismaPromise<Array<OrphansGetPayload<T>>>

        /**
         * Create a Orphans.
         * @param {OrphansCreateArgs} args - Arguments to create a Orphans.
         * @example
         * // Create one Orphans
         * const Orphans = await prisma.orphans.create({
         *   data: {
         *     // ... data to create a Orphans
         *   }
         * })
         *
         **/
        create<T extends OrphansCreateArgs>(
            args: SelectSubset<T, OrphansCreateArgs>
        ): Prisma__OrphansClient<OrphansGetPayload<T>>

        /**
         * Create many Orphans.
         *     @param {OrphansCreateManyArgs} args - Arguments to create many Orphans.
         *     @example
         *     // Create many Orphans
         *     const orphans = await prisma.orphans.createMany({
         *       data: {
         *         // ... provide data here
         *       }
         *     })
         *
         **/
        createMany<T extends OrphansCreateManyArgs>(
            args?: SelectSubset<T, OrphansCreateManyArgs>
        ): PrismaPromise<BatchPayload>

        /**
         * Delete a Orphans.
         * @param {OrphansDeleteArgs} args - Arguments to delete one Orphans.
         * @example
         * // Delete one Orphans
         * const Orphans = await prisma.orphans.delete({
         *   where: {
         *     // ... filter to delete one Orphans
         *   }
         * })
         *
         **/
        delete<T extends OrphansDeleteArgs>(
            args: SelectSubset<T, OrphansDeleteArgs>
        ): Prisma__OrphansClient<OrphansGetPayload<T>>

        /**
         * Update one Orphans.
         * @param {OrphansUpdateArgs} args - Arguments to update one Orphans.
         * @example
         * // Update one Orphans
         * const orphans = await prisma.orphans.update({
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: {
         *     // ... provide data here
         *   }
         * })
         *
         **/
        update<T extends OrphansUpdateArgs>(
            args: SelectSubset<T, OrphansUpdateArgs>
        ): Prisma__OrphansClient<OrphansGetPayload<T>>

        /**
         * Delete zero or more Orphans.
         * @param {OrphansDeleteManyArgs} args - Arguments to filter Orphans to delete.
         * @example
         * // Delete a few Orphans
         * const { count } = await prisma.orphans.deleteMany({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         *
         **/
        deleteMany<T extends OrphansDeleteManyArgs>(
            args?: SelectSubset<T, OrphansDeleteManyArgs>
        ): PrismaPromise<BatchPayload>

        /**
         * Update zero or more Orphans.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {OrphansUpdateManyArgs} args - Arguments to update one or more rows.
         * @example
         * // Update many Orphans
         * const orphans = await prisma.orphans.updateMany({
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: {
         *     // ... provide data here
         *   }
         * })
         *
         **/
        updateMany<T extends OrphansUpdateManyArgs>(
            args: SelectSubset<T, OrphansUpdateManyArgs>
        ): PrismaPromise<BatchPayload>

        /**
         * Create or update one Orphans.
         * @param {OrphansUpsertArgs} args - Arguments to update or create a Orphans.
         * @example
         * // Update or create a Orphans
         * const orphans = await prisma.orphans.upsert({
         *   create: {
         *     // ... data to create a Orphans
         *   },
         *   update: {
         *     // ... in case it already exists, update
         *   },
         *   where: {
         *     // ... the filter for the Orphans we want to update
         *   }
         * })
         **/
        upsert<T extends OrphansUpsertArgs>(
            args: SelectSubset<T, OrphansUpsertArgs>
        ): Prisma__OrphansClient<OrphansGetPayload<T>>

        /**
         * Count the number of Orphans.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {OrphansCountArgs} args - Arguments to filter Orphans to count.
         * @example
         * // Count the number of Orphans
         * const count = await prisma.orphans.count({
         *   where: {
         *     // ... the filter for the Orphans we want to count
         *   }
         * })
         **/
        count<T extends OrphansCountArgs>(
            args?: Subset<T, OrphansCountArgs>
        ): PrismaPromise<
            T extends _Record<'select', any>
                ? T['select'] extends true
                    ? number
                    : GetScalarType<T['select'], OrphansCountAggregateOutputType>
                : number
        >

        /**
         * Allows you to perform aggregations operations on a Orphans.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {OrphansAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
         * @example
         * // Ordered by age ascending
         * // Where email contains prisma.io
         * // Limited to the 10 users
         * const aggregations = await prisma.user.aggregate({
         *   _avg: {
         *     age: true,
         *   },
         *   where: {
         *     email: {
         *       contains: "prisma.io",
         *     },
         *   },
         *   orderBy: {
         *     age: "asc",
         *   },
         *   take: 10,
         * })
         **/
        aggregate<T extends OrphansAggregateArgs>(
            args: Subset<T, OrphansAggregateArgs>
        ): PrismaPromise<GetOrphansAggregateType<T>>

        /**
         * Group by Orphans.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {OrphansGroupByArgs} args - Group by arguments.
         * @example
         * // Group by city, order by createdAt, get count
         * const result = await prisma.user.groupBy({
         *   by: ['city', 'createdAt'],
         *   orderBy: {
         *     createdAt: true
         *   },
         *   _count: {
         *     _all: true
         *   },
         * })
         *
         **/
        groupBy<
            T extends OrphansGroupByArgs,
            HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
            OrderByArg extends True extends HasSelectOrTake
                ? { orderBy: OrphansGroupByArgs['orderBy'] }
                : { orderBy?: OrphansGroupByArgs['orderBy'] },
            OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
            ByFields extends TupleToUnion<T['by']>,
            ByValid extends Has<ByFields, OrderFields>,
            HavingFields extends GetHavingFields<T['having']>,
            HavingValid extends Has<ByFields, HavingFields>,
            ByEmpty extends T['by'] extends never[] ? True : False,
            InputErrors extends ByEmpty extends True
                ? `Error: "by" must not be empty.`
                : HavingValid extends False
                  ? {
                        [P in HavingFields]: P extends ByFields
                            ? never
                            : P extends string
                              ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                              : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`]
                    }[HavingFields]
                  : 'take' extends Keys<T>
                    ? 'orderBy' extends Keys<T>
                        ? ByValid extends True
                            ? {}
                            : {
                                  [P in OrderFields]: P extends ByFields
                                      ? never
                                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                              }[OrderFields]
                        : 'Error: If you provide "take", you also need to provide "orderBy"'
                    : 'skip' extends Keys<T>
                      ? 'orderBy' extends Keys<T>
                          ? ByValid extends True
                              ? {}
                              : {
                                    [P in OrderFields]: P extends ByFields
                                        ? never
                                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                                }[OrderFields]
                          : 'Error: If you provide "skip", you also need to provide "orderBy"'
                      : ByValid extends True
                        ? {}
                        : {
                              [P in OrderFields]: P extends ByFields
                                  ? never
                                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                          }[OrderFields]
        >(
            args: SubsetIntersection<T, OrphansGroupByArgs, OrderByArg> & InputErrors
        ): {} extends InputErrors ? GetOrphansGroupByPayload<T> : PrismaPromise<InputErrors>
    }

    /**
     * The delegate class that acts as a "Promise-like" for Orphans.
     * Why is this prefixed with `Prisma__`?
     * Because we want to prevent naming conflicts as mentioned in
     * https://github.com/prisma/prisma-client-js/issues/707
     */
    export class Prisma__OrphansClient<T, Null = never> implements PrismaPromise<T> {
        [prisma]: true
        private readonly _dmmf
        private readonly _fetcher
        private readonly _queryType
        private readonly _rootField
        private readonly _clientMethod
        private readonly _args
        private readonly _dataPath
        private readonly _errorFormat
        private readonly _measurePerformance?
        private _isList
        private _callsite
        private _requestPromise?
        constructor(
            _dmmf: runtime.DMMFClass,
            _fetcher: PrismaClientFetcher,
            _queryType: 'query' | 'mutation',
            _rootField: string,
            _clientMethod: string,
            _args: any,
            _dataPath: string[],
            _errorFormat: ErrorFormat,
            _measurePerformance?: boolean | undefined,
            _isList?: boolean
        )
        readonly [Symbol.toStringTag]: 'PrismaClientPromise'

        orphan_sponsorship<T extends Orphans$orphan_sponsorshipArgs = {}>(
            args?: Subset<T, Orphans$orphan_sponsorshipArgs>
        ): PrismaPromise<Array<Orphan_sponsorshipGetPayload<T>> | Null>

        users_orphans_created_byTousers<T extends UsersArgs = {}>(
            args?: Subset<T, UsersArgs>
        ): Prisma__UsersClient<UsersGetPayload<T> | Null>

        users_orphans_deleted_byTousers<T extends UsersArgs = {}>(
            args?: Subset<T, UsersArgs>
        ): Prisma__UsersClient<UsersGetPayload<T> | Null>

        families<T extends FamiliesArgs = {}>(
            args?: Subset<T, FamiliesArgs>
        ): Prisma__FamiliesClient<FamiliesGetPayload<T> | Null>

        tenants<T extends TenantsArgs = {}>(
            args?: Subset<T, TenantsArgs>
        ): Prisma__TenantsClient<TenantsGetPayload<T> | Null>

        private get _document()
        /**
         * Attaches callbacks for the resolution and/or rejection of the Promise.
         * @param onfulfilled The callback to execute when the Promise is resolved.
         * @param onrejected The callback to execute when the Promise is rejected.
         * @returns A Promise for the completion of which ever callback is executed.
         */
        then<TResult1 = T, TResult2 = never>(
            onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
            onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
        ): Promise<TResult1 | TResult2>
        /**
         * Attaches a callback for only the rejection of the Promise.
         * @param onrejected The callback to execute when the Promise is rejected.
         * @returns A Promise for the completion of the callback.
         */
        catch<TResult = never>(
            onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
        ): Promise<T | TResult>
        /**
         * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
         * resolved value cannot be modified from the callback.
         * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
         * @returns A Promise for the completion of the callback.
         */
        finally(onfinally?: (() => void) | undefined | null): Promise<T>
    }

    // Custom InputTypes

    /**
     * Orphans base type for findUnique actions
     */
    export type OrphansFindUniqueArgsBase = {
        /**
         * Select specific fields to fetch from the Orphans
         *
         **/
        select?: OrphansSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: OrphansInclude | null
        /**
         * Filter, which Orphans to fetch.
         *
         **/
        where: OrphansWhereUniqueInput
    }

    /**
     * Orphans findUnique
     */
    export interface OrphansFindUniqueArgs extends OrphansFindUniqueArgsBase {
        /**
         * Throw an Error if query returns no results
         * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
         */
        rejectOnNotFound?: RejectOnNotFound
    }

    /**
     * Orphans findUniqueOrThrow
     */
    export type OrphansFindUniqueOrThrowArgs = {
        /**
         * Select specific fields to fetch from the Orphans
         *
         **/
        select?: OrphansSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: OrphansInclude | null
        /**
         * Filter, which Orphans to fetch.
         *
         **/
        where: OrphansWhereUniqueInput
    }

    /**
     * Orphans base type for findFirst actions
     */
    export type OrphansFindFirstArgsBase = {
        /**
         * Select specific fields to fetch from the Orphans
         *
         **/
        select?: OrphansSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: OrphansInclude | null
        /**
         * Filter, which Orphans to fetch.
         *
         **/
        where?: OrphansWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Orphans to fetch.
         *
         **/
        orderBy?: Enumerable<OrphansOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for searching for Orphans.
         *
         **/
        cursor?: OrphansWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Orphans from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Orphans.
         *
         **/
        skip?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
         *
         * Filter by unique combinations of Orphans.
         *
         **/
        distinct?: Enumerable<OrphansScalarFieldEnum>
    }

    /**
     * Orphans findFirst
     */
    export interface OrphansFindFirstArgs extends OrphansFindFirstArgsBase {
        /**
         * Throw an Error if query returns no results
         * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
         */
        rejectOnNotFound?: RejectOnNotFound
    }

    /**
     * Orphans findFirstOrThrow
     */
    export type OrphansFindFirstOrThrowArgs = {
        /**
         * Select specific fields to fetch from the Orphans
         *
         **/
        select?: OrphansSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: OrphansInclude | null
        /**
         * Filter, which Orphans to fetch.
         *
         **/
        where?: OrphansWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Orphans to fetch.
         *
         **/
        orderBy?: Enumerable<OrphansOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for searching for Orphans.
         *
         **/
        cursor?: OrphansWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Orphans from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Orphans.
         *
         **/
        skip?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
         *
         * Filter by unique combinations of Orphans.
         *
         **/
        distinct?: Enumerable<OrphansScalarFieldEnum>
    }

    /**
     * Orphans findMany
     */
    export type OrphansFindManyArgs = {
        /**
         * Select specific fields to fetch from the Orphans
         *
         **/
        select?: OrphansSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: OrphansInclude | null
        /**
         * Filter, which Orphans to fetch.
         *
         **/
        where?: OrphansWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Orphans to fetch.
         *
         **/
        orderBy?: Enumerable<OrphansOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for listing Orphans.
         *
         **/
        cursor?: OrphansWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Orphans from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Orphans.
         *
         **/
        skip?: number
        distinct?: Enumerable<OrphansScalarFieldEnum>
    }

    /**
     * Orphans create
     */
    export type OrphansCreateArgs = {
        /**
         * Select specific fields to fetch from the Orphans
         *
         **/
        select?: OrphansSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: OrphansInclude | null
        /**
         * The data needed to create a Orphans.
         *
         **/
        data: XOR<OrphansCreateInput, OrphansUncheckedCreateInput>
    }

    /**
     * Orphans createMany
     */
    export type OrphansCreateManyArgs = {
        /**
         * The data used to create many Orphans.
         *
         **/
        data: Enumerable<OrphansCreateManyInput>
        skipDuplicates?: boolean
    }

    /**
     * Orphans update
     */
    export type OrphansUpdateArgs = {
        /**
         * Select specific fields to fetch from the Orphans
         *
         **/
        select?: OrphansSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: OrphansInclude | null
        /**
         * The data needed to update a Orphans.
         *
         **/
        data: XOR<OrphansUpdateInput, OrphansUncheckedUpdateInput>
        /**
         * Choose, which Orphans to update.
         *
         **/
        where: OrphansWhereUniqueInput
    }

    /**
     * Orphans updateMany
     */
    export type OrphansUpdateManyArgs = {
        /**
         * The data used to update Orphans.
         *
         **/
        data: XOR<OrphansUpdateManyMutationInput, OrphansUncheckedUpdateManyInput>
        /**
         * Filter which Orphans to update
         *
         **/
        where?: OrphansWhereInput
    }

    /**
     * Orphans upsert
     */
    export type OrphansUpsertArgs = {
        /**
         * Select specific fields to fetch from the Orphans
         *
         **/
        select?: OrphansSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: OrphansInclude | null
        /**
         * The filter to search for the Orphans to update in case it exists.
         *
         **/
        where: OrphansWhereUniqueInput
        /**
         * In case the Orphans found by the `where` argument doesn't exist, create a new Orphans with this data.
         *
         **/
        create: XOR<OrphansCreateInput, OrphansUncheckedCreateInput>
        /**
         * In case the Orphans was found with the provided `where` argument, update it with this data.
         *
         **/
        update: XOR<OrphansUpdateInput, OrphansUncheckedUpdateInput>
    }

    /**
     * Orphans delete
     */
    export type OrphansDeleteArgs = {
        /**
         * Select specific fields to fetch from the Orphans
         *
         **/
        select?: OrphansSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: OrphansInclude | null
        /**
         * Filter which Orphans to delete.
         *
         **/
        where: OrphansWhereUniqueInput
    }

    /**
     * Orphans deleteMany
     */
    export type OrphansDeleteManyArgs = {
        /**
         * Filter which Orphans to delete
         *
         **/
        where?: OrphansWhereInput
    }

    /**
     * Orphans.orphan_sponsorship
     */
    export type Orphans$orphan_sponsorshipArgs = {
        /**
         * Select specific fields to fetch from the Orphan_sponsorship
         *
         **/
        select?: Orphan_sponsorshipSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Orphan_sponsorshipInclude | null
        where?: Orphan_sponsorshipWhereInput
        orderBy?: Enumerable<Orphan_sponsorshipOrderByWithRelationInput>
        cursor?: Orphan_sponsorshipWhereUniqueInput
        take?: number
        skip?: number
        distinct?: Enumerable<Orphan_sponsorshipScalarFieldEnum>
    }

    /**
     * Orphans without action
     */
    export type OrphansArgs = {
        /**
         * Select specific fields to fetch from the Orphans
         *
         **/
        select?: OrphansSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: OrphansInclude | null
    }

    /**
     * Model Password_reset_tokens
     */

    export type AggregatePassword_reset_tokens = {
        _count: Password_reset_tokensCountAggregateOutputType | null
        _min: Password_reset_tokensMinAggregateOutputType | null
        _max: Password_reset_tokensMaxAggregateOutputType | null
    }

    export type Password_reset_tokensMinAggregateOutputType = {
        email: string | null
        token: string | null
        created_at: Date | null
    }

    export type Password_reset_tokensMaxAggregateOutputType = {
        email: string | null
        token: string | null
        created_at: Date | null
    }

    export type Password_reset_tokensCountAggregateOutputType = {
        email: number
        token: number
        created_at: number
        _all: number
    }

    export type Password_reset_tokensMinAggregateInputType = {
        email?: true
        token?: true
        created_at?: true
    }

    export type Password_reset_tokensMaxAggregateInputType = {
        email?: true
        token?: true
        created_at?: true
    }

    export type Password_reset_tokensCountAggregateInputType = {
        email?: true
        token?: true
        created_at?: true
        _all?: true
    }

    export type Password_reset_tokensAggregateArgs = {
        /**
         * Filter which Password_reset_tokens to aggregate.
         *
         **/
        where?: Password_reset_tokensWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Password_reset_tokens to fetch.
         *
         **/
        orderBy?: Enumerable<Password_reset_tokensOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the start position
         *
         **/
        cursor?: Password_reset_tokensWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Password_reset_tokens from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Password_reset_tokens.
         *
         **/
        skip?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Count returned Password_reset_tokens
         **/
        _count?: true | Password_reset_tokensCountAggregateInputType
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to find the minimum value
         **/
        _min?: Password_reset_tokensMinAggregateInputType
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to find the maximum value
         **/
        _max?: Password_reset_tokensMaxAggregateInputType
    }

    export type GetPassword_reset_tokensAggregateType<T extends Password_reset_tokensAggregateArgs> = {
        [P in keyof T & keyof AggregatePassword_reset_tokens]: P extends '_count' | 'count'
            ? T[P] extends true
                ? number
                : GetScalarType<T[P], AggregatePassword_reset_tokens[P]>
            : GetScalarType<T[P], AggregatePassword_reset_tokens[P]>
    }

    export type Password_reset_tokensGroupByArgs = {
        where?: Password_reset_tokensWhereInput
        orderBy?: Enumerable<Password_reset_tokensOrderByWithAggregationInput>
        by: Array<Password_reset_tokensScalarFieldEnum>
        having?: Password_reset_tokensScalarWhereWithAggregatesInput
        take?: number
        skip?: number
        _count?: Password_reset_tokensCountAggregateInputType | true
        _min?: Password_reset_tokensMinAggregateInputType
        _max?: Password_reset_tokensMaxAggregateInputType
    }

    export type Password_reset_tokensGroupByOutputType = {
        email: string
        token: string
        created_at: Date | null
        _count: Password_reset_tokensCountAggregateOutputType | null
        _min: Password_reset_tokensMinAggregateOutputType | null
        _max: Password_reset_tokensMaxAggregateOutputType | null
    }

    type GetPassword_reset_tokensGroupByPayload<T extends Password_reset_tokensGroupByArgs> = PrismaPromise<
        Array<
            PickArray<Password_reset_tokensGroupByOutputType, T['by']> & {
                [P in keyof T & keyof Password_reset_tokensGroupByOutputType]: P extends '_count'
                    ? T[P] extends boolean
                        ? number
                        : GetScalarType<T[P], Password_reset_tokensGroupByOutputType[P]>
                    : GetScalarType<T[P], Password_reset_tokensGroupByOutputType[P]>
            }
        >
    >

    export type Password_reset_tokensSelect = {
        email?: boolean
        token?: boolean
        created_at?: boolean
    }

    export type Password_reset_tokensGetPayload<S extends boolean | null | undefined | Password_reset_tokensArgs> =
        S extends { select: any; include: any }
            ? 'Please either choose `select` or `include`'
            : S extends true
              ? Password_reset_tokens
              : S extends undefined
                ? never
                : S extends { include: any } & (Password_reset_tokensArgs | Password_reset_tokensFindManyArgs)
                  ? Password_reset_tokens
                  : S extends { select: any } & (Password_reset_tokensArgs | Password_reset_tokensFindManyArgs)
                    ? {
                          [P in TruthyKeys<S['select']>]: P extends keyof Password_reset_tokens
                              ? Password_reset_tokens[P]
                              : never
                      }
                    : Password_reset_tokens

    type Password_reset_tokensCountArgs = Merge<
        Omit<Password_reset_tokensFindManyArgs, 'select' | 'include'> & {
            select?: Password_reset_tokensCountAggregateInputType | true
        }
    >

    export interface Password_reset_tokensDelegate<
        GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined
    > {
        /**
         * Find zero or one Password_reset_tokens that matches the filter.
         * @param {Password_reset_tokensFindUniqueArgs} args - Arguments to find a Password_reset_tokens
         * @example
         * // Get one Password_reset_tokens
         * const password_reset_tokens = await prisma.password_reset_tokens.findUnique({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findUnique<
            T extends Password_reset_tokensFindUniqueArgs,
            LocalRejectSettings = T['rejectOnNotFound'] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined
        >(
            args: SelectSubset<T, Password_reset_tokensFindUniqueArgs>
        ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Password_reset_tokens'> extends True
            ? Prisma__Password_reset_tokensClient<Password_reset_tokensGetPayload<T>>
            : Prisma__Password_reset_tokensClient<Password_reset_tokensGetPayload<T> | null, null>

        /**
         * Find one Password_reset_tokens that matches the filter or throw an error  with `error.code='P2025'`
         *     if no matches were found.
         * @param {Password_reset_tokensFindUniqueOrThrowArgs} args - Arguments to find a Password_reset_tokens
         * @example
         * // Get one Password_reset_tokens
         * const password_reset_tokens = await prisma.password_reset_tokens.findUniqueOrThrow({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findUniqueOrThrow<T extends Password_reset_tokensFindUniqueOrThrowArgs>(
            args?: SelectSubset<T, Password_reset_tokensFindUniqueOrThrowArgs>
        ): Prisma__Password_reset_tokensClient<Password_reset_tokensGetPayload<T>>

        /**
         * Find the first Password_reset_tokens that matches the filter.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {Password_reset_tokensFindFirstArgs} args - Arguments to find a Password_reset_tokens
         * @example
         * // Get one Password_reset_tokens
         * const password_reset_tokens = await prisma.password_reset_tokens.findFirst({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findFirst<
            T extends Password_reset_tokensFindFirstArgs,
            LocalRejectSettings = T['rejectOnNotFound'] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined
        >(
            args?: SelectSubset<T, Password_reset_tokensFindFirstArgs>
        ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Password_reset_tokens'> extends True
            ? Prisma__Password_reset_tokensClient<Password_reset_tokensGetPayload<T>>
            : Prisma__Password_reset_tokensClient<Password_reset_tokensGetPayload<T> | null, null>

        /**
         * Find the first Password_reset_tokens that matches the filter or
         * throw `NotFoundError` if no matches were found.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {Password_reset_tokensFindFirstOrThrowArgs} args - Arguments to find a Password_reset_tokens
         * @example
         * // Get one Password_reset_tokens
         * const password_reset_tokens = await prisma.password_reset_tokens.findFirstOrThrow({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findFirstOrThrow<T extends Password_reset_tokensFindFirstOrThrowArgs>(
            args?: SelectSubset<T, Password_reset_tokensFindFirstOrThrowArgs>
        ): Prisma__Password_reset_tokensClient<Password_reset_tokensGetPayload<T>>

        /**
         * Find zero or more Password_reset_tokens that matches the filter.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {Password_reset_tokensFindManyArgs=} args - Arguments to filter and select certain fields only.
         * @example
         * // Get all Password_reset_tokens
         * const password_reset_tokens = await prisma.password_reset_tokens.findMany()
         *
         * // Get first 10 Password_reset_tokens
         * const password_reset_tokens = await prisma.password_reset_tokens.findMany({ take: 10 })
         *
         * // Only select the `email`
         * const password_reset_tokensWithEmailOnly = await prisma.password_reset_tokens.findMany({ select: { email: true } })
         *
         **/
        findMany<T extends Password_reset_tokensFindManyArgs>(
            args?: SelectSubset<T, Password_reset_tokensFindManyArgs>
        ): PrismaPromise<Array<Password_reset_tokensGetPayload<T>>>

        /**
         * Create a Password_reset_tokens.
         * @param {Password_reset_tokensCreateArgs} args - Arguments to create a Password_reset_tokens.
         * @example
         * // Create one Password_reset_tokens
         * const Password_reset_tokens = await prisma.password_reset_tokens.create({
         *   data: {
         *     // ... data to create a Password_reset_tokens
         *   }
         * })
         *
         **/
        create<T extends Password_reset_tokensCreateArgs>(
            args: SelectSubset<T, Password_reset_tokensCreateArgs>
        ): Prisma__Password_reset_tokensClient<Password_reset_tokensGetPayload<T>>

        /**
         * Create many Password_reset_tokens.
         *     @param {Password_reset_tokensCreateManyArgs} args - Arguments to create many Password_reset_tokens.
         *     @example
         *     // Create many Password_reset_tokens
         *     const password_reset_tokens = await prisma.password_reset_tokens.createMany({
         *       data: {
         *         // ... provide data here
         *       }
         *     })
         *
         **/
        createMany<T extends Password_reset_tokensCreateManyArgs>(
            args?: SelectSubset<T, Password_reset_tokensCreateManyArgs>
        ): PrismaPromise<BatchPayload>

        /**
         * Delete a Password_reset_tokens.
         * @param {Password_reset_tokensDeleteArgs} args - Arguments to delete one Password_reset_tokens.
         * @example
         * // Delete one Password_reset_tokens
         * const Password_reset_tokens = await prisma.password_reset_tokens.delete({
         *   where: {
         *     // ... filter to delete one Password_reset_tokens
         *   }
         * })
         *
         **/
        delete<T extends Password_reset_tokensDeleteArgs>(
            args: SelectSubset<T, Password_reset_tokensDeleteArgs>
        ): Prisma__Password_reset_tokensClient<Password_reset_tokensGetPayload<T>>

        /**
         * Update one Password_reset_tokens.
         * @param {Password_reset_tokensUpdateArgs} args - Arguments to update one Password_reset_tokens.
         * @example
         * // Update one Password_reset_tokens
         * const password_reset_tokens = await prisma.password_reset_tokens.update({
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: {
         *     // ... provide data here
         *   }
         * })
         *
         **/
        update<T extends Password_reset_tokensUpdateArgs>(
            args: SelectSubset<T, Password_reset_tokensUpdateArgs>
        ): Prisma__Password_reset_tokensClient<Password_reset_tokensGetPayload<T>>

        /**
         * Delete zero or more Password_reset_tokens.
         * @param {Password_reset_tokensDeleteManyArgs} args - Arguments to filter Password_reset_tokens to delete.
         * @example
         * // Delete a few Password_reset_tokens
         * const { count } = await prisma.password_reset_tokens.deleteMany({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         *
         **/
        deleteMany<T extends Password_reset_tokensDeleteManyArgs>(
            args?: SelectSubset<T, Password_reset_tokensDeleteManyArgs>
        ): PrismaPromise<BatchPayload>

        /**
         * Update zero or more Password_reset_tokens.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {Password_reset_tokensUpdateManyArgs} args - Arguments to update one or more rows.
         * @example
         * // Update many Password_reset_tokens
         * const password_reset_tokens = await prisma.password_reset_tokens.updateMany({
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: {
         *     // ... provide data here
         *   }
         * })
         *
         **/
        updateMany<T extends Password_reset_tokensUpdateManyArgs>(
            args: SelectSubset<T, Password_reset_tokensUpdateManyArgs>
        ): PrismaPromise<BatchPayload>

        /**
         * Create or update one Password_reset_tokens.
         * @param {Password_reset_tokensUpsertArgs} args - Arguments to update or create a Password_reset_tokens.
         * @example
         * // Update or create a Password_reset_tokens
         * const password_reset_tokens = await prisma.password_reset_tokens.upsert({
         *   create: {
         *     // ... data to create a Password_reset_tokens
         *   },
         *   update: {
         *     // ... in case it already exists, update
         *   },
         *   where: {
         *     // ... the filter for the Password_reset_tokens we want to update
         *   }
         * })
         **/
        upsert<T extends Password_reset_tokensUpsertArgs>(
            args: SelectSubset<T, Password_reset_tokensUpsertArgs>
        ): Prisma__Password_reset_tokensClient<Password_reset_tokensGetPayload<T>>

        /**
         * Count the number of Password_reset_tokens.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {Password_reset_tokensCountArgs} args - Arguments to filter Password_reset_tokens to count.
         * @example
         * // Count the number of Password_reset_tokens
         * const count = await prisma.password_reset_tokens.count({
         *   where: {
         *     // ... the filter for the Password_reset_tokens we want to count
         *   }
         * })
         **/
        count<T extends Password_reset_tokensCountArgs>(
            args?: Subset<T, Password_reset_tokensCountArgs>
        ): PrismaPromise<
            T extends _Record<'select', any>
                ? T['select'] extends true
                    ? number
                    : GetScalarType<T['select'], Password_reset_tokensCountAggregateOutputType>
                : number
        >

        /**
         * Allows you to perform aggregations operations on a Password_reset_tokens.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {Password_reset_tokensAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
         * @example
         * // Ordered by age ascending
         * // Where email contains prisma.io
         * // Limited to the 10 users
         * const aggregations = await prisma.user.aggregate({
         *   _avg: {
         *     age: true,
         *   },
         *   where: {
         *     email: {
         *       contains: "prisma.io",
         *     },
         *   },
         *   orderBy: {
         *     age: "asc",
         *   },
         *   take: 10,
         * })
         **/
        aggregate<T extends Password_reset_tokensAggregateArgs>(
            args: Subset<T, Password_reset_tokensAggregateArgs>
        ): PrismaPromise<GetPassword_reset_tokensAggregateType<T>>

        /**
         * Group by Password_reset_tokens.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {Password_reset_tokensGroupByArgs} args - Group by arguments.
         * @example
         * // Group by city, order by createdAt, get count
         * const result = await prisma.user.groupBy({
         *   by: ['city', 'createdAt'],
         *   orderBy: {
         *     createdAt: true
         *   },
         *   _count: {
         *     _all: true
         *   },
         * })
         *
         **/
        groupBy<
            T extends Password_reset_tokensGroupByArgs,
            HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
            OrderByArg extends True extends HasSelectOrTake
                ? { orderBy: Password_reset_tokensGroupByArgs['orderBy'] }
                : { orderBy?: Password_reset_tokensGroupByArgs['orderBy'] },
            OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
            ByFields extends TupleToUnion<T['by']>,
            ByValid extends Has<ByFields, OrderFields>,
            HavingFields extends GetHavingFields<T['having']>,
            HavingValid extends Has<ByFields, HavingFields>,
            ByEmpty extends T['by'] extends never[] ? True : False,
            InputErrors extends ByEmpty extends True
                ? `Error: "by" must not be empty.`
                : HavingValid extends False
                  ? {
                        [P in HavingFields]: P extends ByFields
                            ? never
                            : P extends string
                              ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                              : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`]
                    }[HavingFields]
                  : 'take' extends Keys<T>
                    ? 'orderBy' extends Keys<T>
                        ? ByValid extends True
                            ? {}
                            : {
                                  [P in OrderFields]: P extends ByFields
                                      ? never
                                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                              }[OrderFields]
                        : 'Error: If you provide "take", you also need to provide "orderBy"'
                    : 'skip' extends Keys<T>
                      ? 'orderBy' extends Keys<T>
                          ? ByValid extends True
                              ? {}
                              : {
                                    [P in OrderFields]: P extends ByFields
                                        ? never
                                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                                }[OrderFields]
                          : 'Error: If you provide "skip", you also need to provide "orderBy"'
                      : ByValid extends True
                        ? {}
                        : {
                              [P in OrderFields]: P extends ByFields
                                  ? never
                                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                          }[OrderFields]
        >(
            args: SubsetIntersection<T, Password_reset_tokensGroupByArgs, OrderByArg> & InputErrors
        ): {} extends InputErrors ? GetPassword_reset_tokensGroupByPayload<T> : PrismaPromise<InputErrors>
    }

    /**
     * The delegate class that acts as a "Promise-like" for Password_reset_tokens.
     * Why is this prefixed with `Prisma__`?
     * Because we want to prevent naming conflicts as mentioned in
     * https://github.com/prisma/prisma-client-js/issues/707
     */
    export class Prisma__Password_reset_tokensClient<T, Null = never> implements PrismaPromise<T> {
        [prisma]: true
        private readonly _dmmf
        private readonly _fetcher
        private readonly _queryType
        private readonly _rootField
        private readonly _clientMethod
        private readonly _args
        private readonly _dataPath
        private readonly _errorFormat
        private readonly _measurePerformance?
        private _isList
        private _callsite
        private _requestPromise?
        constructor(
            _dmmf: runtime.DMMFClass,
            _fetcher: PrismaClientFetcher,
            _queryType: 'query' | 'mutation',
            _rootField: string,
            _clientMethod: string,
            _args: any,
            _dataPath: string[],
            _errorFormat: ErrorFormat,
            _measurePerformance?: boolean | undefined,
            _isList?: boolean
        )
        readonly [Symbol.toStringTag]: 'PrismaClientPromise'

        private get _document()
        /**
         * Attaches callbacks for the resolution and/or rejection of the Promise.
         * @param onfulfilled The callback to execute when the Promise is resolved.
         * @param onrejected The callback to execute when the Promise is rejected.
         * @returns A Promise for the completion of which ever callback is executed.
         */
        then<TResult1 = T, TResult2 = never>(
            onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
            onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
        ): Promise<TResult1 | TResult2>
        /**
         * Attaches a callback for only the rejection of the Promise.
         * @param onrejected The callback to execute when the Promise is rejected.
         * @returns A Promise for the completion of the callback.
         */
        catch<TResult = never>(
            onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
        ): Promise<T | TResult>
        /**
         * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
         * resolved value cannot be modified from the callback.
         * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
         * @returns A Promise for the completion of the callback.
         */
        finally(onfinally?: (() => void) | undefined | null): Promise<T>
    }

    // Custom InputTypes

    /**
     * Password_reset_tokens base type for findUnique actions
     */
    export type Password_reset_tokensFindUniqueArgsBase = {
        /**
         * Select specific fields to fetch from the Password_reset_tokens
         *
         **/
        select?: Password_reset_tokensSelect | null
        /**
         * Filter, which Password_reset_tokens to fetch.
         *
         **/
        where: Password_reset_tokensWhereUniqueInput
    }

    /**
     * Password_reset_tokens findUnique
     */
    export interface Password_reset_tokensFindUniqueArgs extends Password_reset_tokensFindUniqueArgsBase {
        /**
         * Throw an Error if query returns no results
         * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
         */
        rejectOnNotFound?: RejectOnNotFound
    }

    /**
     * Password_reset_tokens findUniqueOrThrow
     */
    export type Password_reset_tokensFindUniqueOrThrowArgs = {
        /**
         * Select specific fields to fetch from the Password_reset_tokens
         *
         **/
        select?: Password_reset_tokensSelect | null
        /**
         * Filter, which Password_reset_tokens to fetch.
         *
         **/
        where: Password_reset_tokensWhereUniqueInput
    }

    /**
     * Password_reset_tokens base type for findFirst actions
     */
    export type Password_reset_tokensFindFirstArgsBase = {
        /**
         * Select specific fields to fetch from the Password_reset_tokens
         *
         **/
        select?: Password_reset_tokensSelect | null
        /**
         * Filter, which Password_reset_tokens to fetch.
         *
         **/
        where?: Password_reset_tokensWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Password_reset_tokens to fetch.
         *
         **/
        orderBy?: Enumerable<Password_reset_tokensOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for searching for Password_reset_tokens.
         *
         **/
        cursor?: Password_reset_tokensWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Password_reset_tokens from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Password_reset_tokens.
         *
         **/
        skip?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
         *
         * Filter by unique combinations of Password_reset_tokens.
         *
         **/
        distinct?: Enumerable<Password_reset_tokensScalarFieldEnum>
    }

    /**
     * Password_reset_tokens findFirst
     */
    export interface Password_reset_tokensFindFirstArgs extends Password_reset_tokensFindFirstArgsBase {
        /**
         * Throw an Error if query returns no results
         * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
         */
        rejectOnNotFound?: RejectOnNotFound
    }

    /**
     * Password_reset_tokens findFirstOrThrow
     */
    export type Password_reset_tokensFindFirstOrThrowArgs = {
        /**
         * Select specific fields to fetch from the Password_reset_tokens
         *
         **/
        select?: Password_reset_tokensSelect | null
        /**
         * Filter, which Password_reset_tokens to fetch.
         *
         **/
        where?: Password_reset_tokensWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Password_reset_tokens to fetch.
         *
         **/
        orderBy?: Enumerable<Password_reset_tokensOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for searching for Password_reset_tokens.
         *
         **/
        cursor?: Password_reset_tokensWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Password_reset_tokens from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Password_reset_tokens.
         *
         **/
        skip?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
         *
         * Filter by unique combinations of Password_reset_tokens.
         *
         **/
        distinct?: Enumerable<Password_reset_tokensScalarFieldEnum>
    }

    /**
     * Password_reset_tokens findMany
     */
    export type Password_reset_tokensFindManyArgs = {
        /**
         * Select specific fields to fetch from the Password_reset_tokens
         *
         **/
        select?: Password_reset_tokensSelect | null
        /**
         * Filter, which Password_reset_tokens to fetch.
         *
         **/
        where?: Password_reset_tokensWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Password_reset_tokens to fetch.
         *
         **/
        orderBy?: Enumerable<Password_reset_tokensOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for listing Password_reset_tokens.
         *
         **/
        cursor?: Password_reset_tokensWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Password_reset_tokens from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Password_reset_tokens.
         *
         **/
        skip?: number
        distinct?: Enumerable<Password_reset_tokensScalarFieldEnum>
    }

    /**
     * Password_reset_tokens create
     */
    export type Password_reset_tokensCreateArgs = {
        /**
         * Select specific fields to fetch from the Password_reset_tokens
         *
         **/
        select?: Password_reset_tokensSelect | null
        /**
         * The data needed to create a Password_reset_tokens.
         *
         **/
        data: XOR<Password_reset_tokensCreateInput, Password_reset_tokensUncheckedCreateInput>
    }

    /**
     * Password_reset_tokens createMany
     */
    export type Password_reset_tokensCreateManyArgs = {
        /**
         * The data used to create many Password_reset_tokens.
         *
         **/
        data: Enumerable<Password_reset_tokensCreateManyInput>
        skipDuplicates?: boolean
    }

    /**
     * Password_reset_tokens update
     */
    export type Password_reset_tokensUpdateArgs = {
        /**
         * Select specific fields to fetch from the Password_reset_tokens
         *
         **/
        select?: Password_reset_tokensSelect | null
        /**
         * The data needed to update a Password_reset_tokens.
         *
         **/
        data: XOR<Password_reset_tokensUpdateInput, Password_reset_tokensUncheckedUpdateInput>
        /**
         * Choose, which Password_reset_tokens to update.
         *
         **/
        where: Password_reset_tokensWhereUniqueInput
    }

    /**
     * Password_reset_tokens updateMany
     */
    export type Password_reset_tokensUpdateManyArgs = {
        /**
         * The data used to update Password_reset_tokens.
         *
         **/
        data: XOR<Password_reset_tokensUpdateManyMutationInput, Password_reset_tokensUncheckedUpdateManyInput>
        /**
         * Filter which Password_reset_tokens to update
         *
         **/
        where?: Password_reset_tokensWhereInput
    }

    /**
     * Password_reset_tokens upsert
     */
    export type Password_reset_tokensUpsertArgs = {
        /**
         * Select specific fields to fetch from the Password_reset_tokens
         *
         **/
        select?: Password_reset_tokensSelect | null
        /**
         * The filter to search for the Password_reset_tokens to update in case it exists.
         *
         **/
        where: Password_reset_tokensWhereUniqueInput
        /**
         * In case the Password_reset_tokens found by the `where` argument doesn't exist, create a new Password_reset_tokens with this data.
         *
         **/
        create: XOR<Password_reset_tokensCreateInput, Password_reset_tokensUncheckedCreateInput>
        /**
         * In case the Password_reset_tokens was found with the provided `where` argument, update it with this data.
         *
         **/
        update: XOR<Password_reset_tokensUpdateInput, Password_reset_tokensUncheckedUpdateInput>
    }

    /**
     * Password_reset_tokens delete
     */
    export type Password_reset_tokensDeleteArgs = {
        /**
         * Select specific fields to fetch from the Password_reset_tokens
         *
         **/
        select?: Password_reset_tokensSelect | null
        /**
         * Filter which Password_reset_tokens to delete.
         *
         **/
        where: Password_reset_tokensWhereUniqueInput
    }

    /**
     * Password_reset_tokens deleteMany
     */
    export type Password_reset_tokensDeleteManyArgs = {
        /**
         * Filter which Password_reset_tokens to delete
         *
         **/
        where?: Password_reset_tokensWhereInput
    }

    /**
     * Password_reset_tokens without action
     */
    export type Password_reset_tokensArgs = {
        /**
         * Select specific fields to fetch from the Password_reset_tokens
         *
         **/
        select?: Password_reset_tokensSelect | null
    }

    /**
     * Model Permissions
     */

    export type AggregatePermissions = {
        _count: PermissionsCountAggregateOutputType | null
        _min: PermissionsMinAggregateOutputType | null
        _max: PermissionsMaxAggregateOutputType | null
    }

    export type PermissionsMinAggregateOutputType = {
        uuid: string | null
        name: string | null
        guard_name: string | null
        created_at: Date | null
        updated_at: Date | null
    }

    export type PermissionsMaxAggregateOutputType = {
        uuid: string | null
        name: string | null
        guard_name: string | null
        created_at: Date | null
        updated_at: Date | null
    }

    export type PermissionsCountAggregateOutputType = {
        uuid: number
        name: number
        guard_name: number
        created_at: number
        updated_at: number
        _all: number
    }

    export type PermissionsMinAggregateInputType = {
        uuid?: true
        name?: true
        guard_name?: true
        created_at?: true
        updated_at?: true
    }

    export type PermissionsMaxAggregateInputType = {
        uuid?: true
        name?: true
        guard_name?: true
        created_at?: true
        updated_at?: true
    }

    export type PermissionsCountAggregateInputType = {
        uuid?: true
        name?: true
        guard_name?: true
        created_at?: true
        updated_at?: true
        _all?: true
    }

    export type PermissionsAggregateArgs = {
        /**
         * Filter which Permissions to aggregate.
         *
         **/
        where?: PermissionsWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Permissions to fetch.
         *
         **/
        orderBy?: Enumerable<PermissionsOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the start position
         *
         **/
        cursor?: PermissionsWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Permissions from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Permissions.
         *
         **/
        skip?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Count returned Permissions
         **/
        _count?: true | PermissionsCountAggregateInputType
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to find the minimum value
         **/
        _min?: PermissionsMinAggregateInputType
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to find the maximum value
         **/
        _max?: PermissionsMaxAggregateInputType
    }

    export type GetPermissionsAggregateType<T extends PermissionsAggregateArgs> = {
        [P in keyof T & keyof AggregatePermissions]: P extends '_count' | 'count'
            ? T[P] extends true
                ? number
                : GetScalarType<T[P], AggregatePermissions[P]>
            : GetScalarType<T[P], AggregatePermissions[P]>
    }

    export type PermissionsGroupByArgs = {
        where?: PermissionsWhereInput
        orderBy?: Enumerable<PermissionsOrderByWithAggregationInput>
        by: Array<PermissionsScalarFieldEnum>
        having?: PermissionsScalarWhereWithAggregatesInput
        take?: number
        skip?: number
        _count?: PermissionsCountAggregateInputType | true
        _min?: PermissionsMinAggregateInputType
        _max?: PermissionsMaxAggregateInputType
    }

    export type PermissionsGroupByOutputType = {
        uuid: string
        name: string
        guard_name: string
        created_at: Date | null
        updated_at: Date | null
        _count: PermissionsCountAggregateOutputType | null
        _min: PermissionsMinAggregateOutputType | null
        _max: PermissionsMaxAggregateOutputType | null
    }

    type GetPermissionsGroupByPayload<T extends PermissionsGroupByArgs> = PrismaPromise<
        Array<
            PickArray<PermissionsGroupByOutputType, T['by']> & {
                [P in keyof T & keyof PermissionsGroupByOutputType]: P extends '_count'
                    ? T[P] extends boolean
                        ? number
                        : GetScalarType<T[P], PermissionsGroupByOutputType[P]>
                    : GetScalarType<T[P], PermissionsGroupByOutputType[P]>
            }
        >
    >

    export type PermissionsSelect = {
        uuid?: boolean
        name?: boolean
        guard_name?: boolean
        created_at?: boolean
        updated_at?: boolean
        model_has_permissions?: boolean | Permissions$model_has_permissionsArgs
        role_has_permissions?: boolean | Permissions$role_has_permissionsArgs
        _count?: boolean | PermissionsCountOutputTypeArgs
    }

    export type PermissionsInclude = {
        model_has_permissions?: boolean | Permissions$model_has_permissionsArgs
        role_has_permissions?: boolean | Permissions$role_has_permissionsArgs
        _count?: boolean | PermissionsCountOutputTypeArgs
    }

    export type PermissionsGetPayload<S extends boolean | null | undefined | PermissionsArgs> = S extends {
        select: any
        include: any
    }
        ? 'Please either choose `select` or `include`'
        : S extends true
          ? Permissions
          : S extends undefined
            ? never
            : S extends { include: any } & (PermissionsArgs | PermissionsFindManyArgs)
              ? Permissions & {
                    [P in TruthyKeys<S['include']>]: P extends 'model_has_permissions'
                        ? Array<Model_has_permissionsGetPayload<S['include'][P]>>
                        : P extends 'role_has_permissions'
                          ? Array<Role_has_permissionsGetPayload<S['include'][P]>>
                          : P extends '_count'
                            ? PermissionsCountOutputTypeGetPayload<S['include'][P]>
                            : never
                }
              : S extends { select: any } & (PermissionsArgs | PermissionsFindManyArgs)
                ? {
                      [P in TruthyKeys<S['select']>]: P extends 'model_has_permissions'
                          ? Array<Model_has_permissionsGetPayload<S['select'][P]>>
                          : P extends 'role_has_permissions'
                            ? Array<Role_has_permissionsGetPayload<S['select'][P]>>
                            : P extends '_count'
                              ? PermissionsCountOutputTypeGetPayload<S['select'][P]>
                              : P extends keyof Permissions
                                ? Permissions[P]
                                : never
                  }
                : Permissions

    type PermissionsCountArgs = Merge<
        Omit<PermissionsFindManyArgs, 'select' | 'include'> & {
            select?: PermissionsCountAggregateInputType | true
        }
    >

    export interface PermissionsDelegate<
        GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined
    > {
        /**
         * Find zero or one Permissions that matches the filter.
         * @param {PermissionsFindUniqueArgs} args - Arguments to find a Permissions
         * @example
         * // Get one Permissions
         * const permissions = await prisma.permissions.findUnique({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findUnique<
            T extends PermissionsFindUniqueArgs,
            LocalRejectSettings = T['rejectOnNotFound'] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined
        >(
            args: SelectSubset<T, PermissionsFindUniqueArgs>
        ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Permissions'> extends True
            ? Prisma__PermissionsClient<PermissionsGetPayload<T>>
            : Prisma__PermissionsClient<PermissionsGetPayload<T> | null, null>

        /**
         * Find one Permissions that matches the filter or throw an error  with `error.code='P2025'`
         *     if no matches were found.
         * @param {PermissionsFindUniqueOrThrowArgs} args - Arguments to find a Permissions
         * @example
         * // Get one Permissions
         * const permissions = await prisma.permissions.findUniqueOrThrow({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findUniqueOrThrow<T extends PermissionsFindUniqueOrThrowArgs>(
            args?: SelectSubset<T, PermissionsFindUniqueOrThrowArgs>
        ): Prisma__PermissionsClient<PermissionsGetPayload<T>>

        /**
         * Find the first Permissions that matches the filter.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {PermissionsFindFirstArgs} args - Arguments to find a Permissions
         * @example
         * // Get one Permissions
         * const permissions = await prisma.permissions.findFirst({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findFirst<
            T extends PermissionsFindFirstArgs,
            LocalRejectSettings = T['rejectOnNotFound'] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined
        >(
            args?: SelectSubset<T, PermissionsFindFirstArgs>
        ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Permissions'> extends True
            ? Prisma__PermissionsClient<PermissionsGetPayload<T>>
            : Prisma__PermissionsClient<PermissionsGetPayload<T> | null, null>

        /**
         * Find the first Permissions that matches the filter or
         * throw `NotFoundError` if no matches were found.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {PermissionsFindFirstOrThrowArgs} args - Arguments to find a Permissions
         * @example
         * // Get one Permissions
         * const permissions = await prisma.permissions.findFirstOrThrow({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findFirstOrThrow<T extends PermissionsFindFirstOrThrowArgs>(
            args?: SelectSubset<T, PermissionsFindFirstOrThrowArgs>
        ): Prisma__PermissionsClient<PermissionsGetPayload<T>>

        /**
         * Find zero or more Permissions that matches the filter.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {PermissionsFindManyArgs=} args - Arguments to filter and select certain fields only.
         * @example
         * // Get all Permissions
         * const permissions = await prisma.permissions.findMany()
         *
         * // Get first 10 Permissions
         * const permissions = await prisma.permissions.findMany({ take: 10 })
         *
         * // Only select the `uuid`
         * const permissionsWithUuidOnly = await prisma.permissions.findMany({ select: { uuid: true } })
         *
         **/
        findMany<T extends PermissionsFindManyArgs>(
            args?: SelectSubset<T, PermissionsFindManyArgs>
        ): PrismaPromise<Array<PermissionsGetPayload<T>>>

        /**
         * Create a Permissions.
         * @param {PermissionsCreateArgs} args - Arguments to create a Permissions.
         * @example
         * // Create one Permissions
         * const Permissions = await prisma.permissions.create({
         *   data: {
         *     // ... data to create a Permissions
         *   }
         * })
         *
         **/
        create<T extends PermissionsCreateArgs>(
            args: SelectSubset<T, PermissionsCreateArgs>
        ): Prisma__PermissionsClient<PermissionsGetPayload<T>>

        /**
         * Create many Permissions.
         *     @param {PermissionsCreateManyArgs} args - Arguments to create many Permissions.
         *     @example
         *     // Create many Permissions
         *     const permissions = await prisma.permissions.createMany({
         *       data: {
         *         // ... provide data here
         *       }
         *     })
         *
         **/
        createMany<T extends PermissionsCreateManyArgs>(
            args?: SelectSubset<T, PermissionsCreateManyArgs>
        ): PrismaPromise<BatchPayload>

        /**
         * Delete a Permissions.
         * @param {PermissionsDeleteArgs} args - Arguments to delete one Permissions.
         * @example
         * // Delete one Permissions
         * const Permissions = await prisma.permissions.delete({
         *   where: {
         *     // ... filter to delete one Permissions
         *   }
         * })
         *
         **/
        delete<T extends PermissionsDeleteArgs>(
            args: SelectSubset<T, PermissionsDeleteArgs>
        ): Prisma__PermissionsClient<PermissionsGetPayload<T>>

        /**
         * Update one Permissions.
         * @param {PermissionsUpdateArgs} args - Arguments to update one Permissions.
         * @example
         * // Update one Permissions
         * const permissions = await prisma.permissions.update({
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: {
         *     // ... provide data here
         *   }
         * })
         *
         **/
        update<T extends PermissionsUpdateArgs>(
            args: SelectSubset<T, PermissionsUpdateArgs>
        ): Prisma__PermissionsClient<PermissionsGetPayload<T>>

        /**
         * Delete zero or more Permissions.
         * @param {PermissionsDeleteManyArgs} args - Arguments to filter Permissions to delete.
         * @example
         * // Delete a few Permissions
         * const { count } = await prisma.permissions.deleteMany({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         *
         **/
        deleteMany<T extends PermissionsDeleteManyArgs>(
            args?: SelectSubset<T, PermissionsDeleteManyArgs>
        ): PrismaPromise<BatchPayload>

        /**
         * Update zero or more Permissions.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {PermissionsUpdateManyArgs} args - Arguments to update one or more rows.
         * @example
         * // Update many Permissions
         * const permissions = await prisma.permissions.updateMany({
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: {
         *     // ... provide data here
         *   }
         * })
         *
         **/
        updateMany<T extends PermissionsUpdateManyArgs>(
            args: SelectSubset<T, PermissionsUpdateManyArgs>
        ): PrismaPromise<BatchPayload>

        /**
         * Create or update one Permissions.
         * @param {PermissionsUpsertArgs} args - Arguments to update or create a Permissions.
         * @example
         * // Update or create a Permissions
         * const permissions = await prisma.permissions.upsert({
         *   create: {
         *     // ... data to create a Permissions
         *   },
         *   update: {
         *     // ... in case it already exists, update
         *   },
         *   where: {
         *     // ... the filter for the Permissions we want to update
         *   }
         * })
         **/
        upsert<T extends PermissionsUpsertArgs>(
            args: SelectSubset<T, PermissionsUpsertArgs>
        ): Prisma__PermissionsClient<PermissionsGetPayload<T>>

        /**
         * Count the number of Permissions.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {PermissionsCountArgs} args - Arguments to filter Permissions to count.
         * @example
         * // Count the number of Permissions
         * const count = await prisma.permissions.count({
         *   where: {
         *     // ... the filter for the Permissions we want to count
         *   }
         * })
         **/
        count<T extends PermissionsCountArgs>(
            args?: Subset<T, PermissionsCountArgs>
        ): PrismaPromise<
            T extends _Record<'select', any>
                ? T['select'] extends true
                    ? number
                    : GetScalarType<T['select'], PermissionsCountAggregateOutputType>
                : number
        >

        /**
         * Allows you to perform aggregations operations on a Permissions.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {PermissionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
         * @example
         * // Ordered by age ascending
         * // Where email contains prisma.io
         * // Limited to the 10 users
         * const aggregations = await prisma.user.aggregate({
         *   _avg: {
         *     age: true,
         *   },
         *   where: {
         *     email: {
         *       contains: "prisma.io",
         *     },
         *   },
         *   orderBy: {
         *     age: "asc",
         *   },
         *   take: 10,
         * })
         **/
        aggregate<T extends PermissionsAggregateArgs>(
            args: Subset<T, PermissionsAggregateArgs>
        ): PrismaPromise<GetPermissionsAggregateType<T>>

        /**
         * Group by Permissions.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {PermissionsGroupByArgs} args - Group by arguments.
         * @example
         * // Group by city, order by createdAt, get count
         * const result = await prisma.user.groupBy({
         *   by: ['city', 'createdAt'],
         *   orderBy: {
         *     createdAt: true
         *   },
         *   _count: {
         *     _all: true
         *   },
         * })
         *
         **/
        groupBy<
            T extends PermissionsGroupByArgs,
            HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
            OrderByArg extends True extends HasSelectOrTake
                ? { orderBy: PermissionsGroupByArgs['orderBy'] }
                : { orderBy?: PermissionsGroupByArgs['orderBy'] },
            OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
            ByFields extends TupleToUnion<T['by']>,
            ByValid extends Has<ByFields, OrderFields>,
            HavingFields extends GetHavingFields<T['having']>,
            HavingValid extends Has<ByFields, HavingFields>,
            ByEmpty extends T['by'] extends never[] ? True : False,
            InputErrors extends ByEmpty extends True
                ? `Error: "by" must not be empty.`
                : HavingValid extends False
                  ? {
                        [P in HavingFields]: P extends ByFields
                            ? never
                            : P extends string
                              ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                              : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`]
                    }[HavingFields]
                  : 'take' extends Keys<T>
                    ? 'orderBy' extends Keys<T>
                        ? ByValid extends True
                            ? {}
                            : {
                                  [P in OrderFields]: P extends ByFields
                                      ? never
                                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                              }[OrderFields]
                        : 'Error: If you provide "take", you also need to provide "orderBy"'
                    : 'skip' extends Keys<T>
                      ? 'orderBy' extends Keys<T>
                          ? ByValid extends True
                              ? {}
                              : {
                                    [P in OrderFields]: P extends ByFields
                                        ? never
                                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                                }[OrderFields]
                          : 'Error: If you provide "skip", you also need to provide "orderBy"'
                      : ByValid extends True
                        ? {}
                        : {
                              [P in OrderFields]: P extends ByFields
                                  ? never
                                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                          }[OrderFields]
        >(
            args: SubsetIntersection<T, PermissionsGroupByArgs, OrderByArg> & InputErrors
        ): {} extends InputErrors ? GetPermissionsGroupByPayload<T> : PrismaPromise<InputErrors>
    }

    /**
     * The delegate class that acts as a "Promise-like" for Permissions.
     * Why is this prefixed with `Prisma__`?
     * Because we want to prevent naming conflicts as mentioned in
     * https://github.com/prisma/prisma-client-js/issues/707
     */
    export class Prisma__PermissionsClient<T, Null = never> implements PrismaPromise<T> {
        [prisma]: true
        private readonly _dmmf
        private readonly _fetcher
        private readonly _queryType
        private readonly _rootField
        private readonly _clientMethod
        private readonly _args
        private readonly _dataPath
        private readonly _errorFormat
        private readonly _measurePerformance?
        private _isList
        private _callsite
        private _requestPromise?
        constructor(
            _dmmf: runtime.DMMFClass,
            _fetcher: PrismaClientFetcher,
            _queryType: 'query' | 'mutation',
            _rootField: string,
            _clientMethod: string,
            _args: any,
            _dataPath: string[],
            _errorFormat: ErrorFormat,
            _measurePerformance?: boolean | undefined,
            _isList?: boolean
        )
        readonly [Symbol.toStringTag]: 'PrismaClientPromise'

        model_has_permissions<T extends Permissions$model_has_permissionsArgs = {}>(
            args?: Subset<T, Permissions$model_has_permissionsArgs>
        ): PrismaPromise<Array<Model_has_permissionsGetPayload<T>> | Null>

        role_has_permissions<T extends Permissions$role_has_permissionsArgs = {}>(
            args?: Subset<T, Permissions$role_has_permissionsArgs>
        ): PrismaPromise<Array<Role_has_permissionsGetPayload<T>> | Null>

        private get _document()
        /**
         * Attaches callbacks for the resolution and/or rejection of the Promise.
         * @param onfulfilled The callback to execute when the Promise is resolved.
         * @param onrejected The callback to execute when the Promise is rejected.
         * @returns A Promise for the completion of which ever callback is executed.
         */
        then<TResult1 = T, TResult2 = never>(
            onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
            onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
        ): Promise<TResult1 | TResult2>
        /**
         * Attaches a callback for only the rejection of the Promise.
         * @param onrejected The callback to execute when the Promise is rejected.
         * @returns A Promise for the completion of the callback.
         */
        catch<TResult = never>(
            onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
        ): Promise<T | TResult>
        /**
         * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
         * resolved value cannot be modified from the callback.
         * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
         * @returns A Promise for the completion of the callback.
         */
        finally(onfinally?: (() => void) | undefined | null): Promise<T>
    }

    // Custom InputTypes

    /**
     * Permissions base type for findUnique actions
     */
    export type PermissionsFindUniqueArgsBase = {
        /**
         * Select specific fields to fetch from the Permissions
         *
         **/
        select?: PermissionsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: PermissionsInclude | null
        /**
         * Filter, which Permissions to fetch.
         *
         **/
        where: PermissionsWhereUniqueInput
    }

    /**
     * Permissions findUnique
     */
    export interface PermissionsFindUniqueArgs extends PermissionsFindUniqueArgsBase {
        /**
         * Throw an Error if query returns no results
         * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
         */
        rejectOnNotFound?: RejectOnNotFound
    }

    /**
     * Permissions findUniqueOrThrow
     */
    export type PermissionsFindUniqueOrThrowArgs = {
        /**
         * Select specific fields to fetch from the Permissions
         *
         **/
        select?: PermissionsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: PermissionsInclude | null
        /**
         * Filter, which Permissions to fetch.
         *
         **/
        where: PermissionsWhereUniqueInput
    }

    /**
     * Permissions base type for findFirst actions
     */
    export type PermissionsFindFirstArgsBase = {
        /**
         * Select specific fields to fetch from the Permissions
         *
         **/
        select?: PermissionsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: PermissionsInclude | null
        /**
         * Filter, which Permissions to fetch.
         *
         **/
        where?: PermissionsWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Permissions to fetch.
         *
         **/
        orderBy?: Enumerable<PermissionsOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for searching for Permissions.
         *
         **/
        cursor?: PermissionsWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Permissions from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Permissions.
         *
         **/
        skip?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
         *
         * Filter by unique combinations of Permissions.
         *
         **/
        distinct?: Enumerable<PermissionsScalarFieldEnum>
    }

    /**
     * Permissions findFirst
     */
    export interface PermissionsFindFirstArgs extends PermissionsFindFirstArgsBase {
        /**
         * Throw an Error if query returns no results
         * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
         */
        rejectOnNotFound?: RejectOnNotFound
    }

    /**
     * Permissions findFirstOrThrow
     */
    export type PermissionsFindFirstOrThrowArgs = {
        /**
         * Select specific fields to fetch from the Permissions
         *
         **/
        select?: PermissionsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: PermissionsInclude | null
        /**
         * Filter, which Permissions to fetch.
         *
         **/
        where?: PermissionsWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Permissions to fetch.
         *
         **/
        orderBy?: Enumerable<PermissionsOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for searching for Permissions.
         *
         **/
        cursor?: PermissionsWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Permissions from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Permissions.
         *
         **/
        skip?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
         *
         * Filter by unique combinations of Permissions.
         *
         **/
        distinct?: Enumerable<PermissionsScalarFieldEnum>
    }

    /**
     * Permissions findMany
     */
    export type PermissionsFindManyArgs = {
        /**
         * Select specific fields to fetch from the Permissions
         *
         **/
        select?: PermissionsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: PermissionsInclude | null
        /**
         * Filter, which Permissions to fetch.
         *
         **/
        where?: PermissionsWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Permissions to fetch.
         *
         **/
        orderBy?: Enumerable<PermissionsOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for listing Permissions.
         *
         **/
        cursor?: PermissionsWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Permissions from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Permissions.
         *
         **/
        skip?: number
        distinct?: Enumerable<PermissionsScalarFieldEnum>
    }

    /**
     * Permissions create
     */
    export type PermissionsCreateArgs = {
        /**
         * Select specific fields to fetch from the Permissions
         *
         **/
        select?: PermissionsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: PermissionsInclude | null
        /**
         * The data needed to create a Permissions.
         *
         **/
        data: XOR<PermissionsCreateInput, PermissionsUncheckedCreateInput>
    }

    /**
     * Permissions createMany
     */
    export type PermissionsCreateManyArgs = {
        /**
         * The data used to create many Permissions.
         *
         **/
        data: Enumerable<PermissionsCreateManyInput>
        skipDuplicates?: boolean
    }

    /**
     * Permissions update
     */
    export type PermissionsUpdateArgs = {
        /**
         * Select specific fields to fetch from the Permissions
         *
         **/
        select?: PermissionsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: PermissionsInclude | null
        /**
         * The data needed to update a Permissions.
         *
         **/
        data: XOR<PermissionsUpdateInput, PermissionsUncheckedUpdateInput>
        /**
         * Choose, which Permissions to update.
         *
         **/
        where: PermissionsWhereUniqueInput
    }

    /**
     * Permissions updateMany
     */
    export type PermissionsUpdateManyArgs = {
        /**
         * The data used to update Permissions.
         *
         **/
        data: XOR<PermissionsUpdateManyMutationInput, PermissionsUncheckedUpdateManyInput>
        /**
         * Filter which Permissions to update
         *
         **/
        where?: PermissionsWhereInput
    }

    /**
     * Permissions upsert
     */
    export type PermissionsUpsertArgs = {
        /**
         * Select specific fields to fetch from the Permissions
         *
         **/
        select?: PermissionsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: PermissionsInclude | null
        /**
         * The filter to search for the Permissions to update in case it exists.
         *
         **/
        where: PermissionsWhereUniqueInput
        /**
         * In case the Permissions found by the `where` argument doesn't exist, create a new Permissions with this data.
         *
         **/
        create: XOR<PermissionsCreateInput, PermissionsUncheckedCreateInput>
        /**
         * In case the Permissions was found with the provided `where` argument, update it with this data.
         *
         **/
        update: XOR<PermissionsUpdateInput, PermissionsUncheckedUpdateInput>
    }

    /**
     * Permissions delete
     */
    export type PermissionsDeleteArgs = {
        /**
         * Select specific fields to fetch from the Permissions
         *
         **/
        select?: PermissionsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: PermissionsInclude | null
        /**
         * Filter which Permissions to delete.
         *
         **/
        where: PermissionsWhereUniqueInput
    }

    /**
     * Permissions deleteMany
     */
    export type PermissionsDeleteManyArgs = {
        /**
         * Filter which Permissions to delete
         *
         **/
        where?: PermissionsWhereInput
    }

    /**
     * Permissions.model_has_permissions
     */
    export type Permissions$model_has_permissionsArgs = {
        /**
         * Select specific fields to fetch from the Model_has_permissions
         *
         **/
        select?: Model_has_permissionsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Model_has_permissionsInclude | null
        where?: Model_has_permissionsWhereInput
        orderBy?: Enumerable<Model_has_permissionsOrderByWithRelationInput>
        cursor?: Model_has_permissionsWhereUniqueInput
        take?: number
        skip?: number
        distinct?: Enumerable<Model_has_permissionsScalarFieldEnum>
    }

    /**
     * Permissions.role_has_permissions
     */
    export type Permissions$role_has_permissionsArgs = {
        /**
         * Select specific fields to fetch from the Role_has_permissions
         *
         **/
        select?: Role_has_permissionsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Role_has_permissionsInclude | null
        where?: Role_has_permissionsWhereInput
        orderBy?: Enumerable<Role_has_permissionsOrderByWithRelationInput>
        cursor?: Role_has_permissionsWhereUniqueInput
        take?: number
        skip?: number
        distinct?: Enumerable<Role_has_permissionsScalarFieldEnum>
    }

    /**
     * Permissions without action
     */
    export type PermissionsArgs = {
        /**
         * Select specific fields to fetch from the Permissions
         *
         **/
        select?: PermissionsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: PermissionsInclude | null
    }

    /**
     * Model Personal_access_tokens
     */

    export type AggregatePersonal_access_tokens = {
        _count: Personal_access_tokensCountAggregateOutputType | null
        _min: Personal_access_tokensMinAggregateOutputType | null
        _max: Personal_access_tokensMaxAggregateOutputType | null
    }

    export type Personal_access_tokensMinAggregateOutputType = {
        id: string | null
        tokenable_type: string | null
        tokenable_id: string | null
        name: string | null
        token: string | null
        abilities: string | null
        last_used_at: Date | null
        expires_at: Date | null
        created_at: Date | null
        updated_at: Date | null
    }

    export type Personal_access_tokensMaxAggregateOutputType = {
        id: string | null
        tokenable_type: string | null
        tokenable_id: string | null
        name: string | null
        token: string | null
        abilities: string | null
        last_used_at: Date | null
        expires_at: Date | null
        created_at: Date | null
        updated_at: Date | null
    }

    export type Personal_access_tokensCountAggregateOutputType = {
        id: number
        tokenable_type: number
        tokenable_id: number
        name: number
        token: number
        abilities: number
        last_used_at: number
        expires_at: number
        created_at: number
        updated_at: number
        _all: number
    }

    export type Personal_access_tokensMinAggregateInputType = {
        id?: true
        tokenable_type?: true
        tokenable_id?: true
        name?: true
        token?: true
        abilities?: true
        last_used_at?: true
        expires_at?: true
        created_at?: true
        updated_at?: true
    }

    export type Personal_access_tokensMaxAggregateInputType = {
        id?: true
        tokenable_type?: true
        tokenable_id?: true
        name?: true
        token?: true
        abilities?: true
        last_used_at?: true
        expires_at?: true
        created_at?: true
        updated_at?: true
    }

    export type Personal_access_tokensCountAggregateInputType = {
        id?: true
        tokenable_type?: true
        tokenable_id?: true
        name?: true
        token?: true
        abilities?: true
        last_used_at?: true
        expires_at?: true
        created_at?: true
        updated_at?: true
        _all?: true
    }

    export type Personal_access_tokensAggregateArgs = {
        /**
         * Filter which Personal_access_tokens to aggregate.
         *
         **/
        where?: Personal_access_tokensWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Personal_access_tokens to fetch.
         *
         **/
        orderBy?: Enumerable<Personal_access_tokensOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the start position
         *
         **/
        cursor?: Personal_access_tokensWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Personal_access_tokens from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Personal_access_tokens.
         *
         **/
        skip?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Count returned Personal_access_tokens
         **/
        _count?: true | Personal_access_tokensCountAggregateInputType
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to find the minimum value
         **/
        _min?: Personal_access_tokensMinAggregateInputType
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to find the maximum value
         **/
        _max?: Personal_access_tokensMaxAggregateInputType
    }

    export type GetPersonal_access_tokensAggregateType<T extends Personal_access_tokensAggregateArgs> = {
        [P in keyof T & keyof AggregatePersonal_access_tokens]: P extends '_count' | 'count'
            ? T[P] extends true
                ? number
                : GetScalarType<T[P], AggregatePersonal_access_tokens[P]>
            : GetScalarType<T[P], AggregatePersonal_access_tokens[P]>
    }

    export type Personal_access_tokensGroupByArgs = {
        where?: Personal_access_tokensWhereInput
        orderBy?: Enumerable<Personal_access_tokensOrderByWithAggregationInput>
        by: Array<Personal_access_tokensScalarFieldEnum>
        having?: Personal_access_tokensScalarWhereWithAggregatesInput
        take?: number
        skip?: number
        _count?: Personal_access_tokensCountAggregateInputType | true
        _min?: Personal_access_tokensMinAggregateInputType
        _max?: Personal_access_tokensMaxAggregateInputType
    }

    export type Personal_access_tokensGroupByOutputType = {
        id: string
        tokenable_type: string
        tokenable_id: string
        name: string
        token: string
        abilities: string | null
        last_used_at: Date | null
        expires_at: Date | null
        created_at: Date | null
        updated_at: Date | null
        _count: Personal_access_tokensCountAggregateOutputType | null
        _min: Personal_access_tokensMinAggregateOutputType | null
        _max: Personal_access_tokensMaxAggregateOutputType | null
    }

    type GetPersonal_access_tokensGroupByPayload<T extends Personal_access_tokensGroupByArgs> = PrismaPromise<
        Array<
            PickArray<Personal_access_tokensGroupByOutputType, T['by']> & {
                [P in keyof T & keyof Personal_access_tokensGroupByOutputType]: P extends '_count'
                    ? T[P] extends boolean
                        ? number
                        : GetScalarType<T[P], Personal_access_tokensGroupByOutputType[P]>
                    : GetScalarType<T[P], Personal_access_tokensGroupByOutputType[P]>
            }
        >
    >

    export type Personal_access_tokensSelect = {
        id?: boolean
        tokenable_type?: boolean
        tokenable_id?: boolean
        name?: boolean
        token?: boolean
        abilities?: boolean
        last_used_at?: boolean
        expires_at?: boolean
        created_at?: boolean
        updated_at?: boolean
    }

    export type Personal_access_tokensGetPayload<S extends boolean | null | undefined | Personal_access_tokensArgs> =
        S extends { select: any; include: any }
            ? 'Please either choose `select` or `include`'
            : S extends true
              ? Personal_access_tokens
              : S extends undefined
                ? never
                : S extends { include: any } & (Personal_access_tokensArgs | Personal_access_tokensFindManyArgs)
                  ? Personal_access_tokens
                  : S extends { select: any } & (Personal_access_tokensArgs | Personal_access_tokensFindManyArgs)
                    ? {
                          [P in TruthyKeys<S['select']>]: P extends keyof Personal_access_tokens
                              ? Personal_access_tokens[P]
                              : never
                      }
                    : Personal_access_tokens

    type Personal_access_tokensCountArgs = Merge<
        Omit<Personal_access_tokensFindManyArgs, 'select' | 'include'> & {
            select?: Personal_access_tokensCountAggregateInputType | true
        }
    >

    export interface Personal_access_tokensDelegate<
        GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined
    > {
        /**
         * Find zero or one Personal_access_tokens that matches the filter.
         * @param {Personal_access_tokensFindUniqueArgs} args - Arguments to find a Personal_access_tokens
         * @example
         * // Get one Personal_access_tokens
         * const personal_access_tokens = await prisma.personal_access_tokens.findUnique({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findUnique<
            T extends Personal_access_tokensFindUniqueArgs,
            LocalRejectSettings = T['rejectOnNotFound'] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined
        >(
            args: SelectSubset<T, Personal_access_tokensFindUniqueArgs>
        ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Personal_access_tokens'> extends True
            ? Prisma__Personal_access_tokensClient<Personal_access_tokensGetPayload<T>>
            : Prisma__Personal_access_tokensClient<Personal_access_tokensGetPayload<T> | null, null>

        /**
         * Find one Personal_access_tokens that matches the filter or throw an error  with `error.code='P2025'`
         *     if no matches were found.
         * @param {Personal_access_tokensFindUniqueOrThrowArgs} args - Arguments to find a Personal_access_tokens
         * @example
         * // Get one Personal_access_tokens
         * const personal_access_tokens = await prisma.personal_access_tokens.findUniqueOrThrow({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findUniqueOrThrow<T extends Personal_access_tokensFindUniqueOrThrowArgs>(
            args?: SelectSubset<T, Personal_access_tokensFindUniqueOrThrowArgs>
        ): Prisma__Personal_access_tokensClient<Personal_access_tokensGetPayload<T>>

        /**
         * Find the first Personal_access_tokens that matches the filter.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {Personal_access_tokensFindFirstArgs} args - Arguments to find a Personal_access_tokens
         * @example
         * // Get one Personal_access_tokens
         * const personal_access_tokens = await prisma.personal_access_tokens.findFirst({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findFirst<
            T extends Personal_access_tokensFindFirstArgs,
            LocalRejectSettings = T['rejectOnNotFound'] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined
        >(
            args?: SelectSubset<T, Personal_access_tokensFindFirstArgs>
        ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Personal_access_tokens'> extends True
            ? Prisma__Personal_access_tokensClient<Personal_access_tokensGetPayload<T>>
            : Prisma__Personal_access_tokensClient<Personal_access_tokensGetPayload<T> | null, null>

        /**
         * Find the first Personal_access_tokens that matches the filter or
         * throw `NotFoundError` if no matches were found.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {Personal_access_tokensFindFirstOrThrowArgs} args - Arguments to find a Personal_access_tokens
         * @example
         * // Get one Personal_access_tokens
         * const personal_access_tokens = await prisma.personal_access_tokens.findFirstOrThrow({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findFirstOrThrow<T extends Personal_access_tokensFindFirstOrThrowArgs>(
            args?: SelectSubset<T, Personal_access_tokensFindFirstOrThrowArgs>
        ): Prisma__Personal_access_tokensClient<Personal_access_tokensGetPayload<T>>

        /**
         * Find zero or more Personal_access_tokens that matches the filter.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {Personal_access_tokensFindManyArgs=} args - Arguments to filter and select certain fields only.
         * @example
         * // Get all Personal_access_tokens
         * const personal_access_tokens = await prisma.personal_access_tokens.findMany()
         *
         * // Get first 10 Personal_access_tokens
         * const personal_access_tokens = await prisma.personal_access_tokens.findMany({ take: 10 })
         *
         * // Only select the `id`
         * const personal_access_tokensWithIdOnly = await prisma.personal_access_tokens.findMany({ select: { id: true } })
         *
         **/
        findMany<T extends Personal_access_tokensFindManyArgs>(
            args?: SelectSubset<T, Personal_access_tokensFindManyArgs>
        ): PrismaPromise<Array<Personal_access_tokensGetPayload<T>>>

        /**
         * Create a Personal_access_tokens.
         * @param {Personal_access_tokensCreateArgs} args - Arguments to create a Personal_access_tokens.
         * @example
         * // Create one Personal_access_tokens
         * const Personal_access_tokens = await prisma.personal_access_tokens.create({
         *   data: {
         *     // ... data to create a Personal_access_tokens
         *   }
         * })
         *
         **/
        create<T extends Personal_access_tokensCreateArgs>(
            args: SelectSubset<T, Personal_access_tokensCreateArgs>
        ): Prisma__Personal_access_tokensClient<Personal_access_tokensGetPayload<T>>

        /**
         * Create many Personal_access_tokens.
         *     @param {Personal_access_tokensCreateManyArgs} args - Arguments to create many Personal_access_tokens.
         *     @example
         *     // Create many Personal_access_tokens
         *     const personal_access_tokens = await prisma.personal_access_tokens.createMany({
         *       data: {
         *         // ... provide data here
         *       }
         *     })
         *
         **/
        createMany<T extends Personal_access_tokensCreateManyArgs>(
            args?: SelectSubset<T, Personal_access_tokensCreateManyArgs>
        ): PrismaPromise<BatchPayload>

        /**
         * Delete a Personal_access_tokens.
         * @param {Personal_access_tokensDeleteArgs} args - Arguments to delete one Personal_access_tokens.
         * @example
         * // Delete one Personal_access_tokens
         * const Personal_access_tokens = await prisma.personal_access_tokens.delete({
         *   where: {
         *     // ... filter to delete one Personal_access_tokens
         *   }
         * })
         *
         **/
        delete<T extends Personal_access_tokensDeleteArgs>(
            args: SelectSubset<T, Personal_access_tokensDeleteArgs>
        ): Prisma__Personal_access_tokensClient<Personal_access_tokensGetPayload<T>>

        /**
         * Update one Personal_access_tokens.
         * @param {Personal_access_tokensUpdateArgs} args - Arguments to update one Personal_access_tokens.
         * @example
         * // Update one Personal_access_tokens
         * const personal_access_tokens = await prisma.personal_access_tokens.update({
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: {
         *     // ... provide data here
         *   }
         * })
         *
         **/
        update<T extends Personal_access_tokensUpdateArgs>(
            args: SelectSubset<T, Personal_access_tokensUpdateArgs>
        ): Prisma__Personal_access_tokensClient<Personal_access_tokensGetPayload<T>>

        /**
         * Delete zero or more Personal_access_tokens.
         * @param {Personal_access_tokensDeleteManyArgs} args - Arguments to filter Personal_access_tokens to delete.
         * @example
         * // Delete a few Personal_access_tokens
         * const { count } = await prisma.personal_access_tokens.deleteMany({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         *
         **/
        deleteMany<T extends Personal_access_tokensDeleteManyArgs>(
            args?: SelectSubset<T, Personal_access_tokensDeleteManyArgs>
        ): PrismaPromise<BatchPayload>

        /**
         * Update zero or more Personal_access_tokens.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {Personal_access_tokensUpdateManyArgs} args - Arguments to update one or more rows.
         * @example
         * // Update many Personal_access_tokens
         * const personal_access_tokens = await prisma.personal_access_tokens.updateMany({
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: {
         *     // ... provide data here
         *   }
         * })
         *
         **/
        updateMany<T extends Personal_access_tokensUpdateManyArgs>(
            args: SelectSubset<T, Personal_access_tokensUpdateManyArgs>
        ): PrismaPromise<BatchPayload>

        /**
         * Create or update one Personal_access_tokens.
         * @param {Personal_access_tokensUpsertArgs} args - Arguments to update or create a Personal_access_tokens.
         * @example
         * // Update or create a Personal_access_tokens
         * const personal_access_tokens = await prisma.personal_access_tokens.upsert({
         *   create: {
         *     // ... data to create a Personal_access_tokens
         *   },
         *   update: {
         *     // ... in case it already exists, update
         *   },
         *   where: {
         *     // ... the filter for the Personal_access_tokens we want to update
         *   }
         * })
         **/
        upsert<T extends Personal_access_tokensUpsertArgs>(
            args: SelectSubset<T, Personal_access_tokensUpsertArgs>
        ): Prisma__Personal_access_tokensClient<Personal_access_tokensGetPayload<T>>

        /**
         * Count the number of Personal_access_tokens.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {Personal_access_tokensCountArgs} args - Arguments to filter Personal_access_tokens to count.
         * @example
         * // Count the number of Personal_access_tokens
         * const count = await prisma.personal_access_tokens.count({
         *   where: {
         *     // ... the filter for the Personal_access_tokens we want to count
         *   }
         * })
         **/
        count<T extends Personal_access_tokensCountArgs>(
            args?: Subset<T, Personal_access_tokensCountArgs>
        ): PrismaPromise<
            T extends _Record<'select', any>
                ? T['select'] extends true
                    ? number
                    : GetScalarType<T['select'], Personal_access_tokensCountAggregateOutputType>
                : number
        >

        /**
         * Allows you to perform aggregations operations on a Personal_access_tokens.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {Personal_access_tokensAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
         * @example
         * // Ordered by age ascending
         * // Where email contains prisma.io
         * // Limited to the 10 users
         * const aggregations = await prisma.user.aggregate({
         *   _avg: {
         *     age: true,
         *   },
         *   where: {
         *     email: {
         *       contains: "prisma.io",
         *     },
         *   },
         *   orderBy: {
         *     age: "asc",
         *   },
         *   take: 10,
         * })
         **/
        aggregate<T extends Personal_access_tokensAggregateArgs>(
            args: Subset<T, Personal_access_tokensAggregateArgs>
        ): PrismaPromise<GetPersonal_access_tokensAggregateType<T>>

        /**
         * Group by Personal_access_tokens.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {Personal_access_tokensGroupByArgs} args - Group by arguments.
         * @example
         * // Group by city, order by createdAt, get count
         * const result = await prisma.user.groupBy({
         *   by: ['city', 'createdAt'],
         *   orderBy: {
         *     createdAt: true
         *   },
         *   _count: {
         *     _all: true
         *   },
         * })
         *
         **/
        groupBy<
            T extends Personal_access_tokensGroupByArgs,
            HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
            OrderByArg extends True extends HasSelectOrTake
                ? { orderBy: Personal_access_tokensGroupByArgs['orderBy'] }
                : { orderBy?: Personal_access_tokensGroupByArgs['orderBy'] },
            OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
            ByFields extends TupleToUnion<T['by']>,
            ByValid extends Has<ByFields, OrderFields>,
            HavingFields extends GetHavingFields<T['having']>,
            HavingValid extends Has<ByFields, HavingFields>,
            ByEmpty extends T['by'] extends never[] ? True : False,
            InputErrors extends ByEmpty extends True
                ? `Error: "by" must not be empty.`
                : HavingValid extends False
                  ? {
                        [P in HavingFields]: P extends ByFields
                            ? never
                            : P extends string
                              ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                              : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`]
                    }[HavingFields]
                  : 'take' extends Keys<T>
                    ? 'orderBy' extends Keys<T>
                        ? ByValid extends True
                            ? {}
                            : {
                                  [P in OrderFields]: P extends ByFields
                                      ? never
                                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                              }[OrderFields]
                        : 'Error: If you provide "take", you also need to provide "orderBy"'
                    : 'skip' extends Keys<T>
                      ? 'orderBy' extends Keys<T>
                          ? ByValid extends True
                              ? {}
                              : {
                                    [P in OrderFields]: P extends ByFields
                                        ? never
                                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                                }[OrderFields]
                          : 'Error: If you provide "skip", you also need to provide "orderBy"'
                      : ByValid extends True
                        ? {}
                        : {
                              [P in OrderFields]: P extends ByFields
                                  ? never
                                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                          }[OrderFields]
        >(
            args: SubsetIntersection<T, Personal_access_tokensGroupByArgs, OrderByArg> & InputErrors
        ): {} extends InputErrors ? GetPersonal_access_tokensGroupByPayload<T> : PrismaPromise<InputErrors>
    }

    /**
     * The delegate class that acts as a "Promise-like" for Personal_access_tokens.
     * Why is this prefixed with `Prisma__`?
     * Because we want to prevent naming conflicts as mentioned in
     * https://github.com/prisma/prisma-client-js/issues/707
     */
    export class Prisma__Personal_access_tokensClient<T, Null = never> implements PrismaPromise<T> {
        [prisma]: true
        private readonly _dmmf
        private readonly _fetcher
        private readonly _queryType
        private readonly _rootField
        private readonly _clientMethod
        private readonly _args
        private readonly _dataPath
        private readonly _errorFormat
        private readonly _measurePerformance?
        private _isList
        private _callsite
        private _requestPromise?
        constructor(
            _dmmf: runtime.DMMFClass,
            _fetcher: PrismaClientFetcher,
            _queryType: 'query' | 'mutation',
            _rootField: string,
            _clientMethod: string,
            _args: any,
            _dataPath: string[],
            _errorFormat: ErrorFormat,
            _measurePerformance?: boolean | undefined,
            _isList?: boolean
        )
        readonly [Symbol.toStringTag]: 'PrismaClientPromise'

        private get _document()
        /**
         * Attaches callbacks for the resolution and/or rejection of the Promise.
         * @param onfulfilled The callback to execute when the Promise is resolved.
         * @param onrejected The callback to execute when the Promise is rejected.
         * @returns A Promise for the completion of which ever callback is executed.
         */
        then<TResult1 = T, TResult2 = never>(
            onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
            onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
        ): Promise<TResult1 | TResult2>
        /**
         * Attaches a callback for only the rejection of the Promise.
         * @param onrejected The callback to execute when the Promise is rejected.
         * @returns A Promise for the completion of the callback.
         */
        catch<TResult = never>(
            onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
        ): Promise<T | TResult>
        /**
         * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
         * resolved value cannot be modified from the callback.
         * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
         * @returns A Promise for the completion of the callback.
         */
        finally(onfinally?: (() => void) | undefined | null): Promise<T>
    }

    // Custom InputTypes

    /**
     * Personal_access_tokens base type for findUnique actions
     */
    export type Personal_access_tokensFindUniqueArgsBase = {
        /**
         * Select specific fields to fetch from the Personal_access_tokens
         *
         **/
        select?: Personal_access_tokensSelect | null
        /**
         * Filter, which Personal_access_tokens to fetch.
         *
         **/
        where: Personal_access_tokensWhereUniqueInput
    }

    /**
     * Personal_access_tokens findUnique
     */
    export interface Personal_access_tokensFindUniqueArgs extends Personal_access_tokensFindUniqueArgsBase {
        /**
         * Throw an Error if query returns no results
         * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
         */
        rejectOnNotFound?: RejectOnNotFound
    }

    /**
     * Personal_access_tokens findUniqueOrThrow
     */
    export type Personal_access_tokensFindUniqueOrThrowArgs = {
        /**
         * Select specific fields to fetch from the Personal_access_tokens
         *
         **/
        select?: Personal_access_tokensSelect | null
        /**
         * Filter, which Personal_access_tokens to fetch.
         *
         **/
        where: Personal_access_tokensWhereUniqueInput
    }

    /**
     * Personal_access_tokens base type for findFirst actions
     */
    export type Personal_access_tokensFindFirstArgsBase = {
        /**
         * Select specific fields to fetch from the Personal_access_tokens
         *
         **/
        select?: Personal_access_tokensSelect | null
        /**
         * Filter, which Personal_access_tokens to fetch.
         *
         **/
        where?: Personal_access_tokensWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Personal_access_tokens to fetch.
         *
         **/
        orderBy?: Enumerable<Personal_access_tokensOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for searching for Personal_access_tokens.
         *
         **/
        cursor?: Personal_access_tokensWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Personal_access_tokens from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Personal_access_tokens.
         *
         **/
        skip?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
         *
         * Filter by unique combinations of Personal_access_tokens.
         *
         **/
        distinct?: Enumerable<Personal_access_tokensScalarFieldEnum>
    }

    /**
     * Personal_access_tokens findFirst
     */
    export interface Personal_access_tokensFindFirstArgs extends Personal_access_tokensFindFirstArgsBase {
        /**
         * Throw an Error if query returns no results
         * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
         */
        rejectOnNotFound?: RejectOnNotFound
    }

    /**
     * Personal_access_tokens findFirstOrThrow
     */
    export type Personal_access_tokensFindFirstOrThrowArgs = {
        /**
         * Select specific fields to fetch from the Personal_access_tokens
         *
         **/
        select?: Personal_access_tokensSelect | null
        /**
         * Filter, which Personal_access_tokens to fetch.
         *
         **/
        where?: Personal_access_tokensWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Personal_access_tokens to fetch.
         *
         **/
        orderBy?: Enumerable<Personal_access_tokensOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for searching for Personal_access_tokens.
         *
         **/
        cursor?: Personal_access_tokensWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Personal_access_tokens from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Personal_access_tokens.
         *
         **/
        skip?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
         *
         * Filter by unique combinations of Personal_access_tokens.
         *
         **/
        distinct?: Enumerable<Personal_access_tokensScalarFieldEnum>
    }

    /**
     * Personal_access_tokens findMany
     */
    export type Personal_access_tokensFindManyArgs = {
        /**
         * Select specific fields to fetch from the Personal_access_tokens
         *
         **/
        select?: Personal_access_tokensSelect | null
        /**
         * Filter, which Personal_access_tokens to fetch.
         *
         **/
        where?: Personal_access_tokensWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Personal_access_tokens to fetch.
         *
         **/
        orderBy?: Enumerable<Personal_access_tokensOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for listing Personal_access_tokens.
         *
         **/
        cursor?: Personal_access_tokensWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Personal_access_tokens from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Personal_access_tokens.
         *
         **/
        skip?: number
        distinct?: Enumerable<Personal_access_tokensScalarFieldEnum>
    }

    /**
     * Personal_access_tokens create
     */
    export type Personal_access_tokensCreateArgs = {
        /**
         * Select specific fields to fetch from the Personal_access_tokens
         *
         **/
        select?: Personal_access_tokensSelect | null
        /**
         * The data needed to create a Personal_access_tokens.
         *
         **/
        data: XOR<Personal_access_tokensCreateInput, Personal_access_tokensUncheckedCreateInput>
    }

    /**
     * Personal_access_tokens createMany
     */
    export type Personal_access_tokensCreateManyArgs = {
        /**
         * The data used to create many Personal_access_tokens.
         *
         **/
        data: Enumerable<Personal_access_tokensCreateManyInput>
        skipDuplicates?: boolean
    }

    /**
     * Personal_access_tokens update
     */
    export type Personal_access_tokensUpdateArgs = {
        /**
         * Select specific fields to fetch from the Personal_access_tokens
         *
         **/
        select?: Personal_access_tokensSelect | null
        /**
         * The data needed to update a Personal_access_tokens.
         *
         **/
        data: XOR<Personal_access_tokensUpdateInput, Personal_access_tokensUncheckedUpdateInput>
        /**
         * Choose, which Personal_access_tokens to update.
         *
         **/
        where: Personal_access_tokensWhereUniqueInput
    }

    /**
     * Personal_access_tokens updateMany
     */
    export type Personal_access_tokensUpdateManyArgs = {
        /**
         * The data used to update Personal_access_tokens.
         *
         **/
        data: XOR<Personal_access_tokensUpdateManyMutationInput, Personal_access_tokensUncheckedUpdateManyInput>
        /**
         * Filter which Personal_access_tokens to update
         *
         **/
        where?: Personal_access_tokensWhereInput
    }

    /**
     * Personal_access_tokens upsert
     */
    export type Personal_access_tokensUpsertArgs = {
        /**
         * Select specific fields to fetch from the Personal_access_tokens
         *
         **/
        select?: Personal_access_tokensSelect | null
        /**
         * The filter to search for the Personal_access_tokens to update in case it exists.
         *
         **/
        where: Personal_access_tokensWhereUniqueInput
        /**
         * In case the Personal_access_tokens found by the `where` argument doesn't exist, create a new Personal_access_tokens with this data.
         *
         **/
        create: XOR<Personal_access_tokensCreateInput, Personal_access_tokensUncheckedCreateInput>
        /**
         * In case the Personal_access_tokens was found with the provided `where` argument, update it with this data.
         *
         **/
        update: XOR<Personal_access_tokensUpdateInput, Personal_access_tokensUncheckedUpdateInput>
    }

    /**
     * Personal_access_tokens delete
     */
    export type Personal_access_tokensDeleteArgs = {
        /**
         * Select specific fields to fetch from the Personal_access_tokens
         *
         **/
        select?: Personal_access_tokensSelect | null
        /**
         * Filter which Personal_access_tokens to delete.
         *
         **/
        where: Personal_access_tokensWhereUniqueInput
    }

    /**
     * Personal_access_tokens deleteMany
     */
    export type Personal_access_tokensDeleteManyArgs = {
        /**
         * Filter which Personal_access_tokens to delete
         *
         **/
        where?: Personal_access_tokensWhereInput
    }

    /**
     * Personal_access_tokens without action
     */
    export type Personal_access_tokensArgs = {
        /**
         * Select specific fields to fetch from the Personal_access_tokens
         *
         **/
        select?: Personal_access_tokensSelect | null
    }

    /**
     * Model Role_has_permissions
     */

    export type AggregateRole_has_permissions = {
        _count: Role_has_permissionsCountAggregateOutputType | null
        _min: Role_has_permissionsMinAggregateOutputType | null
        _max: Role_has_permissionsMaxAggregateOutputType | null
    }

    export type Role_has_permissionsMinAggregateOutputType = {
        permission_id: string | null
        role_id: string | null
    }

    export type Role_has_permissionsMaxAggregateOutputType = {
        permission_id: string | null
        role_id: string | null
    }

    export type Role_has_permissionsCountAggregateOutputType = {
        permission_id: number
        role_id: number
        _all: number
    }

    export type Role_has_permissionsMinAggregateInputType = {
        permission_id?: true
        role_id?: true
    }

    export type Role_has_permissionsMaxAggregateInputType = {
        permission_id?: true
        role_id?: true
    }

    export type Role_has_permissionsCountAggregateInputType = {
        permission_id?: true
        role_id?: true
        _all?: true
    }

    export type Role_has_permissionsAggregateArgs = {
        /**
         * Filter which Role_has_permissions to aggregate.
         *
         **/
        where?: Role_has_permissionsWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Role_has_permissions to fetch.
         *
         **/
        orderBy?: Enumerable<Role_has_permissionsOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the start position
         *
         **/
        cursor?: Role_has_permissionsWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Role_has_permissions from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Role_has_permissions.
         *
         **/
        skip?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Count returned Role_has_permissions
         **/
        _count?: true | Role_has_permissionsCountAggregateInputType
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to find the minimum value
         **/
        _min?: Role_has_permissionsMinAggregateInputType
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to find the maximum value
         **/
        _max?: Role_has_permissionsMaxAggregateInputType
    }

    export type GetRole_has_permissionsAggregateType<T extends Role_has_permissionsAggregateArgs> = {
        [P in keyof T & keyof AggregateRole_has_permissions]: P extends '_count' | 'count'
            ? T[P] extends true
                ? number
                : GetScalarType<T[P], AggregateRole_has_permissions[P]>
            : GetScalarType<T[P], AggregateRole_has_permissions[P]>
    }

    export type Role_has_permissionsGroupByArgs = {
        where?: Role_has_permissionsWhereInput
        orderBy?: Enumerable<Role_has_permissionsOrderByWithAggregationInput>
        by: Array<Role_has_permissionsScalarFieldEnum>
        having?: Role_has_permissionsScalarWhereWithAggregatesInput
        take?: number
        skip?: number
        _count?: Role_has_permissionsCountAggregateInputType | true
        _min?: Role_has_permissionsMinAggregateInputType
        _max?: Role_has_permissionsMaxAggregateInputType
    }

    export type Role_has_permissionsGroupByOutputType = {
        permission_id: string
        role_id: string
        _count: Role_has_permissionsCountAggregateOutputType | null
        _min: Role_has_permissionsMinAggregateOutputType | null
        _max: Role_has_permissionsMaxAggregateOutputType | null
    }

    type GetRole_has_permissionsGroupByPayload<T extends Role_has_permissionsGroupByArgs> = PrismaPromise<
        Array<
            PickArray<Role_has_permissionsGroupByOutputType, T['by']> & {
                [P in keyof T & keyof Role_has_permissionsGroupByOutputType]: P extends '_count'
                    ? T[P] extends boolean
                        ? number
                        : GetScalarType<T[P], Role_has_permissionsGroupByOutputType[P]>
                    : GetScalarType<T[P], Role_has_permissionsGroupByOutputType[P]>
            }
        >
    >

    export type Role_has_permissionsSelect = {
        permission_id?: boolean
        role_id?: boolean
        permissions?: boolean | PermissionsArgs
        roles?: boolean | RolesArgs
    }

    export type Role_has_permissionsInclude = {
        permissions?: boolean | PermissionsArgs
        roles?: boolean | RolesArgs
    }

    export type Role_has_permissionsGetPayload<S extends boolean | null | undefined | Role_has_permissionsArgs> =
        S extends { select: any; include: any }
            ? 'Please either choose `select` or `include`'
            : S extends true
              ? Role_has_permissions
              : S extends undefined
                ? never
                : S extends { include: any } & (Role_has_permissionsArgs | Role_has_permissionsFindManyArgs)
                  ? Role_has_permissions & {
                        [P in TruthyKeys<S['include']>]: P extends 'permissions'
                            ? PermissionsGetPayload<S['include'][P]>
                            : P extends 'roles'
                              ? RolesGetPayload<S['include'][P]>
                              : never
                    }
                  : S extends { select: any } & (Role_has_permissionsArgs | Role_has_permissionsFindManyArgs)
                    ? {
                          [P in TruthyKeys<S['select']>]: P extends 'permissions'
                              ? PermissionsGetPayload<S['select'][P]>
                              : P extends 'roles'
                                ? RolesGetPayload<S['select'][P]>
                                : P extends keyof Role_has_permissions
                                  ? Role_has_permissions[P]
                                  : never
                      }
                    : Role_has_permissions

    type Role_has_permissionsCountArgs = Merge<
        Omit<Role_has_permissionsFindManyArgs, 'select' | 'include'> & {
            select?: Role_has_permissionsCountAggregateInputType | true
        }
    >

    export interface Role_has_permissionsDelegate<
        GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined
    > {
        /**
         * Find zero or one Role_has_permissions that matches the filter.
         * @param {Role_has_permissionsFindUniqueArgs} args - Arguments to find a Role_has_permissions
         * @example
         * // Get one Role_has_permissions
         * const role_has_permissions = await prisma.role_has_permissions.findUnique({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findUnique<
            T extends Role_has_permissionsFindUniqueArgs,
            LocalRejectSettings = T['rejectOnNotFound'] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined
        >(
            args: SelectSubset<T, Role_has_permissionsFindUniqueArgs>
        ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Role_has_permissions'> extends True
            ? Prisma__Role_has_permissionsClient<Role_has_permissionsGetPayload<T>>
            : Prisma__Role_has_permissionsClient<Role_has_permissionsGetPayload<T> | null, null>

        /**
         * Find one Role_has_permissions that matches the filter or throw an error  with `error.code='P2025'`
         *     if no matches were found.
         * @param {Role_has_permissionsFindUniqueOrThrowArgs} args - Arguments to find a Role_has_permissions
         * @example
         * // Get one Role_has_permissions
         * const role_has_permissions = await prisma.role_has_permissions.findUniqueOrThrow({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findUniqueOrThrow<T extends Role_has_permissionsFindUniqueOrThrowArgs>(
            args?: SelectSubset<T, Role_has_permissionsFindUniqueOrThrowArgs>
        ): Prisma__Role_has_permissionsClient<Role_has_permissionsGetPayload<T>>

        /**
         * Find the first Role_has_permissions that matches the filter.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {Role_has_permissionsFindFirstArgs} args - Arguments to find a Role_has_permissions
         * @example
         * // Get one Role_has_permissions
         * const role_has_permissions = await prisma.role_has_permissions.findFirst({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findFirst<
            T extends Role_has_permissionsFindFirstArgs,
            LocalRejectSettings = T['rejectOnNotFound'] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined
        >(
            args?: SelectSubset<T, Role_has_permissionsFindFirstArgs>
        ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Role_has_permissions'> extends True
            ? Prisma__Role_has_permissionsClient<Role_has_permissionsGetPayload<T>>
            : Prisma__Role_has_permissionsClient<Role_has_permissionsGetPayload<T> | null, null>

        /**
         * Find the first Role_has_permissions that matches the filter or
         * throw `NotFoundError` if no matches were found.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {Role_has_permissionsFindFirstOrThrowArgs} args - Arguments to find a Role_has_permissions
         * @example
         * // Get one Role_has_permissions
         * const role_has_permissions = await prisma.role_has_permissions.findFirstOrThrow({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findFirstOrThrow<T extends Role_has_permissionsFindFirstOrThrowArgs>(
            args?: SelectSubset<T, Role_has_permissionsFindFirstOrThrowArgs>
        ): Prisma__Role_has_permissionsClient<Role_has_permissionsGetPayload<T>>

        /**
         * Find zero or more Role_has_permissions that matches the filter.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {Role_has_permissionsFindManyArgs=} args - Arguments to filter and select certain fields only.
         * @example
         * // Get all Role_has_permissions
         * const role_has_permissions = await prisma.role_has_permissions.findMany()
         *
         * // Get first 10 Role_has_permissions
         * const role_has_permissions = await prisma.role_has_permissions.findMany({ take: 10 })
         *
         * // Only select the `permission_id`
         * const role_has_permissionsWithPermission_idOnly = await prisma.role_has_permissions.findMany({ select: { permission_id: true } })
         *
         **/
        findMany<T extends Role_has_permissionsFindManyArgs>(
            args?: SelectSubset<T, Role_has_permissionsFindManyArgs>
        ): PrismaPromise<Array<Role_has_permissionsGetPayload<T>>>

        /**
         * Create a Role_has_permissions.
         * @param {Role_has_permissionsCreateArgs} args - Arguments to create a Role_has_permissions.
         * @example
         * // Create one Role_has_permissions
         * const Role_has_permissions = await prisma.role_has_permissions.create({
         *   data: {
         *     // ... data to create a Role_has_permissions
         *   }
         * })
         *
         **/
        create<T extends Role_has_permissionsCreateArgs>(
            args: SelectSubset<T, Role_has_permissionsCreateArgs>
        ): Prisma__Role_has_permissionsClient<Role_has_permissionsGetPayload<T>>

        /**
         * Create many Role_has_permissions.
         *     @param {Role_has_permissionsCreateManyArgs} args - Arguments to create many Role_has_permissions.
         *     @example
         *     // Create many Role_has_permissions
         *     const role_has_permissions = await prisma.role_has_permissions.createMany({
         *       data: {
         *         // ... provide data here
         *       }
         *     })
         *
         **/
        createMany<T extends Role_has_permissionsCreateManyArgs>(
            args?: SelectSubset<T, Role_has_permissionsCreateManyArgs>
        ): PrismaPromise<BatchPayload>

        /**
         * Delete a Role_has_permissions.
         * @param {Role_has_permissionsDeleteArgs} args - Arguments to delete one Role_has_permissions.
         * @example
         * // Delete one Role_has_permissions
         * const Role_has_permissions = await prisma.role_has_permissions.delete({
         *   where: {
         *     // ... filter to delete one Role_has_permissions
         *   }
         * })
         *
         **/
        delete<T extends Role_has_permissionsDeleteArgs>(
            args: SelectSubset<T, Role_has_permissionsDeleteArgs>
        ): Prisma__Role_has_permissionsClient<Role_has_permissionsGetPayload<T>>

        /**
         * Update one Role_has_permissions.
         * @param {Role_has_permissionsUpdateArgs} args - Arguments to update one Role_has_permissions.
         * @example
         * // Update one Role_has_permissions
         * const role_has_permissions = await prisma.role_has_permissions.update({
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: {
         *     // ... provide data here
         *   }
         * })
         *
         **/
        update<T extends Role_has_permissionsUpdateArgs>(
            args: SelectSubset<T, Role_has_permissionsUpdateArgs>
        ): Prisma__Role_has_permissionsClient<Role_has_permissionsGetPayload<T>>

        /**
         * Delete zero or more Role_has_permissions.
         * @param {Role_has_permissionsDeleteManyArgs} args - Arguments to filter Role_has_permissions to delete.
         * @example
         * // Delete a few Role_has_permissions
         * const { count } = await prisma.role_has_permissions.deleteMany({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         *
         **/
        deleteMany<T extends Role_has_permissionsDeleteManyArgs>(
            args?: SelectSubset<T, Role_has_permissionsDeleteManyArgs>
        ): PrismaPromise<BatchPayload>

        /**
         * Update zero or more Role_has_permissions.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {Role_has_permissionsUpdateManyArgs} args - Arguments to update one or more rows.
         * @example
         * // Update many Role_has_permissions
         * const role_has_permissions = await prisma.role_has_permissions.updateMany({
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: {
         *     // ... provide data here
         *   }
         * })
         *
         **/
        updateMany<T extends Role_has_permissionsUpdateManyArgs>(
            args: SelectSubset<T, Role_has_permissionsUpdateManyArgs>
        ): PrismaPromise<BatchPayload>

        /**
         * Create or update one Role_has_permissions.
         * @param {Role_has_permissionsUpsertArgs} args - Arguments to update or create a Role_has_permissions.
         * @example
         * // Update or create a Role_has_permissions
         * const role_has_permissions = await prisma.role_has_permissions.upsert({
         *   create: {
         *     // ... data to create a Role_has_permissions
         *   },
         *   update: {
         *     // ... in case it already exists, update
         *   },
         *   where: {
         *     // ... the filter for the Role_has_permissions we want to update
         *   }
         * })
         **/
        upsert<T extends Role_has_permissionsUpsertArgs>(
            args: SelectSubset<T, Role_has_permissionsUpsertArgs>
        ): Prisma__Role_has_permissionsClient<Role_has_permissionsGetPayload<T>>

        /**
         * Count the number of Role_has_permissions.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {Role_has_permissionsCountArgs} args - Arguments to filter Role_has_permissions to count.
         * @example
         * // Count the number of Role_has_permissions
         * const count = await prisma.role_has_permissions.count({
         *   where: {
         *     // ... the filter for the Role_has_permissions we want to count
         *   }
         * })
         **/
        count<T extends Role_has_permissionsCountArgs>(
            args?: Subset<T, Role_has_permissionsCountArgs>
        ): PrismaPromise<
            T extends _Record<'select', any>
                ? T['select'] extends true
                    ? number
                    : GetScalarType<T['select'], Role_has_permissionsCountAggregateOutputType>
                : number
        >

        /**
         * Allows you to perform aggregations operations on a Role_has_permissions.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {Role_has_permissionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
         * @example
         * // Ordered by age ascending
         * // Where email contains prisma.io
         * // Limited to the 10 users
         * const aggregations = await prisma.user.aggregate({
         *   _avg: {
         *     age: true,
         *   },
         *   where: {
         *     email: {
         *       contains: "prisma.io",
         *     },
         *   },
         *   orderBy: {
         *     age: "asc",
         *   },
         *   take: 10,
         * })
         **/
        aggregate<T extends Role_has_permissionsAggregateArgs>(
            args: Subset<T, Role_has_permissionsAggregateArgs>
        ): PrismaPromise<GetRole_has_permissionsAggregateType<T>>

        /**
         * Group by Role_has_permissions.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {Role_has_permissionsGroupByArgs} args - Group by arguments.
         * @example
         * // Group by city, order by createdAt, get count
         * const result = await prisma.user.groupBy({
         *   by: ['city', 'createdAt'],
         *   orderBy: {
         *     createdAt: true
         *   },
         *   _count: {
         *     _all: true
         *   },
         * })
         *
         **/
        groupBy<
            T extends Role_has_permissionsGroupByArgs,
            HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
            OrderByArg extends True extends HasSelectOrTake
                ? { orderBy: Role_has_permissionsGroupByArgs['orderBy'] }
                : { orderBy?: Role_has_permissionsGroupByArgs['orderBy'] },
            OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
            ByFields extends TupleToUnion<T['by']>,
            ByValid extends Has<ByFields, OrderFields>,
            HavingFields extends GetHavingFields<T['having']>,
            HavingValid extends Has<ByFields, HavingFields>,
            ByEmpty extends T['by'] extends never[] ? True : False,
            InputErrors extends ByEmpty extends True
                ? `Error: "by" must not be empty.`
                : HavingValid extends False
                  ? {
                        [P in HavingFields]: P extends ByFields
                            ? never
                            : P extends string
                              ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                              : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`]
                    }[HavingFields]
                  : 'take' extends Keys<T>
                    ? 'orderBy' extends Keys<T>
                        ? ByValid extends True
                            ? {}
                            : {
                                  [P in OrderFields]: P extends ByFields
                                      ? never
                                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                              }[OrderFields]
                        : 'Error: If you provide "take", you also need to provide "orderBy"'
                    : 'skip' extends Keys<T>
                      ? 'orderBy' extends Keys<T>
                          ? ByValid extends True
                              ? {}
                              : {
                                    [P in OrderFields]: P extends ByFields
                                        ? never
                                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                                }[OrderFields]
                          : 'Error: If you provide "skip", you also need to provide "orderBy"'
                      : ByValid extends True
                        ? {}
                        : {
                              [P in OrderFields]: P extends ByFields
                                  ? never
                                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                          }[OrderFields]
        >(
            args: SubsetIntersection<T, Role_has_permissionsGroupByArgs, OrderByArg> & InputErrors
        ): {} extends InputErrors ? GetRole_has_permissionsGroupByPayload<T> : PrismaPromise<InputErrors>
    }

    /**
     * The delegate class that acts as a "Promise-like" for Role_has_permissions.
     * Why is this prefixed with `Prisma__`?
     * Because we want to prevent naming conflicts as mentioned in
     * https://github.com/prisma/prisma-client-js/issues/707
     */
    export class Prisma__Role_has_permissionsClient<T, Null = never> implements PrismaPromise<T> {
        [prisma]: true
        private readonly _dmmf
        private readonly _fetcher
        private readonly _queryType
        private readonly _rootField
        private readonly _clientMethod
        private readonly _args
        private readonly _dataPath
        private readonly _errorFormat
        private readonly _measurePerformance?
        private _isList
        private _callsite
        private _requestPromise?
        constructor(
            _dmmf: runtime.DMMFClass,
            _fetcher: PrismaClientFetcher,
            _queryType: 'query' | 'mutation',
            _rootField: string,
            _clientMethod: string,
            _args: any,
            _dataPath: string[],
            _errorFormat: ErrorFormat,
            _measurePerformance?: boolean | undefined,
            _isList?: boolean
        )
        readonly [Symbol.toStringTag]: 'PrismaClientPromise'

        permissions<T extends PermissionsArgs = {}>(
            args?: Subset<T, PermissionsArgs>
        ): Prisma__PermissionsClient<PermissionsGetPayload<T> | Null>

        roles<T extends RolesArgs = {}>(args?: Subset<T, RolesArgs>): Prisma__RolesClient<RolesGetPayload<T> | Null>

        private get _document()
        /**
         * Attaches callbacks for the resolution and/or rejection of the Promise.
         * @param onfulfilled The callback to execute when the Promise is resolved.
         * @param onrejected The callback to execute when the Promise is rejected.
         * @returns A Promise for the completion of which ever callback is executed.
         */
        then<TResult1 = T, TResult2 = never>(
            onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
            onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
        ): Promise<TResult1 | TResult2>
        /**
         * Attaches a callback for only the rejection of the Promise.
         * @param onrejected The callback to execute when the Promise is rejected.
         * @returns A Promise for the completion of the callback.
         */
        catch<TResult = never>(
            onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
        ): Promise<T | TResult>
        /**
         * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
         * resolved value cannot be modified from the callback.
         * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
         * @returns A Promise for the completion of the callback.
         */
        finally(onfinally?: (() => void) | undefined | null): Promise<T>
    }

    // Custom InputTypes

    /**
     * Role_has_permissions base type for findUnique actions
     */
    export type Role_has_permissionsFindUniqueArgsBase = {
        /**
         * Select specific fields to fetch from the Role_has_permissions
         *
         **/
        select?: Role_has_permissionsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Role_has_permissionsInclude | null
        /**
         * Filter, which Role_has_permissions to fetch.
         *
         **/
        where: Role_has_permissionsWhereUniqueInput
    }

    /**
     * Role_has_permissions findUnique
     */
    export interface Role_has_permissionsFindUniqueArgs extends Role_has_permissionsFindUniqueArgsBase {
        /**
         * Throw an Error if query returns no results
         * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
         */
        rejectOnNotFound?: RejectOnNotFound
    }

    /**
     * Role_has_permissions findUniqueOrThrow
     */
    export type Role_has_permissionsFindUniqueOrThrowArgs = {
        /**
         * Select specific fields to fetch from the Role_has_permissions
         *
         **/
        select?: Role_has_permissionsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Role_has_permissionsInclude | null
        /**
         * Filter, which Role_has_permissions to fetch.
         *
         **/
        where: Role_has_permissionsWhereUniqueInput
    }

    /**
     * Role_has_permissions base type for findFirst actions
     */
    export type Role_has_permissionsFindFirstArgsBase = {
        /**
         * Select specific fields to fetch from the Role_has_permissions
         *
         **/
        select?: Role_has_permissionsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Role_has_permissionsInclude | null
        /**
         * Filter, which Role_has_permissions to fetch.
         *
         **/
        where?: Role_has_permissionsWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Role_has_permissions to fetch.
         *
         **/
        orderBy?: Enumerable<Role_has_permissionsOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for searching for Role_has_permissions.
         *
         **/
        cursor?: Role_has_permissionsWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Role_has_permissions from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Role_has_permissions.
         *
         **/
        skip?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
         *
         * Filter by unique combinations of Role_has_permissions.
         *
         **/
        distinct?: Enumerable<Role_has_permissionsScalarFieldEnum>
    }

    /**
     * Role_has_permissions findFirst
     */
    export interface Role_has_permissionsFindFirstArgs extends Role_has_permissionsFindFirstArgsBase {
        /**
         * Throw an Error if query returns no results
         * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
         */
        rejectOnNotFound?: RejectOnNotFound
    }

    /**
     * Role_has_permissions findFirstOrThrow
     */
    export type Role_has_permissionsFindFirstOrThrowArgs = {
        /**
         * Select specific fields to fetch from the Role_has_permissions
         *
         **/
        select?: Role_has_permissionsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Role_has_permissionsInclude | null
        /**
         * Filter, which Role_has_permissions to fetch.
         *
         **/
        where?: Role_has_permissionsWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Role_has_permissions to fetch.
         *
         **/
        orderBy?: Enumerable<Role_has_permissionsOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for searching for Role_has_permissions.
         *
         **/
        cursor?: Role_has_permissionsWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Role_has_permissions from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Role_has_permissions.
         *
         **/
        skip?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
         *
         * Filter by unique combinations of Role_has_permissions.
         *
         **/
        distinct?: Enumerable<Role_has_permissionsScalarFieldEnum>
    }

    /**
     * Role_has_permissions findMany
     */
    export type Role_has_permissionsFindManyArgs = {
        /**
         * Select specific fields to fetch from the Role_has_permissions
         *
         **/
        select?: Role_has_permissionsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Role_has_permissionsInclude | null
        /**
         * Filter, which Role_has_permissions to fetch.
         *
         **/
        where?: Role_has_permissionsWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Role_has_permissions to fetch.
         *
         **/
        orderBy?: Enumerable<Role_has_permissionsOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for listing Role_has_permissions.
         *
         **/
        cursor?: Role_has_permissionsWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Role_has_permissions from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Role_has_permissions.
         *
         **/
        skip?: number
        distinct?: Enumerable<Role_has_permissionsScalarFieldEnum>
    }

    /**
     * Role_has_permissions create
     */
    export type Role_has_permissionsCreateArgs = {
        /**
         * Select specific fields to fetch from the Role_has_permissions
         *
         **/
        select?: Role_has_permissionsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Role_has_permissionsInclude | null
        /**
         * The data needed to create a Role_has_permissions.
         *
         **/
        data: XOR<Role_has_permissionsCreateInput, Role_has_permissionsUncheckedCreateInput>
    }

    /**
     * Role_has_permissions createMany
     */
    export type Role_has_permissionsCreateManyArgs = {
        /**
         * The data used to create many Role_has_permissions.
         *
         **/
        data: Enumerable<Role_has_permissionsCreateManyInput>
        skipDuplicates?: boolean
    }

    /**
     * Role_has_permissions update
     */
    export type Role_has_permissionsUpdateArgs = {
        /**
         * Select specific fields to fetch from the Role_has_permissions
         *
         **/
        select?: Role_has_permissionsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Role_has_permissionsInclude | null
        /**
         * The data needed to update a Role_has_permissions.
         *
         **/
        data: XOR<Role_has_permissionsUpdateInput, Role_has_permissionsUncheckedUpdateInput>
        /**
         * Choose, which Role_has_permissions to update.
         *
         **/
        where: Role_has_permissionsWhereUniqueInput
    }

    /**
     * Role_has_permissions updateMany
     */
    export type Role_has_permissionsUpdateManyArgs = {
        /**
         * The data used to update Role_has_permissions.
         *
         **/
        data: XOR<Role_has_permissionsUpdateManyMutationInput, Role_has_permissionsUncheckedUpdateManyInput>
        /**
         * Filter which Role_has_permissions to update
         *
         **/
        where?: Role_has_permissionsWhereInput
    }

    /**
     * Role_has_permissions upsert
     */
    export type Role_has_permissionsUpsertArgs = {
        /**
         * Select specific fields to fetch from the Role_has_permissions
         *
         **/
        select?: Role_has_permissionsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Role_has_permissionsInclude | null
        /**
         * The filter to search for the Role_has_permissions to update in case it exists.
         *
         **/
        where: Role_has_permissionsWhereUniqueInput
        /**
         * In case the Role_has_permissions found by the `where` argument doesn't exist, create a new Role_has_permissions with this data.
         *
         **/
        create: XOR<Role_has_permissionsCreateInput, Role_has_permissionsUncheckedCreateInput>
        /**
         * In case the Role_has_permissions was found with the provided `where` argument, update it with this data.
         *
         **/
        update: XOR<Role_has_permissionsUpdateInput, Role_has_permissionsUncheckedUpdateInput>
    }

    /**
     * Role_has_permissions delete
     */
    export type Role_has_permissionsDeleteArgs = {
        /**
         * Select specific fields to fetch from the Role_has_permissions
         *
         **/
        select?: Role_has_permissionsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Role_has_permissionsInclude | null
        /**
         * Filter which Role_has_permissions to delete.
         *
         **/
        where: Role_has_permissionsWhereUniqueInput
    }

    /**
     * Role_has_permissions deleteMany
     */
    export type Role_has_permissionsDeleteManyArgs = {
        /**
         * Filter which Role_has_permissions to delete
         *
         **/
        where?: Role_has_permissionsWhereInput
    }

    /**
     * Role_has_permissions without action
     */
    export type Role_has_permissionsArgs = {
        /**
         * Select specific fields to fetch from the Role_has_permissions
         *
         **/
        select?: Role_has_permissionsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Role_has_permissionsInclude | null
    }

    /**
     * Model Roles
     */

    export type AggregateRoles = {
        _count: RolesCountAggregateOutputType | null
        _min: RolesMinAggregateOutputType | null
        _max: RolesMaxAggregateOutputType | null
    }

    export type RolesMinAggregateOutputType = {
        uuid: string | null
        name: string | null
        guard_name: string | null
        created_at: Date | null
        updated_at: Date | null
    }

    export type RolesMaxAggregateOutputType = {
        uuid: string | null
        name: string | null
        guard_name: string | null
        created_at: Date | null
        updated_at: Date | null
    }

    export type RolesCountAggregateOutputType = {
        uuid: number
        name: number
        guard_name: number
        created_at: number
        updated_at: number
        _all: number
    }

    export type RolesMinAggregateInputType = {
        uuid?: true
        name?: true
        guard_name?: true
        created_at?: true
        updated_at?: true
    }

    export type RolesMaxAggregateInputType = {
        uuid?: true
        name?: true
        guard_name?: true
        created_at?: true
        updated_at?: true
    }

    export type RolesCountAggregateInputType = {
        uuid?: true
        name?: true
        guard_name?: true
        created_at?: true
        updated_at?: true
        _all?: true
    }

    export type RolesAggregateArgs = {
        /**
         * Filter which Roles to aggregate.
         *
         **/
        where?: RolesWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Roles to fetch.
         *
         **/
        orderBy?: Enumerable<RolesOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the start position
         *
         **/
        cursor?: RolesWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Roles from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Roles.
         *
         **/
        skip?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Count returned Roles
         **/
        _count?: true | RolesCountAggregateInputType
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to find the minimum value
         **/
        _min?: RolesMinAggregateInputType
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to find the maximum value
         **/
        _max?: RolesMaxAggregateInputType
    }

    export type GetRolesAggregateType<T extends RolesAggregateArgs> = {
        [P in keyof T & keyof AggregateRoles]: P extends '_count' | 'count'
            ? T[P] extends true
                ? number
                : GetScalarType<T[P], AggregateRoles[P]>
            : GetScalarType<T[P], AggregateRoles[P]>
    }

    export type RolesGroupByArgs = {
        where?: RolesWhereInput
        orderBy?: Enumerable<RolesOrderByWithAggregationInput>
        by: Array<RolesScalarFieldEnum>
        having?: RolesScalarWhereWithAggregatesInput
        take?: number
        skip?: number
        _count?: RolesCountAggregateInputType | true
        _min?: RolesMinAggregateInputType
        _max?: RolesMaxAggregateInputType
    }

    export type RolesGroupByOutputType = {
        uuid: string
        name: string
        guard_name: string
        created_at: Date | null
        updated_at: Date | null
        _count: RolesCountAggregateOutputType | null
        _min: RolesMinAggregateOutputType | null
        _max: RolesMaxAggregateOutputType | null
    }

    type GetRolesGroupByPayload<T extends RolesGroupByArgs> = PrismaPromise<
        Array<
            PickArray<RolesGroupByOutputType, T['by']> & {
                [P in keyof T & keyof RolesGroupByOutputType]: P extends '_count'
                    ? T[P] extends boolean
                        ? number
                        : GetScalarType<T[P], RolesGroupByOutputType[P]>
                    : GetScalarType<T[P], RolesGroupByOutputType[P]>
            }
        >
    >

    export type RolesSelect = {
        uuid?: boolean
        name?: boolean
        guard_name?: boolean
        created_at?: boolean
        updated_at?: boolean
        model_has_roles?: boolean | Roles$model_has_rolesArgs
        role_has_permissions?: boolean | Roles$role_has_permissionsArgs
        _count?: boolean | RolesCountOutputTypeArgs
    }

    export type RolesInclude = {
        model_has_roles?: boolean | Roles$model_has_rolesArgs
        role_has_permissions?: boolean | Roles$role_has_permissionsArgs
        _count?: boolean | RolesCountOutputTypeArgs
    }

    export type RolesGetPayload<S extends boolean | null | undefined | RolesArgs> = S extends {
        select: any
        include: any
    }
        ? 'Please either choose `select` or `include`'
        : S extends true
          ? Roles
          : S extends undefined
            ? never
            : S extends { include: any } & (RolesArgs | RolesFindManyArgs)
              ? Roles & {
                    [P in TruthyKeys<S['include']>]: P extends 'model_has_roles'
                        ? Array<Model_has_rolesGetPayload<S['include'][P]>>
                        : P extends 'role_has_permissions'
                          ? Array<Role_has_permissionsGetPayload<S['include'][P]>>
                          : P extends '_count'
                            ? RolesCountOutputTypeGetPayload<S['include'][P]>
                            : never
                }
              : S extends { select: any } & (RolesArgs | RolesFindManyArgs)
                ? {
                      [P in TruthyKeys<S['select']>]: P extends 'model_has_roles'
                          ? Array<Model_has_rolesGetPayload<S['select'][P]>>
                          : P extends 'role_has_permissions'
                            ? Array<Role_has_permissionsGetPayload<S['select'][P]>>
                            : P extends '_count'
                              ? RolesCountOutputTypeGetPayload<S['select'][P]>
                              : P extends keyof Roles
                                ? Roles[P]
                                : never
                  }
                : Roles

    type RolesCountArgs = Merge<
        Omit<RolesFindManyArgs, 'select' | 'include'> & {
            select?: RolesCountAggregateInputType | true
        }
    >

    export interface RolesDelegate<
        GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined
    > {
        /**
         * Find zero or one Roles that matches the filter.
         * @param {RolesFindUniqueArgs} args - Arguments to find a Roles
         * @example
         * // Get one Roles
         * const roles = await prisma.roles.findUnique({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findUnique<
            T extends RolesFindUniqueArgs,
            LocalRejectSettings = T['rejectOnNotFound'] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined
        >(
            args: SelectSubset<T, RolesFindUniqueArgs>
        ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Roles'> extends True
            ? Prisma__RolesClient<RolesGetPayload<T>>
            : Prisma__RolesClient<RolesGetPayload<T> | null, null>

        /**
         * Find one Roles that matches the filter or throw an error  with `error.code='P2025'`
         *     if no matches were found.
         * @param {RolesFindUniqueOrThrowArgs} args - Arguments to find a Roles
         * @example
         * // Get one Roles
         * const roles = await prisma.roles.findUniqueOrThrow({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findUniqueOrThrow<T extends RolesFindUniqueOrThrowArgs>(
            args?: SelectSubset<T, RolesFindUniqueOrThrowArgs>
        ): Prisma__RolesClient<RolesGetPayload<T>>

        /**
         * Find the first Roles that matches the filter.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {RolesFindFirstArgs} args - Arguments to find a Roles
         * @example
         * // Get one Roles
         * const roles = await prisma.roles.findFirst({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findFirst<
            T extends RolesFindFirstArgs,
            LocalRejectSettings = T['rejectOnNotFound'] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined
        >(
            args?: SelectSubset<T, RolesFindFirstArgs>
        ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Roles'> extends True
            ? Prisma__RolesClient<RolesGetPayload<T>>
            : Prisma__RolesClient<RolesGetPayload<T> | null, null>

        /**
         * Find the first Roles that matches the filter or
         * throw `NotFoundError` if no matches were found.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {RolesFindFirstOrThrowArgs} args - Arguments to find a Roles
         * @example
         * // Get one Roles
         * const roles = await prisma.roles.findFirstOrThrow({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findFirstOrThrow<T extends RolesFindFirstOrThrowArgs>(
            args?: SelectSubset<T, RolesFindFirstOrThrowArgs>
        ): Prisma__RolesClient<RolesGetPayload<T>>

        /**
         * Find zero or more Roles that matches the filter.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {RolesFindManyArgs=} args - Arguments to filter and select certain fields only.
         * @example
         * // Get all Roles
         * const roles = await prisma.roles.findMany()
         *
         * // Get first 10 Roles
         * const roles = await prisma.roles.findMany({ take: 10 })
         *
         * // Only select the `uuid`
         * const rolesWithUuidOnly = await prisma.roles.findMany({ select: { uuid: true } })
         *
         **/
        findMany<T extends RolesFindManyArgs>(
            args?: SelectSubset<T, RolesFindManyArgs>
        ): PrismaPromise<Array<RolesGetPayload<T>>>

        /**
         * Create a Roles.
         * @param {RolesCreateArgs} args - Arguments to create a Roles.
         * @example
         * // Create one Roles
         * const Roles = await prisma.roles.create({
         *   data: {
         *     // ... data to create a Roles
         *   }
         * })
         *
         **/
        create<T extends RolesCreateArgs>(
            args: SelectSubset<T, RolesCreateArgs>
        ): Prisma__RolesClient<RolesGetPayload<T>>

        /**
         * Create many Roles.
         *     @param {RolesCreateManyArgs} args - Arguments to create many Roles.
         *     @example
         *     // Create many Roles
         *     const roles = await prisma.roles.createMany({
         *       data: {
         *         // ... provide data here
         *       }
         *     })
         *
         **/
        createMany<T extends RolesCreateManyArgs>(
            args?: SelectSubset<T, RolesCreateManyArgs>
        ): PrismaPromise<BatchPayload>

        /**
         * Delete a Roles.
         * @param {RolesDeleteArgs} args - Arguments to delete one Roles.
         * @example
         * // Delete one Roles
         * const Roles = await prisma.roles.delete({
         *   where: {
         *     // ... filter to delete one Roles
         *   }
         * })
         *
         **/
        delete<T extends RolesDeleteArgs>(
            args: SelectSubset<T, RolesDeleteArgs>
        ): Prisma__RolesClient<RolesGetPayload<T>>

        /**
         * Update one Roles.
         * @param {RolesUpdateArgs} args - Arguments to update one Roles.
         * @example
         * // Update one Roles
         * const roles = await prisma.roles.update({
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: {
         *     // ... provide data here
         *   }
         * })
         *
         **/
        update<T extends RolesUpdateArgs>(
            args: SelectSubset<T, RolesUpdateArgs>
        ): Prisma__RolesClient<RolesGetPayload<T>>

        /**
         * Delete zero or more Roles.
         * @param {RolesDeleteManyArgs} args - Arguments to filter Roles to delete.
         * @example
         * // Delete a few Roles
         * const { count } = await prisma.roles.deleteMany({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         *
         **/
        deleteMany<T extends RolesDeleteManyArgs>(
            args?: SelectSubset<T, RolesDeleteManyArgs>
        ): PrismaPromise<BatchPayload>

        /**
         * Update zero or more Roles.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {RolesUpdateManyArgs} args - Arguments to update one or more rows.
         * @example
         * // Update many Roles
         * const roles = await prisma.roles.updateMany({
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: {
         *     // ... provide data here
         *   }
         * })
         *
         **/
        updateMany<T extends RolesUpdateManyArgs>(
            args: SelectSubset<T, RolesUpdateManyArgs>
        ): PrismaPromise<BatchPayload>

        /**
         * Create or update one Roles.
         * @param {RolesUpsertArgs} args - Arguments to update or create a Roles.
         * @example
         * // Update or create a Roles
         * const roles = await prisma.roles.upsert({
         *   create: {
         *     // ... data to create a Roles
         *   },
         *   update: {
         *     // ... in case it already exists, update
         *   },
         *   where: {
         *     // ... the filter for the Roles we want to update
         *   }
         * })
         **/
        upsert<T extends RolesUpsertArgs>(
            args: SelectSubset<T, RolesUpsertArgs>
        ): Prisma__RolesClient<RolesGetPayload<T>>

        /**
         * Count the number of Roles.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {RolesCountArgs} args - Arguments to filter Roles to count.
         * @example
         * // Count the number of Roles
         * const count = await prisma.roles.count({
         *   where: {
         *     // ... the filter for the Roles we want to count
         *   }
         * })
         **/
        count<T extends RolesCountArgs>(
            args?: Subset<T, RolesCountArgs>
        ): PrismaPromise<
            T extends _Record<'select', any>
                ? T['select'] extends true
                    ? number
                    : GetScalarType<T['select'], RolesCountAggregateOutputType>
                : number
        >

        /**
         * Allows you to perform aggregations operations on a Roles.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {RolesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
         * @example
         * // Ordered by age ascending
         * // Where email contains prisma.io
         * // Limited to the 10 users
         * const aggregations = await prisma.user.aggregate({
         *   _avg: {
         *     age: true,
         *   },
         *   where: {
         *     email: {
         *       contains: "prisma.io",
         *     },
         *   },
         *   orderBy: {
         *     age: "asc",
         *   },
         *   take: 10,
         * })
         **/
        aggregate<T extends RolesAggregateArgs>(
            args: Subset<T, RolesAggregateArgs>
        ): PrismaPromise<GetRolesAggregateType<T>>

        /**
         * Group by Roles.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {RolesGroupByArgs} args - Group by arguments.
         * @example
         * // Group by city, order by createdAt, get count
         * const result = await prisma.user.groupBy({
         *   by: ['city', 'createdAt'],
         *   orderBy: {
         *     createdAt: true
         *   },
         *   _count: {
         *     _all: true
         *   },
         * })
         *
         **/
        groupBy<
            T extends RolesGroupByArgs,
            HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
            OrderByArg extends True extends HasSelectOrTake
                ? { orderBy: RolesGroupByArgs['orderBy'] }
                : { orderBy?: RolesGroupByArgs['orderBy'] },
            OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
            ByFields extends TupleToUnion<T['by']>,
            ByValid extends Has<ByFields, OrderFields>,
            HavingFields extends GetHavingFields<T['having']>,
            HavingValid extends Has<ByFields, HavingFields>,
            ByEmpty extends T['by'] extends never[] ? True : False,
            InputErrors extends ByEmpty extends True
                ? `Error: "by" must not be empty.`
                : HavingValid extends False
                  ? {
                        [P in HavingFields]: P extends ByFields
                            ? never
                            : P extends string
                              ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                              : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`]
                    }[HavingFields]
                  : 'take' extends Keys<T>
                    ? 'orderBy' extends Keys<T>
                        ? ByValid extends True
                            ? {}
                            : {
                                  [P in OrderFields]: P extends ByFields
                                      ? never
                                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                              }[OrderFields]
                        : 'Error: If you provide "take", you also need to provide "orderBy"'
                    : 'skip' extends Keys<T>
                      ? 'orderBy' extends Keys<T>
                          ? ByValid extends True
                              ? {}
                              : {
                                    [P in OrderFields]: P extends ByFields
                                        ? never
                                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                                }[OrderFields]
                          : 'Error: If you provide "skip", you also need to provide "orderBy"'
                      : ByValid extends True
                        ? {}
                        : {
                              [P in OrderFields]: P extends ByFields
                                  ? never
                                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                          }[OrderFields]
        >(
            args: SubsetIntersection<T, RolesGroupByArgs, OrderByArg> & InputErrors
        ): {} extends InputErrors ? GetRolesGroupByPayload<T> : PrismaPromise<InputErrors>
    }

    /**
     * The delegate class that acts as a "Promise-like" for Roles.
     * Why is this prefixed with `Prisma__`?
     * Because we want to prevent naming conflicts as mentioned in
     * https://github.com/prisma/prisma-client-js/issues/707
     */
    export class Prisma__RolesClient<T, Null = never> implements PrismaPromise<T> {
        [prisma]: true
        private readonly _dmmf
        private readonly _fetcher
        private readonly _queryType
        private readonly _rootField
        private readonly _clientMethod
        private readonly _args
        private readonly _dataPath
        private readonly _errorFormat
        private readonly _measurePerformance?
        private _isList
        private _callsite
        private _requestPromise?
        constructor(
            _dmmf: runtime.DMMFClass,
            _fetcher: PrismaClientFetcher,
            _queryType: 'query' | 'mutation',
            _rootField: string,
            _clientMethod: string,
            _args: any,
            _dataPath: string[],
            _errorFormat: ErrorFormat,
            _measurePerformance?: boolean | undefined,
            _isList?: boolean
        )
        readonly [Symbol.toStringTag]: 'PrismaClientPromise'

        model_has_roles<T extends Roles$model_has_rolesArgs = {}>(
            args?: Subset<T, Roles$model_has_rolesArgs>
        ): PrismaPromise<Array<Model_has_rolesGetPayload<T>> | Null>

        role_has_permissions<T extends Roles$role_has_permissionsArgs = {}>(
            args?: Subset<T, Roles$role_has_permissionsArgs>
        ): PrismaPromise<Array<Role_has_permissionsGetPayload<T>> | Null>

        private get _document()
        /**
         * Attaches callbacks for the resolution and/or rejection of the Promise.
         * @param onfulfilled The callback to execute when the Promise is resolved.
         * @param onrejected The callback to execute when the Promise is rejected.
         * @returns A Promise for the completion of which ever callback is executed.
         */
        then<TResult1 = T, TResult2 = never>(
            onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
            onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
        ): Promise<TResult1 | TResult2>
        /**
         * Attaches a callback for only the rejection of the Promise.
         * @param onrejected The callback to execute when the Promise is rejected.
         * @returns A Promise for the completion of the callback.
         */
        catch<TResult = never>(
            onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
        ): Promise<T | TResult>
        /**
         * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
         * resolved value cannot be modified from the callback.
         * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
         * @returns A Promise for the completion of the callback.
         */
        finally(onfinally?: (() => void) | undefined | null): Promise<T>
    }

    // Custom InputTypes

    /**
     * Roles base type for findUnique actions
     */
    export type RolesFindUniqueArgsBase = {
        /**
         * Select specific fields to fetch from the Roles
         *
         **/
        select?: RolesSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: RolesInclude | null
        /**
         * Filter, which Roles to fetch.
         *
         **/
        where: RolesWhereUniqueInput
    }

    /**
     * Roles findUnique
     */
    export interface RolesFindUniqueArgs extends RolesFindUniqueArgsBase {
        /**
         * Throw an Error if query returns no results
         * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
         */
        rejectOnNotFound?: RejectOnNotFound
    }

    /**
     * Roles findUniqueOrThrow
     */
    export type RolesFindUniqueOrThrowArgs = {
        /**
         * Select specific fields to fetch from the Roles
         *
         **/
        select?: RolesSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: RolesInclude | null
        /**
         * Filter, which Roles to fetch.
         *
         **/
        where: RolesWhereUniqueInput
    }

    /**
     * Roles base type for findFirst actions
     */
    export type RolesFindFirstArgsBase = {
        /**
         * Select specific fields to fetch from the Roles
         *
         **/
        select?: RolesSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: RolesInclude | null
        /**
         * Filter, which Roles to fetch.
         *
         **/
        where?: RolesWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Roles to fetch.
         *
         **/
        orderBy?: Enumerable<RolesOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for searching for Roles.
         *
         **/
        cursor?: RolesWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Roles from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Roles.
         *
         **/
        skip?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
         *
         * Filter by unique combinations of Roles.
         *
         **/
        distinct?: Enumerable<RolesScalarFieldEnum>
    }

    /**
     * Roles findFirst
     */
    export interface RolesFindFirstArgs extends RolesFindFirstArgsBase {
        /**
         * Throw an Error if query returns no results
         * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
         */
        rejectOnNotFound?: RejectOnNotFound
    }

    /**
     * Roles findFirstOrThrow
     */
    export type RolesFindFirstOrThrowArgs = {
        /**
         * Select specific fields to fetch from the Roles
         *
         **/
        select?: RolesSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: RolesInclude | null
        /**
         * Filter, which Roles to fetch.
         *
         **/
        where?: RolesWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Roles to fetch.
         *
         **/
        orderBy?: Enumerable<RolesOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for searching for Roles.
         *
         **/
        cursor?: RolesWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Roles from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Roles.
         *
         **/
        skip?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
         *
         * Filter by unique combinations of Roles.
         *
         **/
        distinct?: Enumerable<RolesScalarFieldEnum>
    }

    /**
     * Roles findMany
     */
    export type RolesFindManyArgs = {
        /**
         * Select specific fields to fetch from the Roles
         *
         **/
        select?: RolesSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: RolesInclude | null
        /**
         * Filter, which Roles to fetch.
         *
         **/
        where?: RolesWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Roles to fetch.
         *
         **/
        orderBy?: Enumerable<RolesOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for listing Roles.
         *
         **/
        cursor?: RolesWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Roles from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Roles.
         *
         **/
        skip?: number
        distinct?: Enumerable<RolesScalarFieldEnum>
    }

    /**
     * Roles create
     */
    export type RolesCreateArgs = {
        /**
         * Select specific fields to fetch from the Roles
         *
         **/
        select?: RolesSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: RolesInclude | null
        /**
         * The data needed to create a Roles.
         *
         **/
        data: XOR<RolesCreateInput, RolesUncheckedCreateInput>
    }

    /**
     * Roles createMany
     */
    export type RolesCreateManyArgs = {
        /**
         * The data used to create many Roles.
         *
         **/
        data: Enumerable<RolesCreateManyInput>
        skipDuplicates?: boolean
    }

    /**
     * Roles update
     */
    export type RolesUpdateArgs = {
        /**
         * Select specific fields to fetch from the Roles
         *
         **/
        select?: RolesSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: RolesInclude | null
        /**
         * The data needed to update a Roles.
         *
         **/
        data: XOR<RolesUpdateInput, RolesUncheckedUpdateInput>
        /**
         * Choose, which Roles to update.
         *
         **/
        where: RolesWhereUniqueInput
    }

    /**
     * Roles updateMany
     */
    export type RolesUpdateManyArgs = {
        /**
         * The data used to update Roles.
         *
         **/
        data: XOR<RolesUpdateManyMutationInput, RolesUncheckedUpdateManyInput>
        /**
         * Filter which Roles to update
         *
         **/
        where?: RolesWhereInput
    }

    /**
     * Roles upsert
     */
    export type RolesUpsertArgs = {
        /**
         * Select specific fields to fetch from the Roles
         *
         **/
        select?: RolesSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: RolesInclude | null
        /**
         * The filter to search for the Roles to update in case it exists.
         *
         **/
        where: RolesWhereUniqueInput
        /**
         * In case the Roles found by the `where` argument doesn't exist, create a new Roles with this data.
         *
         **/
        create: XOR<RolesCreateInput, RolesUncheckedCreateInput>
        /**
         * In case the Roles was found with the provided `where` argument, update it with this data.
         *
         **/
        update: XOR<RolesUpdateInput, RolesUncheckedUpdateInput>
    }

    /**
     * Roles delete
     */
    export type RolesDeleteArgs = {
        /**
         * Select specific fields to fetch from the Roles
         *
         **/
        select?: RolesSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: RolesInclude | null
        /**
         * Filter which Roles to delete.
         *
         **/
        where: RolesWhereUniqueInput
    }

    /**
     * Roles deleteMany
     */
    export type RolesDeleteManyArgs = {
        /**
         * Filter which Roles to delete
         *
         **/
        where?: RolesWhereInput
    }

    /**
     * Roles.model_has_roles
     */
    export type Roles$model_has_rolesArgs = {
        /**
         * Select specific fields to fetch from the Model_has_roles
         *
         **/
        select?: Model_has_rolesSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Model_has_rolesInclude | null
        where?: Model_has_rolesWhereInput
        orderBy?: Enumerable<Model_has_rolesOrderByWithRelationInput>
        cursor?: Model_has_rolesWhereUniqueInput
        take?: number
        skip?: number
        distinct?: Enumerable<Model_has_rolesScalarFieldEnum>
    }

    /**
     * Roles.role_has_permissions
     */
    export type Roles$role_has_permissionsArgs = {
        /**
         * Select specific fields to fetch from the Role_has_permissions
         *
         **/
        select?: Role_has_permissionsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Role_has_permissionsInclude | null
        where?: Role_has_permissionsWhereInput
        orderBy?: Enumerable<Role_has_permissionsOrderByWithRelationInput>
        cursor?: Role_has_permissionsWhereUniqueInput
        take?: number
        skip?: number
        distinct?: Enumerable<Role_has_permissionsScalarFieldEnum>
    }

    /**
     * Roles without action
     */
    export type RolesArgs = {
        /**
         * Select specific fields to fetch from the Roles
         *
         **/
        select?: RolesSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: RolesInclude | null
    }

    /**
     * Model Second_sponsors
     */

    export type AggregateSecond_sponsors = {
        _count: Second_sponsorsCountAggregateOutputType | null
        _avg: Second_sponsorsAvgAggregateOutputType | null
        _sum: Second_sponsorsSumAggregateOutputType | null
        _min: Second_sponsorsMinAggregateOutputType | null
        _max: Second_sponsorsMaxAggregateOutputType | null
    }

    export type Second_sponsorsAvgAggregateOutputType = {
        income: number | null
    }

    export type Second_sponsorsSumAggregateOutputType = {
        income: number | null
    }

    export type Second_sponsorsMinAggregateOutputType = {
        id: string | null
        first_name: string | null
        last_name: string | null
        degree_of_kinship: string | null
        phone_number: string | null
        address: string | null
        income: number | null
        family_id: string | null
        tenant_id: string | null
        deleted_at: Date | null
        created_at: Date | null
        updated_at: Date | null
    }

    export type Second_sponsorsMaxAggregateOutputType = {
        id: string | null
        first_name: string | null
        last_name: string | null
        degree_of_kinship: string | null
        phone_number: string | null
        address: string | null
        income: number | null
        family_id: string | null
        tenant_id: string | null
        deleted_at: Date | null
        created_at: Date | null
        updated_at: Date | null
    }

    export type Second_sponsorsCountAggregateOutputType = {
        id: number
        first_name: number
        last_name: number
        degree_of_kinship: number
        phone_number: number
        address: number
        income: number
        family_id: number
        tenant_id: number
        deleted_at: number
        created_at: number
        updated_at: number
        _all: number
    }

    export type Second_sponsorsAvgAggregateInputType = {
        income?: true
    }

    export type Second_sponsorsSumAggregateInputType = {
        income?: true
    }

    export type Second_sponsorsMinAggregateInputType = {
        id?: true
        first_name?: true
        last_name?: true
        degree_of_kinship?: true
        phone_number?: true
        address?: true
        income?: true
        family_id?: true
        tenant_id?: true
        deleted_at?: true
        created_at?: true
        updated_at?: true
    }

    export type Second_sponsorsMaxAggregateInputType = {
        id?: true
        first_name?: true
        last_name?: true
        degree_of_kinship?: true
        phone_number?: true
        address?: true
        income?: true
        family_id?: true
        tenant_id?: true
        deleted_at?: true
        created_at?: true
        updated_at?: true
    }

    export type Second_sponsorsCountAggregateInputType = {
        id?: true
        first_name?: true
        last_name?: true
        degree_of_kinship?: true
        phone_number?: true
        address?: true
        income?: true
        family_id?: true
        tenant_id?: true
        deleted_at?: true
        created_at?: true
        updated_at?: true
        _all?: true
    }

    export type Second_sponsorsAggregateArgs = {
        /**
         * Filter which Second_sponsors to aggregate.
         *
         **/
        where?: Second_sponsorsWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Second_sponsors to fetch.
         *
         **/
        orderBy?: Enumerable<Second_sponsorsOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the start position
         *
         **/
        cursor?: Second_sponsorsWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Second_sponsors from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Second_sponsors.
         *
         **/
        skip?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Count returned Second_sponsors
         **/
        _count?: true | Second_sponsorsCountAggregateInputType
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to average
         **/
        _avg?: Second_sponsorsAvgAggregateInputType
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to sum
         **/
        _sum?: Second_sponsorsSumAggregateInputType
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to find the minimum value
         **/
        _min?: Second_sponsorsMinAggregateInputType
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to find the maximum value
         **/
        _max?: Second_sponsorsMaxAggregateInputType
    }

    export type GetSecond_sponsorsAggregateType<T extends Second_sponsorsAggregateArgs> = {
        [P in keyof T & keyof AggregateSecond_sponsors]: P extends '_count' | 'count'
            ? T[P] extends true
                ? number
                : GetScalarType<T[P], AggregateSecond_sponsors[P]>
            : GetScalarType<T[P], AggregateSecond_sponsors[P]>
    }

    export type Second_sponsorsGroupByArgs = {
        where?: Second_sponsorsWhereInput
        orderBy?: Enumerable<Second_sponsorsOrderByWithAggregationInput>
        by: Array<Second_sponsorsScalarFieldEnum>
        having?: Second_sponsorsScalarWhereWithAggregatesInput
        take?: number
        skip?: number
        _count?: Second_sponsorsCountAggregateInputType | true
        _avg?: Second_sponsorsAvgAggregateInputType
        _sum?: Second_sponsorsSumAggregateInputType
        _min?: Second_sponsorsMinAggregateInputType
        _max?: Second_sponsorsMaxAggregateInputType
    }

    export type Second_sponsorsGroupByOutputType = {
        id: string
        first_name: string
        last_name: string
        degree_of_kinship: string
        phone_number: string
        address: string
        income: number
        family_id: string
        tenant_id: string
        deleted_at: Date | null
        created_at: Date | null
        updated_at: Date | null
        _count: Second_sponsorsCountAggregateOutputType | null
        _avg: Second_sponsorsAvgAggregateOutputType | null
        _sum: Second_sponsorsSumAggregateOutputType | null
        _min: Second_sponsorsMinAggregateOutputType | null
        _max: Second_sponsorsMaxAggregateOutputType | null
    }

    type GetSecond_sponsorsGroupByPayload<T extends Second_sponsorsGroupByArgs> = PrismaPromise<
        Array<
            PickArray<Second_sponsorsGroupByOutputType, T['by']> & {
                [P in keyof T & keyof Second_sponsorsGroupByOutputType]: P extends '_count'
                    ? T[P] extends boolean
                        ? number
                        : GetScalarType<T[P], Second_sponsorsGroupByOutputType[P]>
                    : GetScalarType<T[P], Second_sponsorsGroupByOutputType[P]>
            }
        >
    >

    export type Second_sponsorsSelect = {
        id?: boolean
        first_name?: boolean
        last_name?: boolean
        degree_of_kinship?: boolean
        phone_number?: boolean
        address?: boolean
        income?: boolean
        family_id?: boolean
        tenant_id?: boolean
        deleted_at?: boolean
        created_at?: boolean
        updated_at?: boolean
        families?: boolean | FamiliesArgs
        tenants?: boolean | TenantsArgs
    }

    export type Second_sponsorsInclude = {
        families?: boolean | FamiliesArgs
        tenants?: boolean | TenantsArgs
    }

    export type Second_sponsorsGetPayload<S extends boolean | null | undefined | Second_sponsorsArgs> = S extends {
        select: any
        include: any
    }
        ? 'Please either choose `select` or `include`'
        : S extends true
          ? Second_sponsors
          : S extends undefined
            ? never
            : S extends { include: any } & (Second_sponsorsArgs | Second_sponsorsFindManyArgs)
              ? Second_sponsors & {
                    [P in TruthyKeys<S['include']>]: P extends 'families'
                        ? FamiliesGetPayload<S['include'][P]>
                        : P extends 'tenants'
                          ? TenantsGetPayload<S['include'][P]>
                          : never
                }
              : S extends { select: any } & (Second_sponsorsArgs | Second_sponsorsFindManyArgs)
                ? {
                      [P in TruthyKeys<S['select']>]: P extends 'families'
                          ? FamiliesGetPayload<S['select'][P]>
                          : P extends 'tenants'
                            ? TenantsGetPayload<S['select'][P]>
                            : P extends keyof Second_sponsors
                              ? Second_sponsors[P]
                              : never
                  }
                : Second_sponsors

    type Second_sponsorsCountArgs = Merge<
        Omit<Second_sponsorsFindManyArgs, 'select' | 'include'> & {
            select?: Second_sponsorsCountAggregateInputType | true
        }
    >

    export interface Second_sponsorsDelegate<
        GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined
    > {
        /**
         * Find zero or one Second_sponsors that matches the filter.
         * @param {Second_sponsorsFindUniqueArgs} args - Arguments to find a Second_sponsors
         * @example
         * // Get one Second_sponsors
         * const second_sponsors = await prisma.second_sponsors.findUnique({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findUnique<
            T extends Second_sponsorsFindUniqueArgs,
            LocalRejectSettings = T['rejectOnNotFound'] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined
        >(
            args: SelectSubset<T, Second_sponsorsFindUniqueArgs>
        ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Second_sponsors'> extends True
            ? Prisma__Second_sponsorsClient<Second_sponsorsGetPayload<T>>
            : Prisma__Second_sponsorsClient<Second_sponsorsGetPayload<T> | null, null>

        /**
         * Find one Second_sponsors that matches the filter or throw an error  with `error.code='P2025'`
         *     if no matches were found.
         * @param {Second_sponsorsFindUniqueOrThrowArgs} args - Arguments to find a Second_sponsors
         * @example
         * // Get one Second_sponsors
         * const second_sponsors = await prisma.second_sponsors.findUniqueOrThrow({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findUniqueOrThrow<T extends Second_sponsorsFindUniqueOrThrowArgs>(
            args?: SelectSubset<T, Second_sponsorsFindUniqueOrThrowArgs>
        ): Prisma__Second_sponsorsClient<Second_sponsorsGetPayload<T>>

        /**
         * Find the first Second_sponsors that matches the filter.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {Second_sponsorsFindFirstArgs} args - Arguments to find a Second_sponsors
         * @example
         * // Get one Second_sponsors
         * const second_sponsors = await prisma.second_sponsors.findFirst({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findFirst<
            T extends Second_sponsorsFindFirstArgs,
            LocalRejectSettings = T['rejectOnNotFound'] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined
        >(
            args?: SelectSubset<T, Second_sponsorsFindFirstArgs>
        ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Second_sponsors'> extends True
            ? Prisma__Second_sponsorsClient<Second_sponsorsGetPayload<T>>
            : Prisma__Second_sponsorsClient<Second_sponsorsGetPayload<T> | null, null>

        /**
         * Find the first Second_sponsors that matches the filter or
         * throw `NotFoundError` if no matches were found.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {Second_sponsorsFindFirstOrThrowArgs} args - Arguments to find a Second_sponsors
         * @example
         * // Get one Second_sponsors
         * const second_sponsors = await prisma.second_sponsors.findFirstOrThrow({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findFirstOrThrow<T extends Second_sponsorsFindFirstOrThrowArgs>(
            args?: SelectSubset<T, Second_sponsorsFindFirstOrThrowArgs>
        ): Prisma__Second_sponsorsClient<Second_sponsorsGetPayload<T>>

        /**
         * Find zero or more Second_sponsors that matches the filter.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {Second_sponsorsFindManyArgs=} args - Arguments to filter and select certain fields only.
         * @example
         * // Get all Second_sponsors
         * const second_sponsors = await prisma.second_sponsors.findMany()
         *
         * // Get first 10 Second_sponsors
         * const second_sponsors = await prisma.second_sponsors.findMany({ take: 10 })
         *
         * // Only select the `id`
         * const second_sponsorsWithIdOnly = await prisma.second_sponsors.findMany({ select: { id: true } })
         *
         **/
        findMany<T extends Second_sponsorsFindManyArgs>(
            args?: SelectSubset<T, Second_sponsorsFindManyArgs>
        ): PrismaPromise<Array<Second_sponsorsGetPayload<T>>>

        /**
         * Create a Second_sponsors.
         * @param {Second_sponsorsCreateArgs} args - Arguments to create a Second_sponsors.
         * @example
         * // Create one Second_sponsors
         * const Second_sponsors = await prisma.second_sponsors.create({
         *   data: {
         *     // ... data to create a Second_sponsors
         *   }
         * })
         *
         **/
        create<T extends Second_sponsorsCreateArgs>(
            args: SelectSubset<T, Second_sponsorsCreateArgs>
        ): Prisma__Second_sponsorsClient<Second_sponsorsGetPayload<T>>

        /**
         * Create many Second_sponsors.
         *     @param {Second_sponsorsCreateManyArgs} args - Arguments to create many Second_sponsors.
         *     @example
         *     // Create many Second_sponsors
         *     const second_sponsors = await prisma.second_sponsors.createMany({
         *       data: {
         *         // ... provide data here
         *       }
         *     })
         *
         **/
        createMany<T extends Second_sponsorsCreateManyArgs>(
            args?: SelectSubset<T, Second_sponsorsCreateManyArgs>
        ): PrismaPromise<BatchPayload>

        /**
         * Delete a Second_sponsors.
         * @param {Second_sponsorsDeleteArgs} args - Arguments to delete one Second_sponsors.
         * @example
         * // Delete one Second_sponsors
         * const Second_sponsors = await prisma.second_sponsors.delete({
         *   where: {
         *     // ... filter to delete one Second_sponsors
         *   }
         * })
         *
         **/
        delete<T extends Second_sponsorsDeleteArgs>(
            args: SelectSubset<T, Second_sponsorsDeleteArgs>
        ): Prisma__Second_sponsorsClient<Second_sponsorsGetPayload<T>>

        /**
         * Update one Second_sponsors.
         * @param {Second_sponsorsUpdateArgs} args - Arguments to update one Second_sponsors.
         * @example
         * // Update one Second_sponsors
         * const second_sponsors = await prisma.second_sponsors.update({
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: {
         *     // ... provide data here
         *   }
         * })
         *
         **/
        update<T extends Second_sponsorsUpdateArgs>(
            args: SelectSubset<T, Second_sponsorsUpdateArgs>
        ): Prisma__Second_sponsorsClient<Second_sponsorsGetPayload<T>>

        /**
         * Delete zero or more Second_sponsors.
         * @param {Second_sponsorsDeleteManyArgs} args - Arguments to filter Second_sponsors to delete.
         * @example
         * // Delete a few Second_sponsors
         * const { count } = await prisma.second_sponsors.deleteMany({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         *
         **/
        deleteMany<T extends Second_sponsorsDeleteManyArgs>(
            args?: SelectSubset<T, Second_sponsorsDeleteManyArgs>
        ): PrismaPromise<BatchPayload>

        /**
         * Update zero or more Second_sponsors.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {Second_sponsorsUpdateManyArgs} args - Arguments to update one or more rows.
         * @example
         * // Update many Second_sponsors
         * const second_sponsors = await prisma.second_sponsors.updateMany({
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: {
         *     // ... provide data here
         *   }
         * })
         *
         **/
        updateMany<T extends Second_sponsorsUpdateManyArgs>(
            args: SelectSubset<T, Second_sponsorsUpdateManyArgs>
        ): PrismaPromise<BatchPayload>

        /**
         * Create or update one Second_sponsors.
         * @param {Second_sponsorsUpsertArgs} args - Arguments to update or create a Second_sponsors.
         * @example
         * // Update or create a Second_sponsors
         * const second_sponsors = await prisma.second_sponsors.upsert({
         *   create: {
         *     // ... data to create a Second_sponsors
         *   },
         *   update: {
         *     // ... in case it already exists, update
         *   },
         *   where: {
         *     // ... the filter for the Second_sponsors we want to update
         *   }
         * })
         **/
        upsert<T extends Second_sponsorsUpsertArgs>(
            args: SelectSubset<T, Second_sponsorsUpsertArgs>
        ): Prisma__Second_sponsorsClient<Second_sponsorsGetPayload<T>>

        /**
         * Count the number of Second_sponsors.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {Second_sponsorsCountArgs} args - Arguments to filter Second_sponsors to count.
         * @example
         * // Count the number of Second_sponsors
         * const count = await prisma.second_sponsors.count({
         *   where: {
         *     // ... the filter for the Second_sponsors we want to count
         *   }
         * })
         **/
        count<T extends Second_sponsorsCountArgs>(
            args?: Subset<T, Second_sponsorsCountArgs>
        ): PrismaPromise<
            T extends _Record<'select', any>
                ? T['select'] extends true
                    ? number
                    : GetScalarType<T['select'], Second_sponsorsCountAggregateOutputType>
                : number
        >

        /**
         * Allows you to perform aggregations operations on a Second_sponsors.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {Second_sponsorsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
         * @example
         * // Ordered by age ascending
         * // Where email contains prisma.io
         * // Limited to the 10 users
         * const aggregations = await prisma.user.aggregate({
         *   _avg: {
         *     age: true,
         *   },
         *   where: {
         *     email: {
         *       contains: "prisma.io",
         *     },
         *   },
         *   orderBy: {
         *     age: "asc",
         *   },
         *   take: 10,
         * })
         **/
        aggregate<T extends Second_sponsorsAggregateArgs>(
            args: Subset<T, Second_sponsorsAggregateArgs>
        ): PrismaPromise<GetSecond_sponsorsAggregateType<T>>

        /**
         * Group by Second_sponsors.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {Second_sponsorsGroupByArgs} args - Group by arguments.
         * @example
         * // Group by city, order by createdAt, get count
         * const result = await prisma.user.groupBy({
         *   by: ['city', 'createdAt'],
         *   orderBy: {
         *     createdAt: true
         *   },
         *   _count: {
         *     _all: true
         *   },
         * })
         *
         **/
        groupBy<
            T extends Second_sponsorsGroupByArgs,
            HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
            OrderByArg extends True extends HasSelectOrTake
                ? { orderBy: Second_sponsorsGroupByArgs['orderBy'] }
                : { orderBy?: Second_sponsorsGroupByArgs['orderBy'] },
            OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
            ByFields extends TupleToUnion<T['by']>,
            ByValid extends Has<ByFields, OrderFields>,
            HavingFields extends GetHavingFields<T['having']>,
            HavingValid extends Has<ByFields, HavingFields>,
            ByEmpty extends T['by'] extends never[] ? True : False,
            InputErrors extends ByEmpty extends True
                ? `Error: "by" must not be empty.`
                : HavingValid extends False
                  ? {
                        [P in HavingFields]: P extends ByFields
                            ? never
                            : P extends string
                              ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                              : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`]
                    }[HavingFields]
                  : 'take' extends Keys<T>
                    ? 'orderBy' extends Keys<T>
                        ? ByValid extends True
                            ? {}
                            : {
                                  [P in OrderFields]: P extends ByFields
                                      ? never
                                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                              }[OrderFields]
                        : 'Error: If you provide "take", you also need to provide "orderBy"'
                    : 'skip' extends Keys<T>
                      ? 'orderBy' extends Keys<T>
                          ? ByValid extends True
                              ? {}
                              : {
                                    [P in OrderFields]: P extends ByFields
                                        ? never
                                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                                }[OrderFields]
                          : 'Error: If you provide "skip", you also need to provide "orderBy"'
                      : ByValid extends True
                        ? {}
                        : {
                              [P in OrderFields]: P extends ByFields
                                  ? never
                                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                          }[OrderFields]
        >(
            args: SubsetIntersection<T, Second_sponsorsGroupByArgs, OrderByArg> & InputErrors
        ): {} extends InputErrors ? GetSecond_sponsorsGroupByPayload<T> : PrismaPromise<InputErrors>
    }

    /**
     * The delegate class that acts as a "Promise-like" for Second_sponsors.
     * Why is this prefixed with `Prisma__`?
     * Because we want to prevent naming conflicts as mentioned in
     * https://github.com/prisma/prisma-client-js/issues/707
     */
    export class Prisma__Second_sponsorsClient<T, Null = never> implements PrismaPromise<T> {
        [prisma]: true
        private readonly _dmmf
        private readonly _fetcher
        private readonly _queryType
        private readonly _rootField
        private readonly _clientMethod
        private readonly _args
        private readonly _dataPath
        private readonly _errorFormat
        private readonly _measurePerformance?
        private _isList
        private _callsite
        private _requestPromise?
        constructor(
            _dmmf: runtime.DMMFClass,
            _fetcher: PrismaClientFetcher,
            _queryType: 'query' | 'mutation',
            _rootField: string,
            _clientMethod: string,
            _args: any,
            _dataPath: string[],
            _errorFormat: ErrorFormat,
            _measurePerformance?: boolean | undefined,
            _isList?: boolean
        )
        readonly [Symbol.toStringTag]: 'PrismaClientPromise'

        families<T extends FamiliesArgs = {}>(
            args?: Subset<T, FamiliesArgs>
        ): Prisma__FamiliesClient<FamiliesGetPayload<T> | Null>

        tenants<T extends TenantsArgs = {}>(
            args?: Subset<T, TenantsArgs>
        ): Prisma__TenantsClient<TenantsGetPayload<T> | Null>

        private get _document()
        /**
         * Attaches callbacks for the resolution and/or rejection of the Promise.
         * @param onfulfilled The callback to execute when the Promise is resolved.
         * @param onrejected The callback to execute when the Promise is rejected.
         * @returns A Promise for the completion of which ever callback is executed.
         */
        then<TResult1 = T, TResult2 = never>(
            onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
            onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
        ): Promise<TResult1 | TResult2>
        /**
         * Attaches a callback for only the rejection of the Promise.
         * @param onrejected The callback to execute when the Promise is rejected.
         * @returns A Promise for the completion of the callback.
         */
        catch<TResult = never>(
            onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
        ): Promise<T | TResult>
        /**
         * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
         * resolved value cannot be modified from the callback.
         * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
         * @returns A Promise for the completion of the callback.
         */
        finally(onfinally?: (() => void) | undefined | null): Promise<T>
    }

    // Custom InputTypes

    /**
     * Second_sponsors base type for findUnique actions
     */
    export type Second_sponsorsFindUniqueArgsBase = {
        /**
         * Select specific fields to fetch from the Second_sponsors
         *
         **/
        select?: Second_sponsorsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Second_sponsorsInclude | null
        /**
         * Filter, which Second_sponsors to fetch.
         *
         **/
        where: Second_sponsorsWhereUniqueInput
    }

    /**
     * Second_sponsors findUnique
     */
    export interface Second_sponsorsFindUniqueArgs extends Second_sponsorsFindUniqueArgsBase {
        /**
         * Throw an Error if query returns no results
         * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
         */
        rejectOnNotFound?: RejectOnNotFound
    }

    /**
     * Second_sponsors findUniqueOrThrow
     */
    export type Second_sponsorsFindUniqueOrThrowArgs = {
        /**
         * Select specific fields to fetch from the Second_sponsors
         *
         **/
        select?: Second_sponsorsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Second_sponsorsInclude | null
        /**
         * Filter, which Second_sponsors to fetch.
         *
         **/
        where: Second_sponsorsWhereUniqueInput
    }

    /**
     * Second_sponsors base type for findFirst actions
     */
    export type Second_sponsorsFindFirstArgsBase = {
        /**
         * Select specific fields to fetch from the Second_sponsors
         *
         **/
        select?: Second_sponsorsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Second_sponsorsInclude | null
        /**
         * Filter, which Second_sponsors to fetch.
         *
         **/
        where?: Second_sponsorsWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Second_sponsors to fetch.
         *
         **/
        orderBy?: Enumerable<Second_sponsorsOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for searching for Second_sponsors.
         *
         **/
        cursor?: Second_sponsorsWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Second_sponsors from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Second_sponsors.
         *
         **/
        skip?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
         *
         * Filter by unique combinations of Second_sponsors.
         *
         **/
        distinct?: Enumerable<Second_sponsorsScalarFieldEnum>
    }

    /**
     * Second_sponsors findFirst
     */
    export interface Second_sponsorsFindFirstArgs extends Second_sponsorsFindFirstArgsBase {
        /**
         * Throw an Error if query returns no results
         * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
         */
        rejectOnNotFound?: RejectOnNotFound
    }

    /**
     * Second_sponsors findFirstOrThrow
     */
    export type Second_sponsorsFindFirstOrThrowArgs = {
        /**
         * Select specific fields to fetch from the Second_sponsors
         *
         **/
        select?: Second_sponsorsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Second_sponsorsInclude | null
        /**
         * Filter, which Second_sponsors to fetch.
         *
         **/
        where?: Second_sponsorsWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Second_sponsors to fetch.
         *
         **/
        orderBy?: Enumerable<Second_sponsorsOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for searching for Second_sponsors.
         *
         **/
        cursor?: Second_sponsorsWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Second_sponsors from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Second_sponsors.
         *
         **/
        skip?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
         *
         * Filter by unique combinations of Second_sponsors.
         *
         **/
        distinct?: Enumerable<Second_sponsorsScalarFieldEnum>
    }

    /**
     * Second_sponsors findMany
     */
    export type Second_sponsorsFindManyArgs = {
        /**
         * Select specific fields to fetch from the Second_sponsors
         *
         **/
        select?: Second_sponsorsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Second_sponsorsInclude | null
        /**
         * Filter, which Second_sponsors to fetch.
         *
         **/
        where?: Second_sponsorsWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Second_sponsors to fetch.
         *
         **/
        orderBy?: Enumerable<Second_sponsorsOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for listing Second_sponsors.
         *
         **/
        cursor?: Second_sponsorsWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Second_sponsors from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Second_sponsors.
         *
         **/
        skip?: number
        distinct?: Enumerable<Second_sponsorsScalarFieldEnum>
    }

    /**
     * Second_sponsors create
     */
    export type Second_sponsorsCreateArgs = {
        /**
         * Select specific fields to fetch from the Second_sponsors
         *
         **/
        select?: Second_sponsorsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Second_sponsorsInclude | null
        /**
         * The data needed to create a Second_sponsors.
         *
         **/
        data: XOR<Second_sponsorsCreateInput, Second_sponsorsUncheckedCreateInput>
    }

    /**
     * Second_sponsors createMany
     */
    export type Second_sponsorsCreateManyArgs = {
        /**
         * The data used to create many Second_sponsors.
         *
         **/
        data: Enumerable<Second_sponsorsCreateManyInput>
        skipDuplicates?: boolean
    }

    /**
     * Second_sponsors update
     */
    export type Second_sponsorsUpdateArgs = {
        /**
         * Select specific fields to fetch from the Second_sponsors
         *
         **/
        select?: Second_sponsorsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Second_sponsorsInclude | null
        /**
         * The data needed to update a Second_sponsors.
         *
         **/
        data: XOR<Second_sponsorsUpdateInput, Second_sponsorsUncheckedUpdateInput>
        /**
         * Choose, which Second_sponsors to update.
         *
         **/
        where: Second_sponsorsWhereUniqueInput
    }

    /**
     * Second_sponsors updateMany
     */
    export type Second_sponsorsUpdateManyArgs = {
        /**
         * The data used to update Second_sponsors.
         *
         **/
        data: XOR<Second_sponsorsUpdateManyMutationInput, Second_sponsorsUncheckedUpdateManyInput>
        /**
         * Filter which Second_sponsors to update
         *
         **/
        where?: Second_sponsorsWhereInput
    }

    /**
     * Second_sponsors upsert
     */
    export type Second_sponsorsUpsertArgs = {
        /**
         * Select specific fields to fetch from the Second_sponsors
         *
         **/
        select?: Second_sponsorsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Second_sponsorsInclude | null
        /**
         * The filter to search for the Second_sponsors to update in case it exists.
         *
         **/
        where: Second_sponsorsWhereUniqueInput
        /**
         * In case the Second_sponsors found by the `where` argument doesn't exist, create a new Second_sponsors with this data.
         *
         **/
        create: XOR<Second_sponsorsCreateInput, Second_sponsorsUncheckedCreateInput>
        /**
         * In case the Second_sponsors was found with the provided `where` argument, update it with this data.
         *
         **/
        update: XOR<Second_sponsorsUpdateInput, Second_sponsorsUncheckedUpdateInput>
    }

    /**
     * Second_sponsors delete
     */
    export type Second_sponsorsDeleteArgs = {
        /**
         * Select specific fields to fetch from the Second_sponsors
         *
         **/
        select?: Second_sponsorsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Second_sponsorsInclude | null
        /**
         * Filter which Second_sponsors to delete.
         *
         **/
        where: Second_sponsorsWhereUniqueInput
    }

    /**
     * Second_sponsors deleteMany
     */
    export type Second_sponsorsDeleteManyArgs = {
        /**
         * Filter which Second_sponsors to delete
         *
         **/
        where?: Second_sponsorsWhereInput
    }

    /**
     * Second_sponsors without action
     */
    export type Second_sponsorsArgs = {
        /**
         * Select specific fields to fetch from the Second_sponsors
         *
         **/
        select?: Second_sponsorsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Second_sponsorsInclude | null
    }

    /**
     * Model Sessions
     */

    export type AggregateSessions = {
        _count: SessionsCountAggregateOutputType | null
        _avg: SessionsAvgAggregateOutputType | null
        _sum: SessionsSumAggregateOutputType | null
        _min: SessionsMinAggregateOutputType | null
        _max: SessionsMaxAggregateOutputType | null
    }

    export type SessionsAvgAggregateOutputType = {
        last_activity: number | null
    }

    export type SessionsSumAggregateOutputType = {
        last_activity: number | null
    }

    export type SessionsMinAggregateOutputType = {
        id: string | null
        user_id: string | null
        ip_address: string | null
        user_agent: string | null
        payload: string | null
        last_activity: number | null
    }

    export type SessionsMaxAggregateOutputType = {
        id: string | null
        user_id: string | null
        ip_address: string | null
        user_agent: string | null
        payload: string | null
        last_activity: number | null
    }

    export type SessionsCountAggregateOutputType = {
        id: number
        user_id: number
        ip_address: number
        user_agent: number
        payload: number
        last_activity: number
        _all: number
    }

    export type SessionsAvgAggregateInputType = {
        last_activity?: true
    }

    export type SessionsSumAggregateInputType = {
        last_activity?: true
    }

    export type SessionsMinAggregateInputType = {
        id?: true
        user_id?: true
        ip_address?: true
        user_agent?: true
        payload?: true
        last_activity?: true
    }

    export type SessionsMaxAggregateInputType = {
        id?: true
        user_id?: true
        ip_address?: true
        user_agent?: true
        payload?: true
        last_activity?: true
    }

    export type SessionsCountAggregateInputType = {
        id?: true
        user_id?: true
        ip_address?: true
        user_agent?: true
        payload?: true
        last_activity?: true
        _all?: true
    }

    export type SessionsAggregateArgs = {
        /**
         * Filter which Sessions to aggregate.
         *
         **/
        where?: SessionsWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Sessions to fetch.
         *
         **/
        orderBy?: Enumerable<SessionsOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the start position
         *
         **/
        cursor?: SessionsWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Sessions from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Sessions.
         *
         **/
        skip?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Count returned Sessions
         **/
        _count?: true | SessionsCountAggregateInputType
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to average
         **/
        _avg?: SessionsAvgAggregateInputType
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to sum
         **/
        _sum?: SessionsSumAggregateInputType
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to find the minimum value
         **/
        _min?: SessionsMinAggregateInputType
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to find the maximum value
         **/
        _max?: SessionsMaxAggregateInputType
    }

    export type GetSessionsAggregateType<T extends SessionsAggregateArgs> = {
        [P in keyof T & keyof AggregateSessions]: P extends '_count' | 'count'
            ? T[P] extends true
                ? number
                : GetScalarType<T[P], AggregateSessions[P]>
            : GetScalarType<T[P], AggregateSessions[P]>
    }

    export type SessionsGroupByArgs = {
        where?: SessionsWhereInput
        orderBy?: Enumerable<SessionsOrderByWithAggregationInput>
        by: Array<SessionsScalarFieldEnum>
        having?: SessionsScalarWhereWithAggregatesInput
        take?: number
        skip?: number
        _count?: SessionsCountAggregateInputType | true
        _avg?: SessionsAvgAggregateInputType
        _sum?: SessionsSumAggregateInputType
        _min?: SessionsMinAggregateInputType
        _max?: SessionsMaxAggregateInputType
    }

    export type SessionsGroupByOutputType = {
        id: string
        user_id: string | null
        ip_address: string | null
        user_agent: string | null
        payload: string
        last_activity: number
        _count: SessionsCountAggregateOutputType | null
        _avg: SessionsAvgAggregateOutputType | null
        _sum: SessionsSumAggregateOutputType | null
        _min: SessionsMinAggregateOutputType | null
        _max: SessionsMaxAggregateOutputType | null
    }

    type GetSessionsGroupByPayload<T extends SessionsGroupByArgs> = PrismaPromise<
        Array<
            PickArray<SessionsGroupByOutputType, T['by']> & {
                [P in keyof T & keyof SessionsGroupByOutputType]: P extends '_count'
                    ? T[P] extends boolean
                        ? number
                        : GetScalarType<T[P], SessionsGroupByOutputType[P]>
                    : GetScalarType<T[P], SessionsGroupByOutputType[P]>
            }
        >
    >

    export type SessionsSelect = {
        id?: boolean
        user_id?: boolean
        ip_address?: boolean
        user_agent?: boolean
        payload?: boolean
        last_activity?: boolean
        users?: boolean | UsersArgs
    }

    export type SessionsInclude = {
        users?: boolean | UsersArgs
    }

    export type SessionsGetPayload<S extends boolean | null | undefined | SessionsArgs> = S extends {
        select: any
        include: any
    }
        ? 'Please either choose `select` or `include`'
        : S extends true
          ? Sessions
          : S extends undefined
            ? never
            : S extends { include: any } & (SessionsArgs | SessionsFindManyArgs)
              ? Sessions & {
                    [P in TruthyKeys<S['include']>]: P extends 'users' ? UsersGetPayload<S['include'][P]> | null : never
                }
              : S extends { select: any } & (SessionsArgs | SessionsFindManyArgs)
                ? {
                      [P in TruthyKeys<S['select']>]: P extends 'users'
                          ? UsersGetPayload<S['select'][P]> | null
                          : P extends keyof Sessions
                            ? Sessions[P]
                            : never
                  }
                : Sessions

    type SessionsCountArgs = Merge<
        Omit<SessionsFindManyArgs, 'select' | 'include'> & {
            select?: SessionsCountAggregateInputType | true
        }
    >

    export interface SessionsDelegate<
        GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined
    > {
        /**
         * Find zero or one Sessions that matches the filter.
         * @param {SessionsFindUniqueArgs} args - Arguments to find a Sessions
         * @example
         * // Get one Sessions
         * const sessions = await prisma.sessions.findUnique({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findUnique<
            T extends SessionsFindUniqueArgs,
            LocalRejectSettings = T['rejectOnNotFound'] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined
        >(
            args: SelectSubset<T, SessionsFindUniqueArgs>
        ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Sessions'> extends True
            ? Prisma__SessionsClient<SessionsGetPayload<T>>
            : Prisma__SessionsClient<SessionsGetPayload<T> | null, null>

        /**
         * Find one Sessions that matches the filter or throw an error  with `error.code='P2025'`
         *     if no matches were found.
         * @param {SessionsFindUniqueOrThrowArgs} args - Arguments to find a Sessions
         * @example
         * // Get one Sessions
         * const sessions = await prisma.sessions.findUniqueOrThrow({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findUniqueOrThrow<T extends SessionsFindUniqueOrThrowArgs>(
            args?: SelectSubset<T, SessionsFindUniqueOrThrowArgs>
        ): Prisma__SessionsClient<SessionsGetPayload<T>>

        /**
         * Find the first Sessions that matches the filter.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {SessionsFindFirstArgs} args - Arguments to find a Sessions
         * @example
         * // Get one Sessions
         * const sessions = await prisma.sessions.findFirst({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findFirst<
            T extends SessionsFindFirstArgs,
            LocalRejectSettings = T['rejectOnNotFound'] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined
        >(
            args?: SelectSubset<T, SessionsFindFirstArgs>
        ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Sessions'> extends True
            ? Prisma__SessionsClient<SessionsGetPayload<T>>
            : Prisma__SessionsClient<SessionsGetPayload<T> | null, null>

        /**
         * Find the first Sessions that matches the filter or
         * throw `NotFoundError` if no matches were found.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {SessionsFindFirstOrThrowArgs} args - Arguments to find a Sessions
         * @example
         * // Get one Sessions
         * const sessions = await prisma.sessions.findFirstOrThrow({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findFirstOrThrow<T extends SessionsFindFirstOrThrowArgs>(
            args?: SelectSubset<T, SessionsFindFirstOrThrowArgs>
        ): Prisma__SessionsClient<SessionsGetPayload<T>>

        /**
         * Find zero or more Sessions that matches the filter.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {SessionsFindManyArgs=} args - Arguments to filter and select certain fields only.
         * @example
         * // Get all Sessions
         * const sessions = await prisma.sessions.findMany()
         *
         * // Get first 10 Sessions
         * const sessions = await prisma.sessions.findMany({ take: 10 })
         *
         * // Only select the `id`
         * const sessionsWithIdOnly = await prisma.sessions.findMany({ select: { id: true } })
         *
         **/
        findMany<T extends SessionsFindManyArgs>(
            args?: SelectSubset<T, SessionsFindManyArgs>
        ): PrismaPromise<Array<SessionsGetPayload<T>>>

        /**
         * Create a Sessions.
         * @param {SessionsCreateArgs} args - Arguments to create a Sessions.
         * @example
         * // Create one Sessions
         * const Sessions = await prisma.sessions.create({
         *   data: {
         *     // ... data to create a Sessions
         *   }
         * })
         *
         **/
        create<T extends SessionsCreateArgs>(
            args: SelectSubset<T, SessionsCreateArgs>
        ): Prisma__SessionsClient<SessionsGetPayload<T>>

        /**
         * Create many Sessions.
         *     @param {SessionsCreateManyArgs} args - Arguments to create many Sessions.
         *     @example
         *     // Create many Sessions
         *     const sessions = await prisma.sessions.createMany({
         *       data: {
         *         // ... provide data here
         *       }
         *     })
         *
         **/
        createMany<T extends SessionsCreateManyArgs>(
            args?: SelectSubset<T, SessionsCreateManyArgs>
        ): PrismaPromise<BatchPayload>

        /**
         * Delete a Sessions.
         * @param {SessionsDeleteArgs} args - Arguments to delete one Sessions.
         * @example
         * // Delete one Sessions
         * const Sessions = await prisma.sessions.delete({
         *   where: {
         *     // ... filter to delete one Sessions
         *   }
         * })
         *
         **/
        delete<T extends SessionsDeleteArgs>(
            args: SelectSubset<T, SessionsDeleteArgs>
        ): Prisma__SessionsClient<SessionsGetPayload<T>>

        /**
         * Update one Sessions.
         * @param {SessionsUpdateArgs} args - Arguments to update one Sessions.
         * @example
         * // Update one Sessions
         * const sessions = await prisma.sessions.update({
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: {
         *     // ... provide data here
         *   }
         * })
         *
         **/
        update<T extends SessionsUpdateArgs>(
            args: SelectSubset<T, SessionsUpdateArgs>
        ): Prisma__SessionsClient<SessionsGetPayload<T>>

        /**
         * Delete zero or more Sessions.
         * @param {SessionsDeleteManyArgs} args - Arguments to filter Sessions to delete.
         * @example
         * // Delete a few Sessions
         * const { count } = await prisma.sessions.deleteMany({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         *
         **/
        deleteMany<T extends SessionsDeleteManyArgs>(
            args?: SelectSubset<T, SessionsDeleteManyArgs>
        ): PrismaPromise<BatchPayload>

        /**
         * Update zero or more Sessions.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {SessionsUpdateManyArgs} args - Arguments to update one or more rows.
         * @example
         * // Update many Sessions
         * const sessions = await prisma.sessions.updateMany({
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: {
         *     // ... provide data here
         *   }
         * })
         *
         **/
        updateMany<T extends SessionsUpdateManyArgs>(
            args: SelectSubset<T, SessionsUpdateManyArgs>
        ): PrismaPromise<BatchPayload>

        /**
         * Create or update one Sessions.
         * @param {SessionsUpsertArgs} args - Arguments to update or create a Sessions.
         * @example
         * // Update or create a Sessions
         * const sessions = await prisma.sessions.upsert({
         *   create: {
         *     // ... data to create a Sessions
         *   },
         *   update: {
         *     // ... in case it already exists, update
         *   },
         *   where: {
         *     // ... the filter for the Sessions we want to update
         *   }
         * })
         **/
        upsert<T extends SessionsUpsertArgs>(
            args: SelectSubset<T, SessionsUpsertArgs>
        ): Prisma__SessionsClient<SessionsGetPayload<T>>

        /**
         * Count the number of Sessions.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {SessionsCountArgs} args - Arguments to filter Sessions to count.
         * @example
         * // Count the number of Sessions
         * const count = await prisma.sessions.count({
         *   where: {
         *     // ... the filter for the Sessions we want to count
         *   }
         * })
         **/
        count<T extends SessionsCountArgs>(
            args?: Subset<T, SessionsCountArgs>
        ): PrismaPromise<
            T extends _Record<'select', any>
                ? T['select'] extends true
                    ? number
                    : GetScalarType<T['select'], SessionsCountAggregateOutputType>
                : number
        >

        /**
         * Allows you to perform aggregations operations on a Sessions.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {SessionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
         * @example
         * // Ordered by age ascending
         * // Where email contains prisma.io
         * // Limited to the 10 users
         * const aggregations = await prisma.user.aggregate({
         *   _avg: {
         *     age: true,
         *   },
         *   where: {
         *     email: {
         *       contains: "prisma.io",
         *     },
         *   },
         *   orderBy: {
         *     age: "asc",
         *   },
         *   take: 10,
         * })
         **/
        aggregate<T extends SessionsAggregateArgs>(
            args: Subset<T, SessionsAggregateArgs>
        ): PrismaPromise<GetSessionsAggregateType<T>>

        /**
         * Group by Sessions.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {SessionsGroupByArgs} args - Group by arguments.
         * @example
         * // Group by city, order by createdAt, get count
         * const result = await prisma.user.groupBy({
         *   by: ['city', 'createdAt'],
         *   orderBy: {
         *     createdAt: true
         *   },
         *   _count: {
         *     _all: true
         *   },
         * })
         *
         **/
        groupBy<
            T extends SessionsGroupByArgs,
            HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
            OrderByArg extends True extends HasSelectOrTake
                ? { orderBy: SessionsGroupByArgs['orderBy'] }
                : { orderBy?: SessionsGroupByArgs['orderBy'] },
            OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
            ByFields extends TupleToUnion<T['by']>,
            ByValid extends Has<ByFields, OrderFields>,
            HavingFields extends GetHavingFields<T['having']>,
            HavingValid extends Has<ByFields, HavingFields>,
            ByEmpty extends T['by'] extends never[] ? True : False,
            InputErrors extends ByEmpty extends True
                ? `Error: "by" must not be empty.`
                : HavingValid extends False
                  ? {
                        [P in HavingFields]: P extends ByFields
                            ? never
                            : P extends string
                              ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                              : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`]
                    }[HavingFields]
                  : 'take' extends Keys<T>
                    ? 'orderBy' extends Keys<T>
                        ? ByValid extends True
                            ? {}
                            : {
                                  [P in OrderFields]: P extends ByFields
                                      ? never
                                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                              }[OrderFields]
                        : 'Error: If you provide "take", you also need to provide "orderBy"'
                    : 'skip' extends Keys<T>
                      ? 'orderBy' extends Keys<T>
                          ? ByValid extends True
                              ? {}
                              : {
                                    [P in OrderFields]: P extends ByFields
                                        ? never
                                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                                }[OrderFields]
                          : 'Error: If you provide "skip", you also need to provide "orderBy"'
                      : ByValid extends True
                        ? {}
                        : {
                              [P in OrderFields]: P extends ByFields
                                  ? never
                                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                          }[OrderFields]
        >(
            args: SubsetIntersection<T, SessionsGroupByArgs, OrderByArg> & InputErrors
        ): {} extends InputErrors ? GetSessionsGroupByPayload<T> : PrismaPromise<InputErrors>
    }

    /**
     * The delegate class that acts as a "Promise-like" for Sessions.
     * Why is this prefixed with `Prisma__`?
     * Because we want to prevent naming conflicts as mentioned in
     * https://github.com/prisma/prisma-client-js/issues/707
     */
    export class Prisma__SessionsClient<T, Null = never> implements PrismaPromise<T> {
        [prisma]: true
        private readonly _dmmf
        private readonly _fetcher
        private readonly _queryType
        private readonly _rootField
        private readonly _clientMethod
        private readonly _args
        private readonly _dataPath
        private readonly _errorFormat
        private readonly _measurePerformance?
        private _isList
        private _callsite
        private _requestPromise?
        constructor(
            _dmmf: runtime.DMMFClass,
            _fetcher: PrismaClientFetcher,
            _queryType: 'query' | 'mutation',
            _rootField: string,
            _clientMethod: string,
            _args: any,
            _dataPath: string[],
            _errorFormat: ErrorFormat,
            _measurePerformance?: boolean | undefined,
            _isList?: boolean
        )
        readonly [Symbol.toStringTag]: 'PrismaClientPromise'

        users<T extends UsersArgs = {}>(args?: Subset<T, UsersArgs>): Prisma__UsersClient<UsersGetPayload<T> | Null>

        private get _document()
        /**
         * Attaches callbacks for the resolution and/or rejection of the Promise.
         * @param onfulfilled The callback to execute when the Promise is resolved.
         * @param onrejected The callback to execute when the Promise is rejected.
         * @returns A Promise for the completion of which ever callback is executed.
         */
        then<TResult1 = T, TResult2 = never>(
            onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
            onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
        ): Promise<TResult1 | TResult2>
        /**
         * Attaches a callback for only the rejection of the Promise.
         * @param onrejected The callback to execute when the Promise is rejected.
         * @returns A Promise for the completion of the callback.
         */
        catch<TResult = never>(
            onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
        ): Promise<T | TResult>
        /**
         * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
         * resolved value cannot be modified from the callback.
         * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
         * @returns A Promise for the completion of the callback.
         */
        finally(onfinally?: (() => void) | undefined | null): Promise<T>
    }

    // Custom InputTypes

    /**
     * Sessions base type for findUnique actions
     */
    export type SessionsFindUniqueArgsBase = {
        /**
         * Select specific fields to fetch from the Sessions
         *
         **/
        select?: SessionsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: SessionsInclude | null
        /**
         * Filter, which Sessions to fetch.
         *
         **/
        where: SessionsWhereUniqueInput
    }

    /**
     * Sessions findUnique
     */
    export interface SessionsFindUniqueArgs extends SessionsFindUniqueArgsBase {
        /**
         * Throw an Error if query returns no results
         * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
         */
        rejectOnNotFound?: RejectOnNotFound
    }

    /**
     * Sessions findUniqueOrThrow
     */
    export type SessionsFindUniqueOrThrowArgs = {
        /**
         * Select specific fields to fetch from the Sessions
         *
         **/
        select?: SessionsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: SessionsInclude | null
        /**
         * Filter, which Sessions to fetch.
         *
         **/
        where: SessionsWhereUniqueInput
    }

    /**
     * Sessions base type for findFirst actions
     */
    export type SessionsFindFirstArgsBase = {
        /**
         * Select specific fields to fetch from the Sessions
         *
         **/
        select?: SessionsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: SessionsInclude | null
        /**
         * Filter, which Sessions to fetch.
         *
         **/
        where?: SessionsWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Sessions to fetch.
         *
         **/
        orderBy?: Enumerable<SessionsOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for searching for Sessions.
         *
         **/
        cursor?: SessionsWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Sessions from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Sessions.
         *
         **/
        skip?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
         *
         * Filter by unique combinations of Sessions.
         *
         **/
        distinct?: Enumerable<SessionsScalarFieldEnum>
    }

    /**
     * Sessions findFirst
     */
    export interface SessionsFindFirstArgs extends SessionsFindFirstArgsBase {
        /**
         * Throw an Error if query returns no results
         * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
         */
        rejectOnNotFound?: RejectOnNotFound
    }

    /**
     * Sessions findFirstOrThrow
     */
    export type SessionsFindFirstOrThrowArgs = {
        /**
         * Select specific fields to fetch from the Sessions
         *
         **/
        select?: SessionsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: SessionsInclude | null
        /**
         * Filter, which Sessions to fetch.
         *
         **/
        where?: SessionsWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Sessions to fetch.
         *
         **/
        orderBy?: Enumerable<SessionsOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for searching for Sessions.
         *
         **/
        cursor?: SessionsWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Sessions from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Sessions.
         *
         **/
        skip?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
         *
         * Filter by unique combinations of Sessions.
         *
         **/
        distinct?: Enumerable<SessionsScalarFieldEnum>
    }

    /**
     * Sessions findMany
     */
    export type SessionsFindManyArgs = {
        /**
         * Select specific fields to fetch from the Sessions
         *
         **/
        select?: SessionsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: SessionsInclude | null
        /**
         * Filter, which Sessions to fetch.
         *
         **/
        where?: SessionsWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Sessions to fetch.
         *
         **/
        orderBy?: Enumerable<SessionsOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for listing Sessions.
         *
         **/
        cursor?: SessionsWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Sessions from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Sessions.
         *
         **/
        skip?: number
        distinct?: Enumerable<SessionsScalarFieldEnum>
    }

    /**
     * Sessions create
     */
    export type SessionsCreateArgs = {
        /**
         * Select specific fields to fetch from the Sessions
         *
         **/
        select?: SessionsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: SessionsInclude | null
        /**
         * The data needed to create a Sessions.
         *
         **/
        data: XOR<SessionsCreateInput, SessionsUncheckedCreateInput>
    }

    /**
     * Sessions createMany
     */
    export type SessionsCreateManyArgs = {
        /**
         * The data used to create many Sessions.
         *
         **/
        data: Enumerable<SessionsCreateManyInput>
        skipDuplicates?: boolean
    }

    /**
     * Sessions update
     */
    export type SessionsUpdateArgs = {
        /**
         * Select specific fields to fetch from the Sessions
         *
         **/
        select?: SessionsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: SessionsInclude | null
        /**
         * The data needed to update a Sessions.
         *
         **/
        data: XOR<SessionsUpdateInput, SessionsUncheckedUpdateInput>
        /**
         * Choose, which Sessions to update.
         *
         **/
        where: SessionsWhereUniqueInput
    }

    /**
     * Sessions updateMany
     */
    export type SessionsUpdateManyArgs = {
        /**
         * The data used to update Sessions.
         *
         **/
        data: XOR<SessionsUpdateManyMutationInput, SessionsUncheckedUpdateManyInput>
        /**
         * Filter which Sessions to update
         *
         **/
        where?: SessionsWhereInput
    }

    /**
     * Sessions upsert
     */
    export type SessionsUpsertArgs = {
        /**
         * Select specific fields to fetch from the Sessions
         *
         **/
        select?: SessionsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: SessionsInclude | null
        /**
         * The filter to search for the Sessions to update in case it exists.
         *
         **/
        where: SessionsWhereUniqueInput
        /**
         * In case the Sessions found by the `where` argument doesn't exist, create a new Sessions with this data.
         *
         **/
        create: XOR<SessionsCreateInput, SessionsUncheckedCreateInput>
        /**
         * In case the Sessions was found with the provided `where` argument, update it with this data.
         *
         **/
        update: XOR<SessionsUpdateInput, SessionsUncheckedUpdateInput>
    }

    /**
     * Sessions delete
     */
    export type SessionsDeleteArgs = {
        /**
         * Select specific fields to fetch from the Sessions
         *
         **/
        select?: SessionsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: SessionsInclude | null
        /**
         * Filter which Sessions to delete.
         *
         **/
        where: SessionsWhereUniqueInput
    }

    /**
     * Sessions deleteMany
     */
    export type SessionsDeleteManyArgs = {
        /**
         * Filter which Sessions to delete
         *
         **/
        where?: SessionsWhereInput
    }

    /**
     * Sessions without action
     */
    export type SessionsArgs = {
        /**
         * Select specific fields to fetch from the Sessions
         *
         **/
        select?: SessionsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: SessionsInclude | null
    }

    /**
     * Model Settings
     */

    export type AggregateSettings = {
        _count: SettingsCountAggregateOutputType | null
        _min: SettingsMinAggregateOutputType | null
        _max: SettingsMaxAggregateOutputType | null
    }

    export type SettingsMinAggregateOutputType = {
        id: string | null
        user_id: string | null
        theme: theme | null
        color_scheme: color_scheme | null
        layout: layout | null
        appearance: appearance | null
        created_at: Date | null
        updated_at: Date | null
    }

    export type SettingsMaxAggregateOutputType = {
        id: string | null
        user_id: string | null
        theme: theme | null
        color_scheme: color_scheme | null
        layout: layout | null
        appearance: appearance | null
        created_at: Date | null
        updated_at: Date | null
    }

    export type SettingsCountAggregateOutputType = {
        id: number
        user_id: number
        theme: number
        color_scheme: number
        layout: number
        appearance: number
        notifications: number
        created_at: number
        updated_at: number
        _all: number
    }

    export type SettingsMinAggregateInputType = {
        id?: true
        user_id?: true
        theme?: true
        color_scheme?: true
        layout?: true
        appearance?: true
        created_at?: true
        updated_at?: true
    }

    export type SettingsMaxAggregateInputType = {
        id?: true
        user_id?: true
        theme?: true
        color_scheme?: true
        layout?: true
        appearance?: true
        created_at?: true
        updated_at?: true
    }

    export type SettingsCountAggregateInputType = {
        id?: true
        user_id?: true
        theme?: true
        color_scheme?: true
        layout?: true
        appearance?: true
        notifications?: true
        created_at?: true
        updated_at?: true
        _all?: true
    }

    export type SettingsAggregateArgs = {
        /**
         * Filter which Settings to aggregate.
         *
         **/
        where?: SettingsWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Settings to fetch.
         *
         **/
        orderBy?: Enumerable<SettingsOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the start position
         *
         **/
        cursor?: SettingsWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Settings from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Settings.
         *
         **/
        skip?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Count returned Settings
         **/
        _count?: true | SettingsCountAggregateInputType
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to find the minimum value
         **/
        _min?: SettingsMinAggregateInputType
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to find the maximum value
         **/
        _max?: SettingsMaxAggregateInputType
    }

    export type GetSettingsAggregateType<T extends SettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateSettings]: P extends '_count' | 'count'
            ? T[P] extends true
                ? number
                : GetScalarType<T[P], AggregateSettings[P]>
            : GetScalarType<T[P], AggregateSettings[P]>
    }

    export type SettingsGroupByArgs = {
        where?: SettingsWhereInput
        orderBy?: Enumerable<SettingsOrderByWithAggregationInput>
        by: Array<SettingsScalarFieldEnum>
        having?: SettingsScalarWhereWithAggregatesInput
        take?: number
        skip?: number
        _count?: SettingsCountAggregateInputType | true
        _min?: SettingsMinAggregateInputType
        _max?: SettingsMaxAggregateInputType
    }

    export type SettingsGroupByOutputType = {
        id: string
        user_id: string
        theme: theme
        color_scheme: color_scheme
        layout: layout
        appearance: appearance
        notifications: JsonValue | null
        created_at: Date | null
        updated_at: Date | null
        _count: SettingsCountAggregateOutputType | null
        _min: SettingsMinAggregateOutputType | null
        _max: SettingsMaxAggregateOutputType | null
    }

    type GetSettingsGroupByPayload<T extends SettingsGroupByArgs> = PrismaPromise<
        Array<
            PickArray<SettingsGroupByOutputType, T['by']> & {
                [P in keyof T & keyof SettingsGroupByOutputType]: P extends '_count'
                    ? T[P] extends boolean
                        ? number
                        : GetScalarType<T[P], SettingsGroupByOutputType[P]>
                    : GetScalarType<T[P], SettingsGroupByOutputType[P]>
            }
        >
    >

    export type SettingsSelect = {
        id?: boolean
        user_id?: boolean
        theme?: boolean
        color_scheme?: boolean
        layout?: boolean
        appearance?: boolean
        notifications?: boolean
        created_at?: boolean
        updated_at?: boolean
        users?: boolean | UsersArgs
    }

    export type SettingsInclude = {
        users?: boolean | UsersArgs
    }

    export type SettingsGetPayload<S extends boolean | null | undefined | SettingsArgs> = S extends {
        select: any
        include: any
    }
        ? 'Please either choose `select` or `include`'
        : S extends true
          ? Settings
          : S extends undefined
            ? never
            : S extends { include: any } & (SettingsArgs | SettingsFindManyArgs)
              ? Settings & {
                    [P in TruthyKeys<S['include']>]: P extends 'users' ? UsersGetPayload<S['include'][P]> : never
                }
              : S extends { select: any } & (SettingsArgs | SettingsFindManyArgs)
                ? {
                      [P in TruthyKeys<S['select']>]: P extends 'users'
                          ? UsersGetPayload<S['select'][P]>
                          : P extends keyof Settings
                            ? Settings[P]
                            : never
                  }
                : Settings

    type SettingsCountArgs = Merge<
        Omit<SettingsFindManyArgs, 'select' | 'include'> & {
            select?: SettingsCountAggregateInputType | true
        }
    >

    export interface SettingsDelegate<
        GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined
    > {
        /**
         * Find zero or one Settings that matches the filter.
         * @param {SettingsFindUniqueArgs} args - Arguments to find a Settings
         * @example
         * // Get one Settings
         * const settings = await prisma.settings.findUnique({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findUnique<
            T extends SettingsFindUniqueArgs,
            LocalRejectSettings = T['rejectOnNotFound'] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined
        >(
            args: SelectSubset<T, SettingsFindUniqueArgs>
        ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Settings'> extends True
            ? Prisma__SettingsClient<SettingsGetPayload<T>>
            : Prisma__SettingsClient<SettingsGetPayload<T> | null, null>

        /**
         * Find one Settings that matches the filter or throw an error  with `error.code='P2025'`
         *     if no matches were found.
         * @param {SettingsFindUniqueOrThrowArgs} args - Arguments to find a Settings
         * @example
         * // Get one Settings
         * const settings = await prisma.settings.findUniqueOrThrow({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findUniqueOrThrow<T extends SettingsFindUniqueOrThrowArgs>(
            args?: SelectSubset<T, SettingsFindUniqueOrThrowArgs>
        ): Prisma__SettingsClient<SettingsGetPayload<T>>

        /**
         * Find the first Settings that matches the filter.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {SettingsFindFirstArgs} args - Arguments to find a Settings
         * @example
         * // Get one Settings
         * const settings = await prisma.settings.findFirst({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findFirst<
            T extends SettingsFindFirstArgs,
            LocalRejectSettings = T['rejectOnNotFound'] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined
        >(
            args?: SelectSubset<T, SettingsFindFirstArgs>
        ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Settings'> extends True
            ? Prisma__SettingsClient<SettingsGetPayload<T>>
            : Prisma__SettingsClient<SettingsGetPayload<T> | null, null>

        /**
         * Find the first Settings that matches the filter or
         * throw `NotFoundError` if no matches were found.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {SettingsFindFirstOrThrowArgs} args - Arguments to find a Settings
         * @example
         * // Get one Settings
         * const settings = await prisma.settings.findFirstOrThrow({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findFirstOrThrow<T extends SettingsFindFirstOrThrowArgs>(
            args?: SelectSubset<T, SettingsFindFirstOrThrowArgs>
        ): Prisma__SettingsClient<SettingsGetPayload<T>>

        /**
         * Find zero or more Settings that matches the filter.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {SettingsFindManyArgs=} args - Arguments to filter and select certain fields only.
         * @example
         * // Get all Settings
         * const settings = await prisma.settings.findMany()
         *
         * // Get first 10 Settings
         * const settings = await prisma.settings.findMany({ take: 10 })
         *
         * // Only select the `id`
         * const settingsWithIdOnly = await prisma.settings.findMany({ select: { id: true } })
         *
         **/
        findMany<T extends SettingsFindManyArgs>(
            args?: SelectSubset<T, SettingsFindManyArgs>
        ): PrismaPromise<Array<SettingsGetPayload<T>>>

        /**
         * Create a Settings.
         * @param {SettingsCreateArgs} args - Arguments to create a Settings.
         * @example
         * // Create one Settings
         * const Settings = await prisma.settings.create({
         *   data: {
         *     // ... data to create a Settings
         *   }
         * })
         *
         **/
        create<T extends SettingsCreateArgs>(
            args: SelectSubset<T, SettingsCreateArgs>
        ): Prisma__SettingsClient<SettingsGetPayload<T>>

        /**
         * Create many Settings.
         *     @param {SettingsCreateManyArgs} args - Arguments to create many Settings.
         *     @example
         *     // Create many Settings
         *     const settings = await prisma.settings.createMany({
         *       data: {
         *         // ... provide data here
         *       }
         *     })
         *
         **/
        createMany<T extends SettingsCreateManyArgs>(
            args?: SelectSubset<T, SettingsCreateManyArgs>
        ): PrismaPromise<BatchPayload>

        /**
         * Delete a Settings.
         * @param {SettingsDeleteArgs} args - Arguments to delete one Settings.
         * @example
         * // Delete one Settings
         * const Settings = await prisma.settings.delete({
         *   where: {
         *     // ... filter to delete one Settings
         *   }
         * })
         *
         **/
        delete<T extends SettingsDeleteArgs>(
            args: SelectSubset<T, SettingsDeleteArgs>
        ): Prisma__SettingsClient<SettingsGetPayload<T>>

        /**
         * Update one Settings.
         * @param {SettingsUpdateArgs} args - Arguments to update one Settings.
         * @example
         * // Update one Settings
         * const settings = await prisma.settings.update({
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: {
         *     // ... provide data here
         *   }
         * })
         *
         **/
        update<T extends SettingsUpdateArgs>(
            args: SelectSubset<T, SettingsUpdateArgs>
        ): Prisma__SettingsClient<SettingsGetPayload<T>>

        /**
         * Delete zero or more Settings.
         * @param {SettingsDeleteManyArgs} args - Arguments to filter Settings to delete.
         * @example
         * // Delete a few Settings
         * const { count } = await prisma.settings.deleteMany({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         *
         **/
        deleteMany<T extends SettingsDeleteManyArgs>(
            args?: SelectSubset<T, SettingsDeleteManyArgs>
        ): PrismaPromise<BatchPayload>

        /**
         * Update zero or more Settings.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {SettingsUpdateManyArgs} args - Arguments to update one or more rows.
         * @example
         * // Update many Settings
         * const settings = await prisma.settings.updateMany({
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: {
         *     // ... provide data here
         *   }
         * })
         *
         **/
        updateMany<T extends SettingsUpdateManyArgs>(
            args: SelectSubset<T, SettingsUpdateManyArgs>
        ): PrismaPromise<BatchPayload>

        /**
         * Create or update one Settings.
         * @param {SettingsUpsertArgs} args - Arguments to update or create a Settings.
         * @example
         * // Update or create a Settings
         * const settings = await prisma.settings.upsert({
         *   create: {
         *     // ... data to create a Settings
         *   },
         *   update: {
         *     // ... in case it already exists, update
         *   },
         *   where: {
         *     // ... the filter for the Settings we want to update
         *   }
         * })
         **/
        upsert<T extends SettingsUpsertArgs>(
            args: SelectSubset<T, SettingsUpsertArgs>
        ): Prisma__SettingsClient<SettingsGetPayload<T>>

        /**
         * Count the number of Settings.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {SettingsCountArgs} args - Arguments to filter Settings to count.
         * @example
         * // Count the number of Settings
         * const count = await prisma.settings.count({
         *   where: {
         *     // ... the filter for the Settings we want to count
         *   }
         * })
         **/
        count<T extends SettingsCountArgs>(
            args?: Subset<T, SettingsCountArgs>
        ): PrismaPromise<
            T extends _Record<'select', any>
                ? T['select'] extends true
                    ? number
                    : GetScalarType<T['select'], SettingsCountAggregateOutputType>
                : number
        >

        /**
         * Allows you to perform aggregations operations on a Settings.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {SettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
         * @example
         * // Ordered by age ascending
         * // Where email contains prisma.io
         * // Limited to the 10 users
         * const aggregations = await prisma.user.aggregate({
         *   _avg: {
         *     age: true,
         *   },
         *   where: {
         *     email: {
         *       contains: "prisma.io",
         *     },
         *   },
         *   orderBy: {
         *     age: "asc",
         *   },
         *   take: 10,
         * })
         **/
        aggregate<T extends SettingsAggregateArgs>(
            args: Subset<T, SettingsAggregateArgs>
        ): PrismaPromise<GetSettingsAggregateType<T>>

        /**
         * Group by Settings.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {SettingsGroupByArgs} args - Group by arguments.
         * @example
         * // Group by city, order by createdAt, get count
         * const result = await prisma.user.groupBy({
         *   by: ['city', 'createdAt'],
         *   orderBy: {
         *     createdAt: true
         *   },
         *   _count: {
         *     _all: true
         *   },
         * })
         *
         **/
        groupBy<
            T extends SettingsGroupByArgs,
            HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
            OrderByArg extends True extends HasSelectOrTake
                ? { orderBy: SettingsGroupByArgs['orderBy'] }
                : { orderBy?: SettingsGroupByArgs['orderBy'] },
            OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
            ByFields extends TupleToUnion<T['by']>,
            ByValid extends Has<ByFields, OrderFields>,
            HavingFields extends GetHavingFields<T['having']>,
            HavingValid extends Has<ByFields, HavingFields>,
            ByEmpty extends T['by'] extends never[] ? True : False,
            InputErrors extends ByEmpty extends True
                ? `Error: "by" must not be empty.`
                : HavingValid extends False
                  ? {
                        [P in HavingFields]: P extends ByFields
                            ? never
                            : P extends string
                              ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                              : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`]
                    }[HavingFields]
                  : 'take' extends Keys<T>
                    ? 'orderBy' extends Keys<T>
                        ? ByValid extends True
                            ? {}
                            : {
                                  [P in OrderFields]: P extends ByFields
                                      ? never
                                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                              }[OrderFields]
                        : 'Error: If you provide "take", you also need to provide "orderBy"'
                    : 'skip' extends Keys<T>
                      ? 'orderBy' extends Keys<T>
                          ? ByValid extends True
                              ? {}
                              : {
                                    [P in OrderFields]: P extends ByFields
                                        ? never
                                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                                }[OrderFields]
                          : 'Error: If you provide "skip", you also need to provide "orderBy"'
                      : ByValid extends True
                        ? {}
                        : {
                              [P in OrderFields]: P extends ByFields
                                  ? never
                                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                          }[OrderFields]
        >(
            args: SubsetIntersection<T, SettingsGroupByArgs, OrderByArg> & InputErrors
        ): {} extends InputErrors ? GetSettingsGroupByPayload<T> : PrismaPromise<InputErrors>
    }

    /**
     * The delegate class that acts as a "Promise-like" for Settings.
     * Why is this prefixed with `Prisma__`?
     * Because we want to prevent naming conflicts as mentioned in
     * https://github.com/prisma/prisma-client-js/issues/707
     */
    export class Prisma__SettingsClient<T, Null = never> implements PrismaPromise<T> {
        [prisma]: true
        private readonly _dmmf
        private readonly _fetcher
        private readonly _queryType
        private readonly _rootField
        private readonly _clientMethod
        private readonly _args
        private readonly _dataPath
        private readonly _errorFormat
        private readonly _measurePerformance?
        private _isList
        private _callsite
        private _requestPromise?
        constructor(
            _dmmf: runtime.DMMFClass,
            _fetcher: PrismaClientFetcher,
            _queryType: 'query' | 'mutation',
            _rootField: string,
            _clientMethod: string,
            _args: any,
            _dataPath: string[],
            _errorFormat: ErrorFormat,
            _measurePerformance?: boolean | undefined,
            _isList?: boolean
        )
        readonly [Symbol.toStringTag]: 'PrismaClientPromise'

        users<T extends UsersArgs = {}>(args?: Subset<T, UsersArgs>): Prisma__UsersClient<UsersGetPayload<T> | Null>

        private get _document()
        /**
         * Attaches callbacks for the resolution and/or rejection of the Promise.
         * @param onfulfilled The callback to execute when the Promise is resolved.
         * @param onrejected The callback to execute when the Promise is rejected.
         * @returns A Promise for the completion of which ever callback is executed.
         */
        then<TResult1 = T, TResult2 = never>(
            onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
            onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
        ): Promise<TResult1 | TResult2>
        /**
         * Attaches a callback for only the rejection of the Promise.
         * @param onrejected The callback to execute when the Promise is rejected.
         * @returns A Promise for the completion of the callback.
         */
        catch<TResult = never>(
            onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
        ): Promise<T | TResult>
        /**
         * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
         * resolved value cannot be modified from the callback.
         * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
         * @returns A Promise for the completion of the callback.
         */
        finally(onfinally?: (() => void) | undefined | null): Promise<T>
    }

    // Custom InputTypes

    /**
     * Settings base type for findUnique actions
     */
    export type SettingsFindUniqueArgsBase = {
        /**
         * Select specific fields to fetch from the Settings
         *
         **/
        select?: SettingsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: SettingsInclude | null
        /**
         * Filter, which Settings to fetch.
         *
         **/
        where: SettingsWhereUniqueInput
    }

    /**
     * Settings findUnique
     */
    export interface SettingsFindUniqueArgs extends SettingsFindUniqueArgsBase {
        /**
         * Throw an Error if query returns no results
         * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
         */
        rejectOnNotFound?: RejectOnNotFound
    }

    /**
     * Settings findUniqueOrThrow
     */
    export type SettingsFindUniqueOrThrowArgs = {
        /**
         * Select specific fields to fetch from the Settings
         *
         **/
        select?: SettingsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: SettingsInclude | null
        /**
         * Filter, which Settings to fetch.
         *
         **/
        where: SettingsWhereUniqueInput
    }

    /**
     * Settings base type for findFirst actions
     */
    export type SettingsFindFirstArgsBase = {
        /**
         * Select specific fields to fetch from the Settings
         *
         **/
        select?: SettingsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: SettingsInclude | null
        /**
         * Filter, which Settings to fetch.
         *
         **/
        where?: SettingsWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Settings to fetch.
         *
         **/
        orderBy?: Enumerable<SettingsOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for searching for Settings.
         *
         **/
        cursor?: SettingsWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Settings from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Settings.
         *
         **/
        skip?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
         *
         * Filter by unique combinations of Settings.
         *
         **/
        distinct?: Enumerable<SettingsScalarFieldEnum>
    }

    /**
     * Settings findFirst
     */
    export interface SettingsFindFirstArgs extends SettingsFindFirstArgsBase {
        /**
         * Throw an Error if query returns no results
         * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
         */
        rejectOnNotFound?: RejectOnNotFound
    }

    /**
     * Settings findFirstOrThrow
     */
    export type SettingsFindFirstOrThrowArgs = {
        /**
         * Select specific fields to fetch from the Settings
         *
         **/
        select?: SettingsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: SettingsInclude | null
        /**
         * Filter, which Settings to fetch.
         *
         **/
        where?: SettingsWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Settings to fetch.
         *
         **/
        orderBy?: Enumerable<SettingsOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for searching for Settings.
         *
         **/
        cursor?: SettingsWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Settings from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Settings.
         *
         **/
        skip?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
         *
         * Filter by unique combinations of Settings.
         *
         **/
        distinct?: Enumerable<SettingsScalarFieldEnum>
    }

    /**
     * Settings findMany
     */
    export type SettingsFindManyArgs = {
        /**
         * Select specific fields to fetch from the Settings
         *
         **/
        select?: SettingsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: SettingsInclude | null
        /**
         * Filter, which Settings to fetch.
         *
         **/
        where?: SettingsWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Settings to fetch.
         *
         **/
        orderBy?: Enumerable<SettingsOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for listing Settings.
         *
         **/
        cursor?: SettingsWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Settings from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Settings.
         *
         **/
        skip?: number
        distinct?: Enumerable<SettingsScalarFieldEnum>
    }

    /**
     * Settings create
     */
    export type SettingsCreateArgs = {
        /**
         * Select specific fields to fetch from the Settings
         *
         **/
        select?: SettingsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: SettingsInclude | null
        /**
         * The data needed to create a Settings.
         *
         **/
        data: XOR<SettingsCreateInput, SettingsUncheckedCreateInput>
    }

    /**
     * Settings createMany
     */
    export type SettingsCreateManyArgs = {
        /**
         * The data used to create many Settings.
         *
         **/
        data: Enumerable<SettingsCreateManyInput>
        skipDuplicates?: boolean
    }

    /**
     * Settings update
     */
    export type SettingsUpdateArgs = {
        /**
         * Select specific fields to fetch from the Settings
         *
         **/
        select?: SettingsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: SettingsInclude | null
        /**
         * The data needed to update a Settings.
         *
         **/
        data: XOR<SettingsUpdateInput, SettingsUncheckedUpdateInput>
        /**
         * Choose, which Settings to update.
         *
         **/
        where: SettingsWhereUniqueInput
    }

    /**
     * Settings updateMany
     */
    export type SettingsUpdateManyArgs = {
        /**
         * The data used to update Settings.
         *
         **/
        data: XOR<SettingsUpdateManyMutationInput, SettingsUncheckedUpdateManyInput>
        /**
         * Filter which Settings to update
         *
         **/
        where?: SettingsWhereInput
    }

    /**
     * Settings upsert
     */
    export type SettingsUpsertArgs = {
        /**
         * Select specific fields to fetch from the Settings
         *
         **/
        select?: SettingsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: SettingsInclude | null
        /**
         * The filter to search for the Settings to update in case it exists.
         *
         **/
        where: SettingsWhereUniqueInput
        /**
         * In case the Settings found by the `where` argument doesn't exist, create a new Settings with this data.
         *
         **/
        create: XOR<SettingsCreateInput, SettingsUncheckedCreateInput>
        /**
         * In case the Settings was found with the provided `where` argument, update it with this data.
         *
         **/
        update: XOR<SettingsUpdateInput, SettingsUncheckedUpdateInput>
    }

    /**
     * Settings delete
     */
    export type SettingsDeleteArgs = {
        /**
         * Select specific fields to fetch from the Settings
         *
         **/
        select?: SettingsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: SettingsInclude | null
        /**
         * Filter which Settings to delete.
         *
         **/
        where: SettingsWhereUniqueInput
    }

    /**
     * Settings deleteMany
     */
    export type SettingsDeleteManyArgs = {
        /**
         * Filter which Settings to delete
         *
         **/
        where?: SettingsWhereInput
    }

    /**
     * Settings without action
     */
    export type SettingsArgs = {
        /**
         * Select specific fields to fetch from the Settings
         *
         **/
        select?: SettingsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: SettingsInclude | null
    }

    /**
     * Model Sponsor_sponsorship
     */

    export type AggregateSponsor_sponsorship = {
        _count: Sponsor_sponsorshipCountAggregateOutputType | null
        _min: Sponsor_sponsorshipMinAggregateOutputType | null
        _max: Sponsor_sponsorshipMaxAggregateOutputType | null
    }

    export type Sponsor_sponsorshipMinAggregateOutputType = {
        id: string | null
        sponsor_id: string | null
        type: sponsor_sponsorship_type | null
        value: string | null
        tenant_id: string | null
        created_at: Date | null
        updated_at: Date | null
    }

    export type Sponsor_sponsorshipMaxAggregateOutputType = {
        id: string | null
        sponsor_id: string | null
        type: sponsor_sponsorship_type | null
        value: string | null
        tenant_id: string | null
        created_at: Date | null
        updated_at: Date | null
    }

    export type Sponsor_sponsorshipCountAggregateOutputType = {
        id: number
        sponsor_id: number
        type: number
        value: number
        tenant_id: number
        created_at: number
        updated_at: number
        _all: number
    }

    export type Sponsor_sponsorshipMinAggregateInputType = {
        id?: true
        sponsor_id?: true
        type?: true
        value?: true
        tenant_id?: true
        created_at?: true
        updated_at?: true
    }

    export type Sponsor_sponsorshipMaxAggregateInputType = {
        id?: true
        sponsor_id?: true
        type?: true
        value?: true
        tenant_id?: true
        created_at?: true
        updated_at?: true
    }

    export type Sponsor_sponsorshipCountAggregateInputType = {
        id?: true
        sponsor_id?: true
        type?: true
        value?: true
        tenant_id?: true
        created_at?: true
        updated_at?: true
        _all?: true
    }

    export type Sponsor_sponsorshipAggregateArgs = {
        /**
         * Filter which Sponsor_sponsorship to aggregate.
         *
         **/
        where?: Sponsor_sponsorshipWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Sponsor_sponsorships to fetch.
         *
         **/
        orderBy?: Enumerable<Sponsor_sponsorshipOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the start position
         *
         **/
        cursor?: Sponsor_sponsorshipWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Sponsor_sponsorships from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Sponsor_sponsorships.
         *
         **/
        skip?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Count returned Sponsor_sponsorships
         **/
        _count?: true | Sponsor_sponsorshipCountAggregateInputType
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to find the minimum value
         **/
        _min?: Sponsor_sponsorshipMinAggregateInputType
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to find the maximum value
         **/
        _max?: Sponsor_sponsorshipMaxAggregateInputType
    }

    export type GetSponsor_sponsorshipAggregateType<T extends Sponsor_sponsorshipAggregateArgs> = {
        [P in keyof T & keyof AggregateSponsor_sponsorship]: P extends '_count' | 'count'
            ? T[P] extends true
                ? number
                : GetScalarType<T[P], AggregateSponsor_sponsorship[P]>
            : GetScalarType<T[P], AggregateSponsor_sponsorship[P]>
    }

    export type Sponsor_sponsorshipGroupByArgs = {
        where?: Sponsor_sponsorshipWhereInput
        orderBy?: Enumerable<Sponsor_sponsorshipOrderByWithAggregationInput>
        by: Array<Sponsor_sponsorshipScalarFieldEnum>
        having?: Sponsor_sponsorshipScalarWhereWithAggregatesInput
        take?: number
        skip?: number
        _count?: Sponsor_sponsorshipCountAggregateInputType | true
        _min?: Sponsor_sponsorshipMinAggregateInputType
        _max?: Sponsor_sponsorshipMaxAggregateInputType
    }

    export type Sponsor_sponsorshipGroupByOutputType = {
        id: string
        sponsor_id: string
        type: sponsor_sponsorship_type
        value: string
        tenant_id: string
        created_at: Date | null
        updated_at: Date | null
        _count: Sponsor_sponsorshipCountAggregateOutputType | null
        _min: Sponsor_sponsorshipMinAggregateOutputType | null
        _max: Sponsor_sponsorshipMaxAggregateOutputType | null
    }

    type GetSponsor_sponsorshipGroupByPayload<T extends Sponsor_sponsorshipGroupByArgs> = PrismaPromise<
        Array<
            PickArray<Sponsor_sponsorshipGroupByOutputType, T['by']> & {
                [P in keyof T & keyof Sponsor_sponsorshipGroupByOutputType]: P extends '_count'
                    ? T[P] extends boolean
                        ? number
                        : GetScalarType<T[P], Sponsor_sponsorshipGroupByOutputType[P]>
                    : GetScalarType<T[P], Sponsor_sponsorshipGroupByOutputType[P]>
            }
        >
    >

    export type Sponsor_sponsorshipSelect = {
        id?: boolean
        sponsor_id?: boolean
        type?: boolean
        value?: boolean
        tenant_id?: boolean
        created_at?: boolean
        updated_at?: boolean
        sponsors?: boolean | SponsorsArgs
        tenants?: boolean | TenantsArgs
    }

    export type Sponsor_sponsorshipInclude = {
        sponsors?: boolean | SponsorsArgs
        tenants?: boolean | TenantsArgs
    }

    export type Sponsor_sponsorshipGetPayload<S extends boolean | null | undefined | Sponsor_sponsorshipArgs> =
        S extends { select: any; include: any }
            ? 'Please either choose `select` or `include`'
            : S extends true
              ? Sponsor_sponsorship
              : S extends undefined
                ? never
                : S extends { include: any } & (Sponsor_sponsorshipArgs | Sponsor_sponsorshipFindManyArgs)
                  ? Sponsor_sponsorship & {
                        [P in TruthyKeys<S['include']>]: P extends 'sponsors'
                            ? SponsorsGetPayload<S['include'][P]>
                            : P extends 'tenants'
                              ? TenantsGetPayload<S['include'][P]>
                              : never
                    }
                  : S extends { select: any } & (Sponsor_sponsorshipArgs | Sponsor_sponsorshipFindManyArgs)
                    ? {
                          [P in TruthyKeys<S['select']>]: P extends 'sponsors'
                              ? SponsorsGetPayload<S['select'][P]>
                              : P extends 'tenants'
                                ? TenantsGetPayload<S['select'][P]>
                                : P extends keyof Sponsor_sponsorship
                                  ? Sponsor_sponsorship[P]
                                  : never
                      }
                    : Sponsor_sponsorship

    type Sponsor_sponsorshipCountArgs = Merge<
        Omit<Sponsor_sponsorshipFindManyArgs, 'select' | 'include'> & {
            select?: Sponsor_sponsorshipCountAggregateInputType | true
        }
    >

    export interface Sponsor_sponsorshipDelegate<
        GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined
    > {
        /**
         * Find zero or one Sponsor_sponsorship that matches the filter.
         * @param {Sponsor_sponsorshipFindUniqueArgs} args - Arguments to find a Sponsor_sponsorship
         * @example
         * // Get one Sponsor_sponsorship
         * const sponsor_sponsorship = await prisma.sponsor_sponsorship.findUnique({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findUnique<
            T extends Sponsor_sponsorshipFindUniqueArgs,
            LocalRejectSettings = T['rejectOnNotFound'] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined
        >(
            args: SelectSubset<T, Sponsor_sponsorshipFindUniqueArgs>
        ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Sponsor_sponsorship'> extends True
            ? Prisma__Sponsor_sponsorshipClient<Sponsor_sponsorshipGetPayload<T>>
            : Prisma__Sponsor_sponsorshipClient<Sponsor_sponsorshipGetPayload<T> | null, null>

        /**
         * Find one Sponsor_sponsorship that matches the filter or throw an error  with `error.code='P2025'`
         *     if no matches were found.
         * @param {Sponsor_sponsorshipFindUniqueOrThrowArgs} args - Arguments to find a Sponsor_sponsorship
         * @example
         * // Get one Sponsor_sponsorship
         * const sponsor_sponsorship = await prisma.sponsor_sponsorship.findUniqueOrThrow({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findUniqueOrThrow<T extends Sponsor_sponsorshipFindUniqueOrThrowArgs>(
            args?: SelectSubset<T, Sponsor_sponsorshipFindUniqueOrThrowArgs>
        ): Prisma__Sponsor_sponsorshipClient<Sponsor_sponsorshipGetPayload<T>>

        /**
         * Find the first Sponsor_sponsorship that matches the filter.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {Sponsor_sponsorshipFindFirstArgs} args - Arguments to find a Sponsor_sponsorship
         * @example
         * // Get one Sponsor_sponsorship
         * const sponsor_sponsorship = await prisma.sponsor_sponsorship.findFirst({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findFirst<
            T extends Sponsor_sponsorshipFindFirstArgs,
            LocalRejectSettings = T['rejectOnNotFound'] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined
        >(
            args?: SelectSubset<T, Sponsor_sponsorshipFindFirstArgs>
        ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Sponsor_sponsorship'> extends True
            ? Prisma__Sponsor_sponsorshipClient<Sponsor_sponsorshipGetPayload<T>>
            : Prisma__Sponsor_sponsorshipClient<Sponsor_sponsorshipGetPayload<T> | null, null>

        /**
         * Find the first Sponsor_sponsorship that matches the filter or
         * throw `NotFoundError` if no matches were found.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {Sponsor_sponsorshipFindFirstOrThrowArgs} args - Arguments to find a Sponsor_sponsorship
         * @example
         * // Get one Sponsor_sponsorship
         * const sponsor_sponsorship = await prisma.sponsor_sponsorship.findFirstOrThrow({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findFirstOrThrow<T extends Sponsor_sponsorshipFindFirstOrThrowArgs>(
            args?: SelectSubset<T, Sponsor_sponsorshipFindFirstOrThrowArgs>
        ): Prisma__Sponsor_sponsorshipClient<Sponsor_sponsorshipGetPayload<T>>

        /**
         * Find zero or more Sponsor_sponsorships that matches the filter.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {Sponsor_sponsorshipFindManyArgs=} args - Arguments to filter and select certain fields only.
         * @example
         * // Get all Sponsor_sponsorships
         * const sponsor_sponsorships = await prisma.sponsor_sponsorship.findMany()
         *
         * // Get first 10 Sponsor_sponsorships
         * const sponsor_sponsorships = await prisma.sponsor_sponsorship.findMany({ take: 10 })
         *
         * // Only select the `id`
         * const sponsor_sponsorshipWithIdOnly = await prisma.sponsor_sponsorship.findMany({ select: { id: true } })
         *
         **/
        findMany<T extends Sponsor_sponsorshipFindManyArgs>(
            args?: SelectSubset<T, Sponsor_sponsorshipFindManyArgs>
        ): PrismaPromise<Array<Sponsor_sponsorshipGetPayload<T>>>

        /**
         * Create a Sponsor_sponsorship.
         * @param {Sponsor_sponsorshipCreateArgs} args - Arguments to create a Sponsor_sponsorship.
         * @example
         * // Create one Sponsor_sponsorship
         * const Sponsor_sponsorship = await prisma.sponsor_sponsorship.create({
         *   data: {
         *     // ... data to create a Sponsor_sponsorship
         *   }
         * })
         *
         **/
        create<T extends Sponsor_sponsorshipCreateArgs>(
            args: SelectSubset<T, Sponsor_sponsorshipCreateArgs>
        ): Prisma__Sponsor_sponsorshipClient<Sponsor_sponsorshipGetPayload<T>>

        /**
         * Create many Sponsor_sponsorships.
         *     @param {Sponsor_sponsorshipCreateManyArgs} args - Arguments to create many Sponsor_sponsorships.
         *     @example
         *     // Create many Sponsor_sponsorships
         *     const sponsor_sponsorship = await prisma.sponsor_sponsorship.createMany({
         *       data: {
         *         // ... provide data here
         *       }
         *     })
         *
         **/
        createMany<T extends Sponsor_sponsorshipCreateManyArgs>(
            args?: SelectSubset<T, Sponsor_sponsorshipCreateManyArgs>
        ): PrismaPromise<BatchPayload>

        /**
         * Delete a Sponsor_sponsorship.
         * @param {Sponsor_sponsorshipDeleteArgs} args - Arguments to delete one Sponsor_sponsorship.
         * @example
         * // Delete one Sponsor_sponsorship
         * const Sponsor_sponsorship = await prisma.sponsor_sponsorship.delete({
         *   where: {
         *     // ... filter to delete one Sponsor_sponsorship
         *   }
         * })
         *
         **/
        delete<T extends Sponsor_sponsorshipDeleteArgs>(
            args: SelectSubset<T, Sponsor_sponsorshipDeleteArgs>
        ): Prisma__Sponsor_sponsorshipClient<Sponsor_sponsorshipGetPayload<T>>

        /**
         * Update one Sponsor_sponsorship.
         * @param {Sponsor_sponsorshipUpdateArgs} args - Arguments to update one Sponsor_sponsorship.
         * @example
         * // Update one Sponsor_sponsorship
         * const sponsor_sponsorship = await prisma.sponsor_sponsorship.update({
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: {
         *     // ... provide data here
         *   }
         * })
         *
         **/
        update<T extends Sponsor_sponsorshipUpdateArgs>(
            args: SelectSubset<T, Sponsor_sponsorshipUpdateArgs>
        ): Prisma__Sponsor_sponsorshipClient<Sponsor_sponsorshipGetPayload<T>>

        /**
         * Delete zero or more Sponsor_sponsorships.
         * @param {Sponsor_sponsorshipDeleteManyArgs} args - Arguments to filter Sponsor_sponsorships to delete.
         * @example
         * // Delete a few Sponsor_sponsorships
         * const { count } = await prisma.sponsor_sponsorship.deleteMany({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         *
         **/
        deleteMany<T extends Sponsor_sponsorshipDeleteManyArgs>(
            args?: SelectSubset<T, Sponsor_sponsorshipDeleteManyArgs>
        ): PrismaPromise<BatchPayload>

        /**
         * Update zero or more Sponsor_sponsorships.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {Sponsor_sponsorshipUpdateManyArgs} args - Arguments to update one or more rows.
         * @example
         * // Update many Sponsor_sponsorships
         * const sponsor_sponsorship = await prisma.sponsor_sponsorship.updateMany({
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: {
         *     // ... provide data here
         *   }
         * })
         *
         **/
        updateMany<T extends Sponsor_sponsorshipUpdateManyArgs>(
            args: SelectSubset<T, Sponsor_sponsorshipUpdateManyArgs>
        ): PrismaPromise<BatchPayload>

        /**
         * Create or update one Sponsor_sponsorship.
         * @param {Sponsor_sponsorshipUpsertArgs} args - Arguments to update or create a Sponsor_sponsorship.
         * @example
         * // Update or create a Sponsor_sponsorship
         * const sponsor_sponsorship = await prisma.sponsor_sponsorship.upsert({
         *   create: {
         *     // ... data to create a Sponsor_sponsorship
         *   },
         *   update: {
         *     // ... in case it already exists, update
         *   },
         *   where: {
         *     // ... the filter for the Sponsor_sponsorship we want to update
         *   }
         * })
         **/
        upsert<T extends Sponsor_sponsorshipUpsertArgs>(
            args: SelectSubset<T, Sponsor_sponsorshipUpsertArgs>
        ): Prisma__Sponsor_sponsorshipClient<Sponsor_sponsorshipGetPayload<T>>

        /**
         * Count the number of Sponsor_sponsorships.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {Sponsor_sponsorshipCountArgs} args - Arguments to filter Sponsor_sponsorships to count.
         * @example
         * // Count the number of Sponsor_sponsorships
         * const count = await prisma.sponsor_sponsorship.count({
         *   where: {
         *     // ... the filter for the Sponsor_sponsorships we want to count
         *   }
         * })
         **/
        count<T extends Sponsor_sponsorshipCountArgs>(
            args?: Subset<T, Sponsor_sponsorshipCountArgs>
        ): PrismaPromise<
            T extends _Record<'select', any>
                ? T['select'] extends true
                    ? number
                    : GetScalarType<T['select'], Sponsor_sponsorshipCountAggregateOutputType>
                : number
        >

        /**
         * Allows you to perform aggregations operations on a Sponsor_sponsorship.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {Sponsor_sponsorshipAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
         * @example
         * // Ordered by age ascending
         * // Where email contains prisma.io
         * // Limited to the 10 users
         * const aggregations = await prisma.user.aggregate({
         *   _avg: {
         *     age: true,
         *   },
         *   where: {
         *     email: {
         *       contains: "prisma.io",
         *     },
         *   },
         *   orderBy: {
         *     age: "asc",
         *   },
         *   take: 10,
         * })
         **/
        aggregate<T extends Sponsor_sponsorshipAggregateArgs>(
            args: Subset<T, Sponsor_sponsorshipAggregateArgs>
        ): PrismaPromise<GetSponsor_sponsorshipAggregateType<T>>

        /**
         * Group by Sponsor_sponsorship.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {Sponsor_sponsorshipGroupByArgs} args - Group by arguments.
         * @example
         * // Group by city, order by createdAt, get count
         * const result = await prisma.user.groupBy({
         *   by: ['city', 'createdAt'],
         *   orderBy: {
         *     createdAt: true
         *   },
         *   _count: {
         *     _all: true
         *   },
         * })
         *
         **/
        groupBy<
            T extends Sponsor_sponsorshipGroupByArgs,
            HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
            OrderByArg extends True extends HasSelectOrTake
                ? { orderBy: Sponsor_sponsorshipGroupByArgs['orderBy'] }
                : { orderBy?: Sponsor_sponsorshipGroupByArgs['orderBy'] },
            OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
            ByFields extends TupleToUnion<T['by']>,
            ByValid extends Has<ByFields, OrderFields>,
            HavingFields extends GetHavingFields<T['having']>,
            HavingValid extends Has<ByFields, HavingFields>,
            ByEmpty extends T['by'] extends never[] ? True : False,
            InputErrors extends ByEmpty extends True
                ? `Error: "by" must not be empty.`
                : HavingValid extends False
                  ? {
                        [P in HavingFields]: P extends ByFields
                            ? never
                            : P extends string
                              ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                              : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`]
                    }[HavingFields]
                  : 'take' extends Keys<T>
                    ? 'orderBy' extends Keys<T>
                        ? ByValid extends True
                            ? {}
                            : {
                                  [P in OrderFields]: P extends ByFields
                                      ? never
                                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                              }[OrderFields]
                        : 'Error: If you provide "take", you also need to provide "orderBy"'
                    : 'skip' extends Keys<T>
                      ? 'orderBy' extends Keys<T>
                          ? ByValid extends True
                              ? {}
                              : {
                                    [P in OrderFields]: P extends ByFields
                                        ? never
                                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                                }[OrderFields]
                          : 'Error: If you provide "skip", you also need to provide "orderBy"'
                      : ByValid extends True
                        ? {}
                        : {
                              [P in OrderFields]: P extends ByFields
                                  ? never
                                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                          }[OrderFields]
        >(
            args: SubsetIntersection<T, Sponsor_sponsorshipGroupByArgs, OrderByArg> & InputErrors
        ): {} extends InputErrors ? GetSponsor_sponsorshipGroupByPayload<T> : PrismaPromise<InputErrors>
    }

    /**
     * The delegate class that acts as a "Promise-like" for Sponsor_sponsorship.
     * Why is this prefixed with `Prisma__`?
     * Because we want to prevent naming conflicts as mentioned in
     * https://github.com/prisma/prisma-client-js/issues/707
     */
    export class Prisma__Sponsor_sponsorshipClient<T, Null = never> implements PrismaPromise<T> {
        [prisma]: true
        private readonly _dmmf
        private readonly _fetcher
        private readonly _queryType
        private readonly _rootField
        private readonly _clientMethod
        private readonly _args
        private readonly _dataPath
        private readonly _errorFormat
        private readonly _measurePerformance?
        private _isList
        private _callsite
        private _requestPromise?
        constructor(
            _dmmf: runtime.DMMFClass,
            _fetcher: PrismaClientFetcher,
            _queryType: 'query' | 'mutation',
            _rootField: string,
            _clientMethod: string,
            _args: any,
            _dataPath: string[],
            _errorFormat: ErrorFormat,
            _measurePerformance?: boolean | undefined,
            _isList?: boolean
        )
        readonly [Symbol.toStringTag]: 'PrismaClientPromise'

        sponsors<T extends SponsorsArgs = {}>(
            args?: Subset<T, SponsorsArgs>
        ): Prisma__SponsorsClient<SponsorsGetPayload<T> | Null>

        tenants<T extends TenantsArgs = {}>(
            args?: Subset<T, TenantsArgs>
        ): Prisma__TenantsClient<TenantsGetPayload<T> | Null>

        private get _document()
        /**
         * Attaches callbacks for the resolution and/or rejection of the Promise.
         * @param onfulfilled The callback to execute when the Promise is resolved.
         * @param onrejected The callback to execute when the Promise is rejected.
         * @returns A Promise for the completion of which ever callback is executed.
         */
        then<TResult1 = T, TResult2 = never>(
            onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
            onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
        ): Promise<TResult1 | TResult2>
        /**
         * Attaches a callback for only the rejection of the Promise.
         * @param onrejected The callback to execute when the Promise is rejected.
         * @returns A Promise for the completion of the callback.
         */
        catch<TResult = never>(
            onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
        ): Promise<T | TResult>
        /**
         * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
         * resolved value cannot be modified from the callback.
         * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
         * @returns A Promise for the completion of the callback.
         */
        finally(onfinally?: (() => void) | undefined | null): Promise<T>
    }

    // Custom InputTypes

    /**
     * Sponsor_sponsorship base type for findUnique actions
     */
    export type Sponsor_sponsorshipFindUniqueArgsBase = {
        /**
         * Select specific fields to fetch from the Sponsor_sponsorship
         *
         **/
        select?: Sponsor_sponsorshipSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Sponsor_sponsorshipInclude | null
        /**
         * Filter, which Sponsor_sponsorship to fetch.
         *
         **/
        where: Sponsor_sponsorshipWhereUniqueInput
    }

    /**
     * Sponsor_sponsorship findUnique
     */
    export interface Sponsor_sponsorshipFindUniqueArgs extends Sponsor_sponsorshipFindUniqueArgsBase {
        /**
         * Throw an Error if query returns no results
         * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
         */
        rejectOnNotFound?: RejectOnNotFound
    }

    /**
     * Sponsor_sponsorship findUniqueOrThrow
     */
    export type Sponsor_sponsorshipFindUniqueOrThrowArgs = {
        /**
         * Select specific fields to fetch from the Sponsor_sponsorship
         *
         **/
        select?: Sponsor_sponsorshipSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Sponsor_sponsorshipInclude | null
        /**
         * Filter, which Sponsor_sponsorship to fetch.
         *
         **/
        where: Sponsor_sponsorshipWhereUniqueInput
    }

    /**
     * Sponsor_sponsorship base type for findFirst actions
     */
    export type Sponsor_sponsorshipFindFirstArgsBase = {
        /**
         * Select specific fields to fetch from the Sponsor_sponsorship
         *
         **/
        select?: Sponsor_sponsorshipSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Sponsor_sponsorshipInclude | null
        /**
         * Filter, which Sponsor_sponsorship to fetch.
         *
         **/
        where?: Sponsor_sponsorshipWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Sponsor_sponsorships to fetch.
         *
         **/
        orderBy?: Enumerable<Sponsor_sponsorshipOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for searching for Sponsor_sponsorships.
         *
         **/
        cursor?: Sponsor_sponsorshipWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Sponsor_sponsorships from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Sponsor_sponsorships.
         *
         **/
        skip?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
         *
         * Filter by unique combinations of Sponsor_sponsorships.
         *
         **/
        distinct?: Enumerable<Sponsor_sponsorshipScalarFieldEnum>
    }

    /**
     * Sponsor_sponsorship findFirst
     */
    export interface Sponsor_sponsorshipFindFirstArgs extends Sponsor_sponsorshipFindFirstArgsBase {
        /**
         * Throw an Error if query returns no results
         * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
         */
        rejectOnNotFound?: RejectOnNotFound
    }

    /**
     * Sponsor_sponsorship findFirstOrThrow
     */
    export type Sponsor_sponsorshipFindFirstOrThrowArgs = {
        /**
         * Select specific fields to fetch from the Sponsor_sponsorship
         *
         **/
        select?: Sponsor_sponsorshipSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Sponsor_sponsorshipInclude | null
        /**
         * Filter, which Sponsor_sponsorship to fetch.
         *
         **/
        where?: Sponsor_sponsorshipWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Sponsor_sponsorships to fetch.
         *
         **/
        orderBy?: Enumerable<Sponsor_sponsorshipOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for searching for Sponsor_sponsorships.
         *
         **/
        cursor?: Sponsor_sponsorshipWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Sponsor_sponsorships from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Sponsor_sponsorships.
         *
         **/
        skip?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
         *
         * Filter by unique combinations of Sponsor_sponsorships.
         *
         **/
        distinct?: Enumerable<Sponsor_sponsorshipScalarFieldEnum>
    }

    /**
     * Sponsor_sponsorship findMany
     */
    export type Sponsor_sponsorshipFindManyArgs = {
        /**
         * Select specific fields to fetch from the Sponsor_sponsorship
         *
         **/
        select?: Sponsor_sponsorshipSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Sponsor_sponsorshipInclude | null
        /**
         * Filter, which Sponsor_sponsorships to fetch.
         *
         **/
        where?: Sponsor_sponsorshipWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Sponsor_sponsorships to fetch.
         *
         **/
        orderBy?: Enumerable<Sponsor_sponsorshipOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for listing Sponsor_sponsorships.
         *
         **/
        cursor?: Sponsor_sponsorshipWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Sponsor_sponsorships from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Sponsor_sponsorships.
         *
         **/
        skip?: number
        distinct?: Enumerable<Sponsor_sponsorshipScalarFieldEnum>
    }

    /**
     * Sponsor_sponsorship create
     */
    export type Sponsor_sponsorshipCreateArgs = {
        /**
         * Select specific fields to fetch from the Sponsor_sponsorship
         *
         **/
        select?: Sponsor_sponsorshipSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Sponsor_sponsorshipInclude | null
        /**
         * The data needed to create a Sponsor_sponsorship.
         *
         **/
        data: XOR<Sponsor_sponsorshipCreateInput, Sponsor_sponsorshipUncheckedCreateInput>
    }

    /**
     * Sponsor_sponsorship createMany
     */
    export type Sponsor_sponsorshipCreateManyArgs = {
        /**
         * The data used to create many Sponsor_sponsorships.
         *
         **/
        data: Enumerable<Sponsor_sponsorshipCreateManyInput>
        skipDuplicates?: boolean
    }

    /**
     * Sponsor_sponsorship update
     */
    export type Sponsor_sponsorshipUpdateArgs = {
        /**
         * Select specific fields to fetch from the Sponsor_sponsorship
         *
         **/
        select?: Sponsor_sponsorshipSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Sponsor_sponsorshipInclude | null
        /**
         * The data needed to update a Sponsor_sponsorship.
         *
         **/
        data: XOR<Sponsor_sponsorshipUpdateInput, Sponsor_sponsorshipUncheckedUpdateInput>
        /**
         * Choose, which Sponsor_sponsorship to update.
         *
         **/
        where: Sponsor_sponsorshipWhereUniqueInput
    }

    /**
     * Sponsor_sponsorship updateMany
     */
    export type Sponsor_sponsorshipUpdateManyArgs = {
        /**
         * The data used to update Sponsor_sponsorships.
         *
         **/
        data: XOR<Sponsor_sponsorshipUpdateManyMutationInput, Sponsor_sponsorshipUncheckedUpdateManyInput>
        /**
         * Filter which Sponsor_sponsorships to update
         *
         **/
        where?: Sponsor_sponsorshipWhereInput
    }

    /**
     * Sponsor_sponsorship upsert
     */
    export type Sponsor_sponsorshipUpsertArgs = {
        /**
         * Select specific fields to fetch from the Sponsor_sponsorship
         *
         **/
        select?: Sponsor_sponsorshipSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Sponsor_sponsorshipInclude | null
        /**
         * The filter to search for the Sponsor_sponsorship to update in case it exists.
         *
         **/
        where: Sponsor_sponsorshipWhereUniqueInput
        /**
         * In case the Sponsor_sponsorship found by the `where` argument doesn't exist, create a new Sponsor_sponsorship with this data.
         *
         **/
        create: XOR<Sponsor_sponsorshipCreateInput, Sponsor_sponsorshipUncheckedCreateInput>
        /**
         * In case the Sponsor_sponsorship was found with the provided `where` argument, update it with this data.
         *
         **/
        update: XOR<Sponsor_sponsorshipUpdateInput, Sponsor_sponsorshipUncheckedUpdateInput>
    }

    /**
     * Sponsor_sponsorship delete
     */
    export type Sponsor_sponsorshipDeleteArgs = {
        /**
         * Select specific fields to fetch from the Sponsor_sponsorship
         *
         **/
        select?: Sponsor_sponsorshipSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Sponsor_sponsorshipInclude | null
        /**
         * Filter which Sponsor_sponsorship to delete.
         *
         **/
        where: Sponsor_sponsorshipWhereUniqueInput
    }

    /**
     * Sponsor_sponsorship deleteMany
     */
    export type Sponsor_sponsorshipDeleteManyArgs = {
        /**
         * Filter which Sponsor_sponsorships to delete
         *
         **/
        where?: Sponsor_sponsorshipWhereInput
    }

    /**
     * Sponsor_sponsorship without action
     */
    export type Sponsor_sponsorshipArgs = {
        /**
         * Select specific fields to fetch from the Sponsor_sponsorship
         *
         **/
        select?: Sponsor_sponsorshipSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Sponsor_sponsorshipInclude | null
    }

    /**
     * Model Sponsors
     */

    export type AggregateSponsors = {
        _count: SponsorsCountAggregateOutputType | null
        _avg: SponsorsAvgAggregateOutputType | null
        _sum: SponsorsSumAggregateOutputType | null
        _min: SponsorsMinAggregateOutputType | null
        _max: SponsorsMaxAggregateOutputType | null
    }

    export type SponsorsAvgAggregateOutputType = {
        file_number: number | null
    }

    export type SponsorsSumAggregateOutputType = {
        file_number: number | null
    }

    export type SponsorsMinAggregateOutputType = {
        id: string | null
        zone_id: string | null
        file_number: number | null
        start_date: Date | null
        name: string | null
        address: string | null
        phone_number: string | null
        sponsorship_type: string | null
        birth_date: Date | null
        father_name: string | null
        mother_name: string | null
        birth_certificate_number: string | null
        academic_level: string | null
        function: string | null
        health_status: string | null
        diploma: string | null
        card_number: string | null
        tenant_id: string | null
        created_by: string | null
        deleted_by: string | null
        deleted_at: Date | null
        created_at: Date | null
        updated_at: Date | null
    }

    export type SponsorsMaxAggregateOutputType = {
        id: string | null
        zone_id: string | null
        file_number: number | null
        start_date: Date | null
        name: string | null
        address: string | null
        phone_number: string | null
        sponsorship_type: string | null
        birth_date: Date | null
        father_name: string | null
        mother_name: string | null
        birth_certificate_number: string | null
        academic_level: string | null
        function: string | null
        health_status: string | null
        diploma: string | null
        card_number: string | null
        tenant_id: string | null
        created_by: string | null
        deleted_by: string | null
        deleted_at: Date | null
        created_at: Date | null
        updated_at: Date | null
    }

    export type SponsorsCountAggregateOutputType = {
        id: number
        zone_id: number
        file_number: number
        start_date: number
        name: number
        address: number
        phone_number: number
        sponsorship_type: number
        birth_date: number
        father_name: number
        mother_name: number
        birth_certificate_number: number
        academic_level: number
        function: number
        health_status: number
        diploma: number
        card_number: number
        tenant_id: number
        created_by: number
        deleted_by: number
        deleted_at: number
        created_at: number
        updated_at: number
        _all: number
    }

    export type SponsorsAvgAggregateInputType = {
        file_number?: true
    }

    export type SponsorsSumAggregateInputType = {
        file_number?: true
    }

    export type SponsorsMinAggregateInputType = {
        id?: true
        zone_id?: true
        file_number?: true
        start_date?: true
        name?: true
        address?: true
        phone_number?: true
        sponsorship_type?: true
        birth_date?: true
        father_name?: true
        mother_name?: true
        birth_certificate_number?: true
        academic_level?: true
        function?: true
        health_status?: true
        diploma?: true
        card_number?: true
        tenant_id?: true
        created_by?: true
        deleted_by?: true
        deleted_at?: true
        created_at?: true
        updated_at?: true
    }

    export type SponsorsMaxAggregateInputType = {
        id?: true
        zone_id?: true
        file_number?: true
        start_date?: true
        name?: true
        address?: true
        phone_number?: true
        sponsorship_type?: true
        birth_date?: true
        father_name?: true
        mother_name?: true
        birth_certificate_number?: true
        academic_level?: true
        function?: true
        health_status?: true
        diploma?: true
        card_number?: true
        tenant_id?: true
        created_by?: true
        deleted_by?: true
        deleted_at?: true
        created_at?: true
        updated_at?: true
    }

    export type SponsorsCountAggregateInputType = {
        id?: true
        zone_id?: true
        file_number?: true
        start_date?: true
        name?: true
        address?: true
        phone_number?: true
        sponsorship_type?: true
        birth_date?: true
        father_name?: true
        mother_name?: true
        birth_certificate_number?: true
        academic_level?: true
        function?: true
        health_status?: true
        diploma?: true
        card_number?: true
        tenant_id?: true
        created_by?: true
        deleted_by?: true
        deleted_at?: true
        created_at?: true
        updated_at?: true
        _all?: true
    }

    export type SponsorsAggregateArgs = {
        /**
         * Filter which Sponsors to aggregate.
         *
         **/
        where?: SponsorsWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Sponsors to fetch.
         *
         **/
        orderBy?: Enumerable<SponsorsOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the start position
         *
         **/
        cursor?: SponsorsWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Sponsors from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Sponsors.
         *
         **/
        skip?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Count returned Sponsors
         **/
        _count?: true | SponsorsCountAggregateInputType
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to average
         **/
        _avg?: SponsorsAvgAggregateInputType
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to sum
         **/
        _sum?: SponsorsSumAggregateInputType
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to find the minimum value
         **/
        _min?: SponsorsMinAggregateInputType
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to find the maximum value
         **/
        _max?: SponsorsMaxAggregateInputType
    }

    export type GetSponsorsAggregateType<T extends SponsorsAggregateArgs> = {
        [P in keyof T & keyof AggregateSponsors]: P extends '_count' | 'count'
            ? T[P] extends true
                ? number
                : GetScalarType<T[P], AggregateSponsors[P]>
            : GetScalarType<T[P], AggregateSponsors[P]>
    }

    export type SponsorsGroupByArgs = {
        where?: SponsorsWhereInput
        orderBy?: Enumerable<SponsorsOrderByWithAggregationInput>
        by: Array<SponsorsScalarFieldEnum>
        having?: SponsorsScalarWhereWithAggregatesInput
        take?: number
        skip?: number
        _count?: SponsorsCountAggregateInputType | true
        _avg?: SponsorsAvgAggregateInputType
        _sum?: SponsorsSumAggregateInputType
        _min?: SponsorsMinAggregateInputType
        _max?: SponsorsMaxAggregateInputType
    }

    export type SponsorsGroupByOutputType = {
        id: string
        zone_id: string
        file_number: number
        start_date: Date
        name: string
        address: string
        phone_number: string
        sponsorship_type: string
        birth_date: Date
        father_name: string
        mother_name: string
        birth_certificate_number: string
        academic_level: string
        function: string
        health_status: string
        diploma: string | null
        card_number: string | null
        tenant_id: string
        created_by: string
        deleted_by: string | null
        deleted_at: Date | null
        created_at: Date | null
        updated_at: Date | null
        _count: SponsorsCountAggregateOutputType | null
        _avg: SponsorsAvgAggregateOutputType | null
        _sum: SponsorsSumAggregateOutputType | null
        _min: SponsorsMinAggregateOutputType | null
        _max: SponsorsMaxAggregateOutputType | null
    }

    type GetSponsorsGroupByPayload<T extends SponsorsGroupByArgs> = PrismaPromise<
        Array<
            PickArray<SponsorsGroupByOutputType, T['by']> & {
                [P in keyof T & keyof SponsorsGroupByOutputType]: P extends '_count'
                    ? T[P] extends boolean
                        ? number
                        : GetScalarType<T[P], SponsorsGroupByOutputType[P]>
                    : GetScalarType<T[P], SponsorsGroupByOutputType[P]>
            }
        >
    >

    export type SponsorsSelect = {
        id?: boolean
        zone_id?: boolean
        file_number?: boolean
        start_date?: boolean
        name?: boolean
        address?: boolean
        phone_number?: boolean
        sponsorship_type?: boolean
        birth_date?: boolean
        father_name?: boolean
        mother_name?: boolean
        birth_certificate_number?: boolean
        academic_level?: boolean
        function?: boolean
        health_status?: boolean
        diploma?: boolean
        card_number?: boolean
        tenant_id?: boolean
        created_by?: boolean
        deleted_by?: boolean
        deleted_at?: boolean
        created_at?: boolean
        updated_at?: boolean
        income_sponsor?: boolean | Sponsors$income_sponsorArgs
        sponsor_sponsorship?: boolean | Sponsors$sponsor_sponsorshipArgs
        users_sponsors_created_byTousers?: boolean | UsersArgs
        users_sponsors_deleted_byTousers?: boolean | UsersArgs
        tenants?: boolean | TenantsArgs
        _count?: boolean | SponsorsCountOutputTypeArgs
    }

    export type SponsorsInclude = {
        income_sponsor?: boolean | Sponsors$income_sponsorArgs
        sponsor_sponsorship?: boolean | Sponsors$sponsor_sponsorshipArgs
        users_sponsors_created_byTousers?: boolean | UsersArgs
        users_sponsors_deleted_byTousers?: boolean | UsersArgs
        tenants?: boolean | TenantsArgs
        _count?: boolean | SponsorsCountOutputTypeArgs
    }

    export type SponsorsGetPayload<S extends boolean | null | undefined | SponsorsArgs> = S extends {
        select: any
        include: any
    }
        ? 'Please either choose `select` or `include`'
        : S extends true
          ? Sponsors
          : S extends undefined
            ? never
            : S extends { include: any } & (SponsorsArgs | SponsorsFindManyArgs)
              ? Sponsors & {
                    [P in TruthyKeys<S['include']>]: P extends 'income_sponsor'
                        ? Array<Income_sponsorGetPayload<S['include'][P]>>
                        : P extends 'sponsor_sponsorship'
                          ? Array<Sponsor_sponsorshipGetPayload<S['include'][P]>>
                          : P extends 'users_sponsors_created_byTousers'
                            ? UsersGetPayload<S['include'][P]>
                            : P extends 'users_sponsors_deleted_byTousers'
                              ? UsersGetPayload<S['include'][P]> | null
                              : P extends 'tenants'
                                ? TenantsGetPayload<S['include'][P]>
                                : P extends '_count'
                                  ? SponsorsCountOutputTypeGetPayload<S['include'][P]>
                                  : never
                }
              : S extends { select: any } & (SponsorsArgs | SponsorsFindManyArgs)
                ? {
                      [P in TruthyKeys<S['select']>]: P extends 'income_sponsor'
                          ? Array<Income_sponsorGetPayload<S['select'][P]>>
                          : P extends 'sponsor_sponsorship'
                            ? Array<Sponsor_sponsorshipGetPayload<S['select'][P]>>
                            : P extends 'users_sponsors_created_byTousers'
                              ? UsersGetPayload<S['select'][P]>
                              : P extends 'users_sponsors_deleted_byTousers'
                                ? UsersGetPayload<S['select'][P]> | null
                                : P extends 'tenants'
                                  ? TenantsGetPayload<S['select'][P]>
                                  : P extends '_count'
                                    ? SponsorsCountOutputTypeGetPayload<S['select'][P]>
                                    : P extends keyof Sponsors
                                      ? Sponsors[P]
                                      : never
                  }
                : Sponsors

    type SponsorsCountArgs = Merge<
        Omit<SponsorsFindManyArgs, 'select' | 'include'> & {
            select?: SponsorsCountAggregateInputType | true
        }
    >

    export interface SponsorsDelegate<
        GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined
    > {
        /**
         * Find zero or one Sponsors that matches the filter.
         * @param {SponsorsFindUniqueArgs} args - Arguments to find a Sponsors
         * @example
         * // Get one Sponsors
         * const sponsors = await prisma.sponsors.findUnique({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findUnique<
            T extends SponsorsFindUniqueArgs,
            LocalRejectSettings = T['rejectOnNotFound'] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined
        >(
            args: SelectSubset<T, SponsorsFindUniqueArgs>
        ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Sponsors'> extends True
            ? Prisma__SponsorsClient<SponsorsGetPayload<T>>
            : Prisma__SponsorsClient<SponsorsGetPayload<T> | null, null>

        /**
         * Find one Sponsors that matches the filter or throw an error  with `error.code='P2025'`
         *     if no matches were found.
         * @param {SponsorsFindUniqueOrThrowArgs} args - Arguments to find a Sponsors
         * @example
         * // Get one Sponsors
         * const sponsors = await prisma.sponsors.findUniqueOrThrow({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findUniqueOrThrow<T extends SponsorsFindUniqueOrThrowArgs>(
            args?: SelectSubset<T, SponsorsFindUniqueOrThrowArgs>
        ): Prisma__SponsorsClient<SponsorsGetPayload<T>>

        /**
         * Find the first Sponsors that matches the filter.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {SponsorsFindFirstArgs} args - Arguments to find a Sponsors
         * @example
         * // Get one Sponsors
         * const sponsors = await prisma.sponsors.findFirst({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findFirst<
            T extends SponsorsFindFirstArgs,
            LocalRejectSettings = T['rejectOnNotFound'] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined
        >(
            args?: SelectSubset<T, SponsorsFindFirstArgs>
        ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Sponsors'> extends True
            ? Prisma__SponsorsClient<SponsorsGetPayload<T>>
            : Prisma__SponsorsClient<SponsorsGetPayload<T> | null, null>

        /**
         * Find the first Sponsors that matches the filter or
         * throw `NotFoundError` if no matches were found.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {SponsorsFindFirstOrThrowArgs} args - Arguments to find a Sponsors
         * @example
         * // Get one Sponsors
         * const sponsors = await prisma.sponsors.findFirstOrThrow({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findFirstOrThrow<T extends SponsorsFindFirstOrThrowArgs>(
            args?: SelectSubset<T, SponsorsFindFirstOrThrowArgs>
        ): Prisma__SponsorsClient<SponsorsGetPayload<T>>

        /**
         * Find zero or more Sponsors that matches the filter.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {SponsorsFindManyArgs=} args - Arguments to filter and select certain fields only.
         * @example
         * // Get all Sponsors
         * const sponsors = await prisma.sponsors.findMany()
         *
         * // Get first 10 Sponsors
         * const sponsors = await prisma.sponsors.findMany({ take: 10 })
         *
         * // Only select the `id`
         * const sponsorsWithIdOnly = await prisma.sponsors.findMany({ select: { id: true } })
         *
         **/
        findMany<T extends SponsorsFindManyArgs>(
            args?: SelectSubset<T, SponsorsFindManyArgs>
        ): PrismaPromise<Array<SponsorsGetPayload<T>>>

        /**
         * Create a Sponsors.
         * @param {SponsorsCreateArgs} args - Arguments to create a Sponsors.
         * @example
         * // Create one Sponsors
         * const Sponsors = await prisma.sponsors.create({
         *   data: {
         *     // ... data to create a Sponsors
         *   }
         * })
         *
         **/
        create<T extends SponsorsCreateArgs>(
            args: SelectSubset<T, SponsorsCreateArgs>
        ): Prisma__SponsorsClient<SponsorsGetPayload<T>>

        /**
         * Create many Sponsors.
         *     @param {SponsorsCreateManyArgs} args - Arguments to create many Sponsors.
         *     @example
         *     // Create many Sponsors
         *     const sponsors = await prisma.sponsors.createMany({
         *       data: {
         *         // ... provide data here
         *       }
         *     })
         *
         **/
        createMany<T extends SponsorsCreateManyArgs>(
            args?: SelectSubset<T, SponsorsCreateManyArgs>
        ): PrismaPromise<BatchPayload>

        /**
         * Delete a Sponsors.
         * @param {SponsorsDeleteArgs} args - Arguments to delete one Sponsors.
         * @example
         * // Delete one Sponsors
         * const Sponsors = await prisma.sponsors.delete({
         *   where: {
         *     // ... filter to delete one Sponsors
         *   }
         * })
         *
         **/
        delete<T extends SponsorsDeleteArgs>(
            args: SelectSubset<T, SponsorsDeleteArgs>
        ): Prisma__SponsorsClient<SponsorsGetPayload<T>>

        /**
         * Update one Sponsors.
         * @param {SponsorsUpdateArgs} args - Arguments to update one Sponsors.
         * @example
         * // Update one Sponsors
         * const sponsors = await prisma.sponsors.update({
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: {
         *     // ... provide data here
         *   }
         * })
         *
         **/
        update<T extends SponsorsUpdateArgs>(
            args: SelectSubset<T, SponsorsUpdateArgs>
        ): Prisma__SponsorsClient<SponsorsGetPayload<T>>

        /**
         * Delete zero or more Sponsors.
         * @param {SponsorsDeleteManyArgs} args - Arguments to filter Sponsors to delete.
         * @example
         * // Delete a few Sponsors
         * const { count } = await prisma.sponsors.deleteMany({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         *
         **/
        deleteMany<T extends SponsorsDeleteManyArgs>(
            args?: SelectSubset<T, SponsorsDeleteManyArgs>
        ): PrismaPromise<BatchPayload>

        /**
         * Update zero or more Sponsors.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {SponsorsUpdateManyArgs} args - Arguments to update one or more rows.
         * @example
         * // Update many Sponsors
         * const sponsors = await prisma.sponsors.updateMany({
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: {
         *     // ... provide data here
         *   }
         * })
         *
         **/
        updateMany<T extends SponsorsUpdateManyArgs>(
            args: SelectSubset<T, SponsorsUpdateManyArgs>
        ): PrismaPromise<BatchPayload>

        /**
         * Create or update one Sponsors.
         * @param {SponsorsUpsertArgs} args - Arguments to update or create a Sponsors.
         * @example
         * // Update or create a Sponsors
         * const sponsors = await prisma.sponsors.upsert({
         *   create: {
         *     // ... data to create a Sponsors
         *   },
         *   update: {
         *     // ... in case it already exists, update
         *   },
         *   where: {
         *     // ... the filter for the Sponsors we want to update
         *   }
         * })
         **/
        upsert<T extends SponsorsUpsertArgs>(
            args: SelectSubset<T, SponsorsUpsertArgs>
        ): Prisma__SponsorsClient<SponsorsGetPayload<T>>

        /**
         * Count the number of Sponsors.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {SponsorsCountArgs} args - Arguments to filter Sponsors to count.
         * @example
         * // Count the number of Sponsors
         * const count = await prisma.sponsors.count({
         *   where: {
         *     // ... the filter for the Sponsors we want to count
         *   }
         * })
         **/
        count<T extends SponsorsCountArgs>(
            args?: Subset<T, SponsorsCountArgs>
        ): PrismaPromise<
            T extends _Record<'select', any>
                ? T['select'] extends true
                    ? number
                    : GetScalarType<T['select'], SponsorsCountAggregateOutputType>
                : number
        >

        /**
         * Allows you to perform aggregations operations on a Sponsors.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {SponsorsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
         * @example
         * // Ordered by age ascending
         * // Where email contains prisma.io
         * // Limited to the 10 users
         * const aggregations = await prisma.user.aggregate({
         *   _avg: {
         *     age: true,
         *   },
         *   where: {
         *     email: {
         *       contains: "prisma.io",
         *     },
         *   },
         *   orderBy: {
         *     age: "asc",
         *   },
         *   take: 10,
         * })
         **/
        aggregate<T extends SponsorsAggregateArgs>(
            args: Subset<T, SponsorsAggregateArgs>
        ): PrismaPromise<GetSponsorsAggregateType<T>>

        /**
         * Group by Sponsors.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {SponsorsGroupByArgs} args - Group by arguments.
         * @example
         * // Group by city, order by createdAt, get count
         * const result = await prisma.user.groupBy({
         *   by: ['city', 'createdAt'],
         *   orderBy: {
         *     createdAt: true
         *   },
         *   _count: {
         *     _all: true
         *   },
         * })
         *
         **/
        groupBy<
            T extends SponsorsGroupByArgs,
            HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
            OrderByArg extends True extends HasSelectOrTake
                ? { orderBy: SponsorsGroupByArgs['orderBy'] }
                : { orderBy?: SponsorsGroupByArgs['orderBy'] },
            OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
            ByFields extends TupleToUnion<T['by']>,
            ByValid extends Has<ByFields, OrderFields>,
            HavingFields extends GetHavingFields<T['having']>,
            HavingValid extends Has<ByFields, HavingFields>,
            ByEmpty extends T['by'] extends never[] ? True : False,
            InputErrors extends ByEmpty extends True
                ? `Error: "by" must not be empty.`
                : HavingValid extends False
                  ? {
                        [P in HavingFields]: P extends ByFields
                            ? never
                            : P extends string
                              ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                              : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`]
                    }[HavingFields]
                  : 'take' extends Keys<T>
                    ? 'orderBy' extends Keys<T>
                        ? ByValid extends True
                            ? {}
                            : {
                                  [P in OrderFields]: P extends ByFields
                                      ? never
                                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                              }[OrderFields]
                        : 'Error: If you provide "take", you also need to provide "orderBy"'
                    : 'skip' extends Keys<T>
                      ? 'orderBy' extends Keys<T>
                          ? ByValid extends True
                              ? {}
                              : {
                                    [P in OrderFields]: P extends ByFields
                                        ? never
                                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                                }[OrderFields]
                          : 'Error: If you provide "skip", you also need to provide "orderBy"'
                      : ByValid extends True
                        ? {}
                        : {
                              [P in OrderFields]: P extends ByFields
                                  ? never
                                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                          }[OrderFields]
        >(
            args: SubsetIntersection<T, SponsorsGroupByArgs, OrderByArg> & InputErrors
        ): {} extends InputErrors ? GetSponsorsGroupByPayload<T> : PrismaPromise<InputErrors>
    }

    /**
     * The delegate class that acts as a "Promise-like" for Sponsors.
     * Why is this prefixed with `Prisma__`?
     * Because we want to prevent naming conflicts as mentioned in
     * https://github.com/prisma/prisma-client-js/issues/707
     */
    export class Prisma__SponsorsClient<T, Null = never> implements PrismaPromise<T> {
        [prisma]: true
        private readonly _dmmf
        private readonly _fetcher
        private readonly _queryType
        private readonly _rootField
        private readonly _clientMethod
        private readonly _args
        private readonly _dataPath
        private readonly _errorFormat
        private readonly _measurePerformance?
        private _isList
        private _callsite
        private _requestPromise?
        constructor(
            _dmmf: runtime.DMMFClass,
            _fetcher: PrismaClientFetcher,
            _queryType: 'query' | 'mutation',
            _rootField: string,
            _clientMethod: string,
            _args: any,
            _dataPath: string[],
            _errorFormat: ErrorFormat,
            _measurePerformance?: boolean | undefined,
            _isList?: boolean
        )
        readonly [Symbol.toStringTag]: 'PrismaClientPromise'

        income_sponsor<T extends Sponsors$income_sponsorArgs = {}>(
            args?: Subset<T, Sponsors$income_sponsorArgs>
        ): PrismaPromise<Array<Income_sponsorGetPayload<T>> | Null>

        sponsor_sponsorship<T extends Sponsors$sponsor_sponsorshipArgs = {}>(
            args?: Subset<T, Sponsors$sponsor_sponsorshipArgs>
        ): PrismaPromise<Array<Sponsor_sponsorshipGetPayload<T>> | Null>

        users_sponsors_created_byTousers<T extends UsersArgs = {}>(
            args?: Subset<T, UsersArgs>
        ): Prisma__UsersClient<UsersGetPayload<T> | Null>

        users_sponsors_deleted_byTousers<T extends UsersArgs = {}>(
            args?: Subset<T, UsersArgs>
        ): Prisma__UsersClient<UsersGetPayload<T> | Null>

        tenants<T extends TenantsArgs = {}>(
            args?: Subset<T, TenantsArgs>
        ): Prisma__TenantsClient<TenantsGetPayload<T> | Null>

        private get _document()
        /**
         * Attaches callbacks for the resolution and/or rejection of the Promise.
         * @param onfulfilled The callback to execute when the Promise is resolved.
         * @param onrejected The callback to execute when the Promise is rejected.
         * @returns A Promise for the completion of which ever callback is executed.
         */
        then<TResult1 = T, TResult2 = never>(
            onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
            onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
        ): Promise<TResult1 | TResult2>
        /**
         * Attaches a callback for only the rejection of the Promise.
         * @param onrejected The callback to execute when the Promise is rejected.
         * @returns A Promise for the completion of the callback.
         */
        catch<TResult = never>(
            onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
        ): Promise<T | TResult>
        /**
         * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
         * resolved value cannot be modified from the callback.
         * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
         * @returns A Promise for the completion of the callback.
         */
        finally(onfinally?: (() => void) | undefined | null): Promise<T>
    }

    // Custom InputTypes

    /**
     * Sponsors base type for findUnique actions
     */
    export type SponsorsFindUniqueArgsBase = {
        /**
         * Select specific fields to fetch from the Sponsors
         *
         **/
        select?: SponsorsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: SponsorsInclude | null
        /**
         * Filter, which Sponsors to fetch.
         *
         **/
        where: SponsorsWhereUniqueInput
    }

    /**
     * Sponsors findUnique
     */
    export interface SponsorsFindUniqueArgs extends SponsorsFindUniqueArgsBase {
        /**
         * Throw an Error if query returns no results
         * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
         */
        rejectOnNotFound?: RejectOnNotFound
    }

    /**
     * Sponsors findUniqueOrThrow
     */
    export type SponsorsFindUniqueOrThrowArgs = {
        /**
         * Select specific fields to fetch from the Sponsors
         *
         **/
        select?: SponsorsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: SponsorsInclude | null
        /**
         * Filter, which Sponsors to fetch.
         *
         **/
        where: SponsorsWhereUniqueInput
    }

    /**
     * Sponsors base type for findFirst actions
     */
    export type SponsorsFindFirstArgsBase = {
        /**
         * Select specific fields to fetch from the Sponsors
         *
         **/
        select?: SponsorsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: SponsorsInclude | null
        /**
         * Filter, which Sponsors to fetch.
         *
         **/
        where?: SponsorsWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Sponsors to fetch.
         *
         **/
        orderBy?: Enumerable<SponsorsOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for searching for Sponsors.
         *
         **/
        cursor?: SponsorsWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Sponsors from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Sponsors.
         *
         **/
        skip?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
         *
         * Filter by unique combinations of Sponsors.
         *
         **/
        distinct?: Enumerable<SponsorsScalarFieldEnum>
    }

    /**
     * Sponsors findFirst
     */
    export interface SponsorsFindFirstArgs extends SponsorsFindFirstArgsBase {
        /**
         * Throw an Error if query returns no results
         * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
         */
        rejectOnNotFound?: RejectOnNotFound
    }

    /**
     * Sponsors findFirstOrThrow
     */
    export type SponsorsFindFirstOrThrowArgs = {
        /**
         * Select specific fields to fetch from the Sponsors
         *
         **/
        select?: SponsorsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: SponsorsInclude | null
        /**
         * Filter, which Sponsors to fetch.
         *
         **/
        where?: SponsorsWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Sponsors to fetch.
         *
         **/
        orderBy?: Enumerable<SponsorsOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for searching for Sponsors.
         *
         **/
        cursor?: SponsorsWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Sponsors from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Sponsors.
         *
         **/
        skip?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
         *
         * Filter by unique combinations of Sponsors.
         *
         **/
        distinct?: Enumerable<SponsorsScalarFieldEnum>
    }

    /**
     * Sponsors findMany
     */
    export type SponsorsFindManyArgs = {
        /**
         * Select specific fields to fetch from the Sponsors
         *
         **/
        select?: SponsorsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: SponsorsInclude | null
        /**
         * Filter, which Sponsors to fetch.
         *
         **/
        where?: SponsorsWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Sponsors to fetch.
         *
         **/
        orderBy?: Enumerable<SponsorsOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for listing Sponsors.
         *
         **/
        cursor?: SponsorsWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Sponsors from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Sponsors.
         *
         **/
        skip?: number
        distinct?: Enumerable<SponsorsScalarFieldEnum>
    }

    /**
     * Sponsors create
     */
    export type SponsorsCreateArgs = {
        /**
         * Select specific fields to fetch from the Sponsors
         *
         **/
        select?: SponsorsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: SponsorsInclude | null
        /**
         * The data needed to create a Sponsors.
         *
         **/
        data: XOR<SponsorsCreateInput, SponsorsUncheckedCreateInput>
    }

    /**
     * Sponsors createMany
     */
    export type SponsorsCreateManyArgs = {
        /**
         * The data used to create many Sponsors.
         *
         **/
        data: Enumerable<SponsorsCreateManyInput>
        skipDuplicates?: boolean
    }

    /**
     * Sponsors update
     */
    export type SponsorsUpdateArgs = {
        /**
         * Select specific fields to fetch from the Sponsors
         *
         **/
        select?: SponsorsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: SponsorsInclude | null
        /**
         * The data needed to update a Sponsors.
         *
         **/
        data: XOR<SponsorsUpdateInput, SponsorsUncheckedUpdateInput>
        /**
         * Choose, which Sponsors to update.
         *
         **/
        where: SponsorsWhereUniqueInput
    }

    /**
     * Sponsors updateMany
     */
    export type SponsorsUpdateManyArgs = {
        /**
         * The data used to update Sponsors.
         *
         **/
        data: XOR<SponsorsUpdateManyMutationInput, SponsorsUncheckedUpdateManyInput>
        /**
         * Filter which Sponsors to update
         *
         **/
        where?: SponsorsWhereInput
    }

    /**
     * Sponsors upsert
     */
    export type SponsorsUpsertArgs = {
        /**
         * Select specific fields to fetch from the Sponsors
         *
         **/
        select?: SponsorsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: SponsorsInclude | null
        /**
         * The filter to search for the Sponsors to update in case it exists.
         *
         **/
        where: SponsorsWhereUniqueInput
        /**
         * In case the Sponsors found by the `where` argument doesn't exist, create a new Sponsors with this data.
         *
         **/
        create: XOR<SponsorsCreateInput, SponsorsUncheckedCreateInput>
        /**
         * In case the Sponsors was found with the provided `where` argument, update it with this data.
         *
         **/
        update: XOR<SponsorsUpdateInput, SponsorsUncheckedUpdateInput>
    }

    /**
     * Sponsors delete
     */
    export type SponsorsDeleteArgs = {
        /**
         * Select specific fields to fetch from the Sponsors
         *
         **/
        select?: SponsorsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: SponsorsInclude | null
        /**
         * Filter which Sponsors to delete.
         *
         **/
        where: SponsorsWhereUniqueInput
    }

    /**
     * Sponsors deleteMany
     */
    export type SponsorsDeleteManyArgs = {
        /**
         * Filter which Sponsors to delete
         *
         **/
        where?: SponsorsWhereInput
    }

    /**
     * Sponsors.income_sponsor
     */
    export type Sponsors$income_sponsorArgs = {
        /**
         * Select specific fields to fetch from the Income_sponsor
         *
         **/
        select?: Income_sponsorSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Income_sponsorInclude | null
        where?: Income_sponsorWhereInput
        orderBy?: Enumerable<Income_sponsorOrderByWithRelationInput>
        cursor?: Income_sponsorWhereUniqueInput
        take?: number
        skip?: number
        distinct?: Enumerable<Income_sponsorScalarFieldEnum>
    }

    /**
     * Sponsors.sponsor_sponsorship
     */
    export type Sponsors$sponsor_sponsorshipArgs = {
        /**
         * Select specific fields to fetch from the Sponsor_sponsorship
         *
         **/
        select?: Sponsor_sponsorshipSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Sponsor_sponsorshipInclude | null
        where?: Sponsor_sponsorshipWhereInput
        orderBy?: Enumerable<Sponsor_sponsorshipOrderByWithRelationInput>
        cursor?: Sponsor_sponsorshipWhereUniqueInput
        take?: number
        skip?: number
        distinct?: Enumerable<Sponsor_sponsorshipScalarFieldEnum>
    }

    /**
     * Sponsors without action
     */
    export type SponsorsArgs = {
        /**
         * Select specific fields to fetch from the Sponsors
         *
         **/
        select?: SponsorsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: SponsorsInclude | null
    }

    /**
     * Model Sponsorships
     */

    export type AggregateSponsorships = {
        _count: SponsorshipsCountAggregateOutputType | null
        _min: SponsorshipsMinAggregateOutputType | null
        _max: SponsorshipsMaxAggregateOutputType | null
    }

    export type SponsorshipsMinAggregateOutputType = {
        id: string | null
        type: sponsorship_type | null
        name: string | null
        tenant_id: string | null
        deleted_at: Date | null
        created_at: Date | null
        updated_at: Date | null
    }

    export type SponsorshipsMaxAggregateOutputType = {
        id: string | null
        type: sponsorship_type | null
        name: string | null
        tenant_id: string | null
        deleted_at: Date | null
        created_at: Date | null
        updated_at: Date | null
    }

    export type SponsorshipsCountAggregateOutputType = {
        id: number
        type: number
        name: number
        tenant_id: number
        deleted_at: number
        created_at: number
        updated_at: number
        _all: number
    }

    export type SponsorshipsMinAggregateInputType = {
        id?: true
        type?: true
        name?: true
        tenant_id?: true
        deleted_at?: true
        created_at?: true
        updated_at?: true
    }

    export type SponsorshipsMaxAggregateInputType = {
        id?: true
        type?: true
        name?: true
        tenant_id?: true
        deleted_at?: true
        created_at?: true
        updated_at?: true
    }

    export type SponsorshipsCountAggregateInputType = {
        id?: true
        type?: true
        name?: true
        tenant_id?: true
        deleted_at?: true
        created_at?: true
        updated_at?: true
        _all?: true
    }

    export type SponsorshipsAggregateArgs = {
        /**
         * Filter which Sponsorships to aggregate.
         *
         **/
        where?: SponsorshipsWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Sponsorships to fetch.
         *
         **/
        orderBy?: Enumerable<SponsorshipsOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the start position
         *
         **/
        cursor?: SponsorshipsWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Sponsorships from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Sponsorships.
         *
         **/
        skip?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Count returned Sponsorships
         **/
        _count?: true | SponsorshipsCountAggregateInputType
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to find the minimum value
         **/
        _min?: SponsorshipsMinAggregateInputType
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to find the maximum value
         **/
        _max?: SponsorshipsMaxAggregateInputType
    }

    export type GetSponsorshipsAggregateType<T extends SponsorshipsAggregateArgs> = {
        [P in keyof T & keyof AggregateSponsorships]: P extends '_count' | 'count'
            ? T[P] extends true
                ? number
                : GetScalarType<T[P], AggregateSponsorships[P]>
            : GetScalarType<T[P], AggregateSponsorships[P]>
    }

    export type SponsorshipsGroupByArgs = {
        where?: SponsorshipsWhereInput
        orderBy?: Enumerable<SponsorshipsOrderByWithAggregationInput>
        by: Array<SponsorshipsScalarFieldEnum>
        having?: SponsorshipsScalarWhereWithAggregatesInput
        take?: number
        skip?: number
        _count?: SponsorshipsCountAggregateInputType | true
        _min?: SponsorshipsMinAggregateInputType
        _max?: SponsorshipsMaxAggregateInputType
    }

    export type SponsorshipsGroupByOutputType = {
        id: string
        type: sponsorship_type
        name: string
        tenant_id: string
        deleted_at: Date | null
        created_at: Date | null
        updated_at: Date | null
        _count: SponsorshipsCountAggregateOutputType | null
        _min: SponsorshipsMinAggregateOutputType | null
        _max: SponsorshipsMaxAggregateOutputType | null
    }

    type GetSponsorshipsGroupByPayload<T extends SponsorshipsGroupByArgs> = PrismaPromise<
        Array<
            PickArray<SponsorshipsGroupByOutputType, T['by']> & {
                [P in keyof T & keyof SponsorshipsGroupByOutputType]: P extends '_count'
                    ? T[P] extends boolean
                        ? number
                        : GetScalarType<T[P], SponsorshipsGroupByOutputType[P]>
                    : GetScalarType<T[P], SponsorshipsGroupByOutputType[P]>
            }
        >
    >

    export type SponsorshipsSelect = {
        id?: boolean
        type?: boolean
        name?: boolean
        tenant_id?: boolean
        deleted_at?: boolean
        created_at?: boolean
        updated_at?: boolean
        tenants?: boolean | TenantsArgs
    }

    export type SponsorshipsInclude = {
        tenants?: boolean | TenantsArgs
    }

    export type SponsorshipsGetPayload<S extends boolean | null | undefined | SponsorshipsArgs> = S extends {
        select: any
        include: any
    }
        ? 'Please either choose `select` or `include`'
        : S extends true
          ? Sponsorships
          : S extends undefined
            ? never
            : S extends { include: any } & (SponsorshipsArgs | SponsorshipsFindManyArgs)
              ? Sponsorships & {
                    [P in TruthyKeys<S['include']>]: P extends 'tenants' ? TenantsGetPayload<S['include'][P]> : never
                }
              : S extends { select: any } & (SponsorshipsArgs | SponsorshipsFindManyArgs)
                ? {
                      [P in TruthyKeys<S['select']>]: P extends 'tenants'
                          ? TenantsGetPayload<S['select'][P]>
                          : P extends keyof Sponsorships
                            ? Sponsorships[P]
                            : never
                  }
                : Sponsorships

    type SponsorshipsCountArgs = Merge<
        Omit<SponsorshipsFindManyArgs, 'select' | 'include'> & {
            select?: SponsorshipsCountAggregateInputType | true
        }
    >

    export interface SponsorshipsDelegate<
        GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined
    > {
        /**
         * Find zero or one Sponsorships that matches the filter.
         * @param {SponsorshipsFindUniqueArgs} args - Arguments to find a Sponsorships
         * @example
         * // Get one Sponsorships
         * const sponsorships = await prisma.sponsorships.findUnique({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findUnique<
            T extends SponsorshipsFindUniqueArgs,
            LocalRejectSettings = T['rejectOnNotFound'] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined
        >(
            args: SelectSubset<T, SponsorshipsFindUniqueArgs>
        ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Sponsorships'> extends True
            ? Prisma__SponsorshipsClient<SponsorshipsGetPayload<T>>
            : Prisma__SponsorshipsClient<SponsorshipsGetPayload<T> | null, null>

        /**
         * Find one Sponsorships that matches the filter or throw an error  with `error.code='P2025'`
         *     if no matches were found.
         * @param {SponsorshipsFindUniqueOrThrowArgs} args - Arguments to find a Sponsorships
         * @example
         * // Get one Sponsorships
         * const sponsorships = await prisma.sponsorships.findUniqueOrThrow({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findUniqueOrThrow<T extends SponsorshipsFindUniqueOrThrowArgs>(
            args?: SelectSubset<T, SponsorshipsFindUniqueOrThrowArgs>
        ): Prisma__SponsorshipsClient<SponsorshipsGetPayload<T>>

        /**
         * Find the first Sponsorships that matches the filter.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {SponsorshipsFindFirstArgs} args - Arguments to find a Sponsorships
         * @example
         * // Get one Sponsorships
         * const sponsorships = await prisma.sponsorships.findFirst({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findFirst<
            T extends SponsorshipsFindFirstArgs,
            LocalRejectSettings = T['rejectOnNotFound'] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined
        >(
            args?: SelectSubset<T, SponsorshipsFindFirstArgs>
        ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Sponsorships'> extends True
            ? Prisma__SponsorshipsClient<SponsorshipsGetPayload<T>>
            : Prisma__SponsorshipsClient<SponsorshipsGetPayload<T> | null, null>

        /**
         * Find the first Sponsorships that matches the filter or
         * throw `NotFoundError` if no matches were found.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {SponsorshipsFindFirstOrThrowArgs} args - Arguments to find a Sponsorships
         * @example
         * // Get one Sponsorships
         * const sponsorships = await prisma.sponsorships.findFirstOrThrow({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findFirstOrThrow<T extends SponsorshipsFindFirstOrThrowArgs>(
            args?: SelectSubset<T, SponsorshipsFindFirstOrThrowArgs>
        ): Prisma__SponsorshipsClient<SponsorshipsGetPayload<T>>

        /**
         * Find zero or more Sponsorships that matches the filter.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {SponsorshipsFindManyArgs=} args - Arguments to filter and select certain fields only.
         * @example
         * // Get all Sponsorships
         * const sponsorships = await prisma.sponsorships.findMany()
         *
         * // Get first 10 Sponsorships
         * const sponsorships = await prisma.sponsorships.findMany({ take: 10 })
         *
         * // Only select the `id`
         * const sponsorshipsWithIdOnly = await prisma.sponsorships.findMany({ select: { id: true } })
         *
         **/
        findMany<T extends SponsorshipsFindManyArgs>(
            args?: SelectSubset<T, SponsorshipsFindManyArgs>
        ): PrismaPromise<Array<SponsorshipsGetPayload<T>>>

        /**
         * Create a Sponsorships.
         * @param {SponsorshipsCreateArgs} args - Arguments to create a Sponsorships.
         * @example
         * // Create one Sponsorships
         * const Sponsorships = await prisma.sponsorships.create({
         *   data: {
         *     // ... data to create a Sponsorships
         *   }
         * })
         *
         **/
        create<T extends SponsorshipsCreateArgs>(
            args: SelectSubset<T, SponsorshipsCreateArgs>
        ): Prisma__SponsorshipsClient<SponsorshipsGetPayload<T>>

        /**
         * Create many Sponsorships.
         *     @param {SponsorshipsCreateManyArgs} args - Arguments to create many Sponsorships.
         *     @example
         *     // Create many Sponsorships
         *     const sponsorships = await prisma.sponsorships.createMany({
         *       data: {
         *         // ... provide data here
         *       }
         *     })
         *
         **/
        createMany<T extends SponsorshipsCreateManyArgs>(
            args?: SelectSubset<T, SponsorshipsCreateManyArgs>
        ): PrismaPromise<BatchPayload>

        /**
         * Delete a Sponsorships.
         * @param {SponsorshipsDeleteArgs} args - Arguments to delete one Sponsorships.
         * @example
         * // Delete one Sponsorships
         * const Sponsorships = await prisma.sponsorships.delete({
         *   where: {
         *     // ... filter to delete one Sponsorships
         *   }
         * })
         *
         **/
        delete<T extends SponsorshipsDeleteArgs>(
            args: SelectSubset<T, SponsorshipsDeleteArgs>
        ): Prisma__SponsorshipsClient<SponsorshipsGetPayload<T>>

        /**
         * Update one Sponsorships.
         * @param {SponsorshipsUpdateArgs} args - Arguments to update one Sponsorships.
         * @example
         * // Update one Sponsorships
         * const sponsorships = await prisma.sponsorships.update({
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: {
         *     // ... provide data here
         *   }
         * })
         *
         **/
        update<T extends SponsorshipsUpdateArgs>(
            args: SelectSubset<T, SponsorshipsUpdateArgs>
        ): Prisma__SponsorshipsClient<SponsorshipsGetPayload<T>>

        /**
         * Delete zero or more Sponsorships.
         * @param {SponsorshipsDeleteManyArgs} args - Arguments to filter Sponsorships to delete.
         * @example
         * // Delete a few Sponsorships
         * const { count } = await prisma.sponsorships.deleteMany({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         *
         **/
        deleteMany<T extends SponsorshipsDeleteManyArgs>(
            args?: SelectSubset<T, SponsorshipsDeleteManyArgs>
        ): PrismaPromise<BatchPayload>

        /**
         * Update zero or more Sponsorships.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {SponsorshipsUpdateManyArgs} args - Arguments to update one or more rows.
         * @example
         * // Update many Sponsorships
         * const sponsorships = await prisma.sponsorships.updateMany({
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: {
         *     // ... provide data here
         *   }
         * })
         *
         **/
        updateMany<T extends SponsorshipsUpdateManyArgs>(
            args: SelectSubset<T, SponsorshipsUpdateManyArgs>
        ): PrismaPromise<BatchPayload>

        /**
         * Create or update one Sponsorships.
         * @param {SponsorshipsUpsertArgs} args - Arguments to update or create a Sponsorships.
         * @example
         * // Update or create a Sponsorships
         * const sponsorships = await prisma.sponsorships.upsert({
         *   create: {
         *     // ... data to create a Sponsorships
         *   },
         *   update: {
         *     // ... in case it already exists, update
         *   },
         *   where: {
         *     // ... the filter for the Sponsorships we want to update
         *   }
         * })
         **/
        upsert<T extends SponsorshipsUpsertArgs>(
            args: SelectSubset<T, SponsorshipsUpsertArgs>
        ): Prisma__SponsorshipsClient<SponsorshipsGetPayload<T>>

        /**
         * Count the number of Sponsorships.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {SponsorshipsCountArgs} args - Arguments to filter Sponsorships to count.
         * @example
         * // Count the number of Sponsorships
         * const count = await prisma.sponsorships.count({
         *   where: {
         *     // ... the filter for the Sponsorships we want to count
         *   }
         * })
         **/
        count<T extends SponsorshipsCountArgs>(
            args?: Subset<T, SponsorshipsCountArgs>
        ): PrismaPromise<
            T extends _Record<'select', any>
                ? T['select'] extends true
                    ? number
                    : GetScalarType<T['select'], SponsorshipsCountAggregateOutputType>
                : number
        >

        /**
         * Allows you to perform aggregations operations on a Sponsorships.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {SponsorshipsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
         * @example
         * // Ordered by age ascending
         * // Where email contains prisma.io
         * // Limited to the 10 users
         * const aggregations = await prisma.user.aggregate({
         *   _avg: {
         *     age: true,
         *   },
         *   where: {
         *     email: {
         *       contains: "prisma.io",
         *     },
         *   },
         *   orderBy: {
         *     age: "asc",
         *   },
         *   take: 10,
         * })
         **/
        aggregate<T extends SponsorshipsAggregateArgs>(
            args: Subset<T, SponsorshipsAggregateArgs>
        ): PrismaPromise<GetSponsorshipsAggregateType<T>>

        /**
         * Group by Sponsorships.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {SponsorshipsGroupByArgs} args - Group by arguments.
         * @example
         * // Group by city, order by createdAt, get count
         * const result = await prisma.user.groupBy({
         *   by: ['city', 'createdAt'],
         *   orderBy: {
         *     createdAt: true
         *   },
         *   _count: {
         *     _all: true
         *   },
         * })
         *
         **/
        groupBy<
            T extends SponsorshipsGroupByArgs,
            HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
            OrderByArg extends True extends HasSelectOrTake
                ? { orderBy: SponsorshipsGroupByArgs['orderBy'] }
                : { orderBy?: SponsorshipsGroupByArgs['orderBy'] },
            OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
            ByFields extends TupleToUnion<T['by']>,
            ByValid extends Has<ByFields, OrderFields>,
            HavingFields extends GetHavingFields<T['having']>,
            HavingValid extends Has<ByFields, HavingFields>,
            ByEmpty extends T['by'] extends never[] ? True : False,
            InputErrors extends ByEmpty extends True
                ? `Error: "by" must not be empty.`
                : HavingValid extends False
                  ? {
                        [P in HavingFields]: P extends ByFields
                            ? never
                            : P extends string
                              ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                              : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`]
                    }[HavingFields]
                  : 'take' extends Keys<T>
                    ? 'orderBy' extends Keys<T>
                        ? ByValid extends True
                            ? {}
                            : {
                                  [P in OrderFields]: P extends ByFields
                                      ? never
                                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                              }[OrderFields]
                        : 'Error: If you provide "take", you also need to provide "orderBy"'
                    : 'skip' extends Keys<T>
                      ? 'orderBy' extends Keys<T>
                          ? ByValid extends True
                              ? {}
                              : {
                                    [P in OrderFields]: P extends ByFields
                                        ? never
                                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                                }[OrderFields]
                          : 'Error: If you provide "skip", you also need to provide "orderBy"'
                      : ByValid extends True
                        ? {}
                        : {
                              [P in OrderFields]: P extends ByFields
                                  ? never
                                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                          }[OrderFields]
        >(
            args: SubsetIntersection<T, SponsorshipsGroupByArgs, OrderByArg> & InputErrors
        ): {} extends InputErrors ? GetSponsorshipsGroupByPayload<T> : PrismaPromise<InputErrors>
    }

    /**
     * The delegate class that acts as a "Promise-like" for Sponsorships.
     * Why is this prefixed with `Prisma__`?
     * Because we want to prevent naming conflicts as mentioned in
     * https://github.com/prisma/prisma-client-js/issues/707
     */
    export class Prisma__SponsorshipsClient<T, Null = never> implements PrismaPromise<T> {
        [prisma]: true
        private readonly _dmmf
        private readonly _fetcher
        private readonly _queryType
        private readonly _rootField
        private readonly _clientMethod
        private readonly _args
        private readonly _dataPath
        private readonly _errorFormat
        private readonly _measurePerformance?
        private _isList
        private _callsite
        private _requestPromise?
        constructor(
            _dmmf: runtime.DMMFClass,
            _fetcher: PrismaClientFetcher,
            _queryType: 'query' | 'mutation',
            _rootField: string,
            _clientMethod: string,
            _args: any,
            _dataPath: string[],
            _errorFormat: ErrorFormat,
            _measurePerformance?: boolean | undefined,
            _isList?: boolean
        )
        readonly [Symbol.toStringTag]: 'PrismaClientPromise'

        tenants<T extends TenantsArgs = {}>(
            args?: Subset<T, TenantsArgs>
        ): Prisma__TenantsClient<TenantsGetPayload<T> | Null>

        private get _document()
        /**
         * Attaches callbacks for the resolution and/or rejection of the Promise.
         * @param onfulfilled The callback to execute when the Promise is resolved.
         * @param onrejected The callback to execute when the Promise is rejected.
         * @returns A Promise for the completion of which ever callback is executed.
         */
        then<TResult1 = T, TResult2 = never>(
            onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
            onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
        ): Promise<TResult1 | TResult2>
        /**
         * Attaches a callback for only the rejection of the Promise.
         * @param onrejected The callback to execute when the Promise is rejected.
         * @returns A Promise for the completion of the callback.
         */
        catch<TResult = never>(
            onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
        ): Promise<T | TResult>
        /**
         * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
         * resolved value cannot be modified from the callback.
         * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
         * @returns A Promise for the completion of the callback.
         */
        finally(onfinally?: (() => void) | undefined | null): Promise<T>
    }

    // Custom InputTypes

    /**
     * Sponsorships base type for findUnique actions
     */
    export type SponsorshipsFindUniqueArgsBase = {
        /**
         * Select specific fields to fetch from the Sponsorships
         *
         **/
        select?: SponsorshipsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: SponsorshipsInclude | null
        /**
         * Filter, which Sponsorships to fetch.
         *
         **/
        where: SponsorshipsWhereUniqueInput
    }

    /**
     * Sponsorships findUnique
     */
    export interface SponsorshipsFindUniqueArgs extends SponsorshipsFindUniqueArgsBase {
        /**
         * Throw an Error if query returns no results
         * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
         */
        rejectOnNotFound?: RejectOnNotFound
    }

    /**
     * Sponsorships findUniqueOrThrow
     */
    export type SponsorshipsFindUniqueOrThrowArgs = {
        /**
         * Select specific fields to fetch from the Sponsorships
         *
         **/
        select?: SponsorshipsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: SponsorshipsInclude | null
        /**
         * Filter, which Sponsorships to fetch.
         *
         **/
        where: SponsorshipsWhereUniqueInput
    }

    /**
     * Sponsorships base type for findFirst actions
     */
    export type SponsorshipsFindFirstArgsBase = {
        /**
         * Select specific fields to fetch from the Sponsorships
         *
         **/
        select?: SponsorshipsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: SponsorshipsInclude | null
        /**
         * Filter, which Sponsorships to fetch.
         *
         **/
        where?: SponsorshipsWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Sponsorships to fetch.
         *
         **/
        orderBy?: Enumerable<SponsorshipsOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for searching for Sponsorships.
         *
         **/
        cursor?: SponsorshipsWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Sponsorships from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Sponsorships.
         *
         **/
        skip?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
         *
         * Filter by unique combinations of Sponsorships.
         *
         **/
        distinct?: Enumerable<SponsorshipsScalarFieldEnum>
    }

    /**
     * Sponsorships findFirst
     */
    export interface SponsorshipsFindFirstArgs extends SponsorshipsFindFirstArgsBase {
        /**
         * Throw an Error if query returns no results
         * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
         */
        rejectOnNotFound?: RejectOnNotFound
    }

    /**
     * Sponsorships findFirstOrThrow
     */
    export type SponsorshipsFindFirstOrThrowArgs = {
        /**
         * Select specific fields to fetch from the Sponsorships
         *
         **/
        select?: SponsorshipsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: SponsorshipsInclude | null
        /**
         * Filter, which Sponsorships to fetch.
         *
         **/
        where?: SponsorshipsWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Sponsorships to fetch.
         *
         **/
        orderBy?: Enumerable<SponsorshipsOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for searching for Sponsorships.
         *
         **/
        cursor?: SponsorshipsWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Sponsorships from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Sponsorships.
         *
         **/
        skip?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
         *
         * Filter by unique combinations of Sponsorships.
         *
         **/
        distinct?: Enumerable<SponsorshipsScalarFieldEnum>
    }

    /**
     * Sponsorships findMany
     */
    export type SponsorshipsFindManyArgs = {
        /**
         * Select specific fields to fetch from the Sponsorships
         *
         **/
        select?: SponsorshipsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: SponsorshipsInclude | null
        /**
         * Filter, which Sponsorships to fetch.
         *
         **/
        where?: SponsorshipsWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Sponsorships to fetch.
         *
         **/
        orderBy?: Enumerable<SponsorshipsOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for listing Sponsorships.
         *
         **/
        cursor?: SponsorshipsWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Sponsorships from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Sponsorships.
         *
         **/
        skip?: number
        distinct?: Enumerable<SponsorshipsScalarFieldEnum>
    }

    /**
     * Sponsorships create
     */
    export type SponsorshipsCreateArgs = {
        /**
         * Select specific fields to fetch from the Sponsorships
         *
         **/
        select?: SponsorshipsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: SponsorshipsInclude | null
        /**
         * The data needed to create a Sponsorships.
         *
         **/
        data: XOR<SponsorshipsCreateInput, SponsorshipsUncheckedCreateInput>
    }

    /**
     * Sponsorships createMany
     */
    export type SponsorshipsCreateManyArgs = {
        /**
         * The data used to create many Sponsorships.
         *
         **/
        data: Enumerable<SponsorshipsCreateManyInput>
        skipDuplicates?: boolean
    }

    /**
     * Sponsorships update
     */
    export type SponsorshipsUpdateArgs = {
        /**
         * Select specific fields to fetch from the Sponsorships
         *
         **/
        select?: SponsorshipsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: SponsorshipsInclude | null
        /**
         * The data needed to update a Sponsorships.
         *
         **/
        data: XOR<SponsorshipsUpdateInput, SponsorshipsUncheckedUpdateInput>
        /**
         * Choose, which Sponsorships to update.
         *
         **/
        where: SponsorshipsWhereUniqueInput
    }

    /**
     * Sponsorships updateMany
     */
    export type SponsorshipsUpdateManyArgs = {
        /**
         * The data used to update Sponsorships.
         *
         **/
        data: XOR<SponsorshipsUpdateManyMutationInput, SponsorshipsUncheckedUpdateManyInput>
        /**
         * Filter which Sponsorships to update
         *
         **/
        where?: SponsorshipsWhereInput
    }

    /**
     * Sponsorships upsert
     */
    export type SponsorshipsUpsertArgs = {
        /**
         * Select specific fields to fetch from the Sponsorships
         *
         **/
        select?: SponsorshipsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: SponsorshipsInclude | null
        /**
         * The filter to search for the Sponsorships to update in case it exists.
         *
         **/
        where: SponsorshipsWhereUniqueInput
        /**
         * In case the Sponsorships found by the `where` argument doesn't exist, create a new Sponsorships with this data.
         *
         **/
        create: XOR<SponsorshipsCreateInput, SponsorshipsUncheckedCreateInput>
        /**
         * In case the Sponsorships was found with the provided `where` argument, update it with this data.
         *
         **/
        update: XOR<SponsorshipsUpdateInput, SponsorshipsUncheckedUpdateInput>
    }

    /**
     * Sponsorships delete
     */
    export type SponsorshipsDeleteArgs = {
        /**
         * Select specific fields to fetch from the Sponsorships
         *
         **/
        select?: SponsorshipsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: SponsorshipsInclude | null
        /**
         * Filter which Sponsorships to delete.
         *
         **/
        where: SponsorshipsWhereUniqueInput
    }

    /**
     * Sponsorships deleteMany
     */
    export type SponsorshipsDeleteManyArgs = {
        /**
         * Filter which Sponsorships to delete
         *
         **/
        where?: SponsorshipsWhereInput
    }

    /**
     * Sponsorships without action
     */
    export type SponsorshipsArgs = {
        /**
         * Select specific fields to fetch from the Sponsorships
         *
         **/
        select?: SponsorshipsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: SponsorshipsInclude | null
    }

    /**
     * Model Spouses
     */

    export type AggregateSpouses = {
        _count: SpousesCountAggregateOutputType | null
        _avg: SpousesAvgAggregateOutputType | null
        _sum: SpousesSumAggregateOutputType | null
        _min: SpousesMinAggregateOutputType | null
        _max: SpousesMaxAggregateOutputType | null
    }

    export type SpousesAvgAggregateOutputType = {
        income: number | null
    }

    export type SpousesSumAggregateOutputType = {
        income: number | null
    }

    export type SpousesMinAggregateOutputType = {
        id: string | null
        first_name: string | null
        last_name: string | null
        birth_date: Date | null
        death_date: Date | null
        function: string | null
        income: number | null
        family_id: string | null
        tenant_id: string | null
        created_at: Date | null
        updated_at: Date | null
    }

    export type SpousesMaxAggregateOutputType = {
        id: string | null
        first_name: string | null
        last_name: string | null
        birth_date: Date | null
        death_date: Date | null
        function: string | null
        income: number | null
        family_id: string | null
        tenant_id: string | null
        created_at: Date | null
        updated_at: Date | null
    }

    export type SpousesCountAggregateOutputType = {
        id: number
        first_name: number
        last_name: number
        birth_date: number
        death_date: number
        function: number
        income: number
        family_id: number
        tenant_id: number
        created_at: number
        updated_at: number
        _all: number
    }

    export type SpousesAvgAggregateInputType = {
        income?: true
    }

    export type SpousesSumAggregateInputType = {
        income?: true
    }

    export type SpousesMinAggregateInputType = {
        id?: true
        first_name?: true
        last_name?: true
        birth_date?: true
        death_date?: true
        function?: true
        income?: true
        family_id?: true
        tenant_id?: true
        created_at?: true
        updated_at?: true
    }

    export type SpousesMaxAggregateInputType = {
        id?: true
        first_name?: true
        last_name?: true
        birth_date?: true
        death_date?: true
        function?: true
        income?: true
        family_id?: true
        tenant_id?: true
        created_at?: true
        updated_at?: true
    }

    export type SpousesCountAggregateInputType = {
        id?: true
        first_name?: true
        last_name?: true
        birth_date?: true
        death_date?: true
        function?: true
        income?: true
        family_id?: true
        tenant_id?: true
        created_at?: true
        updated_at?: true
        _all?: true
    }

    export type SpousesAggregateArgs = {
        /**
         * Filter which Spouses to aggregate.
         *
         **/
        where?: SpousesWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Spouses to fetch.
         *
         **/
        orderBy?: Enumerable<SpousesOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the start position
         *
         **/
        cursor?: SpousesWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Spouses from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Spouses.
         *
         **/
        skip?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Count returned Spouses
         **/
        _count?: true | SpousesCountAggregateInputType
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to average
         **/
        _avg?: SpousesAvgAggregateInputType
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to sum
         **/
        _sum?: SpousesSumAggregateInputType
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to find the minimum value
         **/
        _min?: SpousesMinAggregateInputType
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to find the maximum value
         **/
        _max?: SpousesMaxAggregateInputType
    }

    export type GetSpousesAggregateType<T extends SpousesAggregateArgs> = {
        [P in keyof T & keyof AggregateSpouses]: P extends '_count' | 'count'
            ? T[P] extends true
                ? number
                : GetScalarType<T[P], AggregateSpouses[P]>
            : GetScalarType<T[P], AggregateSpouses[P]>
    }

    export type SpousesGroupByArgs = {
        where?: SpousesWhereInput
        orderBy?: Enumerable<SpousesOrderByWithAggregationInput>
        by: Array<SpousesScalarFieldEnum>
        having?: SpousesScalarWhereWithAggregatesInput
        take?: number
        skip?: number
        _count?: SpousesCountAggregateInputType | true
        _avg?: SpousesAvgAggregateInputType
        _sum?: SpousesSumAggregateInputType
        _min?: SpousesMinAggregateInputType
        _max?: SpousesMaxAggregateInputType
    }

    export type SpousesGroupByOutputType = {
        id: string
        first_name: string
        last_name: string
        birth_date: Date
        death_date: Date
        function: string
        income: number
        family_id: string
        tenant_id: string
        created_at: Date | null
        updated_at: Date | null
        _count: SpousesCountAggregateOutputType | null
        _avg: SpousesAvgAggregateOutputType | null
        _sum: SpousesSumAggregateOutputType | null
        _min: SpousesMinAggregateOutputType | null
        _max: SpousesMaxAggregateOutputType | null
    }

    type GetSpousesGroupByPayload<T extends SpousesGroupByArgs> = PrismaPromise<
        Array<
            PickArray<SpousesGroupByOutputType, T['by']> & {
                [P in keyof T & keyof SpousesGroupByOutputType]: P extends '_count'
                    ? T[P] extends boolean
                        ? number
                        : GetScalarType<T[P], SpousesGroupByOutputType[P]>
                    : GetScalarType<T[P], SpousesGroupByOutputType[P]>
            }
        >
    >

    export type SpousesSelect = {
        id?: boolean
        first_name?: boolean
        last_name?: boolean
        birth_date?: boolean
        death_date?: boolean
        function?: boolean
        income?: boolean
        family_id?: boolean
        tenant_id?: boolean
        created_at?: boolean
        updated_at?: boolean
        families?: boolean | FamiliesArgs
        tenants?: boolean | TenantsArgs
    }

    export type SpousesInclude = {
        families?: boolean | FamiliesArgs
        tenants?: boolean | TenantsArgs
    }

    export type SpousesGetPayload<S extends boolean | null | undefined | SpousesArgs> = S extends {
        select: any
        include: any
    }
        ? 'Please either choose `select` or `include`'
        : S extends true
          ? Spouses
          : S extends undefined
            ? never
            : S extends { include: any } & (SpousesArgs | SpousesFindManyArgs)
              ? Spouses & {
                    [P in TruthyKeys<S['include']>]: P extends 'families'
                        ? FamiliesGetPayload<S['include'][P]>
                        : P extends 'tenants'
                          ? TenantsGetPayload<S['include'][P]>
                          : never
                }
              : S extends { select: any } & (SpousesArgs | SpousesFindManyArgs)
                ? {
                      [P in TruthyKeys<S['select']>]: P extends 'families'
                          ? FamiliesGetPayload<S['select'][P]>
                          : P extends 'tenants'
                            ? TenantsGetPayload<S['select'][P]>
                            : P extends keyof Spouses
                              ? Spouses[P]
                              : never
                  }
                : Spouses

    type SpousesCountArgs = Merge<
        Omit<SpousesFindManyArgs, 'select' | 'include'> & {
            select?: SpousesCountAggregateInputType | true
        }
    >

    export interface SpousesDelegate<
        GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined
    > {
        /**
         * Find zero or one Spouses that matches the filter.
         * @param {SpousesFindUniqueArgs} args - Arguments to find a Spouses
         * @example
         * // Get one Spouses
         * const spouses = await prisma.spouses.findUnique({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findUnique<
            T extends SpousesFindUniqueArgs,
            LocalRejectSettings = T['rejectOnNotFound'] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined
        >(
            args: SelectSubset<T, SpousesFindUniqueArgs>
        ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Spouses'> extends True
            ? Prisma__SpousesClient<SpousesGetPayload<T>>
            : Prisma__SpousesClient<SpousesGetPayload<T> | null, null>

        /**
         * Find one Spouses that matches the filter or throw an error  with `error.code='P2025'`
         *     if no matches were found.
         * @param {SpousesFindUniqueOrThrowArgs} args - Arguments to find a Spouses
         * @example
         * // Get one Spouses
         * const spouses = await prisma.spouses.findUniqueOrThrow({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findUniqueOrThrow<T extends SpousesFindUniqueOrThrowArgs>(
            args?: SelectSubset<T, SpousesFindUniqueOrThrowArgs>
        ): Prisma__SpousesClient<SpousesGetPayload<T>>

        /**
         * Find the first Spouses that matches the filter.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {SpousesFindFirstArgs} args - Arguments to find a Spouses
         * @example
         * // Get one Spouses
         * const spouses = await prisma.spouses.findFirst({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findFirst<
            T extends SpousesFindFirstArgs,
            LocalRejectSettings = T['rejectOnNotFound'] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined
        >(
            args?: SelectSubset<T, SpousesFindFirstArgs>
        ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Spouses'> extends True
            ? Prisma__SpousesClient<SpousesGetPayload<T>>
            : Prisma__SpousesClient<SpousesGetPayload<T> | null, null>

        /**
         * Find the first Spouses that matches the filter or
         * throw `NotFoundError` if no matches were found.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {SpousesFindFirstOrThrowArgs} args - Arguments to find a Spouses
         * @example
         * // Get one Spouses
         * const spouses = await prisma.spouses.findFirstOrThrow({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findFirstOrThrow<T extends SpousesFindFirstOrThrowArgs>(
            args?: SelectSubset<T, SpousesFindFirstOrThrowArgs>
        ): Prisma__SpousesClient<SpousesGetPayload<T>>

        /**
         * Find zero or more Spouses that matches the filter.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {SpousesFindManyArgs=} args - Arguments to filter and select certain fields only.
         * @example
         * // Get all Spouses
         * const spouses = await prisma.spouses.findMany()
         *
         * // Get first 10 Spouses
         * const spouses = await prisma.spouses.findMany({ take: 10 })
         *
         * // Only select the `id`
         * const spousesWithIdOnly = await prisma.spouses.findMany({ select: { id: true } })
         *
         **/
        findMany<T extends SpousesFindManyArgs>(
            args?: SelectSubset<T, SpousesFindManyArgs>
        ): PrismaPromise<Array<SpousesGetPayload<T>>>

        /**
         * Create a Spouses.
         * @param {SpousesCreateArgs} args - Arguments to create a Spouses.
         * @example
         * // Create one Spouses
         * const Spouses = await prisma.spouses.create({
         *   data: {
         *     // ... data to create a Spouses
         *   }
         * })
         *
         **/
        create<T extends SpousesCreateArgs>(
            args: SelectSubset<T, SpousesCreateArgs>
        ): Prisma__SpousesClient<SpousesGetPayload<T>>

        /**
         * Create many Spouses.
         *     @param {SpousesCreateManyArgs} args - Arguments to create many Spouses.
         *     @example
         *     // Create many Spouses
         *     const spouses = await prisma.spouses.createMany({
         *       data: {
         *         // ... provide data here
         *       }
         *     })
         *
         **/
        createMany<T extends SpousesCreateManyArgs>(
            args?: SelectSubset<T, SpousesCreateManyArgs>
        ): PrismaPromise<BatchPayload>

        /**
         * Delete a Spouses.
         * @param {SpousesDeleteArgs} args - Arguments to delete one Spouses.
         * @example
         * // Delete one Spouses
         * const Spouses = await prisma.spouses.delete({
         *   where: {
         *     // ... filter to delete one Spouses
         *   }
         * })
         *
         **/
        delete<T extends SpousesDeleteArgs>(
            args: SelectSubset<T, SpousesDeleteArgs>
        ): Prisma__SpousesClient<SpousesGetPayload<T>>

        /**
         * Update one Spouses.
         * @param {SpousesUpdateArgs} args - Arguments to update one Spouses.
         * @example
         * // Update one Spouses
         * const spouses = await prisma.spouses.update({
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: {
         *     // ... provide data here
         *   }
         * })
         *
         **/
        update<T extends SpousesUpdateArgs>(
            args: SelectSubset<T, SpousesUpdateArgs>
        ): Prisma__SpousesClient<SpousesGetPayload<T>>

        /**
         * Delete zero or more Spouses.
         * @param {SpousesDeleteManyArgs} args - Arguments to filter Spouses to delete.
         * @example
         * // Delete a few Spouses
         * const { count } = await prisma.spouses.deleteMany({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         *
         **/
        deleteMany<T extends SpousesDeleteManyArgs>(
            args?: SelectSubset<T, SpousesDeleteManyArgs>
        ): PrismaPromise<BatchPayload>

        /**
         * Update zero or more Spouses.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {SpousesUpdateManyArgs} args - Arguments to update one or more rows.
         * @example
         * // Update many Spouses
         * const spouses = await prisma.spouses.updateMany({
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: {
         *     // ... provide data here
         *   }
         * })
         *
         **/
        updateMany<T extends SpousesUpdateManyArgs>(
            args: SelectSubset<T, SpousesUpdateManyArgs>
        ): PrismaPromise<BatchPayload>

        /**
         * Create or update one Spouses.
         * @param {SpousesUpsertArgs} args - Arguments to update or create a Spouses.
         * @example
         * // Update or create a Spouses
         * const spouses = await prisma.spouses.upsert({
         *   create: {
         *     // ... data to create a Spouses
         *   },
         *   update: {
         *     // ... in case it already exists, update
         *   },
         *   where: {
         *     // ... the filter for the Spouses we want to update
         *   }
         * })
         **/
        upsert<T extends SpousesUpsertArgs>(
            args: SelectSubset<T, SpousesUpsertArgs>
        ): Prisma__SpousesClient<SpousesGetPayload<T>>

        /**
         * Count the number of Spouses.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {SpousesCountArgs} args - Arguments to filter Spouses to count.
         * @example
         * // Count the number of Spouses
         * const count = await prisma.spouses.count({
         *   where: {
         *     // ... the filter for the Spouses we want to count
         *   }
         * })
         **/
        count<T extends SpousesCountArgs>(
            args?: Subset<T, SpousesCountArgs>
        ): PrismaPromise<
            T extends _Record<'select', any>
                ? T['select'] extends true
                    ? number
                    : GetScalarType<T['select'], SpousesCountAggregateOutputType>
                : number
        >

        /**
         * Allows you to perform aggregations operations on a Spouses.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {SpousesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
         * @example
         * // Ordered by age ascending
         * // Where email contains prisma.io
         * // Limited to the 10 users
         * const aggregations = await prisma.user.aggregate({
         *   _avg: {
         *     age: true,
         *   },
         *   where: {
         *     email: {
         *       contains: "prisma.io",
         *     },
         *   },
         *   orderBy: {
         *     age: "asc",
         *   },
         *   take: 10,
         * })
         **/
        aggregate<T extends SpousesAggregateArgs>(
            args: Subset<T, SpousesAggregateArgs>
        ): PrismaPromise<GetSpousesAggregateType<T>>

        /**
         * Group by Spouses.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {SpousesGroupByArgs} args - Group by arguments.
         * @example
         * // Group by city, order by createdAt, get count
         * const result = await prisma.user.groupBy({
         *   by: ['city', 'createdAt'],
         *   orderBy: {
         *     createdAt: true
         *   },
         *   _count: {
         *     _all: true
         *   },
         * })
         *
         **/
        groupBy<
            T extends SpousesGroupByArgs,
            HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
            OrderByArg extends True extends HasSelectOrTake
                ? { orderBy: SpousesGroupByArgs['orderBy'] }
                : { orderBy?: SpousesGroupByArgs['orderBy'] },
            OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
            ByFields extends TupleToUnion<T['by']>,
            ByValid extends Has<ByFields, OrderFields>,
            HavingFields extends GetHavingFields<T['having']>,
            HavingValid extends Has<ByFields, HavingFields>,
            ByEmpty extends T['by'] extends never[] ? True : False,
            InputErrors extends ByEmpty extends True
                ? `Error: "by" must not be empty.`
                : HavingValid extends False
                  ? {
                        [P in HavingFields]: P extends ByFields
                            ? never
                            : P extends string
                              ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                              : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`]
                    }[HavingFields]
                  : 'take' extends Keys<T>
                    ? 'orderBy' extends Keys<T>
                        ? ByValid extends True
                            ? {}
                            : {
                                  [P in OrderFields]: P extends ByFields
                                      ? never
                                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                              }[OrderFields]
                        : 'Error: If you provide "take", you also need to provide "orderBy"'
                    : 'skip' extends Keys<T>
                      ? 'orderBy' extends Keys<T>
                          ? ByValid extends True
                              ? {}
                              : {
                                    [P in OrderFields]: P extends ByFields
                                        ? never
                                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                                }[OrderFields]
                          : 'Error: If you provide "skip", you also need to provide "orderBy"'
                      : ByValid extends True
                        ? {}
                        : {
                              [P in OrderFields]: P extends ByFields
                                  ? never
                                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                          }[OrderFields]
        >(
            args: SubsetIntersection<T, SpousesGroupByArgs, OrderByArg> & InputErrors
        ): {} extends InputErrors ? GetSpousesGroupByPayload<T> : PrismaPromise<InputErrors>
    }

    /**
     * The delegate class that acts as a "Promise-like" for Spouses.
     * Why is this prefixed with `Prisma__`?
     * Because we want to prevent naming conflicts as mentioned in
     * https://github.com/prisma/prisma-client-js/issues/707
     */
    export class Prisma__SpousesClient<T, Null = never> implements PrismaPromise<T> {
        [prisma]: true
        private readonly _dmmf
        private readonly _fetcher
        private readonly _queryType
        private readonly _rootField
        private readonly _clientMethod
        private readonly _args
        private readonly _dataPath
        private readonly _errorFormat
        private readonly _measurePerformance?
        private _isList
        private _callsite
        private _requestPromise?
        constructor(
            _dmmf: runtime.DMMFClass,
            _fetcher: PrismaClientFetcher,
            _queryType: 'query' | 'mutation',
            _rootField: string,
            _clientMethod: string,
            _args: any,
            _dataPath: string[],
            _errorFormat: ErrorFormat,
            _measurePerformance?: boolean | undefined,
            _isList?: boolean
        )
        readonly [Symbol.toStringTag]: 'PrismaClientPromise'

        families<T extends FamiliesArgs = {}>(
            args?: Subset<T, FamiliesArgs>
        ): Prisma__FamiliesClient<FamiliesGetPayload<T> | Null>

        tenants<T extends TenantsArgs = {}>(
            args?: Subset<T, TenantsArgs>
        ): Prisma__TenantsClient<TenantsGetPayload<T> | Null>

        private get _document()
        /**
         * Attaches callbacks for the resolution and/or rejection of the Promise.
         * @param onfulfilled The callback to execute when the Promise is resolved.
         * @param onrejected The callback to execute when the Promise is rejected.
         * @returns A Promise for the completion of which ever callback is executed.
         */
        then<TResult1 = T, TResult2 = never>(
            onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
            onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
        ): Promise<TResult1 | TResult2>
        /**
         * Attaches a callback for only the rejection of the Promise.
         * @param onrejected The callback to execute when the Promise is rejected.
         * @returns A Promise for the completion of the callback.
         */
        catch<TResult = never>(
            onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
        ): Promise<T | TResult>
        /**
         * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
         * resolved value cannot be modified from the callback.
         * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
         * @returns A Promise for the completion of the callback.
         */
        finally(onfinally?: (() => void) | undefined | null): Promise<T>
    }

    // Custom InputTypes

    /**
     * Spouses base type for findUnique actions
     */
    export type SpousesFindUniqueArgsBase = {
        /**
         * Select specific fields to fetch from the Spouses
         *
         **/
        select?: SpousesSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: SpousesInclude | null
        /**
         * Filter, which Spouses to fetch.
         *
         **/
        where: SpousesWhereUniqueInput
    }

    /**
     * Spouses findUnique
     */
    export interface SpousesFindUniqueArgs extends SpousesFindUniqueArgsBase {
        /**
         * Throw an Error if query returns no results
         * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
         */
        rejectOnNotFound?: RejectOnNotFound
    }

    /**
     * Spouses findUniqueOrThrow
     */
    export type SpousesFindUniqueOrThrowArgs = {
        /**
         * Select specific fields to fetch from the Spouses
         *
         **/
        select?: SpousesSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: SpousesInclude | null
        /**
         * Filter, which Spouses to fetch.
         *
         **/
        where: SpousesWhereUniqueInput
    }

    /**
     * Spouses base type for findFirst actions
     */
    export type SpousesFindFirstArgsBase = {
        /**
         * Select specific fields to fetch from the Spouses
         *
         **/
        select?: SpousesSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: SpousesInclude | null
        /**
         * Filter, which Spouses to fetch.
         *
         **/
        where?: SpousesWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Spouses to fetch.
         *
         **/
        orderBy?: Enumerable<SpousesOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for searching for Spouses.
         *
         **/
        cursor?: SpousesWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Spouses from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Spouses.
         *
         **/
        skip?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
         *
         * Filter by unique combinations of Spouses.
         *
         **/
        distinct?: Enumerable<SpousesScalarFieldEnum>
    }

    /**
     * Spouses findFirst
     */
    export interface SpousesFindFirstArgs extends SpousesFindFirstArgsBase {
        /**
         * Throw an Error if query returns no results
         * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
         */
        rejectOnNotFound?: RejectOnNotFound
    }

    /**
     * Spouses findFirstOrThrow
     */
    export type SpousesFindFirstOrThrowArgs = {
        /**
         * Select specific fields to fetch from the Spouses
         *
         **/
        select?: SpousesSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: SpousesInclude | null
        /**
         * Filter, which Spouses to fetch.
         *
         **/
        where?: SpousesWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Spouses to fetch.
         *
         **/
        orderBy?: Enumerable<SpousesOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for searching for Spouses.
         *
         **/
        cursor?: SpousesWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Spouses from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Spouses.
         *
         **/
        skip?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
         *
         * Filter by unique combinations of Spouses.
         *
         **/
        distinct?: Enumerable<SpousesScalarFieldEnum>
    }

    /**
     * Spouses findMany
     */
    export type SpousesFindManyArgs = {
        /**
         * Select specific fields to fetch from the Spouses
         *
         **/
        select?: SpousesSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: SpousesInclude | null
        /**
         * Filter, which Spouses to fetch.
         *
         **/
        where?: SpousesWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Spouses to fetch.
         *
         **/
        orderBy?: Enumerable<SpousesOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for listing Spouses.
         *
         **/
        cursor?: SpousesWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Spouses from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Spouses.
         *
         **/
        skip?: number
        distinct?: Enumerable<SpousesScalarFieldEnum>
    }

    /**
     * Spouses create
     */
    export type SpousesCreateArgs = {
        /**
         * Select specific fields to fetch from the Spouses
         *
         **/
        select?: SpousesSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: SpousesInclude | null
        /**
         * The data needed to create a Spouses.
         *
         **/
        data: XOR<SpousesCreateInput, SpousesUncheckedCreateInput>
    }

    /**
     * Spouses createMany
     */
    export type SpousesCreateManyArgs = {
        /**
         * The data used to create many Spouses.
         *
         **/
        data: Enumerable<SpousesCreateManyInput>
        skipDuplicates?: boolean
    }

    /**
     * Spouses update
     */
    export type SpousesUpdateArgs = {
        /**
         * Select specific fields to fetch from the Spouses
         *
         **/
        select?: SpousesSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: SpousesInclude | null
        /**
         * The data needed to update a Spouses.
         *
         **/
        data: XOR<SpousesUpdateInput, SpousesUncheckedUpdateInput>
        /**
         * Choose, which Spouses to update.
         *
         **/
        where: SpousesWhereUniqueInput
    }

    /**
     * Spouses updateMany
     */
    export type SpousesUpdateManyArgs = {
        /**
         * The data used to update Spouses.
         *
         **/
        data: XOR<SpousesUpdateManyMutationInput, SpousesUncheckedUpdateManyInput>
        /**
         * Filter which Spouses to update
         *
         **/
        where?: SpousesWhereInput
    }

    /**
     * Spouses upsert
     */
    export type SpousesUpsertArgs = {
        /**
         * Select specific fields to fetch from the Spouses
         *
         **/
        select?: SpousesSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: SpousesInclude | null
        /**
         * The filter to search for the Spouses to update in case it exists.
         *
         **/
        where: SpousesWhereUniqueInput
        /**
         * In case the Spouses found by the `where` argument doesn't exist, create a new Spouses with this data.
         *
         **/
        create: XOR<SpousesCreateInput, SpousesUncheckedCreateInput>
        /**
         * In case the Spouses was found with the provided `where` argument, update it with this data.
         *
         **/
        update: XOR<SpousesUpdateInput, SpousesUncheckedUpdateInput>
    }

    /**
     * Spouses delete
     */
    export type SpousesDeleteArgs = {
        /**
         * Select specific fields to fetch from the Spouses
         *
         **/
        select?: SpousesSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: SpousesInclude | null
        /**
         * Filter which Spouses to delete.
         *
         **/
        where: SpousesWhereUniqueInput
    }

    /**
     * Spouses deleteMany
     */
    export type SpousesDeleteManyArgs = {
        /**
         * Filter which Spouses to delete
         *
         **/
        where?: SpousesWhereInput
    }

    /**
     * Spouses without action
     */
    export type SpousesArgs = {
        /**
         * Select specific fields to fetch from the Spouses
         *
         **/
        select?: SpousesSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: SpousesInclude | null
    }

    /**
     * Model Tenants
     */

    export type AggregateTenants = {
        _count: TenantsCountAggregateOutputType | null
        _min: TenantsMinAggregateOutputType | null
        _max: TenantsMaxAggregateOutputType | null
    }

    export type TenantsMinAggregateOutputType = {
        id: string | null
        created_at: Date | null
        updated_at: Date | null
    }

    export type TenantsMaxAggregateOutputType = {
        id: string | null
        created_at: Date | null
        updated_at: Date | null
    }

    export type TenantsCountAggregateOutputType = {
        id: number
        data: number
        created_at: number
        updated_at: number
        _all: number
    }

    export type TenantsMinAggregateInputType = {
        id?: true
        created_at?: true
        updated_at?: true
    }

    export type TenantsMaxAggregateInputType = {
        id?: true
        created_at?: true
        updated_at?: true
    }

    export type TenantsCountAggregateInputType = {
        id?: true
        data?: true
        created_at?: true
        updated_at?: true
        _all?: true
    }

    export type TenantsAggregateArgs = {
        /**
         * Filter which Tenants to aggregate.
         *
         **/
        where?: TenantsWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Tenants to fetch.
         *
         **/
        orderBy?: Enumerable<TenantsOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the start position
         *
         **/
        cursor?: TenantsWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Tenants from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Tenants.
         *
         **/
        skip?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Count returned Tenants
         **/
        _count?: true | TenantsCountAggregateInputType
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to find the minimum value
         **/
        _min?: TenantsMinAggregateInputType
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to find the maximum value
         **/
        _max?: TenantsMaxAggregateInputType
    }

    export type GetTenantsAggregateType<T extends TenantsAggregateArgs> = {
        [P in keyof T & keyof AggregateTenants]: P extends '_count' | 'count'
            ? T[P] extends true
                ? number
                : GetScalarType<T[P], AggregateTenants[P]>
            : GetScalarType<T[P], AggregateTenants[P]>
    }

    export type TenantsGroupByArgs = {
        where?: TenantsWhereInput
        orderBy?: Enumerable<TenantsOrderByWithAggregationInput>
        by: Array<TenantsScalarFieldEnum>
        having?: TenantsScalarWhereWithAggregatesInput
        take?: number
        skip?: number
        _count?: TenantsCountAggregateInputType | true
        _min?: TenantsMinAggregateInputType
        _max?: TenantsMaxAggregateInputType
    }

    export type TenantsGroupByOutputType = {
        id: string
        data: JsonValue | null
        created_at: Date | null
        updated_at: Date | null
        _count: TenantsCountAggregateOutputType | null
        _min: TenantsMinAggregateOutputType | null
        _max: TenantsMaxAggregateOutputType | null
    }

    type GetTenantsGroupByPayload<T extends TenantsGroupByArgs> = PrismaPromise<
        Array<
            PickArray<TenantsGroupByOutputType, T['by']> & {
                [P in keyof T & keyof TenantsGroupByOutputType]: P extends '_count'
                    ? T[P] extends boolean
                        ? number
                        : GetScalarType<T[P], TenantsGroupByOutputType[P]>
                    : GetScalarType<T[P], TenantsGroupByOutputType[P]>
            }
        >
    >

    export type TenantsSelect = {
        id?: boolean
        data?: boolean
        created_at?: boolean
        updated_at?: boolean
        benefactors?: boolean | Tenants$benefactorsArgs
        domains?: boolean | Tenants$domainsArgs
        families?: boolean | Tenants$familiesArgs
        family_sponsorship?: boolean | Tenants$family_sponsorshipArgs
        income_sponsor?: boolean | Tenants$income_sponsorArgs
        orphan_sponsorship?: boolean | Tenants$orphan_sponsorshipArgs
        orphans?: boolean | Tenants$orphansArgs
        second_sponsors?: boolean | Tenants$second_sponsorsArgs
        sponsor_sponsorship?: boolean | Tenants$sponsor_sponsorshipArgs
        sponsors?: boolean | Tenants$sponsorsArgs
        sponsorships?: boolean | Tenants$sponsorshipsArgs
        spouses?: boolean | Tenants$spousesArgs
        users?: boolean | Tenants$usersArgs
        _count?: boolean | TenantsCountOutputTypeArgs
    }

    export type TenantsInclude = {
        benefactors?: boolean | Tenants$benefactorsArgs
        domains?: boolean | Tenants$domainsArgs
        families?: boolean | Tenants$familiesArgs
        family_sponsorship?: boolean | Tenants$family_sponsorshipArgs
        income_sponsor?: boolean | Tenants$income_sponsorArgs
        orphan_sponsorship?: boolean | Tenants$orphan_sponsorshipArgs
        orphans?: boolean | Tenants$orphansArgs
        second_sponsors?: boolean | Tenants$second_sponsorsArgs
        sponsor_sponsorship?: boolean | Tenants$sponsor_sponsorshipArgs
        sponsors?: boolean | Tenants$sponsorsArgs
        sponsorships?: boolean | Tenants$sponsorshipsArgs
        spouses?: boolean | Tenants$spousesArgs
        users?: boolean | Tenants$usersArgs
        _count?: boolean | TenantsCountOutputTypeArgs
    }

    export type TenantsGetPayload<S extends boolean | null | undefined | TenantsArgs> = S extends {
        select: any
        include: any
    }
        ? 'Please either choose `select` or `include`'
        : S extends true
          ? Tenants
          : S extends undefined
            ? never
            : S extends { include: any } & (TenantsArgs | TenantsFindManyArgs)
              ? Tenants & {
                    [P in TruthyKeys<S['include']>]: P extends 'benefactors'
                        ? Array<BenefactorsGetPayload<S['include'][P]>>
                        : P extends 'domains'
                          ? Array<DomainsGetPayload<S['include'][P]>>
                          : P extends 'families'
                            ? Array<FamiliesGetPayload<S['include'][P]>>
                            : P extends 'family_sponsorship'
                              ? Array<Family_sponsorshipGetPayload<S['include'][P]>>
                              : P extends 'income_sponsor'
                                ? Array<Income_sponsorGetPayload<S['include'][P]>>
                                : P extends 'orphan_sponsorship'
                                  ? Array<Orphan_sponsorshipGetPayload<S['include'][P]>>
                                  : P extends 'orphans'
                                    ? Array<OrphansGetPayload<S['include'][P]>>
                                    : P extends 'second_sponsors'
                                      ? Array<Second_sponsorsGetPayload<S['include'][P]>>
                                      : P extends 'sponsor_sponsorship'
                                        ? Array<Sponsor_sponsorshipGetPayload<S['include'][P]>>
                                        : P extends 'sponsors'
                                          ? Array<SponsorsGetPayload<S['include'][P]>>
                                          : P extends 'sponsorships'
                                            ? Array<SponsorshipsGetPayload<S['include'][P]>>
                                            : P extends 'spouses'
                                              ? Array<SpousesGetPayload<S['include'][P]>>
                                              : P extends 'users'
                                                ? Array<UsersGetPayload<S['include'][P]>>
                                                : P extends '_count'
                                                  ? TenantsCountOutputTypeGetPayload<S['include'][P]>
                                                  : never
                }
              : S extends { select: any } & (TenantsArgs | TenantsFindManyArgs)
                ? {
                      [P in TruthyKeys<S['select']>]: P extends 'benefactors'
                          ? Array<BenefactorsGetPayload<S['select'][P]>>
                          : P extends 'domains'
                            ? Array<DomainsGetPayload<S['select'][P]>>
                            : P extends 'families'
                              ? Array<FamiliesGetPayload<S['select'][P]>>
                              : P extends 'family_sponsorship'
                                ? Array<Family_sponsorshipGetPayload<S['select'][P]>>
                                : P extends 'income_sponsor'
                                  ? Array<Income_sponsorGetPayload<S['select'][P]>>
                                  : P extends 'orphan_sponsorship'
                                    ? Array<Orphan_sponsorshipGetPayload<S['select'][P]>>
                                    : P extends 'orphans'
                                      ? Array<OrphansGetPayload<S['select'][P]>>
                                      : P extends 'second_sponsors'
                                        ? Array<Second_sponsorsGetPayload<S['select'][P]>>
                                        : P extends 'sponsor_sponsorship'
                                          ? Array<Sponsor_sponsorshipGetPayload<S['select'][P]>>
                                          : P extends 'sponsors'
                                            ? Array<SponsorsGetPayload<S['select'][P]>>
                                            : P extends 'sponsorships'
                                              ? Array<SponsorshipsGetPayload<S['select'][P]>>
                                              : P extends 'spouses'
                                                ? Array<SpousesGetPayload<S['select'][P]>>
                                                : P extends 'users'
                                                  ? Array<UsersGetPayload<S['select'][P]>>
                                                  : P extends '_count'
                                                    ? TenantsCountOutputTypeGetPayload<S['select'][P]>
                                                    : P extends keyof Tenants
                                                      ? Tenants[P]
                                                      : never
                  }
                : Tenants

    type TenantsCountArgs = Merge<
        Omit<TenantsFindManyArgs, 'select' | 'include'> & {
            select?: TenantsCountAggregateInputType | true
        }
    >

    export interface TenantsDelegate<
        GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined
    > {
        /**
         * Find zero or one Tenants that matches the filter.
         * @param {TenantsFindUniqueArgs} args - Arguments to find a Tenants
         * @example
         * // Get one Tenants
         * const tenants = await prisma.tenants.findUnique({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findUnique<
            T extends TenantsFindUniqueArgs,
            LocalRejectSettings = T['rejectOnNotFound'] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined
        >(
            args: SelectSubset<T, TenantsFindUniqueArgs>
        ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Tenants'> extends True
            ? Prisma__TenantsClient<TenantsGetPayload<T>>
            : Prisma__TenantsClient<TenantsGetPayload<T> | null, null>

        /**
         * Find one Tenants that matches the filter or throw an error  with `error.code='P2025'`
         *     if no matches were found.
         * @param {TenantsFindUniqueOrThrowArgs} args - Arguments to find a Tenants
         * @example
         * // Get one Tenants
         * const tenants = await prisma.tenants.findUniqueOrThrow({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findUniqueOrThrow<T extends TenantsFindUniqueOrThrowArgs>(
            args?: SelectSubset<T, TenantsFindUniqueOrThrowArgs>
        ): Prisma__TenantsClient<TenantsGetPayload<T>>

        /**
         * Find the first Tenants that matches the filter.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {TenantsFindFirstArgs} args - Arguments to find a Tenants
         * @example
         * // Get one Tenants
         * const tenants = await prisma.tenants.findFirst({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findFirst<
            T extends TenantsFindFirstArgs,
            LocalRejectSettings = T['rejectOnNotFound'] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined
        >(
            args?: SelectSubset<T, TenantsFindFirstArgs>
        ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Tenants'> extends True
            ? Prisma__TenantsClient<TenantsGetPayload<T>>
            : Prisma__TenantsClient<TenantsGetPayload<T> | null, null>

        /**
         * Find the first Tenants that matches the filter or
         * throw `NotFoundError` if no matches were found.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {TenantsFindFirstOrThrowArgs} args - Arguments to find a Tenants
         * @example
         * // Get one Tenants
         * const tenants = await prisma.tenants.findFirstOrThrow({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findFirstOrThrow<T extends TenantsFindFirstOrThrowArgs>(
            args?: SelectSubset<T, TenantsFindFirstOrThrowArgs>
        ): Prisma__TenantsClient<TenantsGetPayload<T>>

        /**
         * Find zero or more Tenants that matches the filter.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {TenantsFindManyArgs=} args - Arguments to filter and select certain fields only.
         * @example
         * // Get all Tenants
         * const tenants = await prisma.tenants.findMany()
         *
         * // Get first 10 Tenants
         * const tenants = await prisma.tenants.findMany({ take: 10 })
         *
         * // Only select the `id`
         * const tenantsWithIdOnly = await prisma.tenants.findMany({ select: { id: true } })
         *
         **/
        findMany<T extends TenantsFindManyArgs>(
            args?: SelectSubset<T, TenantsFindManyArgs>
        ): PrismaPromise<Array<TenantsGetPayload<T>>>

        /**
         * Create a Tenants.
         * @param {TenantsCreateArgs} args - Arguments to create a Tenants.
         * @example
         * // Create one Tenants
         * const Tenants = await prisma.tenants.create({
         *   data: {
         *     // ... data to create a Tenants
         *   }
         * })
         *
         **/
        create<T extends TenantsCreateArgs>(
            args: SelectSubset<T, TenantsCreateArgs>
        ): Prisma__TenantsClient<TenantsGetPayload<T>>

        /**
         * Create many Tenants.
         *     @param {TenantsCreateManyArgs} args - Arguments to create many Tenants.
         *     @example
         *     // Create many Tenants
         *     const tenants = await prisma.tenants.createMany({
         *       data: {
         *         // ... provide data here
         *       }
         *     })
         *
         **/
        createMany<T extends TenantsCreateManyArgs>(
            args?: SelectSubset<T, TenantsCreateManyArgs>
        ): PrismaPromise<BatchPayload>

        /**
         * Delete a Tenants.
         * @param {TenantsDeleteArgs} args - Arguments to delete one Tenants.
         * @example
         * // Delete one Tenants
         * const Tenants = await prisma.tenants.delete({
         *   where: {
         *     // ... filter to delete one Tenants
         *   }
         * })
         *
         **/
        delete<T extends TenantsDeleteArgs>(
            args: SelectSubset<T, TenantsDeleteArgs>
        ): Prisma__TenantsClient<TenantsGetPayload<T>>

        /**
         * Update one Tenants.
         * @param {TenantsUpdateArgs} args - Arguments to update one Tenants.
         * @example
         * // Update one Tenants
         * const tenants = await prisma.tenants.update({
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: {
         *     // ... provide data here
         *   }
         * })
         *
         **/
        update<T extends TenantsUpdateArgs>(
            args: SelectSubset<T, TenantsUpdateArgs>
        ): Prisma__TenantsClient<TenantsGetPayload<T>>

        /**
         * Delete zero or more Tenants.
         * @param {TenantsDeleteManyArgs} args - Arguments to filter Tenants to delete.
         * @example
         * // Delete a few Tenants
         * const { count } = await prisma.tenants.deleteMany({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         *
         **/
        deleteMany<T extends TenantsDeleteManyArgs>(
            args?: SelectSubset<T, TenantsDeleteManyArgs>
        ): PrismaPromise<BatchPayload>

        /**
         * Update zero or more Tenants.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {TenantsUpdateManyArgs} args - Arguments to update one or more rows.
         * @example
         * // Update many Tenants
         * const tenants = await prisma.tenants.updateMany({
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: {
         *     // ... provide data here
         *   }
         * })
         *
         **/
        updateMany<T extends TenantsUpdateManyArgs>(
            args: SelectSubset<T, TenantsUpdateManyArgs>
        ): PrismaPromise<BatchPayload>

        /**
         * Create or update one Tenants.
         * @param {TenantsUpsertArgs} args - Arguments to update or create a Tenants.
         * @example
         * // Update or create a Tenants
         * const tenants = await prisma.tenants.upsert({
         *   create: {
         *     // ... data to create a Tenants
         *   },
         *   update: {
         *     // ... in case it already exists, update
         *   },
         *   where: {
         *     // ... the filter for the Tenants we want to update
         *   }
         * })
         **/
        upsert<T extends TenantsUpsertArgs>(
            args: SelectSubset<T, TenantsUpsertArgs>
        ): Prisma__TenantsClient<TenantsGetPayload<T>>

        /**
         * Count the number of Tenants.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {TenantsCountArgs} args - Arguments to filter Tenants to count.
         * @example
         * // Count the number of Tenants
         * const count = await prisma.tenants.count({
         *   where: {
         *     // ... the filter for the Tenants we want to count
         *   }
         * })
         **/
        count<T extends TenantsCountArgs>(
            args?: Subset<T, TenantsCountArgs>
        ): PrismaPromise<
            T extends _Record<'select', any>
                ? T['select'] extends true
                    ? number
                    : GetScalarType<T['select'], TenantsCountAggregateOutputType>
                : number
        >

        /**
         * Allows you to perform aggregations operations on a Tenants.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {TenantsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
         * @example
         * // Ordered by age ascending
         * // Where email contains prisma.io
         * // Limited to the 10 users
         * const aggregations = await prisma.user.aggregate({
         *   _avg: {
         *     age: true,
         *   },
         *   where: {
         *     email: {
         *       contains: "prisma.io",
         *     },
         *   },
         *   orderBy: {
         *     age: "asc",
         *   },
         *   take: 10,
         * })
         **/
        aggregate<T extends TenantsAggregateArgs>(
            args: Subset<T, TenantsAggregateArgs>
        ): PrismaPromise<GetTenantsAggregateType<T>>

        /**
         * Group by Tenants.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {TenantsGroupByArgs} args - Group by arguments.
         * @example
         * // Group by city, order by createdAt, get count
         * const result = await prisma.user.groupBy({
         *   by: ['city', 'createdAt'],
         *   orderBy: {
         *     createdAt: true
         *   },
         *   _count: {
         *     _all: true
         *   },
         * })
         *
         **/
        groupBy<
            T extends TenantsGroupByArgs,
            HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
            OrderByArg extends True extends HasSelectOrTake
                ? { orderBy: TenantsGroupByArgs['orderBy'] }
                : { orderBy?: TenantsGroupByArgs['orderBy'] },
            OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
            ByFields extends TupleToUnion<T['by']>,
            ByValid extends Has<ByFields, OrderFields>,
            HavingFields extends GetHavingFields<T['having']>,
            HavingValid extends Has<ByFields, HavingFields>,
            ByEmpty extends T['by'] extends never[] ? True : False,
            InputErrors extends ByEmpty extends True
                ? `Error: "by" must not be empty.`
                : HavingValid extends False
                  ? {
                        [P in HavingFields]: P extends ByFields
                            ? never
                            : P extends string
                              ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                              : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`]
                    }[HavingFields]
                  : 'take' extends Keys<T>
                    ? 'orderBy' extends Keys<T>
                        ? ByValid extends True
                            ? {}
                            : {
                                  [P in OrderFields]: P extends ByFields
                                      ? never
                                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                              }[OrderFields]
                        : 'Error: If you provide "take", you also need to provide "orderBy"'
                    : 'skip' extends Keys<T>
                      ? 'orderBy' extends Keys<T>
                          ? ByValid extends True
                              ? {}
                              : {
                                    [P in OrderFields]: P extends ByFields
                                        ? never
                                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                                }[OrderFields]
                          : 'Error: If you provide "skip", you also need to provide "orderBy"'
                      : ByValid extends True
                        ? {}
                        : {
                              [P in OrderFields]: P extends ByFields
                                  ? never
                                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                          }[OrderFields]
        >(
            args: SubsetIntersection<T, TenantsGroupByArgs, OrderByArg> & InputErrors
        ): {} extends InputErrors ? GetTenantsGroupByPayload<T> : PrismaPromise<InputErrors>
    }

    /**
     * The delegate class that acts as a "Promise-like" for Tenants.
     * Why is this prefixed with `Prisma__`?
     * Because we want to prevent naming conflicts as mentioned in
     * https://github.com/prisma/prisma-client-js/issues/707
     */
    export class Prisma__TenantsClient<T, Null = never> implements PrismaPromise<T> {
        [prisma]: true
        private readonly _dmmf
        private readonly _fetcher
        private readonly _queryType
        private readonly _rootField
        private readonly _clientMethod
        private readonly _args
        private readonly _dataPath
        private readonly _errorFormat
        private readonly _measurePerformance?
        private _isList
        private _callsite
        private _requestPromise?
        constructor(
            _dmmf: runtime.DMMFClass,
            _fetcher: PrismaClientFetcher,
            _queryType: 'query' | 'mutation',
            _rootField: string,
            _clientMethod: string,
            _args: any,
            _dataPath: string[],
            _errorFormat: ErrorFormat,
            _measurePerformance?: boolean | undefined,
            _isList?: boolean
        )
        readonly [Symbol.toStringTag]: 'PrismaClientPromise'

        benefactors<T extends Tenants$benefactorsArgs = {}>(
            args?: Subset<T, Tenants$benefactorsArgs>
        ): PrismaPromise<Array<BenefactorsGetPayload<T>> | Null>

        domains<T extends Tenants$domainsArgs = {}>(
            args?: Subset<T, Tenants$domainsArgs>
        ): PrismaPromise<Array<DomainsGetPayload<T>> | Null>

        families<T extends Tenants$familiesArgs = {}>(
            args?: Subset<T, Tenants$familiesArgs>
        ): PrismaPromise<Array<FamiliesGetPayload<T>> | Null>

        family_sponsorship<T extends Tenants$family_sponsorshipArgs = {}>(
            args?: Subset<T, Tenants$family_sponsorshipArgs>
        ): PrismaPromise<Array<Family_sponsorshipGetPayload<T>> | Null>

        income_sponsor<T extends Tenants$income_sponsorArgs = {}>(
            args?: Subset<T, Tenants$income_sponsorArgs>
        ): PrismaPromise<Array<Income_sponsorGetPayload<T>> | Null>

        orphan_sponsorship<T extends Tenants$orphan_sponsorshipArgs = {}>(
            args?: Subset<T, Tenants$orphan_sponsorshipArgs>
        ): PrismaPromise<Array<Orphan_sponsorshipGetPayload<T>> | Null>

        orphans<T extends Tenants$orphansArgs = {}>(
            args?: Subset<T, Tenants$orphansArgs>
        ): PrismaPromise<Array<OrphansGetPayload<T>> | Null>

        second_sponsors<T extends Tenants$second_sponsorsArgs = {}>(
            args?: Subset<T, Tenants$second_sponsorsArgs>
        ): PrismaPromise<Array<Second_sponsorsGetPayload<T>> | Null>

        sponsor_sponsorship<T extends Tenants$sponsor_sponsorshipArgs = {}>(
            args?: Subset<T, Tenants$sponsor_sponsorshipArgs>
        ): PrismaPromise<Array<Sponsor_sponsorshipGetPayload<T>> | Null>

        sponsors<T extends Tenants$sponsorsArgs = {}>(
            args?: Subset<T, Tenants$sponsorsArgs>
        ): PrismaPromise<Array<SponsorsGetPayload<T>> | Null>

        sponsorships<T extends Tenants$sponsorshipsArgs = {}>(
            args?: Subset<T, Tenants$sponsorshipsArgs>
        ): PrismaPromise<Array<SponsorshipsGetPayload<T>> | Null>

        spouses<T extends Tenants$spousesArgs = {}>(
            args?: Subset<T, Tenants$spousesArgs>
        ): PrismaPromise<Array<SpousesGetPayload<T>> | Null>

        users<T extends Tenants$usersArgs = {}>(
            args?: Subset<T, Tenants$usersArgs>
        ): PrismaPromise<Array<UsersGetPayload<T>> | Null>

        private get _document()
        /**
         * Attaches callbacks for the resolution and/or rejection of the Promise.
         * @param onfulfilled The callback to execute when the Promise is resolved.
         * @param onrejected The callback to execute when the Promise is rejected.
         * @returns A Promise for the completion of which ever callback is executed.
         */
        then<TResult1 = T, TResult2 = never>(
            onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
            onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
        ): Promise<TResult1 | TResult2>
        /**
         * Attaches a callback for only the rejection of the Promise.
         * @param onrejected The callback to execute when the Promise is rejected.
         * @returns A Promise for the completion of the callback.
         */
        catch<TResult = never>(
            onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
        ): Promise<T | TResult>
        /**
         * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
         * resolved value cannot be modified from the callback.
         * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
         * @returns A Promise for the completion of the callback.
         */
        finally(onfinally?: (() => void) | undefined | null): Promise<T>
    }

    // Custom InputTypes

    /**
     * Tenants base type for findUnique actions
     */
    export type TenantsFindUniqueArgsBase = {
        /**
         * Select specific fields to fetch from the Tenants
         *
         **/
        select?: TenantsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: TenantsInclude | null
        /**
         * Filter, which Tenants to fetch.
         *
         **/
        where: TenantsWhereUniqueInput
    }

    /**
     * Tenants findUnique
     */
    export interface TenantsFindUniqueArgs extends TenantsFindUniqueArgsBase {
        /**
         * Throw an Error if query returns no results
         * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
         */
        rejectOnNotFound?: RejectOnNotFound
    }

    /**
     * Tenants findUniqueOrThrow
     */
    export type TenantsFindUniqueOrThrowArgs = {
        /**
         * Select specific fields to fetch from the Tenants
         *
         **/
        select?: TenantsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: TenantsInclude | null
        /**
         * Filter, which Tenants to fetch.
         *
         **/
        where: TenantsWhereUniqueInput
    }

    /**
     * Tenants base type for findFirst actions
     */
    export type TenantsFindFirstArgsBase = {
        /**
         * Select specific fields to fetch from the Tenants
         *
         **/
        select?: TenantsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: TenantsInclude | null
        /**
         * Filter, which Tenants to fetch.
         *
         **/
        where?: TenantsWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Tenants to fetch.
         *
         **/
        orderBy?: Enumerable<TenantsOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for searching for Tenants.
         *
         **/
        cursor?: TenantsWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Tenants from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Tenants.
         *
         **/
        skip?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
         *
         * Filter by unique combinations of Tenants.
         *
         **/
        distinct?: Enumerable<TenantsScalarFieldEnum>
    }

    /**
     * Tenants findFirst
     */
    export interface TenantsFindFirstArgs extends TenantsFindFirstArgsBase {
        /**
         * Throw an Error if query returns no results
         * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
         */
        rejectOnNotFound?: RejectOnNotFound
    }

    /**
     * Tenants findFirstOrThrow
     */
    export type TenantsFindFirstOrThrowArgs = {
        /**
         * Select specific fields to fetch from the Tenants
         *
         **/
        select?: TenantsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: TenantsInclude | null
        /**
         * Filter, which Tenants to fetch.
         *
         **/
        where?: TenantsWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Tenants to fetch.
         *
         **/
        orderBy?: Enumerable<TenantsOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for searching for Tenants.
         *
         **/
        cursor?: TenantsWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Tenants from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Tenants.
         *
         **/
        skip?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
         *
         * Filter by unique combinations of Tenants.
         *
         **/
        distinct?: Enumerable<TenantsScalarFieldEnum>
    }

    /**
     * Tenants findMany
     */
    export type TenantsFindManyArgs = {
        /**
         * Select specific fields to fetch from the Tenants
         *
         **/
        select?: TenantsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: TenantsInclude | null
        /**
         * Filter, which Tenants to fetch.
         *
         **/
        where?: TenantsWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Tenants to fetch.
         *
         **/
        orderBy?: Enumerable<TenantsOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for listing Tenants.
         *
         **/
        cursor?: TenantsWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Tenants from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Tenants.
         *
         **/
        skip?: number
        distinct?: Enumerable<TenantsScalarFieldEnum>
    }

    /**
     * Tenants create
     */
    export type TenantsCreateArgs = {
        /**
         * Select specific fields to fetch from the Tenants
         *
         **/
        select?: TenantsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: TenantsInclude | null
        /**
         * The data needed to create a Tenants.
         *
         **/
        data: XOR<TenantsCreateInput, TenantsUncheckedCreateInput>
    }

    /**
     * Tenants createMany
     */
    export type TenantsCreateManyArgs = {
        /**
         * The data used to create many Tenants.
         *
         **/
        data: Enumerable<TenantsCreateManyInput>
        skipDuplicates?: boolean
    }

    /**
     * Tenants update
     */
    export type TenantsUpdateArgs = {
        /**
         * Select specific fields to fetch from the Tenants
         *
         **/
        select?: TenantsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: TenantsInclude | null
        /**
         * The data needed to update a Tenants.
         *
         **/
        data: XOR<TenantsUpdateInput, TenantsUncheckedUpdateInput>
        /**
         * Choose, which Tenants to update.
         *
         **/
        where: TenantsWhereUniqueInput
    }

    /**
     * Tenants updateMany
     */
    export type TenantsUpdateManyArgs = {
        /**
         * The data used to update Tenants.
         *
         **/
        data: XOR<TenantsUpdateManyMutationInput, TenantsUncheckedUpdateManyInput>
        /**
         * Filter which Tenants to update
         *
         **/
        where?: TenantsWhereInput
    }

    /**
     * Tenants upsert
     */
    export type TenantsUpsertArgs = {
        /**
         * Select specific fields to fetch from the Tenants
         *
         **/
        select?: TenantsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: TenantsInclude | null
        /**
         * The filter to search for the Tenants to update in case it exists.
         *
         **/
        where: TenantsWhereUniqueInput
        /**
         * In case the Tenants found by the `where` argument doesn't exist, create a new Tenants with this data.
         *
         **/
        create: XOR<TenantsCreateInput, TenantsUncheckedCreateInput>
        /**
         * In case the Tenants was found with the provided `where` argument, update it with this data.
         *
         **/
        update: XOR<TenantsUpdateInput, TenantsUncheckedUpdateInput>
    }

    /**
     * Tenants delete
     */
    export type TenantsDeleteArgs = {
        /**
         * Select specific fields to fetch from the Tenants
         *
         **/
        select?: TenantsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: TenantsInclude | null
        /**
         * Filter which Tenants to delete.
         *
         **/
        where: TenantsWhereUniqueInput
    }

    /**
     * Tenants deleteMany
     */
    export type TenantsDeleteManyArgs = {
        /**
         * Filter which Tenants to delete
         *
         **/
        where?: TenantsWhereInput
    }

    /**
     * Tenants.benefactors
     */
    export type Tenants$benefactorsArgs = {
        /**
         * Select specific fields to fetch from the Benefactors
         *
         **/
        select?: BenefactorsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: BenefactorsInclude | null
        where?: BenefactorsWhereInput
        orderBy?: Enumerable<BenefactorsOrderByWithRelationInput>
        cursor?: BenefactorsWhereUniqueInput
        take?: number
        skip?: number
        distinct?: Enumerable<BenefactorsScalarFieldEnum>
    }

    /**
     * Tenants.domains
     */
    export type Tenants$domainsArgs = {
        /**
         * Select specific fields to fetch from the Domains
         *
         **/
        select?: DomainsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: DomainsInclude | null
        where?: DomainsWhereInput
        orderBy?: Enumerable<DomainsOrderByWithRelationInput>
        cursor?: DomainsWhereUniqueInput
        take?: number
        skip?: number
        distinct?: Enumerable<DomainsScalarFieldEnum>
    }

    /**
     * Tenants.families
     */
    export type Tenants$familiesArgs = {
        /**
         * Select specific fields to fetch from the Families
         *
         **/
        select?: FamiliesSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: FamiliesInclude | null
        where?: FamiliesWhereInput
        orderBy?: Enumerable<FamiliesOrderByWithRelationInput>
        cursor?: FamiliesWhereUniqueInput
        take?: number
        skip?: number
        distinct?: Enumerable<FamiliesScalarFieldEnum>
    }

    /**
     * Tenants.family_sponsorship
     */
    export type Tenants$family_sponsorshipArgs = {
        /**
         * Select specific fields to fetch from the Family_sponsorship
         *
         **/
        select?: Family_sponsorshipSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Family_sponsorshipInclude | null
        where?: Family_sponsorshipWhereInput
        orderBy?: Enumerable<Family_sponsorshipOrderByWithRelationInput>
        cursor?: Family_sponsorshipWhereUniqueInput
        take?: number
        skip?: number
        distinct?: Enumerable<Family_sponsorshipScalarFieldEnum>
    }

    /**
     * Tenants.income_sponsor
     */
    export type Tenants$income_sponsorArgs = {
        /**
         * Select specific fields to fetch from the Income_sponsor
         *
         **/
        select?: Income_sponsorSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Income_sponsorInclude | null
        where?: Income_sponsorWhereInput
        orderBy?: Enumerable<Income_sponsorOrderByWithRelationInput>
        cursor?: Income_sponsorWhereUniqueInput
        take?: number
        skip?: number
        distinct?: Enumerable<Income_sponsorScalarFieldEnum>
    }

    /**
     * Tenants.orphan_sponsorship
     */
    export type Tenants$orphan_sponsorshipArgs = {
        /**
         * Select specific fields to fetch from the Orphan_sponsorship
         *
         **/
        select?: Orphan_sponsorshipSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Orphan_sponsorshipInclude | null
        where?: Orphan_sponsorshipWhereInput
        orderBy?: Enumerable<Orphan_sponsorshipOrderByWithRelationInput>
        cursor?: Orphan_sponsorshipWhereUniqueInput
        take?: number
        skip?: number
        distinct?: Enumerable<Orphan_sponsorshipScalarFieldEnum>
    }

    /**
     * Tenants.orphans
     */
    export type Tenants$orphansArgs = {
        /**
         * Select specific fields to fetch from the Orphans
         *
         **/
        select?: OrphansSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: OrphansInclude | null
        where?: OrphansWhereInput
        orderBy?: Enumerable<OrphansOrderByWithRelationInput>
        cursor?: OrphansWhereUniqueInput
        take?: number
        skip?: number
        distinct?: Enumerable<OrphansScalarFieldEnum>
    }

    /**
     * Tenants.second_sponsors
     */
    export type Tenants$second_sponsorsArgs = {
        /**
         * Select specific fields to fetch from the Second_sponsors
         *
         **/
        select?: Second_sponsorsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Second_sponsorsInclude | null
        where?: Second_sponsorsWhereInput
        orderBy?: Enumerable<Second_sponsorsOrderByWithRelationInput>
        cursor?: Second_sponsorsWhereUniqueInput
        take?: number
        skip?: number
        distinct?: Enumerable<Second_sponsorsScalarFieldEnum>
    }

    /**
     * Tenants.sponsor_sponsorship
     */
    export type Tenants$sponsor_sponsorshipArgs = {
        /**
         * Select specific fields to fetch from the Sponsor_sponsorship
         *
         **/
        select?: Sponsor_sponsorshipSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: Sponsor_sponsorshipInclude | null
        where?: Sponsor_sponsorshipWhereInput
        orderBy?: Enumerable<Sponsor_sponsorshipOrderByWithRelationInput>
        cursor?: Sponsor_sponsorshipWhereUniqueInput
        take?: number
        skip?: number
        distinct?: Enumerable<Sponsor_sponsorshipScalarFieldEnum>
    }

    /**
     * Tenants.sponsors
     */
    export type Tenants$sponsorsArgs = {
        /**
         * Select specific fields to fetch from the Sponsors
         *
         **/
        select?: SponsorsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: SponsorsInclude | null
        where?: SponsorsWhereInput
        orderBy?: Enumerable<SponsorsOrderByWithRelationInput>
        cursor?: SponsorsWhereUniqueInput
        take?: number
        skip?: number
        distinct?: Enumerable<SponsorsScalarFieldEnum>
    }

    /**
     * Tenants.sponsorships
     */
    export type Tenants$sponsorshipsArgs = {
        /**
         * Select specific fields to fetch from the Sponsorships
         *
         **/
        select?: SponsorshipsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: SponsorshipsInclude | null
        where?: SponsorshipsWhereInput
        orderBy?: Enumerable<SponsorshipsOrderByWithRelationInput>
        cursor?: SponsorshipsWhereUniqueInput
        take?: number
        skip?: number
        distinct?: Enumerable<SponsorshipsScalarFieldEnum>
    }

    /**
     * Tenants.spouses
     */
    export type Tenants$spousesArgs = {
        /**
         * Select specific fields to fetch from the Spouses
         *
         **/
        select?: SpousesSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: SpousesInclude | null
        where?: SpousesWhereInput
        orderBy?: Enumerable<SpousesOrderByWithRelationInput>
        cursor?: SpousesWhereUniqueInput
        take?: number
        skip?: number
        distinct?: Enumerable<SpousesScalarFieldEnum>
    }

    /**
     * Tenants.users
     */
    export type Tenants$usersArgs = {
        /**
         * Select specific fields to fetch from the Users
         *
         **/
        select?: UsersSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: UsersInclude | null
        where?: UsersWhereInput
        orderBy?: Enumerable<UsersOrderByWithRelationInput>
        cursor?: UsersWhereUniqueInput
        take?: number
        skip?: number
        distinct?: Enumerable<UsersScalarFieldEnum>
    }

    /**
     * Tenants without action
     */
    export type TenantsArgs = {
        /**
         * Select specific fields to fetch from the Tenants
         *
         **/
        select?: TenantsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: TenantsInclude | null
    }

    /**
     * Model Users
     */

    export type AggregateUsers = {
        _count: UsersCountAggregateOutputType | null
        _min: UsersMinAggregateOutputType | null
        _max: UsersMaxAggregateOutputType | null
    }

    export type UsersMinAggregateOutputType = {
        id: string | null
        first_name: string | null
        last_name: string | null
        phone: string | null
        email: string | null
        email_verified_at: Date | null
        password: string | null
        remember_token: string | null
        tenant_id: string | null
        created_at: Date | null
        updated_at: Date | null
    }

    export type UsersMaxAggregateOutputType = {
        id: string | null
        first_name: string | null
        last_name: string | null
        phone: string | null
        email: string | null
        email_verified_at: Date | null
        password: string | null
        remember_token: string | null
        tenant_id: string | null
        created_at: Date | null
        updated_at: Date | null
    }

    export type UsersCountAggregateOutputType = {
        id: number
        first_name: number
        last_name: number
        phone: number
        email: number
        email_verified_at: number
        password: number
        remember_token: number
        tenant_id: number
        created_at: number
        updated_at: number
        _all: number
    }

    export type UsersMinAggregateInputType = {
        id?: true
        first_name?: true
        last_name?: true
        phone?: true
        email?: true
        email_verified_at?: true
        password?: true
        remember_token?: true
        tenant_id?: true
        created_at?: true
        updated_at?: true
    }

    export type UsersMaxAggregateInputType = {
        id?: true
        first_name?: true
        last_name?: true
        phone?: true
        email?: true
        email_verified_at?: true
        password?: true
        remember_token?: true
        tenant_id?: true
        created_at?: true
        updated_at?: true
    }

    export type UsersCountAggregateInputType = {
        id?: true
        first_name?: true
        last_name?: true
        phone?: true
        email?: true
        email_verified_at?: true
        password?: true
        remember_token?: true
        tenant_id?: true
        created_at?: true
        updated_at?: true
        _all?: true
    }

    export type UsersAggregateArgs = {
        /**
         * Filter which Users to aggregate.
         *
         **/
        where?: UsersWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Users to fetch.
         *
         **/
        orderBy?: Enumerable<UsersOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the start position
         *
         **/
        cursor?: UsersWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Users from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Users.
         *
         **/
        skip?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Count returned Users
         **/
        _count?: true | UsersCountAggregateInputType
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to find the minimum value
         **/
        _min?: UsersMinAggregateInputType
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
         *
         * Select which fields to find the maximum value
         **/
        _max?: UsersMaxAggregateInputType
    }

    export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'
            ? T[P] extends true
                ? number
                : GetScalarType<T[P], AggregateUsers[P]>
            : GetScalarType<T[P], AggregateUsers[P]>
    }

    export type UsersGroupByArgs = {
        where?: UsersWhereInput
        orderBy?: Enumerable<UsersOrderByWithAggregationInput>
        by: Array<UsersScalarFieldEnum>
        having?: UsersScalarWhereWithAggregatesInput
        take?: number
        skip?: number
        _count?: UsersCountAggregateInputType | true
        _min?: UsersMinAggregateInputType
        _max?: UsersMaxAggregateInputType
    }

    export type UsersGroupByOutputType = {
        id: string
        first_name: string
        last_name: string
        phone: string
        email: string
        email_verified_at: Date | null
        password: string
        remember_token: string | null
        tenant_id: string
        created_at: Date | null
        updated_at: Date | null
        _count: UsersCountAggregateOutputType | null
        _min: UsersMinAggregateOutputType | null
        _max: UsersMaxAggregateOutputType | null
    }

    type GetUsersGroupByPayload<T extends UsersGroupByArgs> = PrismaPromise<
        Array<
            PickArray<UsersGroupByOutputType, T['by']> & {
                [P in keyof T & keyof UsersGroupByOutputType]: P extends '_count'
                    ? T[P] extends boolean
                        ? number
                        : GetScalarType<T[P], UsersGroupByOutputType[P]>
                    : GetScalarType<T[P], UsersGroupByOutputType[P]>
            }
        >
    >

    export type UsersSelect = {
        id?: boolean
        first_name?: boolean
        last_name?: boolean
        phone?: boolean
        email?: boolean
        email_verified_at?: boolean
        password?: boolean
        remember_token?: boolean
        tenant_id?: boolean
        created_at?: boolean
        updated_at?: boolean
        orphans_orphans_created_byTousers?: boolean | Users$orphans_orphans_created_byTousersArgs
        orphans_orphans_deleted_byTousers?: boolean | Users$orphans_orphans_deleted_byTousersArgs
        sessions?: boolean | Users$sessionsArgs
        settings?: boolean | Users$settingsArgs
        sponsors_sponsors_created_byTousers?: boolean | Users$sponsors_sponsors_created_byTousersArgs
        sponsors_sponsors_deleted_byTousers?: boolean | Users$sponsors_sponsors_deleted_byTousersArgs
        tenants?: boolean | TenantsArgs
        _count?: boolean | UsersCountOutputTypeArgs
    }

    export type UsersInclude = {
        orphans_orphans_created_byTousers?: boolean | Users$orphans_orphans_created_byTousersArgs
        orphans_orphans_deleted_byTousers?: boolean | Users$orphans_orphans_deleted_byTousersArgs
        sessions?: boolean | Users$sessionsArgs
        settings?: boolean | Users$settingsArgs
        sponsors_sponsors_created_byTousers?: boolean | Users$sponsors_sponsors_created_byTousersArgs
        sponsors_sponsors_deleted_byTousers?: boolean | Users$sponsors_sponsors_deleted_byTousersArgs
        tenants?: boolean | TenantsArgs
        _count?: boolean | UsersCountOutputTypeArgs
    }

    export type UsersGetPayload<S extends boolean | null | undefined | UsersArgs> = S extends {
        select: any
        include: any
    }
        ? 'Please either choose `select` or `include`'
        : S extends true
          ? Users
          : S extends undefined
            ? never
            : S extends { include: any } & (UsersArgs | UsersFindManyArgs)
              ? Users & {
                    [P in TruthyKeys<S['include']>]: P extends 'orphans_orphans_created_byTousers'
                        ? Array<OrphansGetPayload<S['include'][P]>>
                        : P extends 'orphans_orphans_deleted_byTousers'
                          ? Array<OrphansGetPayload<S['include'][P]>>
                          : P extends 'sessions'
                            ? Array<SessionsGetPayload<S['include'][P]>>
                            : P extends 'settings'
                              ? Array<SettingsGetPayload<S['include'][P]>>
                              : P extends 'sponsors_sponsors_created_byTousers'
                                ? Array<SponsorsGetPayload<S['include'][P]>>
                                : P extends 'sponsors_sponsors_deleted_byTousers'
                                  ? Array<SponsorsGetPayload<S['include'][P]>>
                                  : P extends 'tenants'
                                    ? TenantsGetPayload<S['include'][P]>
                                    : P extends '_count'
                                      ? UsersCountOutputTypeGetPayload<S['include'][P]>
                                      : never
                }
              : S extends { select: any } & (UsersArgs | UsersFindManyArgs)
                ? {
                      [P in TruthyKeys<S['select']>]: P extends 'orphans_orphans_created_byTousers'
                          ? Array<OrphansGetPayload<S['select'][P]>>
                          : P extends 'orphans_orphans_deleted_byTousers'
                            ? Array<OrphansGetPayload<S['select'][P]>>
                            : P extends 'sessions'
                              ? Array<SessionsGetPayload<S['select'][P]>>
                              : P extends 'settings'
                                ? Array<SettingsGetPayload<S['select'][P]>>
                                : P extends 'sponsors_sponsors_created_byTousers'
                                  ? Array<SponsorsGetPayload<S['select'][P]>>
                                  : P extends 'sponsors_sponsors_deleted_byTousers'
                                    ? Array<SponsorsGetPayload<S['select'][P]>>
                                    : P extends 'tenants'
                                      ? TenantsGetPayload<S['select'][P]>
                                      : P extends '_count'
                                        ? UsersCountOutputTypeGetPayload<S['select'][P]>
                                        : P extends keyof Users
                                          ? Users[P]
                                          : never
                  }
                : Users

    type UsersCountArgs = Merge<
        Omit<UsersFindManyArgs, 'select' | 'include'> & {
            select?: UsersCountAggregateInputType | true
        }
    >

    export interface UsersDelegate<
        GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined
    > {
        /**
         * Find zero or one Users that matches the filter.
         * @param {UsersFindUniqueArgs} args - Arguments to find a Users
         * @example
         * // Get one Users
         * const users = await prisma.users.findUnique({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findUnique<
            T extends UsersFindUniqueArgs,
            LocalRejectSettings = T['rejectOnNotFound'] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined
        >(
            args: SelectSubset<T, UsersFindUniqueArgs>
        ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Users'> extends True
            ? Prisma__UsersClient<UsersGetPayload<T>>
            : Prisma__UsersClient<UsersGetPayload<T> | null, null>

        /**
         * Find one Users that matches the filter or throw an error  with `error.code='P2025'`
         *     if no matches were found.
         * @param {UsersFindUniqueOrThrowArgs} args - Arguments to find a Users
         * @example
         * // Get one Users
         * const users = await prisma.users.findUniqueOrThrow({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findUniqueOrThrow<T extends UsersFindUniqueOrThrowArgs>(
            args?: SelectSubset<T, UsersFindUniqueOrThrowArgs>
        ): Prisma__UsersClient<UsersGetPayload<T>>

        /**
         * Find the first Users that matches the filter.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {UsersFindFirstArgs} args - Arguments to find a Users
         * @example
         * // Get one Users
         * const users = await prisma.users.findFirst({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findFirst<
            T extends UsersFindFirstArgs,
            LocalRejectSettings = T['rejectOnNotFound'] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined
        >(
            args?: SelectSubset<T, UsersFindFirstArgs>
        ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Users'> extends True
            ? Prisma__UsersClient<UsersGetPayload<T>>
            : Prisma__UsersClient<UsersGetPayload<T> | null, null>

        /**
         * Find the first Users that matches the filter or
         * throw `NotFoundError` if no matches were found.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {UsersFindFirstOrThrowArgs} args - Arguments to find a Users
         * @example
         * // Get one Users
         * const users = await prisma.users.findFirstOrThrow({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         **/
        findFirstOrThrow<T extends UsersFindFirstOrThrowArgs>(
            args?: SelectSubset<T, UsersFindFirstOrThrowArgs>
        ): Prisma__UsersClient<UsersGetPayload<T>>

        /**
         * Find zero or more Users that matches the filter.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {UsersFindManyArgs=} args - Arguments to filter and select certain fields only.
         * @example
         * // Get all Users
         * const users = await prisma.users.findMany()
         *
         * // Get first 10 Users
         * const users = await prisma.users.findMany({ take: 10 })
         *
         * // Only select the `id`
         * const usersWithIdOnly = await prisma.users.findMany({ select: { id: true } })
         *
         **/
        findMany<T extends UsersFindManyArgs>(
            args?: SelectSubset<T, UsersFindManyArgs>
        ): PrismaPromise<Array<UsersGetPayload<T>>>

        /**
         * Create a Users.
         * @param {UsersCreateArgs} args - Arguments to create a Users.
         * @example
         * // Create one Users
         * const Users = await prisma.users.create({
         *   data: {
         *     // ... data to create a Users
         *   }
         * })
         *
         **/
        create<T extends UsersCreateArgs>(
            args: SelectSubset<T, UsersCreateArgs>
        ): Prisma__UsersClient<UsersGetPayload<T>>

        /**
         * Create many Users.
         *     @param {UsersCreateManyArgs} args - Arguments to create many Users.
         *     @example
         *     // Create many Users
         *     const users = await prisma.users.createMany({
         *       data: {
         *         // ... provide data here
         *       }
         *     })
         *
         **/
        createMany<T extends UsersCreateManyArgs>(
            args?: SelectSubset<T, UsersCreateManyArgs>
        ): PrismaPromise<BatchPayload>

        /**
         * Delete a Users.
         * @param {UsersDeleteArgs} args - Arguments to delete one Users.
         * @example
         * // Delete one Users
         * const Users = await prisma.users.delete({
         *   where: {
         *     // ... filter to delete one Users
         *   }
         * })
         *
         **/
        delete<T extends UsersDeleteArgs>(
            args: SelectSubset<T, UsersDeleteArgs>
        ): Prisma__UsersClient<UsersGetPayload<T>>

        /**
         * Update one Users.
         * @param {UsersUpdateArgs} args - Arguments to update one Users.
         * @example
         * // Update one Users
         * const users = await prisma.users.update({
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: {
         *     // ... provide data here
         *   }
         * })
         *
         **/
        update<T extends UsersUpdateArgs>(
            args: SelectSubset<T, UsersUpdateArgs>
        ): Prisma__UsersClient<UsersGetPayload<T>>

        /**
         * Delete zero or more Users.
         * @param {UsersDeleteManyArgs} args - Arguments to filter Users to delete.
         * @example
         * // Delete a few Users
         * const { count } = await prisma.users.deleteMany({
         *   where: {
         *     // ... provide filter here
         *   }
         * })
         *
         **/
        deleteMany<T extends UsersDeleteManyArgs>(
            args?: SelectSubset<T, UsersDeleteManyArgs>
        ): PrismaPromise<BatchPayload>

        /**
         * Update zero or more Users.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {UsersUpdateManyArgs} args - Arguments to update one or more rows.
         * @example
         * // Update many Users
         * const users = await prisma.users.updateMany({
         *   where: {
         *     // ... provide filter here
         *   },
         *   data: {
         *     // ... provide data here
         *   }
         * })
         *
         **/
        updateMany<T extends UsersUpdateManyArgs>(
            args: SelectSubset<T, UsersUpdateManyArgs>
        ): PrismaPromise<BatchPayload>

        /**
         * Create or update one Users.
         * @param {UsersUpsertArgs} args - Arguments to update or create a Users.
         * @example
         * // Update or create a Users
         * const users = await prisma.users.upsert({
         *   create: {
         *     // ... data to create a Users
         *   },
         *   update: {
         *     // ... in case it already exists, update
         *   },
         *   where: {
         *     // ... the filter for the Users we want to update
         *   }
         * })
         **/
        upsert<T extends UsersUpsertArgs>(
            args: SelectSubset<T, UsersUpsertArgs>
        ): Prisma__UsersClient<UsersGetPayload<T>>

        /**
         * Count the number of Users.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {UsersCountArgs} args - Arguments to filter Users to count.
         * @example
         * // Count the number of Users
         * const count = await prisma.users.count({
         *   where: {
         *     // ... the filter for the Users we want to count
         *   }
         * })
         **/
        count<T extends UsersCountArgs>(
            args?: Subset<T, UsersCountArgs>
        ): PrismaPromise<
            T extends _Record<'select', any>
                ? T['select'] extends true
                    ? number
                    : GetScalarType<T['select'], UsersCountAggregateOutputType>
                : number
        >

        /**
         * Allows you to perform aggregations operations on a Users.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
         * @example
         * // Ordered by age ascending
         * // Where email contains prisma.io
         * // Limited to the 10 users
         * const aggregations = await prisma.user.aggregate({
         *   _avg: {
         *     age: true,
         *   },
         *   where: {
         *     email: {
         *       contains: "prisma.io",
         *     },
         *   },
         *   orderBy: {
         *     age: "asc",
         *   },
         *   take: 10,
         * })
         **/
        aggregate<T extends UsersAggregateArgs>(
            args: Subset<T, UsersAggregateArgs>
        ): PrismaPromise<GetUsersAggregateType<T>>

        /**
         * Group by Users.
         * Note, that providing `undefined` is treated as the value not being there.
         * Read more here: https://pris.ly/d/null-undefined
         * @param {UsersGroupByArgs} args - Group by arguments.
         * @example
         * // Group by city, order by createdAt, get count
         * const result = await prisma.user.groupBy({
         *   by: ['city', 'createdAt'],
         *   orderBy: {
         *     createdAt: true
         *   },
         *   _count: {
         *     _all: true
         *   },
         * })
         *
         **/
        groupBy<
            T extends UsersGroupByArgs,
            HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
            OrderByArg extends True extends HasSelectOrTake
                ? { orderBy: UsersGroupByArgs['orderBy'] }
                : { orderBy?: UsersGroupByArgs['orderBy'] },
            OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
            ByFields extends TupleToUnion<T['by']>,
            ByValid extends Has<ByFields, OrderFields>,
            HavingFields extends GetHavingFields<T['having']>,
            HavingValid extends Has<ByFields, HavingFields>,
            ByEmpty extends T['by'] extends never[] ? True : False,
            InputErrors extends ByEmpty extends True
                ? `Error: "by" must not be empty.`
                : HavingValid extends False
                  ? {
                        [P in HavingFields]: P extends ByFields
                            ? never
                            : P extends string
                              ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                              : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`]
                    }[HavingFields]
                  : 'take' extends Keys<T>
                    ? 'orderBy' extends Keys<T>
                        ? ByValid extends True
                            ? {}
                            : {
                                  [P in OrderFields]: P extends ByFields
                                      ? never
                                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                              }[OrderFields]
                        : 'Error: If you provide "take", you also need to provide "orderBy"'
                    : 'skip' extends Keys<T>
                      ? 'orderBy' extends Keys<T>
                          ? ByValid extends True
                              ? {}
                              : {
                                    [P in OrderFields]: P extends ByFields
                                        ? never
                                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                                }[OrderFields]
                          : 'Error: If you provide "skip", you also need to provide "orderBy"'
                      : ByValid extends True
                        ? {}
                        : {
                              [P in OrderFields]: P extends ByFields
                                  ? never
                                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
                          }[OrderFields]
        >(
            args: SubsetIntersection<T, UsersGroupByArgs, OrderByArg> & InputErrors
        ): {} extends InputErrors ? GetUsersGroupByPayload<T> : PrismaPromise<InputErrors>
    }

    /**
     * The delegate class that acts as a "Promise-like" for Users.
     * Why is this prefixed with `Prisma__`?
     * Because we want to prevent naming conflicts as mentioned in
     * https://github.com/prisma/prisma-client-js/issues/707
     */
    export class Prisma__UsersClient<T, Null = never> implements PrismaPromise<T> {
        [prisma]: true
        private readonly _dmmf
        private readonly _fetcher
        private readonly _queryType
        private readonly _rootField
        private readonly _clientMethod
        private readonly _args
        private readonly _dataPath
        private readonly _errorFormat
        private readonly _measurePerformance?
        private _isList
        private _callsite
        private _requestPromise?
        constructor(
            _dmmf: runtime.DMMFClass,
            _fetcher: PrismaClientFetcher,
            _queryType: 'query' | 'mutation',
            _rootField: string,
            _clientMethod: string,
            _args: any,
            _dataPath: string[],
            _errorFormat: ErrorFormat,
            _measurePerformance?: boolean | undefined,
            _isList?: boolean
        )
        readonly [Symbol.toStringTag]: 'PrismaClientPromise'

        orphans_orphans_created_byTousers<T extends Users$orphans_orphans_created_byTousersArgs = {}>(
            args?: Subset<T, Users$orphans_orphans_created_byTousersArgs>
        ): PrismaPromise<Array<OrphansGetPayload<T>> | Null>

        orphans_orphans_deleted_byTousers<T extends Users$orphans_orphans_deleted_byTousersArgs = {}>(
            args?: Subset<T, Users$orphans_orphans_deleted_byTousersArgs>
        ): PrismaPromise<Array<OrphansGetPayload<T>> | Null>

        sessions<T extends Users$sessionsArgs = {}>(
            args?: Subset<T, Users$sessionsArgs>
        ): PrismaPromise<Array<SessionsGetPayload<T>> | Null>

        settings<T extends Users$settingsArgs = {}>(
            args?: Subset<T, Users$settingsArgs>
        ): PrismaPromise<Array<SettingsGetPayload<T>> | Null>

        sponsors_sponsors_created_byTousers<T extends Users$sponsors_sponsors_created_byTousersArgs = {}>(
            args?: Subset<T, Users$sponsors_sponsors_created_byTousersArgs>
        ): PrismaPromise<Array<SponsorsGetPayload<T>> | Null>

        sponsors_sponsors_deleted_byTousers<T extends Users$sponsors_sponsors_deleted_byTousersArgs = {}>(
            args?: Subset<T, Users$sponsors_sponsors_deleted_byTousersArgs>
        ): PrismaPromise<Array<SponsorsGetPayload<T>> | Null>

        tenants<T extends TenantsArgs = {}>(
            args?: Subset<T, TenantsArgs>
        ): Prisma__TenantsClient<TenantsGetPayload<T> | Null>

        private get _document()
        /**
         * Attaches callbacks for the resolution and/or rejection of the Promise.
         * @param onfulfilled The callback to execute when the Promise is resolved.
         * @param onrejected The callback to execute when the Promise is rejected.
         * @returns A Promise for the completion of which ever callback is executed.
         */
        then<TResult1 = T, TResult2 = never>(
            onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
            onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
        ): Promise<TResult1 | TResult2>
        /**
         * Attaches a callback for only the rejection of the Promise.
         * @param onrejected The callback to execute when the Promise is rejected.
         * @returns A Promise for the completion of the callback.
         */
        catch<TResult = never>(
            onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
        ): Promise<T | TResult>
        /**
         * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
         * resolved value cannot be modified from the callback.
         * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
         * @returns A Promise for the completion of the callback.
         */
        finally(onfinally?: (() => void) | undefined | null): Promise<T>
    }

    // Custom InputTypes

    /**
     * Users base type for findUnique actions
     */
    export type UsersFindUniqueArgsBase = {
        /**
         * Select specific fields to fetch from the Users
         *
         **/
        select?: UsersSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: UsersInclude | null
        /**
         * Filter, which Users to fetch.
         *
         **/
        where: UsersWhereUniqueInput
    }

    /**
     * Users findUnique
     */
    export interface UsersFindUniqueArgs extends UsersFindUniqueArgsBase {
        /**
         * Throw an Error if query returns no results
         * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
         */
        rejectOnNotFound?: RejectOnNotFound
    }

    /**
     * Users findUniqueOrThrow
     */
    export type UsersFindUniqueOrThrowArgs = {
        /**
         * Select specific fields to fetch from the Users
         *
         **/
        select?: UsersSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: UsersInclude | null
        /**
         * Filter, which Users to fetch.
         *
         **/
        where: UsersWhereUniqueInput
    }

    /**
     * Users base type for findFirst actions
     */
    export type UsersFindFirstArgsBase = {
        /**
         * Select specific fields to fetch from the Users
         *
         **/
        select?: UsersSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: UsersInclude | null
        /**
         * Filter, which Users to fetch.
         *
         **/
        where?: UsersWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Users to fetch.
         *
         **/
        orderBy?: Enumerable<UsersOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for searching for Users.
         *
         **/
        cursor?: UsersWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Users from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Users.
         *
         **/
        skip?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
         *
         * Filter by unique combinations of Users.
         *
         **/
        distinct?: Enumerable<UsersScalarFieldEnum>
    }

    /**
     * Users findFirst
     */
    export interface UsersFindFirstArgs extends UsersFindFirstArgsBase {
        /**
         * Throw an Error if query returns no results
         * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
         */
        rejectOnNotFound?: RejectOnNotFound
    }

    /**
     * Users findFirstOrThrow
     */
    export type UsersFindFirstOrThrowArgs = {
        /**
         * Select specific fields to fetch from the Users
         *
         **/
        select?: UsersSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: UsersInclude | null
        /**
         * Filter, which Users to fetch.
         *
         **/
        where?: UsersWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Users to fetch.
         *
         **/
        orderBy?: Enumerable<UsersOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for searching for Users.
         *
         **/
        cursor?: UsersWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Users from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Users.
         *
         **/
        skip?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
         *
         * Filter by unique combinations of Users.
         *
         **/
        distinct?: Enumerable<UsersScalarFieldEnum>
    }

    /**
     * Users findMany
     */
    export type UsersFindManyArgs = {
        /**
         * Select specific fields to fetch from the Users
         *
         **/
        select?: UsersSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: UsersInclude | null
        /**
         * Filter, which Users to fetch.
         *
         **/
        where?: UsersWhereInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
         *
         * Determine the order of Users to fetch.
         *
         **/
        orderBy?: Enumerable<UsersOrderByWithRelationInput>
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
         *
         * Sets the position for listing Users.
         *
         **/
        cursor?: UsersWhereUniqueInput
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Take `±n` Users from the position of the cursor.
         *
         **/
        take?: number
        /**
         * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
         *
         * Skip the first `n` Users.
         *
         **/
        skip?: number
        distinct?: Enumerable<UsersScalarFieldEnum>
    }

    /**
     * Users create
     */
    export type UsersCreateArgs = {
        /**
         * Select specific fields to fetch from the Users
         *
         **/
        select?: UsersSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: UsersInclude | null
        /**
         * The data needed to create a Users.
         *
         **/
        data: XOR<UsersCreateInput, UsersUncheckedCreateInput>
    }

    /**
     * Users createMany
     */
    export type UsersCreateManyArgs = {
        /**
         * The data used to create many Users.
         *
         **/
        data: Enumerable<UsersCreateManyInput>
        skipDuplicates?: boolean
    }

    /**
     * Users update
     */
    export type UsersUpdateArgs = {
        /**
         * Select specific fields to fetch from the Users
         *
         **/
        select?: UsersSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: UsersInclude | null
        /**
         * The data needed to update a Users.
         *
         **/
        data: XOR<UsersUpdateInput, UsersUncheckedUpdateInput>
        /**
         * Choose, which Users to update.
         *
         **/
        where: UsersWhereUniqueInput
    }

    /**
     * Users updateMany
     */
    export type UsersUpdateManyArgs = {
        /**
         * The data used to update Users.
         *
         **/
        data: XOR<UsersUpdateManyMutationInput, UsersUncheckedUpdateManyInput>
        /**
         * Filter which Users to update
         *
         **/
        where?: UsersWhereInput
    }

    /**
     * Users upsert
     */
    export type UsersUpsertArgs = {
        /**
         * Select specific fields to fetch from the Users
         *
         **/
        select?: UsersSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: UsersInclude | null
        /**
         * The filter to search for the Users to update in case it exists.
         *
         **/
        where: UsersWhereUniqueInput
        /**
         * In case the Users found by the `where` argument doesn't exist, create a new Users with this data.
         *
         **/
        create: XOR<UsersCreateInput, UsersUncheckedCreateInput>
        /**
         * In case the Users was found with the provided `where` argument, update it with this data.
         *
         **/
        update: XOR<UsersUpdateInput, UsersUncheckedUpdateInput>
    }

    /**
     * Users delete
     */
    export type UsersDeleteArgs = {
        /**
         * Select specific fields to fetch from the Users
         *
         **/
        select?: UsersSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: UsersInclude | null
        /**
         * Filter which Users to delete.
         *
         **/
        where: UsersWhereUniqueInput
    }

    /**
     * Users deleteMany
     */
    export type UsersDeleteManyArgs = {
        /**
         * Filter which Users to delete
         *
         **/
        where?: UsersWhereInput
    }

    /**
     * Users.orphans_orphans_created_byTousers
     */
    export type Users$orphans_orphans_created_byTousersArgs = {
        /**
         * Select specific fields to fetch from the Orphans
         *
         **/
        select?: OrphansSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: OrphansInclude | null
        where?: OrphansWhereInput
        orderBy?: Enumerable<OrphansOrderByWithRelationInput>
        cursor?: OrphansWhereUniqueInput
        take?: number
        skip?: number
        distinct?: Enumerable<OrphansScalarFieldEnum>
    }

    /**
     * Users.orphans_orphans_deleted_byTousers
     */
    export type Users$orphans_orphans_deleted_byTousersArgs = {
        /**
         * Select specific fields to fetch from the Orphans
         *
         **/
        select?: OrphansSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: OrphansInclude | null
        where?: OrphansWhereInput
        orderBy?: Enumerable<OrphansOrderByWithRelationInput>
        cursor?: OrphansWhereUniqueInput
        take?: number
        skip?: number
        distinct?: Enumerable<OrphansScalarFieldEnum>
    }

    /**
     * Users.sessions
     */
    export type Users$sessionsArgs = {
        /**
         * Select specific fields to fetch from the Sessions
         *
         **/
        select?: SessionsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: SessionsInclude | null
        where?: SessionsWhereInput
        orderBy?: Enumerable<SessionsOrderByWithRelationInput>
        cursor?: SessionsWhereUniqueInput
        take?: number
        skip?: number
        distinct?: Enumerable<SessionsScalarFieldEnum>
    }

    /**
     * Users.settings
     */
    export type Users$settingsArgs = {
        /**
         * Select specific fields to fetch from the Settings
         *
         **/
        select?: SettingsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: SettingsInclude | null
        where?: SettingsWhereInput
        orderBy?: Enumerable<SettingsOrderByWithRelationInput>
        cursor?: SettingsWhereUniqueInput
        take?: number
        skip?: number
        distinct?: Enumerable<SettingsScalarFieldEnum>
    }

    /**
     * Users.sponsors_sponsors_created_byTousers
     */
    export type Users$sponsors_sponsors_created_byTousersArgs = {
        /**
         * Select specific fields to fetch from the Sponsors
         *
         **/
        select?: SponsorsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: SponsorsInclude | null
        where?: SponsorsWhereInput
        orderBy?: Enumerable<SponsorsOrderByWithRelationInput>
        cursor?: SponsorsWhereUniqueInput
        take?: number
        skip?: number
        distinct?: Enumerable<SponsorsScalarFieldEnum>
    }

    /**
     * Users.sponsors_sponsors_deleted_byTousers
     */
    export type Users$sponsors_sponsors_deleted_byTousersArgs = {
        /**
         * Select specific fields to fetch from the Sponsors
         *
         **/
        select?: SponsorsSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: SponsorsInclude | null
        where?: SponsorsWhereInput
        orderBy?: Enumerable<SponsorsOrderByWithRelationInput>
        cursor?: SponsorsWhereUniqueInput
        take?: number
        skip?: number
        distinct?: Enumerable<SponsorsScalarFieldEnum>
    }

    /**
     * Users without action
     */
    export type UsersArgs = {
        /**
         * Select specific fields to fetch from the Users
         *
         **/
        select?: UsersSelect | null
        /**
         * Choose, which related nodes to fetch as well.
         *
         **/
        include?: UsersInclude | null
    }

    /**
     * Enums
     */

    // Based on
    // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

    export const BenefactorsScalarFieldEnum: {
        id: 'id'
        tenant_id: 'tenant_id'
        deleted_at: 'deleted_at'
        created_at: 'created_at'
        updated_at: 'updated_at'
    }

    export type BenefactorsScalarFieldEnum =
        (typeof BenefactorsScalarFieldEnum)[keyof typeof BenefactorsScalarFieldEnum]

    export const CacheScalarFieldEnum: {
        key: 'key'
        value: 'value'
        expiration: 'expiration'
    }

    export type CacheScalarFieldEnum = (typeof CacheScalarFieldEnum)[keyof typeof CacheScalarFieldEnum]

    export const Cache_locksScalarFieldEnum: {
        key: 'key'
        owner: 'owner'
        expiration: 'expiration'
    }

    export type Cache_locksScalarFieldEnum =
        (typeof Cache_locksScalarFieldEnum)[keyof typeof Cache_locksScalarFieldEnum]

    export const DomainsScalarFieldEnum: {
        id: 'id'
        domain: 'domain'
        tenant_id: 'tenant_id'
        created_at: 'created_at'
        updated_at: 'updated_at'
    }

    export type DomainsScalarFieldEnum = (typeof DomainsScalarFieldEnum)[keyof typeof DomainsScalarFieldEnum]

    export const FamiliesScalarFieldEnum: {
        id: 'id'
        name: 'name'
        report: 'report'
        tenant_id: 'tenant_id'
        created_at: 'created_at'
        updated_at: 'updated_at'
    }

    export type FamiliesScalarFieldEnum = (typeof FamiliesScalarFieldEnum)[keyof typeof FamiliesScalarFieldEnum]

    export const Family_furnishingScalarFieldEnum: {
        id: 'id'
        family_id: 'family_id'
        furnishing_id: 'furnishing_id'
        value: 'value'
    }

    export type Family_furnishingScalarFieldEnum =
        (typeof Family_furnishingScalarFieldEnum)[keyof typeof Family_furnishingScalarFieldEnum]

    export const Family_housingScalarFieldEnum: {
        id: 'id'
        family_id: 'family_id'
        housing_id: 'housing_id'
        value: 'value'
    }

    export type Family_housingScalarFieldEnum =
        (typeof Family_housingScalarFieldEnum)[keyof typeof Family_housingScalarFieldEnum]

    export const Family_sponsorshipScalarFieldEnum: {
        id: 'id'
        family_id: 'family_id'
        type: 'type'
        value: 'value'
        tenant_id: 'tenant_id'
        created_at: 'created_at'
        updated_at: 'updated_at'
    }

    export type Family_sponsorshipScalarFieldEnum =
        (typeof Family_sponsorshipScalarFieldEnum)[keyof typeof Family_sponsorshipScalarFieldEnum]

    export const FurnishingsScalarFieldEnum: {
        id: 'id'
        name: 'name'
    }

    export type FurnishingsScalarFieldEnum =
        (typeof FurnishingsScalarFieldEnum)[keyof typeof FurnishingsScalarFieldEnum]

    export const HousingsScalarFieldEnum: {
        id: 'id'
        name: 'name'
    }

    export type HousingsScalarFieldEnum = (typeof HousingsScalarFieldEnum)[keyof typeof HousingsScalarFieldEnum]

    export const Income_sponsorScalarFieldEnum: {
        id: 'id'
        income_id: 'income_id'
        sponsor_id: 'sponsor_id'
        tenant_id: 'tenant_id'
        value: 'value'
        created_at: 'created_at'
        updated_at: 'updated_at'
    }

    export type Income_sponsorScalarFieldEnum =
        (typeof Income_sponsorScalarFieldEnum)[keyof typeof Income_sponsorScalarFieldEnum]

    export const IncomesScalarFieldEnum: {
        id: 'id'
        name: 'name'
    }

    export type IncomesScalarFieldEnum = (typeof IncomesScalarFieldEnum)[keyof typeof IncomesScalarFieldEnum]

    export const JsonNullValueFilter: {
        DbNull: typeof DbNull
        JsonNull: typeof JsonNull
        AnyNull: typeof AnyNull
    }

    export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]

    export const JsonNullValueInput: {
        JsonNull: typeof JsonNull
    }

    export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]

    export const MediaScalarFieldEnum: {
        id: 'id'
        model_type: 'model_type'
        model_id: 'model_id'
        uuid: 'uuid'
        collection_name: 'collection_name'
        name: 'name'
        file_name: 'file_name'
        mime_type: 'mime_type'
        disk: 'disk'
        conversions_disk: 'conversions_disk'
        size: 'size'
        manipulations: 'manipulations'
        custom_properties: 'custom_properties'
        generated_conversions: 'generated_conversions'
        responsive_images: 'responsive_images'
        order_column: 'order_column'
        created_at: 'created_at'
        updated_at: 'updated_at'
    }

    export type MediaScalarFieldEnum = (typeof MediaScalarFieldEnum)[keyof typeof MediaScalarFieldEnum]

    export const Model_has_permissionsScalarFieldEnum: {
        permission_id: 'permission_id'
        model_type: 'model_type'
        model_uuid: 'model_uuid'
    }

    export type Model_has_permissionsScalarFieldEnum =
        (typeof Model_has_permissionsScalarFieldEnum)[keyof typeof Model_has_permissionsScalarFieldEnum]

    export const Model_has_rolesScalarFieldEnum: {
        role_id: 'role_id'
        model_type: 'model_type'
        model_uuid: 'model_uuid'
    }

    export type Model_has_rolesScalarFieldEnum =
        (typeof Model_has_rolesScalarFieldEnum)[keyof typeof Model_has_rolesScalarFieldEnum]

    export const NullableJsonNullValueInput: {
        DbNull: typeof DbNull
        JsonNull: typeof JsonNull
    }

    export type NullableJsonNullValueInput =
        (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]

    export const Orphan_sponsorshipScalarFieldEnum: {
        id: 'id'
        orphan_id: 'orphan_id'
        type: 'type'
        value: 'value'
        tenant_id: 'tenant_id'
        created_at: 'created_at'
        updated_at: 'updated_at'
    }

    export type Orphan_sponsorshipScalarFieldEnum =
        (typeof Orphan_sponsorshipScalarFieldEnum)[keyof typeof Orphan_sponsorshipScalarFieldEnum]

    export const OrphansScalarFieldEnum: {
        id: 'id'
        first_name: 'first_name'
        last_name: 'last_name'
        birth_date: 'birth_date'
        family_status: 'family_status'
        health_status: 'health_status'
        academic_level: 'academic_level'
        shoes_size: 'shoes_size'
        pants_size: 'pants_size'
        shirt_size: 'shirt_size'
        note: 'note'
        tenant_id: 'tenant_id'
        family_id: 'family_id'
        created_by: 'created_by'
        deleted_by: 'deleted_by'
        created_at: 'created_at'
        updated_at: 'updated_at'
    }

    export type OrphansScalarFieldEnum = (typeof OrphansScalarFieldEnum)[keyof typeof OrphansScalarFieldEnum]

    export const Password_reset_tokensScalarFieldEnum: {
        email: 'email'
        token: 'token'
        created_at: 'created_at'
    }

    export type Password_reset_tokensScalarFieldEnum =
        (typeof Password_reset_tokensScalarFieldEnum)[keyof typeof Password_reset_tokensScalarFieldEnum]

    export const PermissionsScalarFieldEnum: {
        uuid: 'uuid'
        name: 'name'
        guard_name: 'guard_name'
        created_at: 'created_at'
        updated_at: 'updated_at'
    }

    export type PermissionsScalarFieldEnum =
        (typeof PermissionsScalarFieldEnum)[keyof typeof PermissionsScalarFieldEnum]

    export const Personal_access_tokensScalarFieldEnum: {
        id: 'id'
        tokenable_type: 'tokenable_type'
        tokenable_id: 'tokenable_id'
        name: 'name'
        token: 'token'
        abilities: 'abilities'
        last_used_at: 'last_used_at'
        expires_at: 'expires_at'
        created_at: 'created_at'
        updated_at: 'updated_at'
    }

    export type Personal_access_tokensScalarFieldEnum =
        (typeof Personal_access_tokensScalarFieldEnum)[keyof typeof Personal_access_tokensScalarFieldEnum]

    export const QueryMode: {
        default: 'default'
        insensitive: 'insensitive'
    }

    export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]

    export const Role_has_permissionsScalarFieldEnum: {
        permission_id: 'permission_id'
        role_id: 'role_id'
    }

    export type Role_has_permissionsScalarFieldEnum =
        (typeof Role_has_permissionsScalarFieldEnum)[keyof typeof Role_has_permissionsScalarFieldEnum]

    export const RolesScalarFieldEnum: {
        uuid: 'uuid'
        name: 'name'
        guard_name: 'guard_name'
        created_at: 'created_at'
        updated_at: 'updated_at'
    }

    export type RolesScalarFieldEnum = (typeof RolesScalarFieldEnum)[keyof typeof RolesScalarFieldEnum]

    export const Second_sponsorsScalarFieldEnum: {
        id: 'id'
        first_name: 'first_name'
        last_name: 'last_name'
        degree_of_kinship: 'degree_of_kinship'
        phone_number: 'phone_number'
        address: 'address'
        income: 'income'
        family_id: 'family_id'
        tenant_id: 'tenant_id'
        deleted_at: 'deleted_at'
        created_at: 'created_at'
        updated_at: 'updated_at'
    }

    export type Second_sponsorsScalarFieldEnum =
        (typeof Second_sponsorsScalarFieldEnum)[keyof typeof Second_sponsorsScalarFieldEnum]

    export const SessionsScalarFieldEnum: {
        id: 'id'
        user_id: 'user_id'
        ip_address: 'ip_address'
        user_agent: 'user_agent'
        payload: 'payload'
        last_activity: 'last_activity'
    }

    export type SessionsScalarFieldEnum = (typeof SessionsScalarFieldEnum)[keyof typeof SessionsScalarFieldEnum]

    export const SettingsScalarFieldEnum: {
        id: 'id'
        user_id: 'user_id'
        theme: 'theme'
        color_scheme: 'color_scheme'
        layout: 'layout'
        appearance: 'appearance'
        notifications: 'notifications'
        created_at: 'created_at'
        updated_at: 'updated_at'
    }

    export type SettingsScalarFieldEnum = (typeof SettingsScalarFieldEnum)[keyof typeof SettingsScalarFieldEnum]

    export const SortOrder: {
        asc: 'asc'
        desc: 'desc'
    }

    export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]

    export const Sponsor_sponsorshipScalarFieldEnum: {
        id: 'id'
        sponsor_id: 'sponsor_id'
        type: 'type'
        value: 'value'
        tenant_id: 'tenant_id'
        created_at: 'created_at'
        updated_at: 'updated_at'
    }

    export type Sponsor_sponsorshipScalarFieldEnum =
        (typeof Sponsor_sponsorshipScalarFieldEnum)[keyof typeof Sponsor_sponsorshipScalarFieldEnum]

    export const SponsorsScalarFieldEnum: {
        id: 'id'
        zone_id: 'zone_id'
        file_number: 'file_number'
        start_date: 'start_date'
        name: 'name'
        address: 'address'
        phone_number: 'phone_number'
        sponsorship_type: 'sponsorship_type'
        birth_date: 'birth_date'
        father_name: 'father_name'
        mother_name: 'mother_name'
        birth_certificate_number: 'birth_certificate_number'
        academic_level: 'academic_level'
        function: 'function'
        health_status: 'health_status'
        diploma: 'diploma'
        card_number: 'card_number'
        tenant_id: 'tenant_id'
        created_by: 'created_by'
        deleted_by: 'deleted_by'
        deleted_at: 'deleted_at'
        created_at: 'created_at'
        updated_at: 'updated_at'
    }

    export type SponsorsScalarFieldEnum = (typeof SponsorsScalarFieldEnum)[keyof typeof SponsorsScalarFieldEnum]

    export const SponsorshipsScalarFieldEnum: {
        id: 'id'
        type: 'type'
        name: 'name'
        tenant_id: 'tenant_id'
        deleted_at: 'deleted_at'
        created_at: 'created_at'
        updated_at: 'updated_at'
    }

    export type SponsorshipsScalarFieldEnum =
        (typeof SponsorshipsScalarFieldEnum)[keyof typeof SponsorshipsScalarFieldEnum]

    export const SpousesScalarFieldEnum: {
        id: 'id'
        first_name: 'first_name'
        last_name: 'last_name'
        birth_date: 'birth_date'
        death_date: 'death_date'
        function: 'function'
        income: 'income'
        family_id: 'family_id'
        tenant_id: 'tenant_id'
        created_at: 'created_at'
        updated_at: 'updated_at'
    }

    export type SpousesScalarFieldEnum = (typeof SpousesScalarFieldEnum)[keyof typeof SpousesScalarFieldEnum]

    export const TenantsScalarFieldEnum: {
        id: 'id'
        data: 'data'
        created_at: 'created_at'
        updated_at: 'updated_at'
    }

    export type TenantsScalarFieldEnum = (typeof TenantsScalarFieldEnum)[keyof typeof TenantsScalarFieldEnum]

    export const TransactionIsolationLevel: {
        ReadUncommitted: 'ReadUncommitted'
        ReadCommitted: 'ReadCommitted'
        RepeatableRead: 'RepeatableRead'
        Serializable: 'Serializable'
    }

    export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]

    export const UsersScalarFieldEnum: {
        id: 'id'
        first_name: 'first_name'
        last_name: 'last_name'
        phone: 'phone'
        email: 'email'
        email_verified_at: 'email_verified_at'
        password: 'password'
        remember_token: 'remember_token'
        tenant_id: 'tenant_id'
        created_at: 'created_at'
        updated_at: 'updated_at'
    }

    export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]

    /**
     * Deep Input Types
     */

    export type BenefactorsWhereInput = {
        AND?: Enumerable<BenefactorsWhereInput>
        OR?: Enumerable<BenefactorsWhereInput>
        NOT?: Enumerable<BenefactorsWhereInput>
        id?: UuidFilter | string
        tenant_id?: StringFilter | string
        deleted_at?: DateTimeNullableFilter | Date | string | null
        created_at?: DateTimeNullableFilter | Date | string | null
        updated_at?: DateTimeNullableFilter | Date | string | null
        tenants?: XOR<TenantsRelationFilter, TenantsWhereInput>
    }

    export type BenefactorsOrderByWithRelationInput = {
        id?: SortOrder
        tenant_id?: SortOrder
        deleted_at?: SortOrder
        created_at?: SortOrder
        updated_at?: SortOrder
        tenants?: TenantsOrderByWithRelationInput
    }

    export type BenefactorsWhereUniqueInput = {
        id?: string
    }

    export type BenefactorsOrderByWithAggregationInput = {
        id?: SortOrder
        tenant_id?: SortOrder
        deleted_at?: SortOrder
        created_at?: SortOrder
        updated_at?: SortOrder
        _count?: BenefactorsCountOrderByAggregateInput
        _max?: BenefactorsMaxOrderByAggregateInput
        _min?: BenefactorsMinOrderByAggregateInput
    }

    export type BenefactorsScalarWhereWithAggregatesInput = {
        AND?: Enumerable<BenefactorsScalarWhereWithAggregatesInput>
        OR?: Enumerable<BenefactorsScalarWhereWithAggregatesInput>
        NOT?: Enumerable<BenefactorsScalarWhereWithAggregatesInput>
        id?: UuidWithAggregatesFilter | string
        tenant_id?: StringWithAggregatesFilter | string
        deleted_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
        created_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
        updated_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    }

    export type CacheWhereInput = {
        AND?: Enumerable<CacheWhereInput>
        OR?: Enumerable<CacheWhereInput>
        NOT?: Enumerable<CacheWhereInput>
        key?: StringFilter | string
        value?: StringFilter | string
        expiration?: IntFilter | number
    }

    export type CacheOrderByWithRelationInput = {
        key?: SortOrder
        value?: SortOrder
        expiration?: SortOrder
    }

    export type CacheWhereUniqueInput = {
        key?: string
    }

    export type CacheOrderByWithAggregationInput = {
        key?: SortOrder
        value?: SortOrder
        expiration?: SortOrder
        _count?: CacheCountOrderByAggregateInput
        _avg?: CacheAvgOrderByAggregateInput
        _max?: CacheMaxOrderByAggregateInput
        _min?: CacheMinOrderByAggregateInput
        _sum?: CacheSumOrderByAggregateInput
    }

    export type CacheScalarWhereWithAggregatesInput = {
        AND?: Enumerable<CacheScalarWhereWithAggregatesInput>
        OR?: Enumerable<CacheScalarWhereWithAggregatesInput>
        NOT?: Enumerable<CacheScalarWhereWithAggregatesInput>
        key?: StringWithAggregatesFilter | string
        value?: StringWithAggregatesFilter | string
        expiration?: IntWithAggregatesFilter | number
    }

    export type Cache_locksWhereInput = {
        AND?: Enumerable<Cache_locksWhereInput>
        OR?: Enumerable<Cache_locksWhereInput>
        NOT?: Enumerable<Cache_locksWhereInput>
        key?: StringFilter | string
        owner?: StringFilter | string
        expiration?: IntFilter | number
    }

    export type Cache_locksOrderByWithRelationInput = {
        key?: SortOrder
        owner?: SortOrder
        expiration?: SortOrder
    }

    export type Cache_locksWhereUniqueInput = {
        key?: string
    }

    export type Cache_locksOrderByWithAggregationInput = {
        key?: SortOrder
        owner?: SortOrder
        expiration?: SortOrder
        _count?: Cache_locksCountOrderByAggregateInput
        _avg?: Cache_locksAvgOrderByAggregateInput
        _max?: Cache_locksMaxOrderByAggregateInput
        _min?: Cache_locksMinOrderByAggregateInput
        _sum?: Cache_locksSumOrderByAggregateInput
    }

    export type Cache_locksScalarWhereWithAggregatesInput = {
        AND?: Enumerable<Cache_locksScalarWhereWithAggregatesInput>
        OR?: Enumerable<Cache_locksScalarWhereWithAggregatesInput>
        NOT?: Enumerable<Cache_locksScalarWhereWithAggregatesInput>
        key?: StringWithAggregatesFilter | string
        owner?: StringWithAggregatesFilter | string
        expiration?: IntWithAggregatesFilter | number
    }

    export type DomainsWhereInput = {
        AND?: Enumerable<DomainsWhereInput>
        OR?: Enumerable<DomainsWhereInput>
        NOT?: Enumerable<DomainsWhereInput>
        id?: UuidFilter | string
        domain?: StringFilter | string
        tenant_id?: StringFilter | string
        created_at?: DateTimeNullableFilter | Date | string | null
        updated_at?: DateTimeNullableFilter | Date | string | null
        tenants?: XOR<TenantsRelationFilter, TenantsWhereInput>
    }

    export type DomainsOrderByWithRelationInput = {
        id?: SortOrder
        domain?: SortOrder
        tenant_id?: SortOrder
        created_at?: SortOrder
        updated_at?: SortOrder
        tenants?: TenantsOrderByWithRelationInput
    }

    export type DomainsWhereUniqueInput = {
        id?: string
    }

    export type DomainsOrderByWithAggregationInput = {
        id?: SortOrder
        domain?: SortOrder
        tenant_id?: SortOrder
        created_at?: SortOrder
        updated_at?: SortOrder
        _count?: DomainsCountOrderByAggregateInput
        _max?: DomainsMaxOrderByAggregateInput
        _min?: DomainsMinOrderByAggregateInput
    }

    export type DomainsScalarWhereWithAggregatesInput = {
        AND?: Enumerable<DomainsScalarWhereWithAggregatesInput>
        OR?: Enumerable<DomainsScalarWhereWithAggregatesInput>
        NOT?: Enumerable<DomainsScalarWhereWithAggregatesInput>
        id?: UuidWithAggregatesFilter | string
        domain?: StringWithAggregatesFilter | string
        tenant_id?: StringWithAggregatesFilter | string
        created_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
        updated_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    }

    export type FamiliesWhereInput = {
        AND?: Enumerable<FamiliesWhereInput>
        OR?: Enumerable<FamiliesWhereInput>
        NOT?: Enumerable<FamiliesWhereInput>
        id?: UuidFilter | string
        name?: StringFilter | string
        report?: StringFilter | string
        tenant_id?: StringFilter | string
        created_at?: DateTimeNullableFilter | Date | string | null
        updated_at?: DateTimeNullableFilter | Date | string | null
        tenants?: XOR<TenantsRelationFilter, TenantsWhereInput>
        family_furnishing?: Family_furnishingListRelationFilter
        family_housing?: Family_housingListRelationFilter
        family_sponsorship?: Family_sponsorshipListRelationFilter
        orphans?: OrphansListRelationFilter
        second_sponsors?: Second_sponsorsListRelationFilter
        spouses?: SpousesListRelationFilter
    }

    export type FamiliesOrderByWithRelationInput = {
        id?: SortOrder
        name?: SortOrder
        report?: SortOrder
        tenant_id?: SortOrder
        created_at?: SortOrder
        updated_at?: SortOrder
        tenants?: TenantsOrderByWithRelationInput
        family_furnishing?: Family_furnishingOrderByRelationAggregateInput
        family_housing?: Family_housingOrderByRelationAggregateInput
        family_sponsorship?: Family_sponsorshipOrderByRelationAggregateInput
        orphans?: OrphansOrderByRelationAggregateInput
        second_sponsors?: Second_sponsorsOrderByRelationAggregateInput
        spouses?: SpousesOrderByRelationAggregateInput
    }

    export type FamiliesWhereUniqueInput = {
        id?: string
    }

    export type FamiliesOrderByWithAggregationInput = {
        id?: SortOrder
        name?: SortOrder
        report?: SortOrder
        tenant_id?: SortOrder
        created_at?: SortOrder
        updated_at?: SortOrder
        _count?: FamiliesCountOrderByAggregateInput
        _max?: FamiliesMaxOrderByAggregateInput
        _min?: FamiliesMinOrderByAggregateInput
    }

    export type FamiliesScalarWhereWithAggregatesInput = {
        AND?: Enumerable<FamiliesScalarWhereWithAggregatesInput>
        OR?: Enumerable<FamiliesScalarWhereWithAggregatesInput>
        NOT?: Enumerable<FamiliesScalarWhereWithAggregatesInput>
        id?: UuidWithAggregatesFilter | string
        name?: StringWithAggregatesFilter | string
        report?: StringWithAggregatesFilter | string
        tenant_id?: StringWithAggregatesFilter | string
        created_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
        updated_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    }

    export type Family_furnishingWhereInput = {
        AND?: Enumerable<Family_furnishingWhereInput>
        OR?: Enumerable<Family_furnishingWhereInput>
        NOT?: Enumerable<Family_furnishingWhereInput>
        id?: UuidFilter | string
        family_id?: UuidFilter | string
        furnishing_id?: UuidFilter | string
        value?: StringFilter | string
        families?: XOR<FamiliesRelationFilter, FamiliesWhereInput>
        furnishings?: XOR<FurnishingsRelationFilter, FurnishingsWhereInput>
    }

    export type Family_furnishingOrderByWithRelationInput = {
        id?: SortOrder
        family_id?: SortOrder
        furnishing_id?: SortOrder
        value?: SortOrder
        families?: FamiliesOrderByWithRelationInput
        furnishings?: FurnishingsOrderByWithRelationInput
    }

    export type Family_furnishingWhereUniqueInput = {
        id?: string
    }

    export type Family_furnishingOrderByWithAggregationInput = {
        id?: SortOrder
        family_id?: SortOrder
        furnishing_id?: SortOrder
        value?: SortOrder
        _count?: Family_furnishingCountOrderByAggregateInput
        _max?: Family_furnishingMaxOrderByAggregateInput
        _min?: Family_furnishingMinOrderByAggregateInput
    }

    export type Family_furnishingScalarWhereWithAggregatesInput = {
        AND?: Enumerable<Family_furnishingScalarWhereWithAggregatesInput>
        OR?: Enumerable<Family_furnishingScalarWhereWithAggregatesInput>
        NOT?: Enumerable<Family_furnishingScalarWhereWithAggregatesInput>
        id?: UuidWithAggregatesFilter | string
        family_id?: UuidWithAggregatesFilter | string
        furnishing_id?: UuidWithAggregatesFilter | string
        value?: StringWithAggregatesFilter | string
    }

    export type Family_housingWhereInput = {
        AND?: Enumerable<Family_housingWhereInput>
        OR?: Enumerable<Family_housingWhereInput>
        NOT?: Enumerable<Family_housingWhereInput>
        id?: UuidFilter | string
        family_id?: UuidFilter | string
        housing_id?: UuidFilter | string
        value?: StringFilter | string
        families?: XOR<FamiliesRelationFilter, FamiliesWhereInput>
        housings?: XOR<HousingsRelationFilter, HousingsWhereInput>
    }

    export type Family_housingOrderByWithRelationInput = {
        id?: SortOrder
        family_id?: SortOrder
        housing_id?: SortOrder
        value?: SortOrder
        families?: FamiliesOrderByWithRelationInput
        housings?: HousingsOrderByWithRelationInput
    }

    export type Family_housingWhereUniqueInput = {
        id?: string
    }

    export type Family_housingOrderByWithAggregationInput = {
        id?: SortOrder
        family_id?: SortOrder
        housing_id?: SortOrder
        value?: SortOrder
        _count?: Family_housingCountOrderByAggregateInput
        _max?: Family_housingMaxOrderByAggregateInput
        _min?: Family_housingMinOrderByAggregateInput
    }

    export type Family_housingScalarWhereWithAggregatesInput = {
        AND?: Enumerable<Family_housingScalarWhereWithAggregatesInput>
        OR?: Enumerable<Family_housingScalarWhereWithAggregatesInput>
        NOT?: Enumerable<Family_housingScalarWhereWithAggregatesInput>
        id?: UuidWithAggregatesFilter | string
        family_id?: UuidWithAggregatesFilter | string
        housing_id?: UuidWithAggregatesFilter | string
        value?: StringWithAggregatesFilter | string
    }

    export type Family_sponsorshipWhereInput = {
        AND?: Enumerable<Family_sponsorshipWhereInput>
        OR?: Enumerable<Family_sponsorshipWhereInput>
        NOT?: Enumerable<Family_sponsorshipWhereInput>
        id?: UuidFilter | string
        family_id?: UuidFilter | string
        type?: Enumfamily_sponsorship_typeFilter | family_sponsorship_type
        value?: StringFilter | string
        tenant_id?: StringFilter | string
        created_at?: DateTimeNullableFilter | Date | string | null
        updated_at?: DateTimeNullableFilter | Date | string | null
        families?: XOR<FamiliesRelationFilter, FamiliesWhereInput>
        tenants?: XOR<TenantsRelationFilter, TenantsWhereInput>
    }

    export type Family_sponsorshipOrderByWithRelationInput = {
        id?: SortOrder
        family_id?: SortOrder
        type?: SortOrder
        value?: SortOrder
        tenant_id?: SortOrder
        created_at?: SortOrder
        updated_at?: SortOrder
        families?: FamiliesOrderByWithRelationInput
        tenants?: TenantsOrderByWithRelationInput
    }

    export type Family_sponsorshipWhereUniqueInput = {
        id?: string
    }

    export type Family_sponsorshipOrderByWithAggregationInput = {
        id?: SortOrder
        family_id?: SortOrder
        type?: SortOrder
        value?: SortOrder
        tenant_id?: SortOrder
        created_at?: SortOrder
        updated_at?: SortOrder
        _count?: Family_sponsorshipCountOrderByAggregateInput
        _max?: Family_sponsorshipMaxOrderByAggregateInput
        _min?: Family_sponsorshipMinOrderByAggregateInput
    }

    export type Family_sponsorshipScalarWhereWithAggregatesInput = {
        AND?: Enumerable<Family_sponsorshipScalarWhereWithAggregatesInput>
        OR?: Enumerable<Family_sponsorshipScalarWhereWithAggregatesInput>
        NOT?: Enumerable<Family_sponsorshipScalarWhereWithAggregatesInput>
        id?: UuidWithAggregatesFilter | string
        family_id?: UuidWithAggregatesFilter | string
        type?: Enumfamily_sponsorship_typeWithAggregatesFilter | family_sponsorship_type
        value?: StringWithAggregatesFilter | string
        tenant_id?: StringWithAggregatesFilter | string
        created_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
        updated_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    }

    export type FurnishingsWhereInput = {
        AND?: Enumerable<FurnishingsWhereInput>
        OR?: Enumerable<FurnishingsWhereInput>
        NOT?: Enumerable<FurnishingsWhereInput>
        id?: UuidFilter | string
        name?: StringFilter | string
        family_furnishing?: Family_furnishingListRelationFilter
    }

    export type FurnishingsOrderByWithRelationInput = {
        id?: SortOrder
        name?: SortOrder
        family_furnishing?: Family_furnishingOrderByRelationAggregateInput
    }

    export type FurnishingsWhereUniqueInput = {
        id?: string
    }

    export type FurnishingsOrderByWithAggregationInput = {
        id?: SortOrder
        name?: SortOrder
        _count?: FurnishingsCountOrderByAggregateInput
        _max?: FurnishingsMaxOrderByAggregateInput
        _min?: FurnishingsMinOrderByAggregateInput
    }

    export type FurnishingsScalarWhereWithAggregatesInput = {
        AND?: Enumerable<FurnishingsScalarWhereWithAggregatesInput>
        OR?: Enumerable<FurnishingsScalarWhereWithAggregatesInput>
        NOT?: Enumerable<FurnishingsScalarWhereWithAggregatesInput>
        id?: UuidWithAggregatesFilter | string
        name?: StringWithAggregatesFilter | string
    }

    export type HousingsWhereInput = {
        AND?: Enumerable<HousingsWhereInput>
        OR?: Enumerable<HousingsWhereInput>
        NOT?: Enumerable<HousingsWhereInput>
        id?: UuidFilter | string
        name?: StringFilter | string
        family_housing?: Family_housingListRelationFilter
    }

    export type HousingsOrderByWithRelationInput = {
        id?: SortOrder
        name?: SortOrder
        family_housing?: Family_housingOrderByRelationAggregateInput
    }

    export type HousingsWhereUniqueInput = {
        id?: string
    }

    export type HousingsOrderByWithAggregationInput = {
        id?: SortOrder
        name?: SortOrder
        _count?: HousingsCountOrderByAggregateInput
        _max?: HousingsMaxOrderByAggregateInput
        _min?: HousingsMinOrderByAggregateInput
    }

    export type HousingsScalarWhereWithAggregatesInput = {
        AND?: Enumerable<HousingsScalarWhereWithAggregatesInput>
        OR?: Enumerable<HousingsScalarWhereWithAggregatesInput>
        NOT?: Enumerable<HousingsScalarWhereWithAggregatesInput>
        id?: UuidWithAggregatesFilter | string
        name?: StringWithAggregatesFilter | string
    }

    export type Income_sponsorWhereInput = {
        AND?: Enumerable<Income_sponsorWhereInput>
        OR?: Enumerable<Income_sponsorWhereInput>
        NOT?: Enumerable<Income_sponsorWhereInput>
        id?: UuidFilter | string
        income_id?: UuidFilter | string
        sponsor_id?: UuidFilter | string
        tenant_id?: StringFilter | string
        value?: FloatFilter | number
        created_at?: DateTimeNullableFilter | Date | string | null
        updated_at?: DateTimeNullableFilter | Date | string | null
        incomes?: XOR<IncomesRelationFilter, IncomesWhereInput>
        sponsors?: XOR<SponsorsRelationFilter, SponsorsWhereInput>
        tenants?: XOR<TenantsRelationFilter, TenantsWhereInput>
    }

    export type Income_sponsorOrderByWithRelationInput = {
        id?: SortOrder
        income_id?: SortOrder
        sponsor_id?: SortOrder
        tenant_id?: SortOrder
        value?: SortOrder
        created_at?: SortOrder
        updated_at?: SortOrder
        incomes?: IncomesOrderByWithRelationInput
        sponsors?: SponsorsOrderByWithRelationInput
        tenants?: TenantsOrderByWithRelationInput
    }

    export type Income_sponsorWhereUniqueInput = {
        id?: string
    }

    export type Income_sponsorOrderByWithAggregationInput = {
        id?: SortOrder
        income_id?: SortOrder
        sponsor_id?: SortOrder
        tenant_id?: SortOrder
        value?: SortOrder
        created_at?: SortOrder
        updated_at?: SortOrder
        _count?: Income_sponsorCountOrderByAggregateInput
        _avg?: Income_sponsorAvgOrderByAggregateInput
        _max?: Income_sponsorMaxOrderByAggregateInput
        _min?: Income_sponsorMinOrderByAggregateInput
        _sum?: Income_sponsorSumOrderByAggregateInput
    }

    export type Income_sponsorScalarWhereWithAggregatesInput = {
        AND?: Enumerable<Income_sponsorScalarWhereWithAggregatesInput>
        OR?: Enumerable<Income_sponsorScalarWhereWithAggregatesInput>
        NOT?: Enumerable<Income_sponsorScalarWhereWithAggregatesInput>
        id?: UuidWithAggregatesFilter | string
        income_id?: UuidWithAggregatesFilter | string
        sponsor_id?: UuidWithAggregatesFilter | string
        tenant_id?: StringWithAggregatesFilter | string
        value?: FloatWithAggregatesFilter | number
        created_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
        updated_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    }

    export type IncomesWhereInput = {
        AND?: Enumerable<IncomesWhereInput>
        OR?: Enumerable<IncomesWhereInput>
        NOT?: Enumerable<IncomesWhereInput>
        id?: UuidFilter | string
        name?: StringFilter | string
        income_sponsor?: Income_sponsorListRelationFilter
    }

    export type IncomesOrderByWithRelationInput = {
        id?: SortOrder
        name?: SortOrder
        income_sponsor?: Income_sponsorOrderByRelationAggregateInput
    }

    export type IncomesWhereUniqueInput = {
        id?: string
    }

    export type IncomesOrderByWithAggregationInput = {
        id?: SortOrder
        name?: SortOrder
        _count?: IncomesCountOrderByAggregateInput
        _max?: IncomesMaxOrderByAggregateInput
        _min?: IncomesMinOrderByAggregateInput
    }

    export type IncomesScalarWhereWithAggregatesInput = {
        AND?: Enumerable<IncomesScalarWhereWithAggregatesInput>
        OR?: Enumerable<IncomesScalarWhereWithAggregatesInput>
        NOT?: Enumerable<IncomesScalarWhereWithAggregatesInput>
        id?: UuidWithAggregatesFilter | string
        name?: StringWithAggregatesFilter | string
    }

    export type MediaWhereInput = {
        AND?: Enumerable<MediaWhereInput>
        OR?: Enumerable<MediaWhereInput>
        NOT?: Enumerable<MediaWhereInput>
        id?: UuidFilter | string
        model_type?: StringFilter | string
        model_id?: BigIntFilter | bigint | number
        uuid?: UuidNullableFilter | string | null
        collection_name?: StringFilter | string
        name?: StringFilter | string
        file_name?: StringFilter | string
        mime_type?: StringNullableFilter | string | null
        disk?: StringFilter | string
        conversions_disk?: StringNullableFilter | string | null
        size?: BigIntFilter | bigint | number
        manipulations?: JsonFilter
        custom_properties?: JsonFilter
        generated_conversions?: JsonFilter
        responsive_images?: JsonFilter
        order_column?: IntNullableFilter | number | null
        created_at?: DateTimeNullableFilter | Date | string | null
        updated_at?: DateTimeNullableFilter | Date | string | null
    }

    export type MediaOrderByWithRelationInput = {
        id?: SortOrder
        model_type?: SortOrder
        model_id?: SortOrder
        uuid?: SortOrder
        collection_name?: SortOrder
        name?: SortOrder
        file_name?: SortOrder
        mime_type?: SortOrder
        disk?: SortOrder
        conversions_disk?: SortOrder
        size?: SortOrder
        manipulations?: SortOrder
        custom_properties?: SortOrder
        generated_conversions?: SortOrder
        responsive_images?: SortOrder
        order_column?: SortOrder
        created_at?: SortOrder
        updated_at?: SortOrder
    }

    export type MediaWhereUniqueInput = {
        id?: string
    }

    export type MediaOrderByWithAggregationInput = {
        id?: SortOrder
        model_type?: SortOrder
        model_id?: SortOrder
        uuid?: SortOrder
        collection_name?: SortOrder
        name?: SortOrder
        file_name?: SortOrder
        mime_type?: SortOrder
        disk?: SortOrder
        conversions_disk?: SortOrder
        size?: SortOrder
        manipulations?: SortOrder
        custom_properties?: SortOrder
        generated_conversions?: SortOrder
        responsive_images?: SortOrder
        order_column?: SortOrder
        created_at?: SortOrder
        updated_at?: SortOrder
        _count?: MediaCountOrderByAggregateInput
        _avg?: MediaAvgOrderByAggregateInput
        _max?: MediaMaxOrderByAggregateInput
        _min?: MediaMinOrderByAggregateInput
        _sum?: MediaSumOrderByAggregateInput
    }

    export type MediaScalarWhereWithAggregatesInput = {
        AND?: Enumerable<MediaScalarWhereWithAggregatesInput>
        OR?: Enumerable<MediaScalarWhereWithAggregatesInput>
        NOT?: Enumerable<MediaScalarWhereWithAggregatesInput>
        id?: UuidWithAggregatesFilter | string
        model_type?: StringWithAggregatesFilter | string
        model_id?: BigIntWithAggregatesFilter | bigint | number
        uuid?: UuidNullableWithAggregatesFilter | string | null
        collection_name?: StringWithAggregatesFilter | string
        name?: StringWithAggregatesFilter | string
        file_name?: StringWithAggregatesFilter | string
        mime_type?: StringNullableWithAggregatesFilter | string | null
        disk?: StringWithAggregatesFilter | string
        conversions_disk?: StringNullableWithAggregatesFilter | string | null
        size?: BigIntWithAggregatesFilter | bigint | number
        manipulations?: JsonWithAggregatesFilter
        custom_properties?: JsonWithAggregatesFilter
        generated_conversions?: JsonWithAggregatesFilter
        responsive_images?: JsonWithAggregatesFilter
        order_column?: IntNullableWithAggregatesFilter | number | null
        created_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
        updated_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    }

    export type Model_has_permissionsWhereInput = {
        AND?: Enumerable<Model_has_permissionsWhereInput>
        OR?: Enumerable<Model_has_permissionsWhereInput>
        NOT?: Enumerable<Model_has_permissionsWhereInput>
        permission_id?: UuidFilter | string
        model_type?: StringFilter | string
        model_uuid?: UuidFilter | string
        permissions?: XOR<PermissionsRelationFilter, PermissionsWhereInput>
    }

    export type Model_has_permissionsOrderByWithRelationInput = {
        permission_id?: SortOrder
        model_type?: SortOrder
        model_uuid?: SortOrder
        permissions?: PermissionsOrderByWithRelationInput
    }

    export type Model_has_permissionsWhereUniqueInput = {
        permission_id_model_uuid_model_type?: Model_has_permissionsPermission_idModel_uuidModel_typeCompoundUniqueInput
    }

    export type Model_has_permissionsOrderByWithAggregationInput = {
        permission_id?: SortOrder
        model_type?: SortOrder
        model_uuid?: SortOrder
        _count?: Model_has_permissionsCountOrderByAggregateInput
        _max?: Model_has_permissionsMaxOrderByAggregateInput
        _min?: Model_has_permissionsMinOrderByAggregateInput
    }

    export type Model_has_permissionsScalarWhereWithAggregatesInput = {
        AND?: Enumerable<Model_has_permissionsScalarWhereWithAggregatesInput>
        OR?: Enumerable<Model_has_permissionsScalarWhereWithAggregatesInput>
        NOT?: Enumerable<Model_has_permissionsScalarWhereWithAggregatesInput>
        permission_id?: UuidWithAggregatesFilter | string
        model_type?: StringWithAggregatesFilter | string
        model_uuid?: UuidWithAggregatesFilter | string
    }

    export type Model_has_rolesWhereInput = {
        AND?: Enumerable<Model_has_rolesWhereInput>
        OR?: Enumerable<Model_has_rolesWhereInput>
        NOT?: Enumerable<Model_has_rolesWhereInput>
        role_id?: UuidFilter | string
        model_type?: StringFilter | string
        model_uuid?: UuidFilter | string
        roles?: XOR<RolesRelationFilter, RolesWhereInput>
    }

    export type Model_has_rolesOrderByWithRelationInput = {
        role_id?: SortOrder
        model_type?: SortOrder
        model_uuid?: SortOrder
        roles?: RolesOrderByWithRelationInput
    }

    export type Model_has_rolesWhereUniqueInput = {
        role_id_model_uuid_model_type?: Model_has_rolesRole_idModel_uuidModel_typeCompoundUniqueInput
    }

    export type Model_has_rolesOrderByWithAggregationInput = {
        role_id?: SortOrder
        model_type?: SortOrder
        model_uuid?: SortOrder
        _count?: Model_has_rolesCountOrderByAggregateInput
        _max?: Model_has_rolesMaxOrderByAggregateInput
        _min?: Model_has_rolesMinOrderByAggregateInput
    }

    export type Model_has_rolesScalarWhereWithAggregatesInput = {
        AND?: Enumerable<Model_has_rolesScalarWhereWithAggregatesInput>
        OR?: Enumerable<Model_has_rolesScalarWhereWithAggregatesInput>
        NOT?: Enumerable<Model_has_rolesScalarWhereWithAggregatesInput>
        role_id?: UuidWithAggregatesFilter | string
        model_type?: StringWithAggregatesFilter | string
        model_uuid?: UuidWithAggregatesFilter | string
    }

    export type Orphan_sponsorshipWhereInput = {
        AND?: Enumerable<Orphan_sponsorshipWhereInput>
        OR?: Enumerable<Orphan_sponsorshipWhereInput>
        NOT?: Enumerable<Orphan_sponsorshipWhereInput>
        id?: UuidFilter | string
        orphan_id?: UuidFilter | string
        type?: Enumorphan_sponsorship_typeFilter | orphan_sponsorship_type
        value?: StringNullableFilter | string | null
        tenant_id?: StringFilter | string
        created_at?: DateTimeNullableFilter | Date | string | null
        updated_at?: DateTimeNullableFilter | Date | string | null
        orphans?: XOR<OrphansRelationFilter, OrphansWhereInput>
        tenants?: XOR<TenantsRelationFilter, TenantsWhereInput>
    }

    export type Orphan_sponsorshipOrderByWithRelationInput = {
        id?: SortOrder
        orphan_id?: SortOrder
        type?: SortOrder
        value?: SortOrder
        tenant_id?: SortOrder
        created_at?: SortOrder
        updated_at?: SortOrder
        orphans?: OrphansOrderByWithRelationInput
        tenants?: TenantsOrderByWithRelationInput
    }

    export type Orphan_sponsorshipWhereUniqueInput = {
        id?: string
    }

    export type Orphan_sponsorshipOrderByWithAggregationInput = {
        id?: SortOrder
        orphan_id?: SortOrder
        type?: SortOrder
        value?: SortOrder
        tenant_id?: SortOrder
        created_at?: SortOrder
        updated_at?: SortOrder
        _count?: Orphan_sponsorshipCountOrderByAggregateInput
        _max?: Orphan_sponsorshipMaxOrderByAggregateInput
        _min?: Orphan_sponsorshipMinOrderByAggregateInput
    }

    export type Orphan_sponsorshipScalarWhereWithAggregatesInput = {
        AND?: Enumerable<Orphan_sponsorshipScalarWhereWithAggregatesInput>
        OR?: Enumerable<Orphan_sponsorshipScalarWhereWithAggregatesInput>
        NOT?: Enumerable<Orphan_sponsorshipScalarWhereWithAggregatesInput>
        id?: UuidWithAggregatesFilter | string
        orphan_id?: UuidWithAggregatesFilter | string
        type?: Enumorphan_sponsorship_typeWithAggregatesFilter | orphan_sponsorship_type
        value?: StringNullableWithAggregatesFilter | string | null
        tenant_id?: StringWithAggregatesFilter | string
        created_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
        updated_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    }

    export type OrphansWhereInput = {
        AND?: Enumerable<OrphansWhereInput>
        OR?: Enumerable<OrphansWhereInput>
        NOT?: Enumerable<OrphansWhereInput>
        id?: UuidFilter | string
        first_name?: StringFilter | string
        last_name?: StringFilter | string
        birth_date?: DateTimeFilter | Date | string
        family_status?: StringFilter | string
        health_status?: StringFilter | string
        academic_level?: StringFilter | string
        shoes_size?: StringFilter | string
        pants_size?: StringFilter | string
        shirt_size?: StringFilter | string
        note?: StringFilter | string
        tenant_id?: StringFilter | string
        family_id?: UuidFilter | string
        created_by?: UuidFilter | string
        deleted_by?: UuidNullableFilter | string | null
        created_at?: DateTimeNullableFilter | Date | string | null
        updated_at?: DateTimeNullableFilter | Date | string | null
        orphan_sponsorship?: Orphan_sponsorshipListRelationFilter
        users_orphans_created_byTousers?: XOR<UsersRelationFilter, UsersWhereInput>
        users_orphans_deleted_byTousers?: XOR<UsersRelationFilter, UsersWhereInput> | null
        families?: XOR<FamiliesRelationFilter, FamiliesWhereInput>
        tenants?: XOR<TenantsRelationFilter, TenantsWhereInput>
    }

    export type OrphansOrderByWithRelationInput = {
        id?: SortOrder
        first_name?: SortOrder
        last_name?: SortOrder
        birth_date?: SortOrder
        family_status?: SortOrder
        health_status?: SortOrder
        academic_level?: SortOrder
        shoes_size?: SortOrder
        pants_size?: SortOrder
        shirt_size?: SortOrder
        note?: SortOrder
        tenant_id?: SortOrder
        family_id?: SortOrder
        created_by?: SortOrder
        deleted_by?: SortOrder
        created_at?: SortOrder
        updated_at?: SortOrder
        orphan_sponsorship?: Orphan_sponsorshipOrderByRelationAggregateInput
        users_orphans_created_byTousers?: UsersOrderByWithRelationInput
        users_orphans_deleted_byTousers?: UsersOrderByWithRelationInput
        families?: FamiliesOrderByWithRelationInput
        tenants?: TenantsOrderByWithRelationInput
    }

    export type OrphansWhereUniqueInput = {
        id?: string
    }

    export type OrphansOrderByWithAggregationInput = {
        id?: SortOrder
        first_name?: SortOrder
        last_name?: SortOrder
        birth_date?: SortOrder
        family_status?: SortOrder
        health_status?: SortOrder
        academic_level?: SortOrder
        shoes_size?: SortOrder
        pants_size?: SortOrder
        shirt_size?: SortOrder
        note?: SortOrder
        tenant_id?: SortOrder
        family_id?: SortOrder
        created_by?: SortOrder
        deleted_by?: SortOrder
        created_at?: SortOrder
        updated_at?: SortOrder
        _count?: OrphansCountOrderByAggregateInput
        _max?: OrphansMaxOrderByAggregateInput
        _min?: OrphansMinOrderByAggregateInput
    }

    export type OrphansScalarWhereWithAggregatesInput = {
        AND?: Enumerable<OrphansScalarWhereWithAggregatesInput>
        OR?: Enumerable<OrphansScalarWhereWithAggregatesInput>
        NOT?: Enumerable<OrphansScalarWhereWithAggregatesInput>
        id?: UuidWithAggregatesFilter | string
        first_name?: StringWithAggregatesFilter | string
        last_name?: StringWithAggregatesFilter | string
        birth_date?: DateTimeWithAggregatesFilter | Date | string
        family_status?: StringWithAggregatesFilter | string
        health_status?: StringWithAggregatesFilter | string
        academic_level?: StringWithAggregatesFilter | string
        shoes_size?: StringWithAggregatesFilter | string
        pants_size?: StringWithAggregatesFilter | string
        shirt_size?: StringWithAggregatesFilter | string
        note?: StringWithAggregatesFilter | string
        tenant_id?: StringWithAggregatesFilter | string
        family_id?: UuidWithAggregatesFilter | string
        created_by?: UuidWithAggregatesFilter | string
        deleted_by?: UuidNullableWithAggregatesFilter | string | null
        created_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
        updated_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    }

    export type Password_reset_tokensWhereInput = {
        AND?: Enumerable<Password_reset_tokensWhereInput>
        OR?: Enumerable<Password_reset_tokensWhereInput>
        NOT?: Enumerable<Password_reset_tokensWhereInput>
        email?: StringFilter | string
        token?: StringFilter | string
        created_at?: DateTimeNullableFilter | Date | string | null
    }

    export type Password_reset_tokensOrderByWithRelationInput = {
        email?: SortOrder
        token?: SortOrder
        created_at?: SortOrder
    }

    export type Password_reset_tokensWhereUniqueInput = {
        email?: string
    }

    export type Password_reset_tokensOrderByWithAggregationInput = {
        email?: SortOrder
        token?: SortOrder
        created_at?: SortOrder
        _count?: Password_reset_tokensCountOrderByAggregateInput
        _max?: Password_reset_tokensMaxOrderByAggregateInput
        _min?: Password_reset_tokensMinOrderByAggregateInput
    }

    export type Password_reset_tokensScalarWhereWithAggregatesInput = {
        AND?: Enumerable<Password_reset_tokensScalarWhereWithAggregatesInput>
        OR?: Enumerable<Password_reset_tokensScalarWhereWithAggregatesInput>
        NOT?: Enumerable<Password_reset_tokensScalarWhereWithAggregatesInput>
        email?: StringWithAggregatesFilter | string
        token?: StringWithAggregatesFilter | string
        created_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    }

    export type PermissionsWhereInput = {
        AND?: Enumerable<PermissionsWhereInput>
        OR?: Enumerable<PermissionsWhereInput>
        NOT?: Enumerable<PermissionsWhereInput>
        uuid?: UuidFilter | string
        name?: StringFilter | string
        guard_name?: StringFilter | string
        created_at?: DateTimeNullableFilter | Date | string | null
        updated_at?: DateTimeNullableFilter | Date | string | null
        model_has_permissions?: Model_has_permissionsListRelationFilter
        role_has_permissions?: Role_has_permissionsListRelationFilter
    }

    export type PermissionsOrderByWithRelationInput = {
        uuid?: SortOrder
        name?: SortOrder
        guard_name?: SortOrder
        created_at?: SortOrder
        updated_at?: SortOrder
        model_has_permissions?: Model_has_permissionsOrderByRelationAggregateInput
        role_has_permissions?: Role_has_permissionsOrderByRelationAggregateInput
    }

    export type PermissionsWhereUniqueInput = {
        uuid?: string
    }

    export type PermissionsOrderByWithAggregationInput = {
        uuid?: SortOrder
        name?: SortOrder
        guard_name?: SortOrder
        created_at?: SortOrder
        updated_at?: SortOrder
        _count?: PermissionsCountOrderByAggregateInput
        _max?: PermissionsMaxOrderByAggregateInput
        _min?: PermissionsMinOrderByAggregateInput
    }

    export type PermissionsScalarWhereWithAggregatesInput = {
        AND?: Enumerable<PermissionsScalarWhereWithAggregatesInput>
        OR?: Enumerable<PermissionsScalarWhereWithAggregatesInput>
        NOT?: Enumerable<PermissionsScalarWhereWithAggregatesInput>
        uuid?: UuidWithAggregatesFilter | string
        name?: StringWithAggregatesFilter | string
        guard_name?: StringWithAggregatesFilter | string
        created_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
        updated_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    }

    export type Personal_access_tokensWhereInput = {
        AND?: Enumerable<Personal_access_tokensWhereInput>
        OR?: Enumerable<Personal_access_tokensWhereInput>
        NOT?: Enumerable<Personal_access_tokensWhereInput>
        id?: UuidFilter | string
        tokenable_type?: StringFilter | string
        tokenable_id?: UuidFilter | string
        name?: StringFilter | string
        token?: StringFilter | string
        abilities?: StringNullableFilter | string | null
        last_used_at?: DateTimeNullableFilter | Date | string | null
        expires_at?: DateTimeNullableFilter | Date | string | null
        created_at?: DateTimeNullableFilter | Date | string | null
        updated_at?: DateTimeNullableFilter | Date | string | null
    }

    export type Personal_access_tokensOrderByWithRelationInput = {
        id?: SortOrder
        tokenable_type?: SortOrder
        tokenable_id?: SortOrder
        name?: SortOrder
        token?: SortOrder
        abilities?: SortOrder
        last_used_at?: SortOrder
        expires_at?: SortOrder
        created_at?: SortOrder
        updated_at?: SortOrder
    }

    export type Personal_access_tokensWhereUniqueInput = {
        id?: string
    }

    export type Personal_access_tokensOrderByWithAggregationInput = {
        id?: SortOrder
        tokenable_type?: SortOrder
        tokenable_id?: SortOrder
        name?: SortOrder
        token?: SortOrder
        abilities?: SortOrder
        last_used_at?: SortOrder
        expires_at?: SortOrder
        created_at?: SortOrder
        updated_at?: SortOrder
        _count?: Personal_access_tokensCountOrderByAggregateInput
        _max?: Personal_access_tokensMaxOrderByAggregateInput
        _min?: Personal_access_tokensMinOrderByAggregateInput
    }

    export type Personal_access_tokensScalarWhereWithAggregatesInput = {
        AND?: Enumerable<Personal_access_tokensScalarWhereWithAggregatesInput>
        OR?: Enumerable<Personal_access_tokensScalarWhereWithAggregatesInput>
        NOT?: Enumerable<Personal_access_tokensScalarWhereWithAggregatesInput>
        id?: UuidWithAggregatesFilter | string
        tokenable_type?: StringWithAggregatesFilter | string
        tokenable_id?: UuidWithAggregatesFilter | string
        name?: StringWithAggregatesFilter | string
        token?: StringWithAggregatesFilter | string
        abilities?: StringNullableWithAggregatesFilter | string | null
        last_used_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
        expires_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
        created_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
        updated_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    }

    export type Role_has_permissionsWhereInput = {
        AND?: Enumerable<Role_has_permissionsWhereInput>
        OR?: Enumerable<Role_has_permissionsWhereInput>
        NOT?: Enumerable<Role_has_permissionsWhereInput>
        permission_id?: UuidFilter | string
        role_id?: UuidFilter | string
        permissions?: XOR<PermissionsRelationFilter, PermissionsWhereInput>
        roles?: XOR<RolesRelationFilter, RolesWhereInput>
    }

    export type Role_has_permissionsOrderByWithRelationInput = {
        permission_id?: SortOrder
        role_id?: SortOrder
        permissions?: PermissionsOrderByWithRelationInput
        roles?: RolesOrderByWithRelationInput
    }

    export type Role_has_permissionsWhereUniqueInput = {
        permission_id_role_id?: Role_has_permissionsPermission_idRole_idCompoundUniqueInput
    }

    export type Role_has_permissionsOrderByWithAggregationInput = {
        permission_id?: SortOrder
        role_id?: SortOrder
        _count?: Role_has_permissionsCountOrderByAggregateInput
        _max?: Role_has_permissionsMaxOrderByAggregateInput
        _min?: Role_has_permissionsMinOrderByAggregateInput
    }

    export type Role_has_permissionsScalarWhereWithAggregatesInput = {
        AND?: Enumerable<Role_has_permissionsScalarWhereWithAggregatesInput>
        OR?: Enumerable<Role_has_permissionsScalarWhereWithAggregatesInput>
        NOT?: Enumerable<Role_has_permissionsScalarWhereWithAggregatesInput>
        permission_id?: UuidWithAggregatesFilter | string
        role_id?: UuidWithAggregatesFilter | string
    }

    export type RolesWhereInput = {
        AND?: Enumerable<RolesWhereInput>
        OR?: Enumerable<RolesWhereInput>
        NOT?: Enumerable<RolesWhereInput>
        uuid?: UuidFilter | string
        name?: StringFilter | string
        guard_name?: StringFilter | string
        created_at?: DateTimeNullableFilter | Date | string | null
        updated_at?: DateTimeNullableFilter | Date | string | null
        model_has_roles?: Model_has_rolesListRelationFilter
        role_has_permissions?: Role_has_permissionsListRelationFilter
    }

    export type RolesOrderByWithRelationInput = {
        uuid?: SortOrder
        name?: SortOrder
        guard_name?: SortOrder
        created_at?: SortOrder
        updated_at?: SortOrder
        model_has_roles?: Model_has_rolesOrderByRelationAggregateInput
        role_has_permissions?: Role_has_permissionsOrderByRelationAggregateInput
    }

    export type RolesWhereUniqueInput = {
        uuid?: string
    }

    export type RolesOrderByWithAggregationInput = {
        uuid?: SortOrder
        name?: SortOrder
        guard_name?: SortOrder
        created_at?: SortOrder
        updated_at?: SortOrder
        _count?: RolesCountOrderByAggregateInput
        _max?: RolesMaxOrderByAggregateInput
        _min?: RolesMinOrderByAggregateInput
    }

    export type RolesScalarWhereWithAggregatesInput = {
        AND?: Enumerable<RolesScalarWhereWithAggregatesInput>
        OR?: Enumerable<RolesScalarWhereWithAggregatesInput>
        NOT?: Enumerable<RolesScalarWhereWithAggregatesInput>
        uuid?: UuidWithAggregatesFilter | string
        name?: StringWithAggregatesFilter | string
        guard_name?: StringWithAggregatesFilter | string
        created_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
        updated_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    }

    export type Second_sponsorsWhereInput = {
        AND?: Enumerable<Second_sponsorsWhereInput>
        OR?: Enumerable<Second_sponsorsWhereInput>
        NOT?: Enumerable<Second_sponsorsWhereInput>
        id?: UuidFilter | string
        first_name?: StringFilter | string
        last_name?: StringFilter | string
        degree_of_kinship?: StringFilter | string
        phone_number?: StringFilter | string
        address?: StringFilter | string
        income?: FloatFilter | number
        family_id?: UuidFilter | string
        tenant_id?: StringFilter | string
        deleted_at?: DateTimeNullableFilter | Date | string | null
        created_at?: DateTimeNullableFilter | Date | string | null
        updated_at?: DateTimeNullableFilter | Date | string | null
        families?: XOR<FamiliesRelationFilter, FamiliesWhereInput>
        tenants?: XOR<TenantsRelationFilter, TenantsWhereInput>
    }

    export type Second_sponsorsOrderByWithRelationInput = {
        id?: SortOrder
        first_name?: SortOrder
        last_name?: SortOrder
        degree_of_kinship?: SortOrder
        phone_number?: SortOrder
        address?: SortOrder
        income?: SortOrder
        family_id?: SortOrder
        tenant_id?: SortOrder
        deleted_at?: SortOrder
        created_at?: SortOrder
        updated_at?: SortOrder
        families?: FamiliesOrderByWithRelationInput
        tenants?: TenantsOrderByWithRelationInput
    }

    export type Second_sponsorsWhereUniqueInput = {
        id?: string
    }

    export type Second_sponsorsOrderByWithAggregationInput = {
        id?: SortOrder
        first_name?: SortOrder
        last_name?: SortOrder
        degree_of_kinship?: SortOrder
        phone_number?: SortOrder
        address?: SortOrder
        income?: SortOrder
        family_id?: SortOrder
        tenant_id?: SortOrder
        deleted_at?: SortOrder
        created_at?: SortOrder
        updated_at?: SortOrder
        _count?: Second_sponsorsCountOrderByAggregateInput
        _avg?: Second_sponsorsAvgOrderByAggregateInput
        _max?: Second_sponsorsMaxOrderByAggregateInput
        _min?: Second_sponsorsMinOrderByAggregateInput
        _sum?: Second_sponsorsSumOrderByAggregateInput
    }

    export type Second_sponsorsScalarWhereWithAggregatesInput = {
        AND?: Enumerable<Second_sponsorsScalarWhereWithAggregatesInput>
        OR?: Enumerable<Second_sponsorsScalarWhereWithAggregatesInput>
        NOT?: Enumerable<Second_sponsorsScalarWhereWithAggregatesInput>
        id?: UuidWithAggregatesFilter | string
        first_name?: StringWithAggregatesFilter | string
        last_name?: StringWithAggregatesFilter | string
        degree_of_kinship?: StringWithAggregatesFilter | string
        phone_number?: StringWithAggregatesFilter | string
        address?: StringWithAggregatesFilter | string
        income?: FloatWithAggregatesFilter | number
        family_id?: UuidWithAggregatesFilter | string
        tenant_id?: StringWithAggregatesFilter | string
        deleted_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
        created_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
        updated_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    }

    export type SessionsWhereInput = {
        AND?: Enumerable<SessionsWhereInput>
        OR?: Enumerable<SessionsWhereInput>
        NOT?: Enumerable<SessionsWhereInput>
        id?: StringFilter | string
        user_id?: UuidNullableFilter | string | null
        ip_address?: StringNullableFilter | string | null
        user_agent?: StringNullableFilter | string | null
        payload?: StringFilter | string
        last_activity?: IntFilter | number
        users?: XOR<UsersRelationFilter, UsersWhereInput> | null
    }

    export type SessionsOrderByWithRelationInput = {
        id?: SortOrder
        user_id?: SortOrder
        ip_address?: SortOrder
        user_agent?: SortOrder
        payload?: SortOrder
        last_activity?: SortOrder
        users?: UsersOrderByWithRelationInput
    }

    export type SessionsWhereUniqueInput = {
        id?: string
    }

    export type SessionsOrderByWithAggregationInput = {
        id?: SortOrder
        user_id?: SortOrder
        ip_address?: SortOrder
        user_agent?: SortOrder
        payload?: SortOrder
        last_activity?: SortOrder
        _count?: SessionsCountOrderByAggregateInput
        _avg?: SessionsAvgOrderByAggregateInput
        _max?: SessionsMaxOrderByAggregateInput
        _min?: SessionsMinOrderByAggregateInput
        _sum?: SessionsSumOrderByAggregateInput
    }

    export type SessionsScalarWhereWithAggregatesInput = {
        AND?: Enumerable<SessionsScalarWhereWithAggregatesInput>
        OR?: Enumerable<SessionsScalarWhereWithAggregatesInput>
        NOT?: Enumerable<SessionsScalarWhereWithAggregatesInput>
        id?: StringWithAggregatesFilter | string
        user_id?: UuidNullableWithAggregatesFilter | string | null
        ip_address?: StringNullableWithAggregatesFilter | string | null
        user_agent?: StringNullableWithAggregatesFilter | string | null
        payload?: StringWithAggregatesFilter | string
        last_activity?: IntWithAggregatesFilter | number
    }

    export type SettingsWhereInput = {
        AND?: Enumerable<SettingsWhereInput>
        OR?: Enumerable<SettingsWhereInput>
        NOT?: Enumerable<SettingsWhereInput>
        id?: UuidFilter | string
        user_id?: UuidFilter | string
        theme?: EnumthemeFilter | theme
        color_scheme?: Enumcolor_schemeFilter | color_scheme
        layout?: EnumlayoutFilter | layout
        appearance?: EnumappearanceFilter | appearance
        notifications?: JsonNullableFilter
        created_at?: DateTimeNullableFilter | Date | string | null
        updated_at?: DateTimeNullableFilter | Date | string | null
        users?: XOR<UsersRelationFilter, UsersWhereInput>
    }

    export type SettingsOrderByWithRelationInput = {
        id?: SortOrder
        user_id?: SortOrder
        theme?: SortOrder
        color_scheme?: SortOrder
        layout?: SortOrder
        appearance?: SortOrder
        notifications?: SortOrder
        created_at?: SortOrder
        updated_at?: SortOrder
        users?: UsersOrderByWithRelationInput
    }

    export type SettingsWhereUniqueInput = {
        id?: string
    }

    export type SettingsOrderByWithAggregationInput = {
        id?: SortOrder
        user_id?: SortOrder
        theme?: SortOrder
        color_scheme?: SortOrder
        layout?: SortOrder
        appearance?: SortOrder
        notifications?: SortOrder
        created_at?: SortOrder
        updated_at?: SortOrder
        _count?: SettingsCountOrderByAggregateInput
        _max?: SettingsMaxOrderByAggregateInput
        _min?: SettingsMinOrderByAggregateInput
    }

    export type SettingsScalarWhereWithAggregatesInput = {
        AND?: Enumerable<SettingsScalarWhereWithAggregatesInput>
        OR?: Enumerable<SettingsScalarWhereWithAggregatesInput>
        NOT?: Enumerable<SettingsScalarWhereWithAggregatesInput>
        id?: UuidWithAggregatesFilter | string
        user_id?: UuidWithAggregatesFilter | string
        theme?: EnumthemeWithAggregatesFilter | theme
        color_scheme?: Enumcolor_schemeWithAggregatesFilter | color_scheme
        layout?: EnumlayoutWithAggregatesFilter | layout
        appearance?: EnumappearanceWithAggregatesFilter | appearance
        notifications?: JsonNullableWithAggregatesFilter
        created_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
        updated_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    }

    export type Sponsor_sponsorshipWhereInput = {
        AND?: Enumerable<Sponsor_sponsorshipWhereInput>
        OR?: Enumerable<Sponsor_sponsorshipWhereInput>
        NOT?: Enumerable<Sponsor_sponsorshipWhereInput>
        id?: UuidFilter | string
        sponsor_id?: UuidFilter | string
        type?: Enumsponsor_sponsorship_typeFilter | sponsor_sponsorship_type
        value?: StringFilter | string
        tenant_id?: StringFilter | string
        created_at?: DateTimeNullableFilter | Date | string | null
        updated_at?: DateTimeNullableFilter | Date | string | null
        sponsors?: XOR<SponsorsRelationFilter, SponsorsWhereInput>
        tenants?: XOR<TenantsRelationFilter, TenantsWhereInput>
    }

    export type Sponsor_sponsorshipOrderByWithRelationInput = {
        id?: SortOrder
        sponsor_id?: SortOrder
        type?: SortOrder
        value?: SortOrder
        tenant_id?: SortOrder
        created_at?: SortOrder
        updated_at?: SortOrder
        sponsors?: SponsorsOrderByWithRelationInput
        tenants?: TenantsOrderByWithRelationInput
    }

    export type Sponsor_sponsorshipWhereUniqueInput = {
        id?: string
    }

    export type Sponsor_sponsorshipOrderByWithAggregationInput = {
        id?: SortOrder
        sponsor_id?: SortOrder
        type?: SortOrder
        value?: SortOrder
        tenant_id?: SortOrder
        created_at?: SortOrder
        updated_at?: SortOrder
        _count?: Sponsor_sponsorshipCountOrderByAggregateInput
        _max?: Sponsor_sponsorshipMaxOrderByAggregateInput
        _min?: Sponsor_sponsorshipMinOrderByAggregateInput
    }

    export type Sponsor_sponsorshipScalarWhereWithAggregatesInput = {
        AND?: Enumerable<Sponsor_sponsorshipScalarWhereWithAggregatesInput>
        OR?: Enumerable<Sponsor_sponsorshipScalarWhereWithAggregatesInput>
        NOT?: Enumerable<Sponsor_sponsorshipScalarWhereWithAggregatesInput>
        id?: UuidWithAggregatesFilter | string
        sponsor_id?: UuidWithAggregatesFilter | string
        type?: Enumsponsor_sponsorship_typeWithAggregatesFilter | sponsor_sponsorship_type
        value?: StringWithAggregatesFilter | string
        tenant_id?: StringWithAggregatesFilter | string
        created_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
        updated_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    }

    export type SponsorsWhereInput = {
        AND?: Enumerable<SponsorsWhereInput>
        OR?: Enumerable<SponsorsWhereInput>
        NOT?: Enumerable<SponsorsWhereInput>
        id?: UuidFilter | string
        zone_id?: UuidFilter | string
        file_number?: IntFilter | number
        start_date?: DateTimeFilter | Date | string
        name?: StringFilter | string
        address?: StringFilter | string
        phone_number?: StringFilter | string
        sponsorship_type?: StringFilter | string
        birth_date?: DateTimeFilter | Date | string
        father_name?: StringFilter | string
        mother_name?: StringFilter | string
        birth_certificate_number?: StringFilter | string
        academic_level?: StringFilter | string
        function?: StringFilter | string
        health_status?: StringFilter | string
        diploma?: StringNullableFilter | string | null
        card_number?: StringNullableFilter | string | null
        tenant_id?: StringFilter | string
        created_by?: UuidFilter | string
        deleted_by?: UuidNullableFilter | string | null
        deleted_at?: DateTimeNullableFilter | Date | string | null
        created_at?: DateTimeNullableFilter | Date | string | null
        updated_at?: DateTimeNullableFilter | Date | string | null
        income_sponsor?: Income_sponsorListRelationFilter
        sponsor_sponsorship?: Sponsor_sponsorshipListRelationFilter
        users_sponsors_created_byTousers?: XOR<UsersRelationFilter, UsersWhereInput>
        users_sponsors_deleted_byTousers?: XOR<UsersRelationFilter, UsersWhereInput> | null
        tenants?: XOR<TenantsRelationFilter, TenantsWhereInput>
    }

    export type SponsorsOrderByWithRelationInput = {
        id?: SortOrder
        zone_id?: SortOrder
        file_number?: SortOrder
        start_date?: SortOrder
        name?: SortOrder
        address?: SortOrder
        phone_number?: SortOrder
        sponsorship_type?: SortOrder
        birth_date?: SortOrder
        father_name?: SortOrder
        mother_name?: SortOrder
        birth_certificate_number?: SortOrder
        academic_level?: SortOrder
        function?: SortOrder
        health_status?: SortOrder
        diploma?: SortOrder
        card_number?: SortOrder
        tenant_id?: SortOrder
        created_by?: SortOrder
        deleted_by?: SortOrder
        deleted_at?: SortOrder
        created_at?: SortOrder
        updated_at?: SortOrder
        income_sponsor?: Income_sponsorOrderByRelationAggregateInput
        sponsor_sponsorship?: Sponsor_sponsorshipOrderByRelationAggregateInput
        users_sponsors_created_byTousers?: UsersOrderByWithRelationInput
        users_sponsors_deleted_byTousers?: UsersOrderByWithRelationInput
        tenants?: TenantsOrderByWithRelationInput
    }

    export type SponsorsWhereUniqueInput = {
        id?: string
    }

    export type SponsorsOrderByWithAggregationInput = {
        id?: SortOrder
        zone_id?: SortOrder
        file_number?: SortOrder
        start_date?: SortOrder
        name?: SortOrder
        address?: SortOrder
        phone_number?: SortOrder
        sponsorship_type?: SortOrder
        birth_date?: SortOrder
        father_name?: SortOrder
        mother_name?: SortOrder
        birth_certificate_number?: SortOrder
        academic_level?: SortOrder
        function?: SortOrder
        health_status?: SortOrder
        diploma?: SortOrder
        card_number?: SortOrder
        tenant_id?: SortOrder
        created_by?: SortOrder
        deleted_by?: SortOrder
        deleted_at?: SortOrder
        created_at?: SortOrder
        updated_at?: SortOrder
        _count?: SponsorsCountOrderByAggregateInput
        _avg?: SponsorsAvgOrderByAggregateInput
        _max?: SponsorsMaxOrderByAggregateInput
        _min?: SponsorsMinOrderByAggregateInput
        _sum?: SponsorsSumOrderByAggregateInput
    }

    export type SponsorsScalarWhereWithAggregatesInput = {
        AND?: Enumerable<SponsorsScalarWhereWithAggregatesInput>
        OR?: Enumerable<SponsorsScalarWhereWithAggregatesInput>
        NOT?: Enumerable<SponsorsScalarWhereWithAggregatesInput>
        id?: UuidWithAggregatesFilter | string
        zone_id?: UuidWithAggregatesFilter | string
        file_number?: IntWithAggregatesFilter | number
        start_date?: DateTimeWithAggregatesFilter | Date | string
        name?: StringWithAggregatesFilter | string
        address?: StringWithAggregatesFilter | string
        phone_number?: StringWithAggregatesFilter | string
        sponsorship_type?: StringWithAggregatesFilter | string
        birth_date?: DateTimeWithAggregatesFilter | Date | string
        father_name?: StringWithAggregatesFilter | string
        mother_name?: StringWithAggregatesFilter | string
        birth_certificate_number?: StringWithAggregatesFilter | string
        academic_level?: StringWithAggregatesFilter | string
        function?: StringWithAggregatesFilter | string
        health_status?: StringWithAggregatesFilter | string
        diploma?: StringNullableWithAggregatesFilter | string | null
        card_number?: StringNullableWithAggregatesFilter | string | null
        tenant_id?: StringWithAggregatesFilter | string
        created_by?: UuidWithAggregatesFilter | string
        deleted_by?: UuidNullableWithAggregatesFilter | string | null
        deleted_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
        created_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
        updated_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    }

    export type SponsorshipsWhereInput = {
        AND?: Enumerable<SponsorshipsWhereInput>
        OR?: Enumerable<SponsorshipsWhereInput>
        NOT?: Enumerable<SponsorshipsWhereInput>
        id?: UuidFilter | string
        type?: Enumsponsorship_typeFilter | sponsorship_type
        name?: StringFilter | string
        tenant_id?: StringFilter | string
        deleted_at?: DateTimeNullableFilter | Date | string | null
        created_at?: DateTimeNullableFilter | Date | string | null
        updated_at?: DateTimeNullableFilter | Date | string | null
        tenants?: XOR<TenantsRelationFilter, TenantsWhereInput>
    }

    export type SponsorshipsOrderByWithRelationInput = {
        id?: SortOrder
        type?: SortOrder
        name?: SortOrder
        tenant_id?: SortOrder
        deleted_at?: SortOrder
        created_at?: SortOrder
        updated_at?: SortOrder
        tenants?: TenantsOrderByWithRelationInput
    }

    export type SponsorshipsWhereUniqueInput = {
        id?: string
    }

    export type SponsorshipsOrderByWithAggregationInput = {
        id?: SortOrder
        type?: SortOrder
        name?: SortOrder
        tenant_id?: SortOrder
        deleted_at?: SortOrder
        created_at?: SortOrder
        updated_at?: SortOrder
        _count?: SponsorshipsCountOrderByAggregateInput
        _max?: SponsorshipsMaxOrderByAggregateInput
        _min?: SponsorshipsMinOrderByAggregateInput
    }

    export type SponsorshipsScalarWhereWithAggregatesInput = {
        AND?: Enumerable<SponsorshipsScalarWhereWithAggregatesInput>
        OR?: Enumerable<SponsorshipsScalarWhereWithAggregatesInput>
        NOT?: Enumerable<SponsorshipsScalarWhereWithAggregatesInput>
        id?: UuidWithAggregatesFilter | string
        type?: Enumsponsorship_typeWithAggregatesFilter | sponsorship_type
        name?: StringWithAggregatesFilter | string
        tenant_id?: StringWithAggregatesFilter | string
        deleted_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
        created_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
        updated_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    }

    export type SpousesWhereInput = {
        AND?: Enumerable<SpousesWhereInput>
        OR?: Enumerable<SpousesWhereInput>
        NOT?: Enumerable<SpousesWhereInput>
        id?: UuidFilter | string
        first_name?: StringFilter | string
        last_name?: StringFilter | string
        birth_date?: DateTimeFilter | Date | string
        death_date?: DateTimeFilter | Date | string
        function?: StringFilter | string
        income?: FloatFilter | number
        family_id?: UuidFilter | string
        tenant_id?: StringFilter | string
        created_at?: DateTimeNullableFilter | Date | string | null
        updated_at?: DateTimeNullableFilter | Date | string | null
        families?: XOR<FamiliesRelationFilter, FamiliesWhereInput>
        tenants?: XOR<TenantsRelationFilter, TenantsWhereInput>
    }

    export type SpousesOrderByWithRelationInput = {
        id?: SortOrder
        first_name?: SortOrder
        last_name?: SortOrder
        birth_date?: SortOrder
        death_date?: SortOrder
        function?: SortOrder
        income?: SortOrder
        family_id?: SortOrder
        tenant_id?: SortOrder
        created_at?: SortOrder
        updated_at?: SortOrder
        families?: FamiliesOrderByWithRelationInput
        tenants?: TenantsOrderByWithRelationInput
    }

    export type SpousesWhereUniqueInput = {
        id?: string
    }

    export type SpousesOrderByWithAggregationInput = {
        id?: SortOrder
        first_name?: SortOrder
        last_name?: SortOrder
        birth_date?: SortOrder
        death_date?: SortOrder
        function?: SortOrder
        income?: SortOrder
        family_id?: SortOrder
        tenant_id?: SortOrder
        created_at?: SortOrder
        updated_at?: SortOrder
        _count?: SpousesCountOrderByAggregateInput
        _avg?: SpousesAvgOrderByAggregateInput
        _max?: SpousesMaxOrderByAggregateInput
        _min?: SpousesMinOrderByAggregateInput
        _sum?: SpousesSumOrderByAggregateInput
    }

    export type SpousesScalarWhereWithAggregatesInput = {
        AND?: Enumerable<SpousesScalarWhereWithAggregatesInput>
        OR?: Enumerable<SpousesScalarWhereWithAggregatesInput>
        NOT?: Enumerable<SpousesScalarWhereWithAggregatesInput>
        id?: UuidWithAggregatesFilter | string
        first_name?: StringWithAggregatesFilter | string
        last_name?: StringWithAggregatesFilter | string
        birth_date?: DateTimeWithAggregatesFilter | Date | string
        death_date?: DateTimeWithAggregatesFilter | Date | string
        function?: StringWithAggregatesFilter | string
        income?: FloatWithAggregatesFilter | number
        family_id?: UuidWithAggregatesFilter | string
        tenant_id?: StringWithAggregatesFilter | string
        created_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
        updated_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    }

    export type TenantsWhereInput = {
        AND?: Enumerable<TenantsWhereInput>
        OR?: Enumerable<TenantsWhereInput>
        NOT?: Enumerable<TenantsWhereInput>
        id?: StringFilter | string
        data?: JsonNullableFilter
        created_at?: DateTimeNullableFilter | Date | string | null
        updated_at?: DateTimeNullableFilter | Date | string | null
        benefactors?: BenefactorsListRelationFilter
        domains?: DomainsListRelationFilter
        families?: FamiliesListRelationFilter
        family_sponsorship?: Family_sponsorshipListRelationFilter
        income_sponsor?: Income_sponsorListRelationFilter
        orphan_sponsorship?: Orphan_sponsorshipListRelationFilter
        orphans?: OrphansListRelationFilter
        second_sponsors?: Second_sponsorsListRelationFilter
        sponsor_sponsorship?: Sponsor_sponsorshipListRelationFilter
        sponsors?: SponsorsListRelationFilter
        sponsorships?: SponsorshipsListRelationFilter
        spouses?: SpousesListRelationFilter
        users?: UsersListRelationFilter
    }

    export type TenantsOrderByWithRelationInput = {
        id?: SortOrder
        data?: SortOrder
        created_at?: SortOrder
        updated_at?: SortOrder
        benefactors?: BenefactorsOrderByRelationAggregateInput
        domains?: DomainsOrderByRelationAggregateInput
        families?: FamiliesOrderByRelationAggregateInput
        family_sponsorship?: Family_sponsorshipOrderByRelationAggregateInput
        income_sponsor?: Income_sponsorOrderByRelationAggregateInput
        orphan_sponsorship?: Orphan_sponsorshipOrderByRelationAggregateInput
        orphans?: OrphansOrderByRelationAggregateInput
        second_sponsors?: Second_sponsorsOrderByRelationAggregateInput
        sponsor_sponsorship?: Sponsor_sponsorshipOrderByRelationAggregateInput
        sponsors?: SponsorsOrderByRelationAggregateInput
        sponsorships?: SponsorshipsOrderByRelationAggregateInput
        spouses?: SpousesOrderByRelationAggregateInput
        users?: UsersOrderByRelationAggregateInput
    }

    export type TenantsWhereUniqueInput = {
        id?: string
    }

    export type TenantsOrderByWithAggregationInput = {
        id?: SortOrder
        data?: SortOrder
        created_at?: SortOrder
        updated_at?: SortOrder
        _count?: TenantsCountOrderByAggregateInput
        _max?: TenantsMaxOrderByAggregateInput
        _min?: TenantsMinOrderByAggregateInput
    }

    export type TenantsScalarWhereWithAggregatesInput = {
        AND?: Enumerable<TenantsScalarWhereWithAggregatesInput>
        OR?: Enumerable<TenantsScalarWhereWithAggregatesInput>
        NOT?: Enumerable<TenantsScalarWhereWithAggregatesInput>
        id?: StringWithAggregatesFilter | string
        data?: JsonNullableWithAggregatesFilter
        created_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
        updated_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    }

    export type UsersWhereInput = {
        AND?: Enumerable<UsersWhereInput>
        OR?: Enumerable<UsersWhereInput>
        NOT?: Enumerable<UsersWhereInput>
        id?: UuidFilter | string
        first_name?: StringFilter | string
        last_name?: StringFilter | string
        phone?: StringFilter | string
        email?: StringFilter | string
        email_verified_at?: DateTimeNullableFilter | Date | string | null
        password?: StringFilter | string
        remember_token?: StringNullableFilter | string | null
        tenant_id?: StringFilter | string
        created_at?: DateTimeNullableFilter | Date | string | null
        updated_at?: DateTimeNullableFilter | Date | string | null
        orphans_orphans_created_byTousers?: OrphansListRelationFilter
        orphans_orphans_deleted_byTousers?: OrphansListRelationFilter
        sessions?: SessionsListRelationFilter
        settings?: SettingsListRelationFilter
        sponsors_sponsors_created_byTousers?: SponsorsListRelationFilter
        sponsors_sponsors_deleted_byTousers?: SponsorsListRelationFilter
        tenants?: XOR<TenantsRelationFilter, TenantsWhereInput>
    }

    export type UsersOrderByWithRelationInput = {
        id?: SortOrder
        first_name?: SortOrder
        last_name?: SortOrder
        phone?: SortOrder
        email?: SortOrder
        email_verified_at?: SortOrder
        password?: SortOrder
        remember_token?: SortOrder
        tenant_id?: SortOrder
        created_at?: SortOrder
        updated_at?: SortOrder
        orphans_orphans_created_byTousers?: OrphansOrderByRelationAggregateInput
        orphans_orphans_deleted_byTousers?: OrphansOrderByRelationAggregateInput
        sessions?: SessionsOrderByRelationAggregateInput
        settings?: SettingsOrderByRelationAggregateInput
        sponsors_sponsors_created_byTousers?: SponsorsOrderByRelationAggregateInput
        sponsors_sponsors_deleted_byTousers?: SponsorsOrderByRelationAggregateInput
        tenants?: TenantsOrderByWithRelationInput
    }

    export type UsersWhereUniqueInput = {
        id?: string
    }

    export type UsersOrderByWithAggregationInput = {
        id?: SortOrder
        first_name?: SortOrder
        last_name?: SortOrder
        phone?: SortOrder
        email?: SortOrder
        email_verified_at?: SortOrder
        password?: SortOrder
        remember_token?: SortOrder
        tenant_id?: SortOrder
        created_at?: SortOrder
        updated_at?: SortOrder
        _count?: UsersCountOrderByAggregateInput
        _max?: UsersMaxOrderByAggregateInput
        _min?: UsersMinOrderByAggregateInput
    }

    export type UsersScalarWhereWithAggregatesInput = {
        AND?: Enumerable<UsersScalarWhereWithAggregatesInput>
        OR?: Enumerable<UsersScalarWhereWithAggregatesInput>
        NOT?: Enumerable<UsersScalarWhereWithAggregatesInput>
        id?: UuidWithAggregatesFilter | string
        first_name?: StringWithAggregatesFilter | string
        last_name?: StringWithAggregatesFilter | string
        phone?: StringWithAggregatesFilter | string
        email?: StringWithAggregatesFilter | string
        email_verified_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
        password?: StringWithAggregatesFilter | string
        remember_token?: StringNullableWithAggregatesFilter | string | null
        tenant_id?: StringWithAggregatesFilter | string
        created_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
        updated_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    }

    export type BenefactorsCreateInput = {
        id: string
        deleted_at?: Date | string | null
        created_at?: Date | string | null
        updated_at?: Date | string | null
        tenants: TenantsCreateNestedOneWithoutBenefactorsInput
    }

    export type BenefactorsUncheckedCreateInput = {
        id: string
        tenant_id: string
        deleted_at?: Date | string | null
        created_at?: Date | string | null
        updated_at?: Date | string | null
    }

    export type BenefactorsUpdateInput = {
        id?: StringFieldUpdateOperationsInput | string
        deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        tenants?: TenantsUpdateOneRequiredWithoutBenefactorsNestedInput
    }

    export type BenefactorsUncheckedUpdateInput = {
        id?: StringFieldUpdateOperationsInput | string
        tenant_id?: StringFieldUpdateOperationsInput | string
        deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    }

    export type BenefactorsCreateManyInput = {
        id: string
        tenant_id: string
        deleted_at?: Date | string | null
        created_at?: Date | string | null
        updated_at?: Date | string | null
    }

    export type BenefactorsUpdateManyMutationInput = {
        id?: StringFieldUpdateOperationsInput | string
        deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    }

    export type BenefactorsUncheckedUpdateManyInput = {
        id?: StringFieldUpdateOperationsInput | string
        tenant_id?: StringFieldUpdateOperationsInput | string
        deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    }

    export type CacheCreateInput = {
        key: string
        value: string
        expiration: number
    }

    export type CacheUncheckedCreateInput = {
        key: string
        value: string
        expiration: number
    }

    export type CacheUpdateInput = {
        key?: StringFieldUpdateOperationsInput | string
        value?: StringFieldUpdateOperationsInput | string
        expiration?: IntFieldUpdateOperationsInput | number
    }

    export type CacheUncheckedUpdateInput = {
        key?: StringFieldUpdateOperationsInput | string
        value?: StringFieldUpdateOperationsInput | string
        expiration?: IntFieldUpdateOperationsInput | number
    }

    export type CacheCreateManyInput = {
        key: string
        value: string
        expiration: number
    }

    export type CacheUpdateManyMutationInput = {
        key?: StringFieldUpdateOperationsInput | string
        value?: StringFieldUpdateOperationsInput | string
        expiration?: IntFieldUpdateOperationsInput | number
    }

    export type CacheUncheckedUpdateManyInput = {
        key?: StringFieldUpdateOperationsInput | string
        value?: StringFieldUpdateOperationsInput | string
        expiration?: IntFieldUpdateOperationsInput | number
    }

    export type Cache_locksCreateInput = {
        key: string
        owner: string
        expiration: number
    }

    export type Cache_locksUncheckedCreateInput = {
        key: string
        owner: string
        expiration: number
    }

    export type Cache_locksUpdateInput = {
        key?: StringFieldUpdateOperationsInput | string
        owner?: StringFieldUpdateOperationsInput | string
        expiration?: IntFieldUpdateOperationsInput | number
    }

    export type Cache_locksUncheckedUpdateInput = {
        key?: StringFieldUpdateOperationsInput | string
        owner?: StringFieldUpdateOperationsInput | string
        expiration?: IntFieldUpdateOperationsInput | number
    }

    export type Cache_locksCreateManyInput = {
        key: string
        owner: string
        expiration: number
    }

    export type Cache_locksUpdateManyMutationInput = {
        key?: StringFieldUpdateOperationsInput | string
        owner?: StringFieldUpdateOperationsInput | string
        expiration?: IntFieldUpdateOperationsInput | number
    }

    export type Cache_locksUncheckedUpdateManyInput = {
        key?: StringFieldUpdateOperationsInput | string
        owner?: StringFieldUpdateOperationsInput | string
        expiration?: IntFieldUpdateOperationsInput | number
    }

    export type DomainsCreateInput = {
        id: string
        domain: string
        created_at?: Date | string | null
        updated_at?: Date | string | null
        tenants: TenantsCreateNestedOneWithoutDomainsInput
    }

    export type DomainsUncheckedCreateInput = {
        id: string
        domain: string
        tenant_id: string
        created_at?: Date | string | null
        updated_at?: Date | string | null
    }

    export type DomainsUpdateInput = {
        id?: StringFieldUpdateOperationsInput | string
        domain?: StringFieldUpdateOperationsInput | string
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        tenants?: TenantsUpdateOneRequiredWithoutDomainsNestedInput
    }

    export type DomainsUncheckedUpdateInput = {
        id?: StringFieldUpdateOperationsInput | string
        domain?: StringFieldUpdateOperationsInput | string
        tenant_id?: StringFieldUpdateOperationsInput | string
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    }

    export type DomainsCreateManyInput = {
        id: string
        domain: string
        tenant_id: string
        created_at?: Date | string | null
        updated_at?: Date | string | null
    }

    export type DomainsUpdateManyMutationInput = {
        id?: StringFieldUpdateOperationsInput | string
        domain?: StringFieldUpdateOperationsInput | string
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    }

    export type DomainsUncheckedUpdateManyInput = {
        id?: StringFieldUpdateOperationsInput | string
        domain?: StringFieldUpdateOperationsInput | string
        tenant_id?: StringFieldUpdateOperationsInput | string
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    }

    export type FamiliesCreateInput = {
        id: string
        name: string
        report: string
        created_at?: Date | string | null
        updated_at?: Date | string | null
        tenants: TenantsCreateNestedOneWithoutFamiliesInput
        family_furnishing?: Family_furnishingCreateNestedManyWithoutFamiliesInput
        family_housing?: Family_housingCreateNestedManyWithoutFamiliesInput
        family_sponsorship?: Family_sponsorshipCreateNestedManyWithoutFamiliesInput
        orphans?: OrphansCreateNestedManyWithoutFamiliesInput
        second_sponsors?: Second_sponsorsCreateNestedManyWithoutFamiliesInput
        spouses?: SpousesCreateNestedManyWithoutFamiliesInput
    }

    export type FamiliesUncheckedCreateInput = {
        id: string
        name: string
        report: string
        tenant_id: string
        created_at?: Date | string | null
        updated_at?: Date | string | null
        family_furnishing?: Family_furnishingUncheckedCreateNestedManyWithoutFamiliesInput
        family_housing?: Family_housingUncheckedCreateNestedManyWithoutFamiliesInput
        family_sponsorship?: Family_sponsorshipUncheckedCreateNestedManyWithoutFamiliesInput
        orphans?: OrphansUncheckedCreateNestedManyWithoutFamiliesInput
        second_sponsors?: Second_sponsorsUncheckedCreateNestedManyWithoutFamiliesInput
        spouses?: SpousesUncheckedCreateNestedManyWithoutFamiliesInput
    }

    export type FamiliesUpdateInput = {
        id?: StringFieldUpdateOperationsInput | string
        name?: StringFieldUpdateOperationsInput | string
        report?: StringFieldUpdateOperationsInput | string
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        tenants?: TenantsUpdateOneRequiredWithoutFamiliesNestedInput
        family_furnishing?: Family_furnishingUpdateManyWithoutFamiliesNestedInput
        family_housing?: Family_housingUpdateManyWithoutFamiliesNestedInput
        family_sponsorship?: Family_sponsorshipUpdateManyWithoutFamiliesNestedInput
        orphans?: OrphansUpdateManyWithoutFamiliesNestedInput
        second_sponsors?: Second_sponsorsUpdateManyWithoutFamiliesNestedInput
        spouses?: SpousesUpdateManyWithoutFamiliesNestedInput
    }

    export type FamiliesUncheckedUpdateInput = {
        id?: StringFieldUpdateOperationsInput | string
        name?: StringFieldUpdateOperationsInput | string
        report?: StringFieldUpdateOperationsInput | string
        tenant_id?: StringFieldUpdateOperationsInput | string
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        family_furnishing?: Family_furnishingUncheckedUpdateManyWithoutFamiliesNestedInput
        family_housing?: Family_housingUncheckedUpdateManyWithoutFamiliesNestedInput
        family_sponsorship?: Family_sponsorshipUncheckedUpdateManyWithoutFamiliesNestedInput
        orphans?: OrphansUncheckedUpdateManyWithoutFamiliesNestedInput
        second_sponsors?: Second_sponsorsUncheckedUpdateManyWithoutFamiliesNestedInput
        spouses?: SpousesUncheckedUpdateManyWithoutFamiliesNestedInput
    }

    export type FamiliesCreateManyInput = {
        id: string
        name: string
        report: string
        tenant_id: string
        created_at?: Date | string | null
        updated_at?: Date | string | null
    }

    export type FamiliesUpdateManyMutationInput = {
        id?: StringFieldUpdateOperationsInput | string
        name?: StringFieldUpdateOperationsInput | string
        report?: StringFieldUpdateOperationsInput | string
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    }

    export type FamiliesUncheckedUpdateManyInput = {
        id?: StringFieldUpdateOperationsInput | string
        name?: StringFieldUpdateOperationsInput | string
        report?: StringFieldUpdateOperationsInput | string
        tenant_id?: StringFieldUpdateOperationsInput | string
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    }

    export type Family_furnishingCreateInput = {
        id: string
        value: string
        families: FamiliesCreateNestedOneWithoutFamily_furnishingInput
        furnishings: FurnishingsCreateNestedOneWithoutFamily_furnishingInput
    }

    export type Family_furnishingUncheckedCreateInput = {
        id: string
        family_id: string
        furnishing_id: string
        value: string
    }

    export type Family_furnishingUpdateInput = {
        id?: StringFieldUpdateOperationsInput | string
        value?: StringFieldUpdateOperationsInput | string
        families?: FamiliesUpdateOneRequiredWithoutFamily_furnishingNestedInput
        furnishings?: FurnishingsUpdateOneRequiredWithoutFamily_furnishingNestedInput
    }

    export type Family_furnishingUncheckedUpdateInput = {
        id?: StringFieldUpdateOperationsInput | string
        family_id?: StringFieldUpdateOperationsInput | string
        furnishing_id?: StringFieldUpdateOperationsInput | string
        value?: StringFieldUpdateOperationsInput | string
    }

    export type Family_furnishingCreateManyInput = {
        id: string
        family_id: string
        furnishing_id: string
        value: string
    }

    export type Family_furnishingUpdateManyMutationInput = {
        id?: StringFieldUpdateOperationsInput | string
        value?: StringFieldUpdateOperationsInput | string
    }

    export type Family_furnishingUncheckedUpdateManyInput = {
        id?: StringFieldUpdateOperationsInput | string
        family_id?: StringFieldUpdateOperationsInput | string
        furnishing_id?: StringFieldUpdateOperationsInput | string
        value?: StringFieldUpdateOperationsInput | string
    }

    export type Family_housingCreateInput = {
        id: string
        value: string
        families: FamiliesCreateNestedOneWithoutFamily_housingInput
        housings: HousingsCreateNestedOneWithoutFamily_housingInput
    }

    export type Family_housingUncheckedCreateInput = {
        id: string
        family_id: string
        housing_id: string
        value: string
    }

    export type Family_housingUpdateInput = {
        id?: StringFieldUpdateOperationsInput | string
        value?: StringFieldUpdateOperationsInput | string
        families?: FamiliesUpdateOneRequiredWithoutFamily_housingNestedInput
        housings?: HousingsUpdateOneRequiredWithoutFamily_housingNestedInput
    }

    export type Family_housingUncheckedUpdateInput = {
        id?: StringFieldUpdateOperationsInput | string
        family_id?: StringFieldUpdateOperationsInput | string
        housing_id?: StringFieldUpdateOperationsInput | string
        value?: StringFieldUpdateOperationsInput | string
    }

    export type Family_housingCreateManyInput = {
        id: string
        family_id: string
        housing_id: string
        value: string
    }

    export type Family_housingUpdateManyMutationInput = {
        id?: StringFieldUpdateOperationsInput | string
        value?: StringFieldUpdateOperationsInput | string
    }

    export type Family_housingUncheckedUpdateManyInput = {
        id?: StringFieldUpdateOperationsInput | string
        family_id?: StringFieldUpdateOperationsInput | string
        housing_id?: StringFieldUpdateOperationsInput | string
        value?: StringFieldUpdateOperationsInput | string
    }

    export type Family_sponsorshipCreateInput = {
        id: string
        type: family_sponsorship_type
        value: string
        created_at?: Date | string | null
        updated_at?: Date | string | null
        families: FamiliesCreateNestedOneWithoutFamily_sponsorshipInput
        tenants: TenantsCreateNestedOneWithoutFamily_sponsorshipInput
    }

    export type Family_sponsorshipUncheckedCreateInput = {
        id: string
        family_id: string
        type: family_sponsorship_type
        value: string
        tenant_id: string
        created_at?: Date | string | null
        updated_at?: Date | string | null
    }

    export type Family_sponsorshipUpdateInput = {
        id?: StringFieldUpdateOperationsInput | string
        type?: Enumfamily_sponsorship_typeFieldUpdateOperationsInput | family_sponsorship_type
        value?: StringFieldUpdateOperationsInput | string
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        families?: FamiliesUpdateOneRequiredWithoutFamily_sponsorshipNestedInput
        tenants?: TenantsUpdateOneRequiredWithoutFamily_sponsorshipNestedInput
    }

    export type Family_sponsorshipUncheckedUpdateInput = {
        id?: StringFieldUpdateOperationsInput | string
        family_id?: StringFieldUpdateOperationsInput | string
        type?: Enumfamily_sponsorship_typeFieldUpdateOperationsInput | family_sponsorship_type
        value?: StringFieldUpdateOperationsInput | string
        tenant_id?: StringFieldUpdateOperationsInput | string
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    }

    export type Family_sponsorshipCreateManyInput = {
        id: string
        family_id: string
        type: family_sponsorship_type
        value: string
        tenant_id: string
        created_at?: Date | string | null
        updated_at?: Date | string | null
    }

    export type Family_sponsorshipUpdateManyMutationInput = {
        id?: StringFieldUpdateOperationsInput | string
        type?: Enumfamily_sponsorship_typeFieldUpdateOperationsInput | family_sponsorship_type
        value?: StringFieldUpdateOperationsInput | string
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    }

    export type Family_sponsorshipUncheckedUpdateManyInput = {
        id?: StringFieldUpdateOperationsInput | string
        family_id?: StringFieldUpdateOperationsInput | string
        type?: Enumfamily_sponsorship_typeFieldUpdateOperationsInput | family_sponsorship_type
        value?: StringFieldUpdateOperationsInput | string
        tenant_id?: StringFieldUpdateOperationsInput | string
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    }

    export type FurnishingsCreateInput = {
        id: string
        name: string
        family_furnishing?: Family_furnishingCreateNestedManyWithoutFurnishingsInput
    }

    export type FurnishingsUncheckedCreateInput = {
        id: string
        name: string
        family_furnishing?: Family_furnishingUncheckedCreateNestedManyWithoutFurnishingsInput
    }

    export type FurnishingsUpdateInput = {
        id?: StringFieldUpdateOperationsInput | string
        name?: StringFieldUpdateOperationsInput | string
        family_furnishing?: Family_furnishingUpdateManyWithoutFurnishingsNestedInput
    }

    export type FurnishingsUncheckedUpdateInput = {
        id?: StringFieldUpdateOperationsInput | string
        name?: StringFieldUpdateOperationsInput | string
        family_furnishing?: Family_furnishingUncheckedUpdateManyWithoutFurnishingsNestedInput
    }

    export type FurnishingsCreateManyInput = {
        id: string
        name: string
    }

    export type FurnishingsUpdateManyMutationInput = {
        id?: StringFieldUpdateOperationsInput | string
        name?: StringFieldUpdateOperationsInput | string
    }

    export type FurnishingsUncheckedUpdateManyInput = {
        id?: StringFieldUpdateOperationsInput | string
        name?: StringFieldUpdateOperationsInput | string
    }

    export type HousingsCreateInput = {
        id: string
        name: string
        family_housing?: Family_housingCreateNestedManyWithoutHousingsInput
    }

    export type HousingsUncheckedCreateInput = {
        id: string
        name: string
        family_housing?: Family_housingUncheckedCreateNestedManyWithoutHousingsInput
    }

    export type HousingsUpdateInput = {
        id?: StringFieldUpdateOperationsInput | string
        name?: StringFieldUpdateOperationsInput | string
        family_housing?: Family_housingUpdateManyWithoutHousingsNestedInput
    }

    export type HousingsUncheckedUpdateInput = {
        id?: StringFieldUpdateOperationsInput | string
        name?: StringFieldUpdateOperationsInput | string
        family_housing?: Family_housingUncheckedUpdateManyWithoutHousingsNestedInput
    }

    export type HousingsCreateManyInput = {
        id: string
        name: string
    }

    export type HousingsUpdateManyMutationInput = {
        id?: StringFieldUpdateOperationsInput | string
        name?: StringFieldUpdateOperationsInput | string
    }

    export type HousingsUncheckedUpdateManyInput = {
        id?: StringFieldUpdateOperationsInput | string
        name?: StringFieldUpdateOperationsInput | string
    }

    export type Income_sponsorCreateInput = {
        id: string
        value: number
        created_at?: Date | string | null
        updated_at?: Date | string | null
        incomes: IncomesCreateNestedOneWithoutIncome_sponsorInput
        sponsors: SponsorsCreateNestedOneWithoutIncome_sponsorInput
        tenants: TenantsCreateNestedOneWithoutIncome_sponsorInput
    }

    export type Income_sponsorUncheckedCreateInput = {
        id: string
        income_id: string
        sponsor_id: string
        tenant_id: string
        value: number
        created_at?: Date | string | null
        updated_at?: Date | string | null
    }

    export type Income_sponsorUpdateInput = {
        id?: StringFieldUpdateOperationsInput | string
        value?: FloatFieldUpdateOperationsInput | number
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        incomes?: IncomesUpdateOneRequiredWithoutIncome_sponsorNestedInput
        sponsors?: SponsorsUpdateOneRequiredWithoutIncome_sponsorNestedInput
        tenants?: TenantsUpdateOneRequiredWithoutIncome_sponsorNestedInput
    }

    export type Income_sponsorUncheckedUpdateInput = {
        id?: StringFieldUpdateOperationsInput | string
        income_id?: StringFieldUpdateOperationsInput | string
        sponsor_id?: StringFieldUpdateOperationsInput | string
        tenant_id?: StringFieldUpdateOperationsInput | string
        value?: FloatFieldUpdateOperationsInput | number
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    }

    export type Income_sponsorCreateManyInput = {
        id: string
        income_id: string
        sponsor_id: string
        tenant_id: string
        value: number
        created_at?: Date | string | null
        updated_at?: Date | string | null
    }

    export type Income_sponsorUpdateManyMutationInput = {
        id?: StringFieldUpdateOperationsInput | string
        value?: FloatFieldUpdateOperationsInput | number
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    }

    export type Income_sponsorUncheckedUpdateManyInput = {
        id?: StringFieldUpdateOperationsInput | string
        income_id?: StringFieldUpdateOperationsInput | string
        sponsor_id?: StringFieldUpdateOperationsInput | string
        tenant_id?: StringFieldUpdateOperationsInput | string
        value?: FloatFieldUpdateOperationsInput | number
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    }

    export type IncomesCreateInput = {
        id: string
        name: string
        income_sponsor?: Income_sponsorCreateNestedManyWithoutIncomesInput
    }

    export type IncomesUncheckedCreateInput = {
        id: string
        name: string
        income_sponsor?: Income_sponsorUncheckedCreateNestedManyWithoutIncomesInput
    }

    export type IncomesUpdateInput = {
        id?: StringFieldUpdateOperationsInput | string
        name?: StringFieldUpdateOperationsInput | string
        income_sponsor?: Income_sponsorUpdateManyWithoutIncomesNestedInput
    }

    export type IncomesUncheckedUpdateInput = {
        id?: StringFieldUpdateOperationsInput | string
        name?: StringFieldUpdateOperationsInput | string
        income_sponsor?: Income_sponsorUncheckedUpdateManyWithoutIncomesNestedInput
    }

    export type IncomesCreateManyInput = {
        id: string
        name: string
    }

    export type IncomesUpdateManyMutationInput = {
        id?: StringFieldUpdateOperationsInput | string
        name?: StringFieldUpdateOperationsInput | string
    }

    export type IncomesUncheckedUpdateManyInput = {
        id?: StringFieldUpdateOperationsInput | string
        name?: StringFieldUpdateOperationsInput | string
    }

    export type MediaCreateInput = {
        id: string
        model_type: string
        model_id: bigint | number
        uuid?: string | null
        collection_name: string
        name: string
        file_name: string
        mime_type?: string | null
        disk: string
        conversions_disk?: string | null
        size: bigint | number
        manipulations: JsonNullValueInput | InputJsonValue
        custom_properties: JsonNullValueInput | InputJsonValue
        generated_conversions: JsonNullValueInput | InputJsonValue
        responsive_images: JsonNullValueInput | InputJsonValue
        order_column?: number | null
        created_at?: Date | string | null
        updated_at?: Date | string | null
    }

    export type MediaUncheckedCreateInput = {
        id: string
        model_type: string
        model_id: bigint | number
        uuid?: string | null
        collection_name: string
        name: string
        file_name: string
        mime_type?: string | null
        disk: string
        conversions_disk?: string | null
        size: bigint | number
        manipulations: JsonNullValueInput | InputJsonValue
        custom_properties: JsonNullValueInput | InputJsonValue
        generated_conversions: JsonNullValueInput | InputJsonValue
        responsive_images: JsonNullValueInput | InputJsonValue
        order_column?: number | null
        created_at?: Date | string | null
        updated_at?: Date | string | null
    }

    export type MediaUpdateInput = {
        id?: StringFieldUpdateOperationsInput | string
        model_type?: StringFieldUpdateOperationsInput | string
        model_id?: BigIntFieldUpdateOperationsInput | bigint | number
        uuid?: NullableStringFieldUpdateOperationsInput | string | null
        collection_name?: StringFieldUpdateOperationsInput | string
        name?: StringFieldUpdateOperationsInput | string
        file_name?: StringFieldUpdateOperationsInput | string
        mime_type?: NullableStringFieldUpdateOperationsInput | string | null
        disk?: StringFieldUpdateOperationsInput | string
        conversions_disk?: NullableStringFieldUpdateOperationsInput | string | null
        size?: BigIntFieldUpdateOperationsInput | bigint | number
        manipulations?: JsonNullValueInput | InputJsonValue
        custom_properties?: JsonNullValueInput | InputJsonValue
        generated_conversions?: JsonNullValueInput | InputJsonValue
        responsive_images?: JsonNullValueInput | InputJsonValue
        order_column?: NullableIntFieldUpdateOperationsInput | number | null
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    }

    export type MediaUncheckedUpdateInput = {
        id?: StringFieldUpdateOperationsInput | string
        model_type?: StringFieldUpdateOperationsInput | string
        model_id?: BigIntFieldUpdateOperationsInput | bigint | number
        uuid?: NullableStringFieldUpdateOperationsInput | string | null
        collection_name?: StringFieldUpdateOperationsInput | string
        name?: StringFieldUpdateOperationsInput | string
        file_name?: StringFieldUpdateOperationsInput | string
        mime_type?: NullableStringFieldUpdateOperationsInput | string | null
        disk?: StringFieldUpdateOperationsInput | string
        conversions_disk?: NullableStringFieldUpdateOperationsInput | string | null
        size?: BigIntFieldUpdateOperationsInput | bigint | number
        manipulations?: JsonNullValueInput | InputJsonValue
        custom_properties?: JsonNullValueInput | InputJsonValue
        generated_conversions?: JsonNullValueInput | InputJsonValue
        responsive_images?: JsonNullValueInput | InputJsonValue
        order_column?: NullableIntFieldUpdateOperationsInput | number | null
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    }

    export type MediaCreateManyInput = {
        id: string
        model_type: string
        model_id: bigint | number
        uuid?: string | null
        collection_name: string
        name: string
        file_name: string
        mime_type?: string | null
        disk: string
        conversions_disk?: string | null
        size: bigint | number
        manipulations: JsonNullValueInput | InputJsonValue
        custom_properties: JsonNullValueInput | InputJsonValue
        generated_conversions: JsonNullValueInput | InputJsonValue
        responsive_images: JsonNullValueInput | InputJsonValue
        order_column?: number | null
        created_at?: Date | string | null
        updated_at?: Date | string | null
    }

    export type MediaUpdateManyMutationInput = {
        id?: StringFieldUpdateOperationsInput | string
        model_type?: StringFieldUpdateOperationsInput | string
        model_id?: BigIntFieldUpdateOperationsInput | bigint | number
        uuid?: NullableStringFieldUpdateOperationsInput | string | null
        collection_name?: StringFieldUpdateOperationsInput | string
        name?: StringFieldUpdateOperationsInput | string
        file_name?: StringFieldUpdateOperationsInput | string
        mime_type?: NullableStringFieldUpdateOperationsInput | string | null
        disk?: StringFieldUpdateOperationsInput | string
        conversions_disk?: NullableStringFieldUpdateOperationsInput | string | null
        size?: BigIntFieldUpdateOperationsInput | bigint | number
        manipulations?: JsonNullValueInput | InputJsonValue
        custom_properties?: JsonNullValueInput | InputJsonValue
        generated_conversions?: JsonNullValueInput | InputJsonValue
        responsive_images?: JsonNullValueInput | InputJsonValue
        order_column?: NullableIntFieldUpdateOperationsInput | number | null
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    }

    export type MediaUncheckedUpdateManyInput = {
        id?: StringFieldUpdateOperationsInput | string
        model_type?: StringFieldUpdateOperationsInput | string
        model_id?: BigIntFieldUpdateOperationsInput | bigint | number
        uuid?: NullableStringFieldUpdateOperationsInput | string | null
        collection_name?: StringFieldUpdateOperationsInput | string
        name?: StringFieldUpdateOperationsInput | string
        file_name?: StringFieldUpdateOperationsInput | string
        mime_type?: NullableStringFieldUpdateOperationsInput | string | null
        disk?: StringFieldUpdateOperationsInput | string
        conversions_disk?: NullableStringFieldUpdateOperationsInput | string | null
        size?: BigIntFieldUpdateOperationsInput | bigint | number
        manipulations?: JsonNullValueInput | InputJsonValue
        custom_properties?: JsonNullValueInput | InputJsonValue
        generated_conversions?: JsonNullValueInput | InputJsonValue
        responsive_images?: JsonNullValueInput | InputJsonValue
        order_column?: NullableIntFieldUpdateOperationsInput | number | null
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    }

    export type Model_has_permissionsCreateInput = {
        model_type: string
        model_uuid: string
        permissions: PermissionsCreateNestedOneWithoutModel_has_permissionsInput
    }

    export type Model_has_permissionsUncheckedCreateInput = {
        permission_id: string
        model_type: string
        model_uuid: string
    }

    export type Model_has_permissionsUpdateInput = {
        model_type?: StringFieldUpdateOperationsInput | string
        model_uuid?: StringFieldUpdateOperationsInput | string
        permissions?: PermissionsUpdateOneRequiredWithoutModel_has_permissionsNestedInput
    }

    export type Model_has_permissionsUncheckedUpdateInput = {
        permission_id?: StringFieldUpdateOperationsInput | string
        model_type?: StringFieldUpdateOperationsInput | string
        model_uuid?: StringFieldUpdateOperationsInput | string
    }

    export type Model_has_permissionsCreateManyInput = {
        permission_id: string
        model_type: string
        model_uuid: string
    }

    export type Model_has_permissionsUpdateManyMutationInput = {
        model_type?: StringFieldUpdateOperationsInput | string
        model_uuid?: StringFieldUpdateOperationsInput | string
    }

    export type Model_has_permissionsUncheckedUpdateManyInput = {
        permission_id?: StringFieldUpdateOperationsInput | string
        model_type?: StringFieldUpdateOperationsInput | string
        model_uuid?: StringFieldUpdateOperationsInput | string
    }

    export type Model_has_rolesCreateInput = {
        model_type: string
        model_uuid: string
        roles: RolesCreateNestedOneWithoutModel_has_rolesInput
    }

    export type Model_has_rolesUncheckedCreateInput = {
        role_id: string
        model_type: string
        model_uuid: string
    }

    export type Model_has_rolesUpdateInput = {
        model_type?: StringFieldUpdateOperationsInput | string
        model_uuid?: StringFieldUpdateOperationsInput | string
        roles?: RolesUpdateOneRequiredWithoutModel_has_rolesNestedInput
    }

    export type Model_has_rolesUncheckedUpdateInput = {
        role_id?: StringFieldUpdateOperationsInput | string
        model_type?: StringFieldUpdateOperationsInput | string
        model_uuid?: StringFieldUpdateOperationsInput | string
    }

    export type Model_has_rolesCreateManyInput = {
        role_id: string
        model_type: string
        model_uuid: string
    }

    export type Model_has_rolesUpdateManyMutationInput = {
        model_type?: StringFieldUpdateOperationsInput | string
        model_uuid?: StringFieldUpdateOperationsInput | string
    }

    export type Model_has_rolesUncheckedUpdateManyInput = {
        role_id?: StringFieldUpdateOperationsInput | string
        model_type?: StringFieldUpdateOperationsInput | string
        model_uuid?: StringFieldUpdateOperationsInput | string
    }

    export type Orphan_sponsorshipCreateInput = {
        id: string
        type: orphan_sponsorship_type
        value?: string | null
        created_at?: Date | string | null
        updated_at?: Date | string | null
        orphans: OrphansCreateNestedOneWithoutOrphan_sponsorshipInput
        tenants: TenantsCreateNestedOneWithoutOrphan_sponsorshipInput
    }

    export type Orphan_sponsorshipUncheckedCreateInput = {
        id: string
        orphan_id: string
        type: orphan_sponsorship_type
        value?: string | null
        tenant_id: string
        created_at?: Date | string | null
        updated_at?: Date | string | null
    }

    export type Orphan_sponsorshipUpdateInput = {
        id?: StringFieldUpdateOperationsInput | string
        type?: Enumorphan_sponsorship_typeFieldUpdateOperationsInput | orphan_sponsorship_type
        value?: NullableStringFieldUpdateOperationsInput | string | null
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        orphans?: OrphansUpdateOneRequiredWithoutOrphan_sponsorshipNestedInput
        tenants?: TenantsUpdateOneRequiredWithoutOrphan_sponsorshipNestedInput
    }

    export type Orphan_sponsorshipUncheckedUpdateInput = {
        id?: StringFieldUpdateOperationsInput | string
        orphan_id?: StringFieldUpdateOperationsInput | string
        type?: Enumorphan_sponsorship_typeFieldUpdateOperationsInput | orphan_sponsorship_type
        value?: NullableStringFieldUpdateOperationsInput | string | null
        tenant_id?: StringFieldUpdateOperationsInput | string
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    }

    export type Orphan_sponsorshipCreateManyInput = {
        id: string
        orphan_id: string
        type: orphan_sponsorship_type
        value?: string | null
        tenant_id: string
        created_at?: Date | string | null
        updated_at?: Date | string | null
    }

    export type Orphan_sponsorshipUpdateManyMutationInput = {
        id?: StringFieldUpdateOperationsInput | string
        type?: Enumorphan_sponsorship_typeFieldUpdateOperationsInput | orphan_sponsorship_type
        value?: NullableStringFieldUpdateOperationsInput | string | null
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    }

    export type Orphan_sponsorshipUncheckedUpdateManyInput = {
        id?: StringFieldUpdateOperationsInput | string
        orphan_id?: StringFieldUpdateOperationsInput | string
        type?: Enumorphan_sponsorship_typeFieldUpdateOperationsInput | orphan_sponsorship_type
        value?: NullableStringFieldUpdateOperationsInput | string | null
        tenant_id?: StringFieldUpdateOperationsInput | string
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    }

    export type OrphansCreateInput = {
        id: string
        first_name: string
        last_name: string
        birth_date: Date | string
        family_status: string
        health_status: string
        academic_level: string
        shoes_size: string
        pants_size: string
        shirt_size: string
        note: string
        created_at?: Date | string | null
        updated_at?: Date | string | null
        orphan_sponsorship?: Orphan_sponsorshipCreateNestedManyWithoutOrphansInput
        users_orphans_created_byTousers: UsersCreateNestedOneWithoutOrphans_orphans_created_byTousersInput
        users_orphans_deleted_byTousers?: UsersCreateNestedOneWithoutOrphans_orphans_deleted_byTousersInput
        families: FamiliesCreateNestedOneWithoutOrphansInput
        tenants: TenantsCreateNestedOneWithoutOrphansInput
    }

    export type OrphansUncheckedCreateInput = {
        id: string
        first_name: string
        last_name: string
        birth_date: Date | string
        family_status: string
        health_status: string
        academic_level: string
        shoes_size: string
        pants_size: string
        shirt_size: string
        note: string
        tenant_id: string
        family_id: string
        created_by: string
        deleted_by?: string | null
        created_at?: Date | string | null
        updated_at?: Date | string | null
        orphan_sponsorship?: Orphan_sponsorshipUncheckedCreateNestedManyWithoutOrphansInput
    }

    export type OrphansUpdateInput = {
        id?: StringFieldUpdateOperationsInput | string
        first_name?: StringFieldUpdateOperationsInput | string
        last_name?: StringFieldUpdateOperationsInput | string
        birth_date?: DateTimeFieldUpdateOperationsInput | Date | string
        family_status?: StringFieldUpdateOperationsInput | string
        health_status?: StringFieldUpdateOperationsInput | string
        academic_level?: StringFieldUpdateOperationsInput | string
        shoes_size?: StringFieldUpdateOperationsInput | string
        pants_size?: StringFieldUpdateOperationsInput | string
        shirt_size?: StringFieldUpdateOperationsInput | string
        note?: StringFieldUpdateOperationsInput | string
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        orphan_sponsorship?: Orphan_sponsorshipUpdateManyWithoutOrphansNestedInput
        users_orphans_created_byTousers?: UsersUpdateOneRequiredWithoutOrphans_orphans_created_byTousersNestedInput
        users_orphans_deleted_byTousers?: UsersUpdateOneWithoutOrphans_orphans_deleted_byTousersNestedInput
        families?: FamiliesUpdateOneRequiredWithoutOrphansNestedInput
        tenants?: TenantsUpdateOneRequiredWithoutOrphansNestedInput
    }

    export type OrphansUncheckedUpdateInput = {
        id?: StringFieldUpdateOperationsInput | string
        first_name?: StringFieldUpdateOperationsInput | string
        last_name?: StringFieldUpdateOperationsInput | string
        birth_date?: DateTimeFieldUpdateOperationsInput | Date | string
        family_status?: StringFieldUpdateOperationsInput | string
        health_status?: StringFieldUpdateOperationsInput | string
        academic_level?: StringFieldUpdateOperationsInput | string
        shoes_size?: StringFieldUpdateOperationsInput | string
        pants_size?: StringFieldUpdateOperationsInput | string
        shirt_size?: StringFieldUpdateOperationsInput | string
        note?: StringFieldUpdateOperationsInput | string
        tenant_id?: StringFieldUpdateOperationsInput | string
        family_id?: StringFieldUpdateOperationsInput | string
        created_by?: StringFieldUpdateOperationsInput | string
        deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        orphan_sponsorship?: Orphan_sponsorshipUncheckedUpdateManyWithoutOrphansNestedInput
    }

    export type OrphansCreateManyInput = {
        id: string
        first_name: string
        last_name: string
        birth_date: Date | string
        family_status: string
        health_status: string
        academic_level: string
        shoes_size: string
        pants_size: string
        shirt_size: string
        note: string
        tenant_id: string
        family_id: string
        created_by: string
        deleted_by?: string | null
        created_at?: Date | string | null
        updated_at?: Date | string | null
    }

    export type OrphansUpdateManyMutationInput = {
        id?: StringFieldUpdateOperationsInput | string
        first_name?: StringFieldUpdateOperationsInput | string
        last_name?: StringFieldUpdateOperationsInput | string
        birth_date?: DateTimeFieldUpdateOperationsInput | Date | string
        family_status?: StringFieldUpdateOperationsInput | string
        health_status?: StringFieldUpdateOperationsInput | string
        academic_level?: StringFieldUpdateOperationsInput | string
        shoes_size?: StringFieldUpdateOperationsInput | string
        pants_size?: StringFieldUpdateOperationsInput | string
        shirt_size?: StringFieldUpdateOperationsInput | string
        note?: StringFieldUpdateOperationsInput | string
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    }

    export type OrphansUncheckedUpdateManyInput = {
        id?: StringFieldUpdateOperationsInput | string
        first_name?: StringFieldUpdateOperationsInput | string
        last_name?: StringFieldUpdateOperationsInput | string
        birth_date?: DateTimeFieldUpdateOperationsInput | Date | string
        family_status?: StringFieldUpdateOperationsInput | string
        health_status?: StringFieldUpdateOperationsInput | string
        academic_level?: StringFieldUpdateOperationsInput | string
        shoes_size?: StringFieldUpdateOperationsInput | string
        pants_size?: StringFieldUpdateOperationsInput | string
        shirt_size?: StringFieldUpdateOperationsInput | string
        note?: StringFieldUpdateOperationsInput | string
        tenant_id?: StringFieldUpdateOperationsInput | string
        family_id?: StringFieldUpdateOperationsInput | string
        created_by?: StringFieldUpdateOperationsInput | string
        deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    }

    export type Password_reset_tokensCreateInput = {
        email: string
        token: string
        created_at?: Date | string | null
    }

    export type Password_reset_tokensUncheckedCreateInput = {
        email: string
        token: string
        created_at?: Date | string | null
    }

    export type Password_reset_tokensUpdateInput = {
        email?: StringFieldUpdateOperationsInput | string
        token?: StringFieldUpdateOperationsInput | string
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    }

    export type Password_reset_tokensUncheckedUpdateInput = {
        email?: StringFieldUpdateOperationsInput | string
        token?: StringFieldUpdateOperationsInput | string
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    }

    export type Password_reset_tokensCreateManyInput = {
        email: string
        token: string
        created_at?: Date | string | null
    }

    export type Password_reset_tokensUpdateManyMutationInput = {
        email?: StringFieldUpdateOperationsInput | string
        token?: StringFieldUpdateOperationsInput | string
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    }

    export type Password_reset_tokensUncheckedUpdateManyInput = {
        email?: StringFieldUpdateOperationsInput | string
        token?: StringFieldUpdateOperationsInput | string
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    }

    export type PermissionsCreateInput = {
        uuid: string
        name: string
        guard_name: string
        created_at?: Date | string | null
        updated_at?: Date | string | null
        model_has_permissions?: Model_has_permissionsCreateNestedManyWithoutPermissionsInput
        role_has_permissions?: Role_has_permissionsCreateNestedManyWithoutPermissionsInput
    }

    export type PermissionsUncheckedCreateInput = {
        uuid: string
        name: string
        guard_name: string
        created_at?: Date | string | null
        updated_at?: Date | string | null
        model_has_permissions?: Model_has_permissionsUncheckedCreateNestedManyWithoutPermissionsInput
        role_has_permissions?: Role_has_permissionsUncheckedCreateNestedManyWithoutPermissionsInput
    }

    export type PermissionsUpdateInput = {
        uuid?: StringFieldUpdateOperationsInput | string
        name?: StringFieldUpdateOperationsInput | string
        guard_name?: StringFieldUpdateOperationsInput | string
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        model_has_permissions?: Model_has_permissionsUpdateManyWithoutPermissionsNestedInput
        role_has_permissions?: Role_has_permissionsUpdateManyWithoutPermissionsNestedInput
    }

    export type PermissionsUncheckedUpdateInput = {
        uuid?: StringFieldUpdateOperationsInput | string
        name?: StringFieldUpdateOperationsInput | string
        guard_name?: StringFieldUpdateOperationsInput | string
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        model_has_permissions?: Model_has_permissionsUncheckedUpdateManyWithoutPermissionsNestedInput
        role_has_permissions?: Role_has_permissionsUncheckedUpdateManyWithoutPermissionsNestedInput
    }

    export type PermissionsCreateManyInput = {
        uuid: string
        name: string
        guard_name: string
        created_at?: Date | string | null
        updated_at?: Date | string | null
    }

    export type PermissionsUpdateManyMutationInput = {
        uuid?: StringFieldUpdateOperationsInput | string
        name?: StringFieldUpdateOperationsInput | string
        guard_name?: StringFieldUpdateOperationsInput | string
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    }

    export type PermissionsUncheckedUpdateManyInput = {
        uuid?: StringFieldUpdateOperationsInput | string
        name?: StringFieldUpdateOperationsInput | string
        guard_name?: StringFieldUpdateOperationsInput | string
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    }

    export type Personal_access_tokensCreateInput = {
        id: string
        tokenable_type: string
        tokenable_id: string
        name: string
        token: string
        abilities?: string | null
        last_used_at?: Date | string | null
        expires_at?: Date | string | null
        created_at?: Date | string | null
        updated_at?: Date | string | null
    }

    export type Personal_access_tokensUncheckedCreateInput = {
        id: string
        tokenable_type: string
        tokenable_id: string
        name: string
        token: string
        abilities?: string | null
        last_used_at?: Date | string | null
        expires_at?: Date | string | null
        created_at?: Date | string | null
        updated_at?: Date | string | null
    }

    export type Personal_access_tokensUpdateInput = {
        id?: StringFieldUpdateOperationsInput | string
        tokenable_type?: StringFieldUpdateOperationsInput | string
        tokenable_id?: StringFieldUpdateOperationsInput | string
        name?: StringFieldUpdateOperationsInput | string
        token?: StringFieldUpdateOperationsInput | string
        abilities?: NullableStringFieldUpdateOperationsInput | string | null
        last_used_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    }

    export type Personal_access_tokensUncheckedUpdateInput = {
        id?: StringFieldUpdateOperationsInput | string
        tokenable_type?: StringFieldUpdateOperationsInput | string
        tokenable_id?: StringFieldUpdateOperationsInput | string
        name?: StringFieldUpdateOperationsInput | string
        token?: StringFieldUpdateOperationsInput | string
        abilities?: NullableStringFieldUpdateOperationsInput | string | null
        last_used_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    }

    export type Personal_access_tokensCreateManyInput = {
        id: string
        tokenable_type: string
        tokenable_id: string
        name: string
        token: string
        abilities?: string | null
        last_used_at?: Date | string | null
        expires_at?: Date | string | null
        created_at?: Date | string | null
        updated_at?: Date | string | null
    }

    export type Personal_access_tokensUpdateManyMutationInput = {
        id?: StringFieldUpdateOperationsInput | string
        tokenable_type?: StringFieldUpdateOperationsInput | string
        tokenable_id?: StringFieldUpdateOperationsInput | string
        name?: StringFieldUpdateOperationsInput | string
        token?: StringFieldUpdateOperationsInput | string
        abilities?: NullableStringFieldUpdateOperationsInput | string | null
        last_used_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    }

    export type Personal_access_tokensUncheckedUpdateManyInput = {
        id?: StringFieldUpdateOperationsInput | string
        tokenable_type?: StringFieldUpdateOperationsInput | string
        tokenable_id?: StringFieldUpdateOperationsInput | string
        name?: StringFieldUpdateOperationsInput | string
        token?: StringFieldUpdateOperationsInput | string
        abilities?: NullableStringFieldUpdateOperationsInput | string | null
        last_used_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    }

    export type Role_has_permissionsCreateInput = {
        permissions: PermissionsCreateNestedOneWithoutRole_has_permissionsInput
        roles: RolesCreateNestedOneWithoutRole_has_permissionsInput
    }

    export type Role_has_permissionsUncheckedCreateInput = {
        permission_id: string
        role_id: string
    }

    export type Role_has_permissionsUpdateInput = {
        permissions?: PermissionsUpdateOneRequiredWithoutRole_has_permissionsNestedInput
        roles?: RolesUpdateOneRequiredWithoutRole_has_permissionsNestedInput
    }

    export type Role_has_permissionsUncheckedUpdateInput = {
        permission_id?: StringFieldUpdateOperationsInput | string
        role_id?: StringFieldUpdateOperationsInput | string
    }

    export type Role_has_permissionsCreateManyInput = {
        permission_id: string
        role_id: string
    }

    export type Role_has_permissionsUpdateManyMutationInput = {}

    export type Role_has_permissionsUncheckedUpdateManyInput = {
        permission_id?: StringFieldUpdateOperationsInput | string
        role_id?: StringFieldUpdateOperationsInput | string
    }

    export type RolesCreateInput = {
        uuid: string
        name: string
        guard_name: string
        created_at?: Date | string | null
        updated_at?: Date | string | null
        model_has_roles?: Model_has_rolesCreateNestedManyWithoutRolesInput
        role_has_permissions?: Role_has_permissionsCreateNestedManyWithoutRolesInput
    }

    export type RolesUncheckedCreateInput = {
        uuid: string
        name: string
        guard_name: string
        created_at?: Date | string | null
        updated_at?: Date | string | null
        model_has_roles?: Model_has_rolesUncheckedCreateNestedManyWithoutRolesInput
        role_has_permissions?: Role_has_permissionsUncheckedCreateNestedManyWithoutRolesInput
    }

    export type RolesUpdateInput = {
        uuid?: StringFieldUpdateOperationsInput | string
        name?: StringFieldUpdateOperationsInput | string
        guard_name?: StringFieldUpdateOperationsInput | string
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        model_has_roles?: Model_has_rolesUpdateManyWithoutRolesNestedInput
        role_has_permissions?: Role_has_permissionsUpdateManyWithoutRolesNestedInput
    }

    export type RolesUncheckedUpdateInput = {
        uuid?: StringFieldUpdateOperationsInput | string
        name?: StringFieldUpdateOperationsInput | string
        guard_name?: StringFieldUpdateOperationsInput | string
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        model_has_roles?: Model_has_rolesUncheckedUpdateManyWithoutRolesNestedInput
        role_has_permissions?: Role_has_permissionsUncheckedUpdateManyWithoutRolesNestedInput
    }

    export type RolesCreateManyInput = {
        uuid: string
        name: string
        guard_name: string
        created_at?: Date | string | null
        updated_at?: Date | string | null
    }

    export type RolesUpdateManyMutationInput = {
        uuid?: StringFieldUpdateOperationsInput | string
        name?: StringFieldUpdateOperationsInput | string
        guard_name?: StringFieldUpdateOperationsInput | string
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    }

    export type RolesUncheckedUpdateManyInput = {
        uuid?: StringFieldUpdateOperationsInput | string
        name?: StringFieldUpdateOperationsInput | string
        guard_name?: StringFieldUpdateOperationsInput | string
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    }

    export type Second_sponsorsCreateInput = {
        id: string
        first_name: string
        last_name: string
        degree_of_kinship: string
        phone_number: string
        address: string
        income: number
        deleted_at?: Date | string | null
        created_at?: Date | string | null
        updated_at?: Date | string | null
        families: FamiliesCreateNestedOneWithoutSecond_sponsorsInput
        tenants: TenantsCreateNestedOneWithoutSecond_sponsorsInput
    }

    export type Second_sponsorsUncheckedCreateInput = {
        id: string
        first_name: string
        last_name: string
        degree_of_kinship: string
        phone_number: string
        address: string
        income: number
        family_id: string
        tenant_id: string
        deleted_at?: Date | string | null
        created_at?: Date | string | null
        updated_at?: Date | string | null
    }

    export type Second_sponsorsUpdateInput = {
        id?: StringFieldUpdateOperationsInput | string
        first_name?: StringFieldUpdateOperationsInput | string
        last_name?: StringFieldUpdateOperationsInput | string
        degree_of_kinship?: StringFieldUpdateOperationsInput | string
        phone_number?: StringFieldUpdateOperationsInput | string
        address?: StringFieldUpdateOperationsInput | string
        income?: FloatFieldUpdateOperationsInput | number
        deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        families?: FamiliesUpdateOneRequiredWithoutSecond_sponsorsNestedInput
        tenants?: TenantsUpdateOneRequiredWithoutSecond_sponsorsNestedInput
    }

    export type Second_sponsorsUncheckedUpdateInput = {
        id?: StringFieldUpdateOperationsInput | string
        first_name?: StringFieldUpdateOperationsInput | string
        last_name?: StringFieldUpdateOperationsInput | string
        degree_of_kinship?: StringFieldUpdateOperationsInput | string
        phone_number?: StringFieldUpdateOperationsInput | string
        address?: StringFieldUpdateOperationsInput | string
        income?: FloatFieldUpdateOperationsInput | number
        family_id?: StringFieldUpdateOperationsInput | string
        tenant_id?: StringFieldUpdateOperationsInput | string
        deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    }

    export type Second_sponsorsCreateManyInput = {
        id: string
        first_name: string
        last_name: string
        degree_of_kinship: string
        phone_number: string
        address: string
        income: number
        family_id: string
        tenant_id: string
        deleted_at?: Date | string | null
        created_at?: Date | string | null
        updated_at?: Date | string | null
    }

    export type Second_sponsorsUpdateManyMutationInput = {
        id?: StringFieldUpdateOperationsInput | string
        first_name?: StringFieldUpdateOperationsInput | string
        last_name?: StringFieldUpdateOperationsInput | string
        degree_of_kinship?: StringFieldUpdateOperationsInput | string
        phone_number?: StringFieldUpdateOperationsInput | string
        address?: StringFieldUpdateOperationsInput | string
        income?: FloatFieldUpdateOperationsInput | number
        deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    }

    export type Second_sponsorsUncheckedUpdateManyInput = {
        id?: StringFieldUpdateOperationsInput | string
        first_name?: StringFieldUpdateOperationsInput | string
        last_name?: StringFieldUpdateOperationsInput | string
        degree_of_kinship?: StringFieldUpdateOperationsInput | string
        phone_number?: StringFieldUpdateOperationsInput | string
        address?: StringFieldUpdateOperationsInput | string
        income?: FloatFieldUpdateOperationsInput | number
        family_id?: StringFieldUpdateOperationsInput | string
        tenant_id?: StringFieldUpdateOperationsInput | string
        deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    }

    export type SessionsCreateInput = {
        id: string
        ip_address?: string | null
        user_agent?: string | null
        payload: string
        last_activity: number
        users?: UsersCreateNestedOneWithoutSessionsInput
    }

    export type SessionsUncheckedCreateInput = {
        id: string
        user_id?: string | null
        ip_address?: string | null
        user_agent?: string | null
        payload: string
        last_activity: number
    }

    export type SessionsUpdateInput = {
        id?: StringFieldUpdateOperationsInput | string
        ip_address?: NullableStringFieldUpdateOperationsInput | string | null
        user_agent?: NullableStringFieldUpdateOperationsInput | string | null
        payload?: StringFieldUpdateOperationsInput | string
        last_activity?: IntFieldUpdateOperationsInput | number
        users?: UsersUpdateOneWithoutSessionsNestedInput
    }

    export type SessionsUncheckedUpdateInput = {
        id?: StringFieldUpdateOperationsInput | string
        user_id?: NullableStringFieldUpdateOperationsInput | string | null
        ip_address?: NullableStringFieldUpdateOperationsInput | string | null
        user_agent?: NullableStringFieldUpdateOperationsInput | string | null
        payload?: StringFieldUpdateOperationsInput | string
        last_activity?: IntFieldUpdateOperationsInput | number
    }

    export type SessionsCreateManyInput = {
        id: string
        user_id?: string | null
        ip_address?: string | null
        user_agent?: string | null
        payload: string
        last_activity: number
    }

    export type SessionsUpdateManyMutationInput = {
        id?: StringFieldUpdateOperationsInput | string
        ip_address?: NullableStringFieldUpdateOperationsInput | string | null
        user_agent?: NullableStringFieldUpdateOperationsInput | string | null
        payload?: StringFieldUpdateOperationsInput | string
        last_activity?: IntFieldUpdateOperationsInput | number
    }

    export type SessionsUncheckedUpdateManyInput = {
        id?: StringFieldUpdateOperationsInput | string
        user_id?: NullableStringFieldUpdateOperationsInput | string | null
        ip_address?: NullableStringFieldUpdateOperationsInput | string | null
        user_agent?: NullableStringFieldUpdateOperationsInput | string | null
        payload?: StringFieldUpdateOperationsInput | string
        last_activity?: IntFieldUpdateOperationsInput | number
    }

    export type SettingsCreateInput = {
        id: string
        theme: theme
        color_scheme: color_scheme
        layout: layout
        appearance: appearance
        notifications?: NullableJsonNullValueInput | InputJsonValue
        created_at?: Date | string | null
        updated_at?: Date | string | null
        users: UsersCreateNestedOneWithoutSettingsInput
    }

    export type SettingsUncheckedCreateInput = {
        id: string
        user_id: string
        theme: theme
        color_scheme: color_scheme
        layout: layout
        appearance: appearance
        notifications?: NullableJsonNullValueInput | InputJsonValue
        created_at?: Date | string | null
        updated_at?: Date | string | null
    }

    export type SettingsUpdateInput = {
        id?: StringFieldUpdateOperationsInput | string
        theme?: EnumthemeFieldUpdateOperationsInput | theme
        color_scheme?: Enumcolor_schemeFieldUpdateOperationsInput | color_scheme
        layout?: EnumlayoutFieldUpdateOperationsInput | layout
        appearance?: EnumappearanceFieldUpdateOperationsInput | appearance
        notifications?: NullableJsonNullValueInput | InputJsonValue
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        users?: UsersUpdateOneRequiredWithoutSettingsNestedInput
    }

    export type SettingsUncheckedUpdateInput = {
        id?: StringFieldUpdateOperationsInput | string
        user_id?: StringFieldUpdateOperationsInput | string
        theme?: EnumthemeFieldUpdateOperationsInput | theme
        color_scheme?: Enumcolor_schemeFieldUpdateOperationsInput | color_scheme
        layout?: EnumlayoutFieldUpdateOperationsInput | layout
        appearance?: EnumappearanceFieldUpdateOperationsInput | appearance
        notifications?: NullableJsonNullValueInput | InputJsonValue
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    }

    export type SettingsCreateManyInput = {
        id: string
        user_id: string
        theme: theme
        color_scheme: color_scheme
        layout: layout
        appearance: appearance
        notifications?: NullableJsonNullValueInput | InputJsonValue
        created_at?: Date | string | null
        updated_at?: Date | string | null
    }

    export type SettingsUpdateManyMutationInput = {
        id?: StringFieldUpdateOperationsInput | string
        theme?: EnumthemeFieldUpdateOperationsInput | theme
        color_scheme?: Enumcolor_schemeFieldUpdateOperationsInput | color_scheme
        layout?: EnumlayoutFieldUpdateOperationsInput | layout
        appearance?: EnumappearanceFieldUpdateOperationsInput | appearance
        notifications?: NullableJsonNullValueInput | InputJsonValue
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    }

    export type SettingsUncheckedUpdateManyInput = {
        id?: StringFieldUpdateOperationsInput | string
        user_id?: StringFieldUpdateOperationsInput | string
        theme?: EnumthemeFieldUpdateOperationsInput | theme
        color_scheme?: Enumcolor_schemeFieldUpdateOperationsInput | color_scheme
        layout?: EnumlayoutFieldUpdateOperationsInput | layout
        appearance?: EnumappearanceFieldUpdateOperationsInput | appearance
        notifications?: NullableJsonNullValueInput | InputJsonValue
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    }

    export type Sponsor_sponsorshipCreateInput = {
        id: string
        type: sponsor_sponsorship_type
        value: string
        created_at?: Date | string | null
        updated_at?: Date | string | null
        sponsors: SponsorsCreateNestedOneWithoutSponsor_sponsorshipInput
        tenants: TenantsCreateNestedOneWithoutSponsor_sponsorshipInput
    }

    export type Sponsor_sponsorshipUncheckedCreateInput = {
        id: string
        sponsor_id: string
        type: sponsor_sponsorship_type
        value: string
        tenant_id: string
        created_at?: Date | string | null
        updated_at?: Date | string | null
    }

    export type Sponsor_sponsorshipUpdateInput = {
        id?: StringFieldUpdateOperationsInput | string
        type?: Enumsponsor_sponsorship_typeFieldUpdateOperationsInput | sponsor_sponsorship_type
        value?: StringFieldUpdateOperationsInput | string
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        sponsors?: SponsorsUpdateOneRequiredWithoutSponsor_sponsorshipNestedInput
        tenants?: TenantsUpdateOneRequiredWithoutSponsor_sponsorshipNestedInput
    }

    export type Sponsor_sponsorshipUncheckedUpdateInput = {
        id?: StringFieldUpdateOperationsInput | string
        sponsor_id?: StringFieldUpdateOperationsInput | string
        type?: Enumsponsor_sponsorship_typeFieldUpdateOperationsInput | sponsor_sponsorship_type
        value?: StringFieldUpdateOperationsInput | string
        tenant_id?: StringFieldUpdateOperationsInput | string
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    }

    export type Sponsor_sponsorshipCreateManyInput = {
        id: string
        sponsor_id: string
        type: sponsor_sponsorship_type
        value: string
        tenant_id: string
        created_at?: Date | string | null
        updated_at?: Date | string | null
    }

    export type Sponsor_sponsorshipUpdateManyMutationInput = {
        id?: StringFieldUpdateOperationsInput | string
        type?: Enumsponsor_sponsorship_typeFieldUpdateOperationsInput | sponsor_sponsorship_type
        value?: StringFieldUpdateOperationsInput | string
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    }

    export type Sponsor_sponsorshipUncheckedUpdateManyInput = {
        id?: StringFieldUpdateOperationsInput | string
        sponsor_id?: StringFieldUpdateOperationsInput | string
        type?: Enumsponsor_sponsorship_typeFieldUpdateOperationsInput | sponsor_sponsorship_type
        value?: StringFieldUpdateOperationsInput | string
        tenant_id?: StringFieldUpdateOperationsInput | string
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    }

    export type SponsorsCreateInput = {
        id: string
        zone_id: string
        file_number: number
        start_date: Date | string
        name: string
        address: string
        phone_number: string
        sponsorship_type: string
        birth_date: Date | string
        father_name: string
        mother_name: string
        birth_certificate_number: string
        academic_level: string
        function: string
        health_status: string
        diploma?: string | null
        card_number?: string | null
        deleted_at?: Date | string | null
        created_at?: Date | string | null
        updated_at?: Date | string | null
        income_sponsor?: Income_sponsorCreateNestedManyWithoutSponsorsInput
        sponsor_sponsorship?: Sponsor_sponsorshipCreateNestedManyWithoutSponsorsInput
        users_sponsors_created_byTousers: UsersCreateNestedOneWithoutSponsors_sponsors_created_byTousersInput
        users_sponsors_deleted_byTousers?: UsersCreateNestedOneWithoutSponsors_sponsors_deleted_byTousersInput
        tenants: TenantsCreateNestedOneWithoutSponsorsInput
    }

    export type SponsorsUncheckedCreateInput = {
        id: string
        zone_id: string
        file_number: number
        start_date: Date | string
        name: string
        address: string
        phone_number: string
        sponsorship_type: string
        birth_date: Date | string
        father_name: string
        mother_name: string
        birth_certificate_number: string
        academic_level: string
        function: string
        health_status: string
        diploma?: string | null
        card_number?: string | null
        tenant_id: string
        created_by: string
        deleted_by?: string | null
        deleted_at?: Date | string | null
        created_at?: Date | string | null
        updated_at?: Date | string | null
        income_sponsor?: Income_sponsorUncheckedCreateNestedManyWithoutSponsorsInput
        sponsor_sponsorship?: Sponsor_sponsorshipUncheckedCreateNestedManyWithoutSponsorsInput
    }

    export type SponsorsUpdateInput = {
        id?: StringFieldUpdateOperationsInput | string
        zone_id?: StringFieldUpdateOperationsInput | string
        file_number?: IntFieldUpdateOperationsInput | number
        start_date?: DateTimeFieldUpdateOperationsInput | Date | string
        name?: StringFieldUpdateOperationsInput | string
        address?: StringFieldUpdateOperationsInput | string
        phone_number?: StringFieldUpdateOperationsInput | string
        sponsorship_type?: StringFieldUpdateOperationsInput | string
        birth_date?: DateTimeFieldUpdateOperationsInput | Date | string
        father_name?: StringFieldUpdateOperationsInput | string
        mother_name?: StringFieldUpdateOperationsInput | string
        birth_certificate_number?: StringFieldUpdateOperationsInput | string
        academic_level?: StringFieldUpdateOperationsInput | string
        function?: StringFieldUpdateOperationsInput | string
        health_status?: StringFieldUpdateOperationsInput | string
        diploma?: NullableStringFieldUpdateOperationsInput | string | null
        card_number?: NullableStringFieldUpdateOperationsInput | string | null
        deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        income_sponsor?: Income_sponsorUpdateManyWithoutSponsorsNestedInput
        sponsor_sponsorship?: Sponsor_sponsorshipUpdateManyWithoutSponsorsNestedInput
        users_sponsors_created_byTousers?: UsersUpdateOneRequiredWithoutSponsors_sponsors_created_byTousersNestedInput
        users_sponsors_deleted_byTousers?: UsersUpdateOneWithoutSponsors_sponsors_deleted_byTousersNestedInput
        tenants?: TenantsUpdateOneRequiredWithoutSponsorsNestedInput
    }

    export type SponsorsUncheckedUpdateInput = {
        id?: StringFieldUpdateOperationsInput | string
        zone_id?: StringFieldUpdateOperationsInput | string
        file_number?: IntFieldUpdateOperationsInput | number
        start_date?: DateTimeFieldUpdateOperationsInput | Date | string
        name?: StringFieldUpdateOperationsInput | string
        address?: StringFieldUpdateOperationsInput | string
        phone_number?: StringFieldUpdateOperationsInput | string
        sponsorship_type?: StringFieldUpdateOperationsInput | string
        birth_date?: DateTimeFieldUpdateOperationsInput | Date | string
        father_name?: StringFieldUpdateOperationsInput | string
        mother_name?: StringFieldUpdateOperationsInput | string
        birth_certificate_number?: StringFieldUpdateOperationsInput | string
        academic_level?: StringFieldUpdateOperationsInput | string
        function?: StringFieldUpdateOperationsInput | string
        health_status?: StringFieldUpdateOperationsInput | string
        diploma?: NullableStringFieldUpdateOperationsInput | string | null
        card_number?: NullableStringFieldUpdateOperationsInput | string | null
        tenant_id?: StringFieldUpdateOperationsInput | string
        created_by?: StringFieldUpdateOperationsInput | string
        deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
        deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        income_sponsor?: Income_sponsorUncheckedUpdateManyWithoutSponsorsNestedInput
        sponsor_sponsorship?: Sponsor_sponsorshipUncheckedUpdateManyWithoutSponsorsNestedInput
    }

    export type SponsorsCreateManyInput = {
        id: string
        zone_id: string
        file_number: number
        start_date: Date | string
        name: string
        address: string
        phone_number: string
        sponsorship_type: string
        birth_date: Date | string
        father_name: string
        mother_name: string
        birth_certificate_number: string
        academic_level: string
        function: string
        health_status: string
        diploma?: string | null
        card_number?: string | null
        tenant_id: string
        created_by: string
        deleted_by?: string | null
        deleted_at?: Date | string | null
        created_at?: Date | string | null
        updated_at?: Date | string | null
    }

    export type SponsorsUpdateManyMutationInput = {
        id?: StringFieldUpdateOperationsInput | string
        zone_id?: StringFieldUpdateOperationsInput | string
        file_number?: IntFieldUpdateOperationsInput | number
        start_date?: DateTimeFieldUpdateOperationsInput | Date | string
        name?: StringFieldUpdateOperationsInput | string
        address?: StringFieldUpdateOperationsInput | string
        phone_number?: StringFieldUpdateOperationsInput | string
        sponsorship_type?: StringFieldUpdateOperationsInput | string
        birth_date?: DateTimeFieldUpdateOperationsInput | Date | string
        father_name?: StringFieldUpdateOperationsInput | string
        mother_name?: StringFieldUpdateOperationsInput | string
        birth_certificate_number?: StringFieldUpdateOperationsInput | string
        academic_level?: StringFieldUpdateOperationsInput | string
        function?: StringFieldUpdateOperationsInput | string
        health_status?: StringFieldUpdateOperationsInput | string
        diploma?: NullableStringFieldUpdateOperationsInput | string | null
        card_number?: NullableStringFieldUpdateOperationsInput | string | null
        deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    }

    export type SponsorsUncheckedUpdateManyInput = {
        id?: StringFieldUpdateOperationsInput | string
        zone_id?: StringFieldUpdateOperationsInput | string
        file_number?: IntFieldUpdateOperationsInput | number
        start_date?: DateTimeFieldUpdateOperationsInput | Date | string
        name?: StringFieldUpdateOperationsInput | string
        address?: StringFieldUpdateOperationsInput | string
        phone_number?: StringFieldUpdateOperationsInput | string
        sponsorship_type?: StringFieldUpdateOperationsInput | string
        birth_date?: DateTimeFieldUpdateOperationsInput | Date | string
        father_name?: StringFieldUpdateOperationsInput | string
        mother_name?: StringFieldUpdateOperationsInput | string
        birth_certificate_number?: StringFieldUpdateOperationsInput | string
        academic_level?: StringFieldUpdateOperationsInput | string
        function?: StringFieldUpdateOperationsInput | string
        health_status?: StringFieldUpdateOperationsInput | string
        diploma?: NullableStringFieldUpdateOperationsInput | string | null
        card_number?: NullableStringFieldUpdateOperationsInput | string | null
        tenant_id?: StringFieldUpdateOperationsInput | string
        created_by?: StringFieldUpdateOperationsInput | string
        deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
        deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    }

    export type SponsorshipsCreateInput = {
        id: string
        type: sponsorship_type
        name: string
        deleted_at?: Date | string | null
        created_at?: Date | string | null
        updated_at?: Date | string | null
        tenants: TenantsCreateNestedOneWithoutSponsorshipsInput
    }

    export type SponsorshipsUncheckedCreateInput = {
        id: string
        type: sponsorship_type
        name: string
        tenant_id: string
        deleted_at?: Date | string | null
        created_at?: Date | string | null
        updated_at?: Date | string | null
    }

    export type SponsorshipsUpdateInput = {
        id?: StringFieldUpdateOperationsInput | string
        type?: Enumsponsorship_typeFieldUpdateOperationsInput | sponsorship_type
        name?: StringFieldUpdateOperationsInput | string
        deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        tenants?: TenantsUpdateOneRequiredWithoutSponsorshipsNestedInput
    }

    export type SponsorshipsUncheckedUpdateInput = {
        id?: StringFieldUpdateOperationsInput | string
        type?: Enumsponsorship_typeFieldUpdateOperationsInput | sponsorship_type
        name?: StringFieldUpdateOperationsInput | string
        tenant_id?: StringFieldUpdateOperationsInput | string
        deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    }

    export type SponsorshipsCreateManyInput = {
        id: string
        type: sponsorship_type
        name: string
        tenant_id: string
        deleted_at?: Date | string | null
        created_at?: Date | string | null
        updated_at?: Date | string | null
    }

    export type SponsorshipsUpdateManyMutationInput = {
        id?: StringFieldUpdateOperationsInput | string
        type?: Enumsponsorship_typeFieldUpdateOperationsInput | sponsorship_type
        name?: StringFieldUpdateOperationsInput | string
        deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    }

    export type SponsorshipsUncheckedUpdateManyInput = {
        id?: StringFieldUpdateOperationsInput | string
        type?: Enumsponsorship_typeFieldUpdateOperationsInput | sponsorship_type
        name?: StringFieldUpdateOperationsInput | string
        tenant_id?: StringFieldUpdateOperationsInput | string
        deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    }

    export type SpousesCreateInput = {
        id: string
        first_name: string
        last_name: string
        birth_date: Date | string
        death_date: Date | string
        function: string
        income: number
        created_at?: Date | string | null
        updated_at?: Date | string | null
        families: FamiliesCreateNestedOneWithoutSpousesInput
        tenants: TenantsCreateNestedOneWithoutSpousesInput
    }

    export type SpousesUncheckedCreateInput = {
        id: string
        first_name: string
        last_name: string
        birth_date: Date | string
        death_date: Date | string
        function: string
        income: number
        family_id: string
        tenant_id: string
        created_at?: Date | string | null
        updated_at?: Date | string | null
    }

    export type SpousesUpdateInput = {
        id?: StringFieldUpdateOperationsInput | string
        first_name?: StringFieldUpdateOperationsInput | string
        last_name?: StringFieldUpdateOperationsInput | string
        birth_date?: DateTimeFieldUpdateOperationsInput | Date | string
        death_date?: DateTimeFieldUpdateOperationsInput | Date | string
        function?: StringFieldUpdateOperationsInput | string
        income?: FloatFieldUpdateOperationsInput | number
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        families?: FamiliesUpdateOneRequiredWithoutSpousesNestedInput
        tenants?: TenantsUpdateOneRequiredWithoutSpousesNestedInput
    }

    export type SpousesUncheckedUpdateInput = {
        id?: StringFieldUpdateOperationsInput | string
        first_name?: StringFieldUpdateOperationsInput | string
        last_name?: StringFieldUpdateOperationsInput | string
        birth_date?: DateTimeFieldUpdateOperationsInput | Date | string
        death_date?: DateTimeFieldUpdateOperationsInput | Date | string
        function?: StringFieldUpdateOperationsInput | string
        income?: FloatFieldUpdateOperationsInput | number
        family_id?: StringFieldUpdateOperationsInput | string
        tenant_id?: StringFieldUpdateOperationsInput | string
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    }

    export type SpousesCreateManyInput = {
        id: string
        first_name: string
        last_name: string
        birth_date: Date | string
        death_date: Date | string
        function: string
        income: number
        family_id: string
        tenant_id: string
        created_at?: Date | string | null
        updated_at?: Date | string | null
    }

    export type SpousesUpdateManyMutationInput = {
        id?: StringFieldUpdateOperationsInput | string
        first_name?: StringFieldUpdateOperationsInput | string
        last_name?: StringFieldUpdateOperationsInput | string
        birth_date?: DateTimeFieldUpdateOperationsInput | Date | string
        death_date?: DateTimeFieldUpdateOperationsInput | Date | string
        function?: StringFieldUpdateOperationsInput | string
        income?: FloatFieldUpdateOperationsInput | number
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    }

    export type SpousesUncheckedUpdateManyInput = {
        id?: StringFieldUpdateOperationsInput | string
        first_name?: StringFieldUpdateOperationsInput | string
        last_name?: StringFieldUpdateOperationsInput | string
        birth_date?: DateTimeFieldUpdateOperationsInput | Date | string
        death_date?: DateTimeFieldUpdateOperationsInput | Date | string
        function?: StringFieldUpdateOperationsInput | string
        income?: FloatFieldUpdateOperationsInput | number
        family_id?: StringFieldUpdateOperationsInput | string
        tenant_id?: StringFieldUpdateOperationsInput | string
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    }

    export type TenantsCreateInput = {
        id: string
        data?: NullableJsonNullValueInput | InputJsonValue
        created_at?: Date | string | null
        updated_at?: Date | string | null
        benefactors?: BenefactorsCreateNestedManyWithoutTenantsInput
        domains?: DomainsCreateNestedManyWithoutTenantsInput
        families?: FamiliesCreateNestedManyWithoutTenantsInput
        family_sponsorship?: Family_sponsorshipCreateNestedManyWithoutTenantsInput
        income_sponsor?: Income_sponsorCreateNestedManyWithoutTenantsInput
        orphan_sponsorship?: Orphan_sponsorshipCreateNestedManyWithoutTenantsInput
        orphans?: OrphansCreateNestedManyWithoutTenantsInput
        second_sponsors?: Second_sponsorsCreateNestedManyWithoutTenantsInput
        sponsor_sponsorship?: Sponsor_sponsorshipCreateNestedManyWithoutTenantsInput
        sponsors?: SponsorsCreateNestedManyWithoutTenantsInput
        sponsorships?: SponsorshipsCreateNestedManyWithoutTenantsInput
        spouses?: SpousesCreateNestedManyWithoutTenantsInput
        users?: UsersCreateNestedManyWithoutTenantsInput
    }

    export type TenantsUncheckedCreateInput = {
        id: string
        data?: NullableJsonNullValueInput | InputJsonValue
        created_at?: Date | string | null
        updated_at?: Date | string | null
        benefactors?: BenefactorsUncheckedCreateNestedManyWithoutTenantsInput
        domains?: DomainsUncheckedCreateNestedManyWithoutTenantsInput
        families?: FamiliesUncheckedCreateNestedManyWithoutTenantsInput
        family_sponsorship?: Family_sponsorshipUncheckedCreateNestedManyWithoutTenantsInput
        income_sponsor?: Income_sponsorUncheckedCreateNestedManyWithoutTenantsInput
        orphan_sponsorship?: Orphan_sponsorshipUncheckedCreateNestedManyWithoutTenantsInput
        orphans?: OrphansUncheckedCreateNestedManyWithoutTenantsInput
        second_sponsors?: Second_sponsorsUncheckedCreateNestedManyWithoutTenantsInput
        sponsor_sponsorship?: Sponsor_sponsorshipUncheckedCreateNestedManyWithoutTenantsInput
        sponsors?: SponsorsUncheckedCreateNestedManyWithoutTenantsInput
        sponsorships?: SponsorshipsUncheckedCreateNestedManyWithoutTenantsInput
        spouses?: SpousesUncheckedCreateNestedManyWithoutTenantsInput
        users?: UsersUncheckedCreateNestedManyWithoutTenantsInput
    }

    export type TenantsUpdateInput = {
        id?: StringFieldUpdateOperationsInput | string
        data?: NullableJsonNullValueInput | InputJsonValue
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        benefactors?: BenefactorsUpdateManyWithoutTenantsNestedInput
        domains?: DomainsUpdateManyWithoutTenantsNestedInput
        families?: FamiliesUpdateManyWithoutTenantsNestedInput
        family_sponsorship?: Family_sponsorshipUpdateManyWithoutTenantsNestedInput
        income_sponsor?: Income_sponsorUpdateManyWithoutTenantsNestedInput
        orphan_sponsorship?: Orphan_sponsorshipUpdateManyWithoutTenantsNestedInput
        orphans?: OrphansUpdateManyWithoutTenantsNestedInput
        second_sponsors?: Second_sponsorsUpdateManyWithoutTenantsNestedInput
        sponsor_sponsorship?: Sponsor_sponsorshipUpdateManyWithoutTenantsNestedInput
        sponsors?: SponsorsUpdateManyWithoutTenantsNestedInput
        sponsorships?: SponsorshipsUpdateManyWithoutTenantsNestedInput
        spouses?: SpousesUpdateManyWithoutTenantsNestedInput
        users?: UsersUpdateManyWithoutTenantsNestedInput
    }

    export type TenantsUncheckedUpdateInput = {
        id?: StringFieldUpdateOperationsInput | string
        data?: NullableJsonNullValueInput | InputJsonValue
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        benefactors?: BenefactorsUncheckedUpdateManyWithoutTenantsNestedInput
        domains?: DomainsUncheckedUpdateManyWithoutTenantsNestedInput
        families?: FamiliesUncheckedUpdateManyWithoutTenantsNestedInput
        family_sponsorship?: Family_sponsorshipUncheckedUpdateManyWithoutTenantsNestedInput
        income_sponsor?: Income_sponsorUncheckedUpdateManyWithoutTenantsNestedInput
        orphan_sponsorship?: Orphan_sponsorshipUncheckedUpdateManyWithoutTenantsNestedInput
        orphans?: OrphansUncheckedUpdateManyWithoutTenantsNestedInput
        second_sponsors?: Second_sponsorsUncheckedUpdateManyWithoutTenantsNestedInput
        sponsor_sponsorship?: Sponsor_sponsorshipUncheckedUpdateManyWithoutTenantsNestedInput
        sponsors?: SponsorsUncheckedUpdateManyWithoutTenantsNestedInput
        sponsorships?: SponsorshipsUncheckedUpdateManyWithoutTenantsNestedInput
        spouses?: SpousesUncheckedUpdateManyWithoutTenantsNestedInput
        users?: UsersUncheckedUpdateManyWithoutTenantsNestedInput
    }

    export type TenantsCreateManyInput = {
        id: string
        data?: NullableJsonNullValueInput | InputJsonValue
        created_at?: Date | string | null
        updated_at?: Date | string | null
    }

    export type TenantsUpdateManyMutationInput = {
        id?: StringFieldUpdateOperationsInput | string
        data?: NullableJsonNullValueInput | InputJsonValue
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    }

    export type TenantsUncheckedUpdateManyInput = {
        id?: StringFieldUpdateOperationsInput | string
        data?: NullableJsonNullValueInput | InputJsonValue
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    }

    export type UsersCreateInput = {
        id: string
        first_name: string
        last_name: string
        phone: string
        email: string
        email_verified_at?: Date | string | null
        password: string
        remember_token?: string | null
        created_at?: Date | string | null
        updated_at?: Date | string | null
        orphans_orphans_created_byTousers?: OrphansCreateNestedManyWithoutUsers_orphans_created_byTousersInput
        orphans_orphans_deleted_byTousers?: OrphansCreateNestedManyWithoutUsers_orphans_deleted_byTousersInput
        sessions?: SessionsCreateNestedManyWithoutUsersInput
        settings?: SettingsCreateNestedManyWithoutUsersInput
        sponsors_sponsors_created_byTousers?: SponsorsCreateNestedManyWithoutUsers_sponsors_created_byTousersInput
        sponsors_sponsors_deleted_byTousers?: SponsorsCreateNestedManyWithoutUsers_sponsors_deleted_byTousersInput
        tenants: TenantsCreateNestedOneWithoutUsersInput
    }

    export type UsersUncheckedCreateInput = {
        id: string
        first_name: string
        last_name: string
        phone: string
        email: string
        email_verified_at?: Date | string | null
        password: string
        remember_token?: string | null
        tenant_id: string
        created_at?: Date | string | null
        updated_at?: Date | string | null
        orphans_orphans_created_byTousers?: OrphansUncheckedCreateNestedManyWithoutUsers_orphans_created_byTousersInput
        orphans_orphans_deleted_byTousers?: OrphansUncheckedCreateNestedManyWithoutUsers_orphans_deleted_byTousersInput
        sessions?: SessionsUncheckedCreateNestedManyWithoutUsersInput
        settings?: SettingsUncheckedCreateNestedManyWithoutUsersInput
        sponsors_sponsors_created_byTousers?: SponsorsUncheckedCreateNestedManyWithoutUsers_sponsors_created_byTousersInput
        sponsors_sponsors_deleted_byTousers?: SponsorsUncheckedCreateNestedManyWithoutUsers_sponsors_deleted_byTousersInput
    }

    export type UsersUpdateInput = {
        id?: StringFieldUpdateOperationsInput | string
        first_name?: StringFieldUpdateOperationsInput | string
        last_name?: StringFieldUpdateOperationsInput | string
        phone?: StringFieldUpdateOperationsInput | string
        email?: StringFieldUpdateOperationsInput | string
        email_verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        password?: StringFieldUpdateOperationsInput | string
        remember_token?: NullableStringFieldUpdateOperationsInput | string | null
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        orphans_orphans_created_byTousers?: OrphansUpdateManyWithoutUsers_orphans_created_byTousersNestedInput
        orphans_orphans_deleted_byTousers?: OrphansUpdateManyWithoutUsers_orphans_deleted_byTousersNestedInput
        sessions?: SessionsUpdateManyWithoutUsersNestedInput
        settings?: SettingsUpdateManyWithoutUsersNestedInput
        sponsors_sponsors_created_byTousers?: SponsorsUpdateManyWithoutUsers_sponsors_created_byTousersNestedInput
        sponsors_sponsors_deleted_byTousers?: SponsorsUpdateManyWithoutUsers_sponsors_deleted_byTousersNestedInput
        tenants?: TenantsUpdateOneRequiredWithoutUsersNestedInput
    }

    export type UsersUncheckedUpdateInput = {
        id?: StringFieldUpdateOperationsInput | string
        first_name?: StringFieldUpdateOperationsInput | string
        last_name?: StringFieldUpdateOperationsInput | string
        phone?: StringFieldUpdateOperationsInput | string
        email?: StringFieldUpdateOperationsInput | string
        email_verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        password?: StringFieldUpdateOperationsInput | string
        remember_token?: NullableStringFieldUpdateOperationsInput | string | null
        tenant_id?: StringFieldUpdateOperationsInput | string
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        orphans_orphans_created_byTousers?: OrphansUncheckedUpdateManyWithoutUsers_orphans_created_byTousersNestedInput
        orphans_orphans_deleted_byTousers?: OrphansUncheckedUpdateManyWithoutUsers_orphans_deleted_byTousersNestedInput
        sessions?: SessionsUncheckedUpdateManyWithoutUsersNestedInput
        settings?: SettingsUncheckedUpdateManyWithoutUsersNestedInput
        sponsors_sponsors_created_byTousers?: SponsorsUncheckedUpdateManyWithoutUsers_sponsors_created_byTousersNestedInput
        sponsors_sponsors_deleted_byTousers?: SponsorsUncheckedUpdateManyWithoutUsers_sponsors_deleted_byTousersNestedInput
    }

    export type UsersCreateManyInput = {
        id: string
        first_name: string
        last_name: string
        phone: string
        email: string
        email_verified_at?: Date | string | null
        password: string
        remember_token?: string | null
        tenant_id: string
        created_at?: Date | string | null
        updated_at?: Date | string | null
    }

    export type UsersUpdateManyMutationInput = {
        id?: StringFieldUpdateOperationsInput | string
        first_name?: StringFieldUpdateOperationsInput | string
        last_name?: StringFieldUpdateOperationsInput | string
        phone?: StringFieldUpdateOperationsInput | string
        email?: StringFieldUpdateOperationsInput | string
        email_verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        password?: StringFieldUpdateOperationsInput | string
        remember_token?: NullableStringFieldUpdateOperationsInput | string | null
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    }

    export type UsersUncheckedUpdateManyInput = {
        id?: StringFieldUpdateOperationsInput | string
        first_name?: StringFieldUpdateOperationsInput | string
        last_name?: StringFieldUpdateOperationsInput | string
        phone?: StringFieldUpdateOperationsInput | string
        email?: StringFieldUpdateOperationsInput | string
        email_verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        password?: StringFieldUpdateOperationsInput | string
        remember_token?: NullableStringFieldUpdateOperationsInput | string | null
        tenant_id?: StringFieldUpdateOperationsInput | string
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    }

    export type UuidFilter = {
        equals?: string
        in?: Enumerable<string>
        notIn?: Enumerable<string>
        lt?: string
        lte?: string
        gt?: string
        gte?: string
        mode?: QueryMode
        not?: NestedUuidFilter | string
    }

    export type StringFilter = {
        equals?: string
        in?: Enumerable<string>
        notIn?: Enumerable<string>
        lt?: string
        lte?: string
        gt?: string
        gte?: string
        contains?: string
        startsWith?: string
        endsWith?: string
        mode?: QueryMode
        not?: NestedStringFilter | string
    }

    export type DateTimeNullableFilter = {
        equals?: Date | string | null
        in?: Enumerable<Date> | Enumerable<string> | null
        notIn?: Enumerable<Date> | Enumerable<string> | null
        lt?: Date | string
        lte?: Date | string
        gt?: Date | string
        gte?: Date | string
        not?: NestedDateTimeNullableFilter | Date | string | null
    }

    export type TenantsRelationFilter = {
        is?: TenantsWhereInput
        isNot?: TenantsWhereInput
    }

    export type BenefactorsCountOrderByAggregateInput = {
        id?: SortOrder
        tenant_id?: SortOrder
        deleted_at?: SortOrder
        created_at?: SortOrder
        updated_at?: SortOrder
    }

    export type BenefactorsMaxOrderByAggregateInput = {
        id?: SortOrder
        tenant_id?: SortOrder
        deleted_at?: SortOrder
        created_at?: SortOrder
        updated_at?: SortOrder
    }

    export type BenefactorsMinOrderByAggregateInput = {
        id?: SortOrder
        tenant_id?: SortOrder
        deleted_at?: SortOrder
        created_at?: SortOrder
        updated_at?: SortOrder
    }

    export type UuidWithAggregatesFilter = {
        equals?: string
        in?: Enumerable<string>
        notIn?: Enumerable<string>
        lt?: string
        lte?: string
        gt?: string
        gte?: string
        mode?: QueryMode
        not?: NestedUuidWithAggregatesFilter | string
        _count?: NestedIntFilter
        _min?: NestedStringFilter
        _max?: NestedStringFilter
    }

    export type StringWithAggregatesFilter = {
        equals?: string
        in?: Enumerable<string>
        notIn?: Enumerable<string>
        lt?: string
        lte?: string
        gt?: string
        gte?: string
        contains?: string
        startsWith?: string
        endsWith?: string
        mode?: QueryMode
        not?: NestedStringWithAggregatesFilter | string
        _count?: NestedIntFilter
        _min?: NestedStringFilter
        _max?: NestedStringFilter
    }

    export type DateTimeNullableWithAggregatesFilter = {
        equals?: Date | string | null
        in?: Enumerable<Date> | Enumerable<string> | null
        notIn?: Enumerable<Date> | Enumerable<string> | null
        lt?: Date | string
        lte?: Date | string
        gt?: Date | string
        gte?: Date | string
        not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
        _count?: NestedIntNullableFilter
        _min?: NestedDateTimeNullableFilter
        _max?: NestedDateTimeNullableFilter
    }

    export type IntFilter = {
        equals?: number
        in?: Enumerable<number>
        notIn?: Enumerable<number>
        lt?: number
        lte?: number
        gt?: number
        gte?: number
        not?: NestedIntFilter | number
    }

    export type CacheCountOrderByAggregateInput = {
        key?: SortOrder
        value?: SortOrder
        expiration?: SortOrder
    }

    export type CacheAvgOrderByAggregateInput = {
        expiration?: SortOrder
    }

    export type CacheMaxOrderByAggregateInput = {
        key?: SortOrder
        value?: SortOrder
        expiration?: SortOrder
    }

    export type CacheMinOrderByAggregateInput = {
        key?: SortOrder
        value?: SortOrder
        expiration?: SortOrder
    }

    export type CacheSumOrderByAggregateInput = {
        expiration?: SortOrder
    }

    export type IntWithAggregatesFilter = {
        equals?: number
        in?: Enumerable<number>
        notIn?: Enumerable<number>
        lt?: number
        lte?: number
        gt?: number
        gte?: number
        not?: NestedIntWithAggregatesFilter | number
        _count?: NestedIntFilter
        _avg?: NestedFloatFilter
        _sum?: NestedIntFilter
        _min?: NestedIntFilter
        _max?: NestedIntFilter
    }

    export type Cache_locksCountOrderByAggregateInput = {
        key?: SortOrder
        owner?: SortOrder
        expiration?: SortOrder
    }

    export type Cache_locksAvgOrderByAggregateInput = {
        expiration?: SortOrder
    }

    export type Cache_locksMaxOrderByAggregateInput = {
        key?: SortOrder
        owner?: SortOrder
        expiration?: SortOrder
    }

    export type Cache_locksMinOrderByAggregateInput = {
        key?: SortOrder
        owner?: SortOrder
        expiration?: SortOrder
    }

    export type Cache_locksSumOrderByAggregateInput = {
        expiration?: SortOrder
    }

    export type DomainsCountOrderByAggregateInput = {
        id?: SortOrder
        domain?: SortOrder
        tenant_id?: SortOrder
        created_at?: SortOrder
        updated_at?: SortOrder
    }

    export type DomainsMaxOrderByAggregateInput = {
        id?: SortOrder
        domain?: SortOrder
        tenant_id?: SortOrder
        created_at?: SortOrder
        updated_at?: SortOrder
    }

    export type DomainsMinOrderByAggregateInput = {
        id?: SortOrder
        domain?: SortOrder
        tenant_id?: SortOrder
        created_at?: SortOrder
        updated_at?: SortOrder
    }

    export type Family_furnishingListRelationFilter = {
        every?: Family_furnishingWhereInput
        some?: Family_furnishingWhereInput
        none?: Family_furnishingWhereInput
    }

    export type Family_housingListRelationFilter = {
        every?: Family_housingWhereInput
        some?: Family_housingWhereInput
        none?: Family_housingWhereInput
    }

    export type Family_sponsorshipListRelationFilter = {
        every?: Family_sponsorshipWhereInput
        some?: Family_sponsorshipWhereInput
        none?: Family_sponsorshipWhereInput
    }

    export type OrphansListRelationFilter = {
        every?: OrphansWhereInput
        some?: OrphansWhereInput
        none?: OrphansWhereInput
    }

    export type Second_sponsorsListRelationFilter = {
        every?: Second_sponsorsWhereInput
        some?: Second_sponsorsWhereInput
        none?: Second_sponsorsWhereInput
    }

    export type SpousesListRelationFilter = {
        every?: SpousesWhereInput
        some?: SpousesWhereInput
        none?: SpousesWhereInput
    }

    export type Family_furnishingOrderByRelationAggregateInput = {
        _count?: SortOrder
    }

    export type Family_housingOrderByRelationAggregateInput = {
        _count?: SortOrder
    }

    export type Family_sponsorshipOrderByRelationAggregateInput = {
        _count?: SortOrder
    }

    export type OrphansOrderByRelationAggregateInput = {
        _count?: SortOrder
    }

    export type Second_sponsorsOrderByRelationAggregateInput = {
        _count?: SortOrder
    }

    export type SpousesOrderByRelationAggregateInput = {
        _count?: SortOrder
    }

    export type FamiliesCountOrderByAggregateInput = {
        id?: SortOrder
        name?: SortOrder
        report?: SortOrder
        tenant_id?: SortOrder
        created_at?: SortOrder
        updated_at?: SortOrder
    }

    export type FamiliesMaxOrderByAggregateInput = {
        id?: SortOrder
        name?: SortOrder
        report?: SortOrder
        tenant_id?: SortOrder
        created_at?: SortOrder
        updated_at?: SortOrder
    }

    export type FamiliesMinOrderByAggregateInput = {
        id?: SortOrder
        name?: SortOrder
        report?: SortOrder
        tenant_id?: SortOrder
        created_at?: SortOrder
        updated_at?: SortOrder
    }

    export type FamiliesRelationFilter = {
        is?: FamiliesWhereInput
        isNot?: FamiliesWhereInput
    }

    export type FurnishingsRelationFilter = {
        is?: FurnishingsWhereInput
        isNot?: FurnishingsWhereInput
    }

    export type Family_furnishingCountOrderByAggregateInput = {
        id?: SortOrder
        family_id?: SortOrder
        furnishing_id?: SortOrder
        value?: SortOrder
    }

    export type Family_furnishingMaxOrderByAggregateInput = {
        id?: SortOrder
        family_id?: SortOrder
        furnishing_id?: SortOrder
        value?: SortOrder
    }

    export type Family_furnishingMinOrderByAggregateInput = {
        id?: SortOrder
        family_id?: SortOrder
        furnishing_id?: SortOrder
        value?: SortOrder
    }

    export type HousingsRelationFilter = {
        is?: HousingsWhereInput
        isNot?: HousingsWhereInput
    }

    export type Family_housingCountOrderByAggregateInput = {
        id?: SortOrder
        family_id?: SortOrder
        housing_id?: SortOrder
        value?: SortOrder
    }

    export type Family_housingMaxOrderByAggregateInput = {
        id?: SortOrder
        family_id?: SortOrder
        housing_id?: SortOrder
        value?: SortOrder
    }

    export type Family_housingMinOrderByAggregateInput = {
        id?: SortOrder
        family_id?: SortOrder
        housing_id?: SortOrder
        value?: SortOrder
    }

    export type Enumfamily_sponsorship_typeFilter = {
        equals?: family_sponsorship_type
        in?: Enumerable<family_sponsorship_type>
        notIn?: Enumerable<family_sponsorship_type>
        not?: NestedEnumfamily_sponsorship_typeFilter | family_sponsorship_type
    }

    export type Family_sponsorshipCountOrderByAggregateInput = {
        id?: SortOrder
        family_id?: SortOrder
        type?: SortOrder
        value?: SortOrder
        tenant_id?: SortOrder
        created_at?: SortOrder
        updated_at?: SortOrder
    }

    export type Family_sponsorshipMaxOrderByAggregateInput = {
        id?: SortOrder
        family_id?: SortOrder
        type?: SortOrder
        value?: SortOrder
        tenant_id?: SortOrder
        created_at?: SortOrder
        updated_at?: SortOrder
    }

    export type Family_sponsorshipMinOrderByAggregateInput = {
        id?: SortOrder
        family_id?: SortOrder
        type?: SortOrder
        value?: SortOrder
        tenant_id?: SortOrder
        created_at?: SortOrder
        updated_at?: SortOrder
    }

    export type Enumfamily_sponsorship_typeWithAggregatesFilter = {
        equals?: family_sponsorship_type
        in?: Enumerable<family_sponsorship_type>
        notIn?: Enumerable<family_sponsorship_type>
        not?: NestedEnumfamily_sponsorship_typeWithAggregatesFilter | family_sponsorship_type
        _count?: NestedIntFilter
        _min?: NestedEnumfamily_sponsorship_typeFilter
        _max?: NestedEnumfamily_sponsorship_typeFilter
    }

    export type FurnishingsCountOrderByAggregateInput = {
        id?: SortOrder
        name?: SortOrder
    }

    export type FurnishingsMaxOrderByAggregateInput = {
        id?: SortOrder
        name?: SortOrder
    }

    export type FurnishingsMinOrderByAggregateInput = {
        id?: SortOrder
        name?: SortOrder
    }

    export type HousingsCountOrderByAggregateInput = {
        id?: SortOrder
        name?: SortOrder
    }

    export type HousingsMaxOrderByAggregateInput = {
        id?: SortOrder
        name?: SortOrder
    }

    export type HousingsMinOrderByAggregateInput = {
        id?: SortOrder
        name?: SortOrder
    }

    export type FloatFilter = {
        equals?: number
        in?: Enumerable<number>
        notIn?: Enumerable<number>
        lt?: number
        lte?: number
        gt?: number
        gte?: number
        not?: NestedFloatFilter | number
    }

    export type IncomesRelationFilter = {
        is?: IncomesWhereInput
        isNot?: IncomesWhereInput
    }

    export type SponsorsRelationFilter = {
        is?: SponsorsWhereInput
        isNot?: SponsorsWhereInput
    }

    export type Income_sponsorCountOrderByAggregateInput = {
        id?: SortOrder
        income_id?: SortOrder
        sponsor_id?: SortOrder
        tenant_id?: SortOrder
        value?: SortOrder
        created_at?: SortOrder
        updated_at?: SortOrder
    }

    export type Income_sponsorAvgOrderByAggregateInput = {
        value?: SortOrder
    }

    export type Income_sponsorMaxOrderByAggregateInput = {
        id?: SortOrder
        income_id?: SortOrder
        sponsor_id?: SortOrder
        tenant_id?: SortOrder
        value?: SortOrder
        created_at?: SortOrder
        updated_at?: SortOrder
    }

    export type Income_sponsorMinOrderByAggregateInput = {
        id?: SortOrder
        income_id?: SortOrder
        sponsor_id?: SortOrder
        tenant_id?: SortOrder
        value?: SortOrder
        created_at?: SortOrder
        updated_at?: SortOrder
    }

    export type Income_sponsorSumOrderByAggregateInput = {
        value?: SortOrder
    }

    export type FloatWithAggregatesFilter = {
        equals?: number
        in?: Enumerable<number>
        notIn?: Enumerable<number>
        lt?: number
        lte?: number
        gt?: number
        gte?: number
        not?: NestedFloatWithAggregatesFilter | number
        _count?: NestedIntFilter
        _avg?: NestedFloatFilter
        _sum?: NestedFloatFilter
        _min?: NestedFloatFilter
        _max?: NestedFloatFilter
    }

    export type Income_sponsorListRelationFilter = {
        every?: Income_sponsorWhereInput
        some?: Income_sponsorWhereInput
        none?: Income_sponsorWhereInput
    }

    export type Income_sponsorOrderByRelationAggregateInput = {
        _count?: SortOrder
    }

    export type IncomesCountOrderByAggregateInput = {
        id?: SortOrder
        name?: SortOrder
    }

    export type IncomesMaxOrderByAggregateInput = {
        id?: SortOrder
        name?: SortOrder
    }

    export type IncomesMinOrderByAggregateInput = {
        id?: SortOrder
        name?: SortOrder
    }

    export type BigIntFilter = {
        equals?: bigint | number
        in?: Enumerable<bigint> | Enumerable<number>
        notIn?: Enumerable<bigint> | Enumerable<number>
        lt?: bigint | number
        lte?: bigint | number
        gt?: bigint | number
        gte?: bigint | number
        not?: NestedBigIntFilter | bigint | number
    }

    export type UuidNullableFilter = {
        equals?: string | null
        in?: Enumerable<string> | null
        notIn?: Enumerable<string> | null
        lt?: string
        lte?: string
        gt?: string
        gte?: string
        mode?: QueryMode
        not?: NestedUuidNullableFilter | string | null
    }

    export type StringNullableFilter = {
        equals?: string | null
        in?: Enumerable<string> | null
        notIn?: Enumerable<string> | null
        lt?: string
        lte?: string
        gt?: string
        gte?: string
        contains?: string
        startsWith?: string
        endsWith?: string
        mode?: QueryMode
        not?: NestedStringNullableFilter | string | null
    }
    export type JsonFilter =
        | PatchUndefined<
              Either<Required<JsonFilterBase>, Exclude<keyof Required<JsonFilterBase>, 'path'>>,
              Required<JsonFilterBase>
          >
        | OptionalFlat<Omit<Required<JsonFilterBase>, 'path'>>

    export type JsonFilterBase = {
        equals?: InputJsonValue | JsonNullValueFilter
        path?: Array<string>
        string_contains?: string
        string_starts_with?: string
        string_ends_with?: string
        array_contains?: InputJsonValue | null
        array_starts_with?: InputJsonValue | null
        array_ends_with?: InputJsonValue | null
        lt?: InputJsonValue
        lte?: InputJsonValue
        gt?: InputJsonValue
        gte?: InputJsonValue
        not?: InputJsonValue | JsonNullValueFilter
    }

    export type IntNullableFilter = {
        equals?: number | null
        in?: Enumerable<number> | null
        notIn?: Enumerable<number> | null
        lt?: number
        lte?: number
        gt?: number
        gte?: number
        not?: NestedIntNullableFilter | number | null
    }

    export type MediaCountOrderByAggregateInput = {
        id?: SortOrder
        model_type?: SortOrder
        model_id?: SortOrder
        uuid?: SortOrder
        collection_name?: SortOrder
        name?: SortOrder
        file_name?: SortOrder
        mime_type?: SortOrder
        disk?: SortOrder
        conversions_disk?: SortOrder
        size?: SortOrder
        manipulations?: SortOrder
        custom_properties?: SortOrder
        generated_conversions?: SortOrder
        responsive_images?: SortOrder
        order_column?: SortOrder
        created_at?: SortOrder
        updated_at?: SortOrder
    }

    export type MediaAvgOrderByAggregateInput = {
        model_id?: SortOrder
        size?: SortOrder
        order_column?: SortOrder
    }

    export type MediaMaxOrderByAggregateInput = {
        id?: SortOrder
        model_type?: SortOrder
        model_id?: SortOrder
        uuid?: SortOrder
        collection_name?: SortOrder
        name?: SortOrder
        file_name?: SortOrder
        mime_type?: SortOrder
        disk?: SortOrder
        conversions_disk?: SortOrder
        size?: SortOrder
        order_column?: SortOrder
        created_at?: SortOrder
        updated_at?: SortOrder
    }

    export type MediaMinOrderByAggregateInput = {
        id?: SortOrder
        model_type?: SortOrder
        model_id?: SortOrder
        uuid?: SortOrder
        collection_name?: SortOrder
        name?: SortOrder
        file_name?: SortOrder
        mime_type?: SortOrder
        disk?: SortOrder
        conversions_disk?: SortOrder
        size?: SortOrder
        order_column?: SortOrder
        created_at?: SortOrder
        updated_at?: SortOrder
    }

    export type MediaSumOrderByAggregateInput = {
        model_id?: SortOrder
        size?: SortOrder
        order_column?: SortOrder
    }

    export type BigIntWithAggregatesFilter = {
        equals?: bigint | number
        in?: Enumerable<bigint> | Enumerable<number>
        notIn?: Enumerable<bigint> | Enumerable<number>
        lt?: bigint | number
        lte?: bigint | number
        gt?: bigint | number
        gte?: bigint | number
        not?: NestedBigIntWithAggregatesFilter | bigint | number
        _count?: NestedIntFilter
        _avg?: NestedFloatFilter
        _sum?: NestedBigIntFilter
        _min?: NestedBigIntFilter
        _max?: NestedBigIntFilter
    }

    export type UuidNullableWithAggregatesFilter = {
        equals?: string | null
        in?: Enumerable<string> | null
        notIn?: Enumerable<string> | null
        lt?: string
        lte?: string
        gt?: string
        gte?: string
        mode?: QueryMode
        not?: NestedUuidNullableWithAggregatesFilter | string | null
        _count?: NestedIntNullableFilter
        _min?: NestedStringNullableFilter
        _max?: NestedStringNullableFilter
    }

    export type StringNullableWithAggregatesFilter = {
        equals?: string | null
        in?: Enumerable<string> | null
        notIn?: Enumerable<string> | null
        lt?: string
        lte?: string
        gt?: string
        gte?: string
        contains?: string
        startsWith?: string
        endsWith?: string
        mode?: QueryMode
        not?: NestedStringNullableWithAggregatesFilter | string | null
        _count?: NestedIntNullableFilter
        _min?: NestedStringNullableFilter
        _max?: NestedStringNullableFilter
    }
    export type JsonWithAggregatesFilter =
        | PatchUndefined<
              Either<
                  Required<JsonWithAggregatesFilterBase>,
                  Exclude<keyof Required<JsonWithAggregatesFilterBase>, 'path'>
              >,
              Required<JsonWithAggregatesFilterBase>
          >
        | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase>, 'path'>>

    export type JsonWithAggregatesFilterBase = {
        equals?: InputJsonValue | JsonNullValueFilter
        path?: Array<string>
        string_contains?: string
        string_starts_with?: string
        string_ends_with?: string
        array_contains?: InputJsonValue | null
        array_starts_with?: InputJsonValue | null
        array_ends_with?: InputJsonValue | null
        lt?: InputJsonValue
        lte?: InputJsonValue
        gt?: InputJsonValue
        gte?: InputJsonValue
        not?: InputJsonValue | JsonNullValueFilter
        _count?: NestedIntFilter
        _min?: NestedJsonFilter
        _max?: NestedJsonFilter
    }

    export type IntNullableWithAggregatesFilter = {
        equals?: number | null
        in?: Enumerable<number> | null
        notIn?: Enumerable<number> | null
        lt?: number
        lte?: number
        gt?: number
        gte?: number
        not?: NestedIntNullableWithAggregatesFilter | number | null
        _count?: NestedIntNullableFilter
        _avg?: NestedFloatNullableFilter
        _sum?: NestedIntNullableFilter
        _min?: NestedIntNullableFilter
        _max?: NestedIntNullableFilter
    }

    export type PermissionsRelationFilter = {
        is?: PermissionsWhereInput
        isNot?: PermissionsWhereInput
    }

    export type Model_has_permissionsPermission_idModel_uuidModel_typeCompoundUniqueInput = {
        permission_id: string
        model_uuid: string
        model_type: string
    }

    export type Model_has_permissionsCountOrderByAggregateInput = {
        permission_id?: SortOrder
        model_type?: SortOrder
        model_uuid?: SortOrder
    }

    export type Model_has_permissionsMaxOrderByAggregateInput = {
        permission_id?: SortOrder
        model_type?: SortOrder
        model_uuid?: SortOrder
    }

    export type Model_has_permissionsMinOrderByAggregateInput = {
        permission_id?: SortOrder
        model_type?: SortOrder
        model_uuid?: SortOrder
    }

    export type RolesRelationFilter = {
        is?: RolesWhereInput
        isNot?: RolesWhereInput
    }

    export type Model_has_rolesRole_idModel_uuidModel_typeCompoundUniqueInput = {
        role_id: string
        model_uuid: string
        model_type: string
    }

    export type Model_has_rolesCountOrderByAggregateInput = {
        role_id?: SortOrder
        model_type?: SortOrder
        model_uuid?: SortOrder
    }

    export type Model_has_rolesMaxOrderByAggregateInput = {
        role_id?: SortOrder
        model_type?: SortOrder
        model_uuid?: SortOrder
    }

    export type Model_has_rolesMinOrderByAggregateInput = {
        role_id?: SortOrder
        model_type?: SortOrder
        model_uuid?: SortOrder
    }

    export type Enumorphan_sponsorship_typeFilter = {
        equals?: orphan_sponsorship_type
        in?: Enumerable<orphan_sponsorship_type>
        notIn?: Enumerable<orphan_sponsorship_type>
        not?: NestedEnumorphan_sponsorship_typeFilter | orphan_sponsorship_type
    }

    export type OrphansRelationFilter = {
        is?: OrphansWhereInput
        isNot?: OrphansWhereInput
    }

    export type Orphan_sponsorshipCountOrderByAggregateInput = {
        id?: SortOrder
        orphan_id?: SortOrder
        type?: SortOrder
        value?: SortOrder
        tenant_id?: SortOrder
        created_at?: SortOrder
        updated_at?: SortOrder
    }

    export type Orphan_sponsorshipMaxOrderByAggregateInput = {
        id?: SortOrder
        orphan_id?: SortOrder
        type?: SortOrder
        value?: SortOrder
        tenant_id?: SortOrder
        created_at?: SortOrder
        updated_at?: SortOrder
    }

    export type Orphan_sponsorshipMinOrderByAggregateInput = {
        id?: SortOrder
        orphan_id?: SortOrder
        type?: SortOrder
        value?: SortOrder
        tenant_id?: SortOrder
        created_at?: SortOrder
        updated_at?: SortOrder
    }

    export type Enumorphan_sponsorship_typeWithAggregatesFilter = {
        equals?: orphan_sponsorship_type
        in?: Enumerable<orphan_sponsorship_type>
        notIn?: Enumerable<orphan_sponsorship_type>
        not?: NestedEnumorphan_sponsorship_typeWithAggregatesFilter | orphan_sponsorship_type
        _count?: NestedIntFilter
        _min?: NestedEnumorphan_sponsorship_typeFilter
        _max?: NestedEnumorphan_sponsorship_typeFilter
    }

    export type DateTimeFilter = {
        equals?: Date | string
        in?: Enumerable<Date> | Enumerable<string>
        notIn?: Enumerable<Date> | Enumerable<string>
        lt?: Date | string
        lte?: Date | string
        gt?: Date | string
        gte?: Date | string
        not?: NestedDateTimeFilter | Date | string
    }

    export type Orphan_sponsorshipListRelationFilter = {
        every?: Orphan_sponsorshipWhereInput
        some?: Orphan_sponsorshipWhereInput
        none?: Orphan_sponsorshipWhereInput
    }

    export type UsersRelationFilter = {
        is?: UsersWhereInput
        isNot?: UsersWhereInput
    }

    export type Orphan_sponsorshipOrderByRelationAggregateInput = {
        _count?: SortOrder
    }

    export type OrphansCountOrderByAggregateInput = {
        id?: SortOrder
        first_name?: SortOrder
        last_name?: SortOrder
        birth_date?: SortOrder
        family_status?: SortOrder
        health_status?: SortOrder
        academic_level?: SortOrder
        shoes_size?: SortOrder
        pants_size?: SortOrder
        shirt_size?: SortOrder
        note?: SortOrder
        tenant_id?: SortOrder
        family_id?: SortOrder
        created_by?: SortOrder
        deleted_by?: SortOrder
        created_at?: SortOrder
        updated_at?: SortOrder
    }

    export type OrphansMaxOrderByAggregateInput = {
        id?: SortOrder
        first_name?: SortOrder
        last_name?: SortOrder
        birth_date?: SortOrder
        family_status?: SortOrder
        health_status?: SortOrder
        academic_level?: SortOrder
        shoes_size?: SortOrder
        pants_size?: SortOrder
        shirt_size?: SortOrder
        note?: SortOrder
        tenant_id?: SortOrder
        family_id?: SortOrder
        created_by?: SortOrder
        deleted_by?: SortOrder
        created_at?: SortOrder
        updated_at?: SortOrder
    }

    export type OrphansMinOrderByAggregateInput = {
        id?: SortOrder
        first_name?: SortOrder
        last_name?: SortOrder
        birth_date?: SortOrder
        family_status?: SortOrder
        health_status?: SortOrder
        academic_level?: SortOrder
        shoes_size?: SortOrder
        pants_size?: SortOrder
        shirt_size?: SortOrder
        note?: SortOrder
        tenant_id?: SortOrder
        family_id?: SortOrder
        created_by?: SortOrder
        deleted_by?: SortOrder
        created_at?: SortOrder
        updated_at?: SortOrder
    }

    export type DateTimeWithAggregatesFilter = {
        equals?: Date | string
        in?: Enumerable<Date> | Enumerable<string>
        notIn?: Enumerable<Date> | Enumerable<string>
        lt?: Date | string
        lte?: Date | string
        gt?: Date | string
        gte?: Date | string
        not?: NestedDateTimeWithAggregatesFilter | Date | string
        _count?: NestedIntFilter
        _min?: NestedDateTimeFilter
        _max?: NestedDateTimeFilter
    }

    export type Password_reset_tokensCountOrderByAggregateInput = {
        email?: SortOrder
        token?: SortOrder
        created_at?: SortOrder
    }

    export type Password_reset_tokensMaxOrderByAggregateInput = {
        email?: SortOrder
        token?: SortOrder
        created_at?: SortOrder
    }

    export type Password_reset_tokensMinOrderByAggregateInput = {
        email?: SortOrder
        token?: SortOrder
        created_at?: SortOrder
    }

    export type Model_has_permissionsListRelationFilter = {
        every?: Model_has_permissionsWhereInput
        some?: Model_has_permissionsWhereInput
        none?: Model_has_permissionsWhereInput
    }

    export type Role_has_permissionsListRelationFilter = {
        every?: Role_has_permissionsWhereInput
        some?: Role_has_permissionsWhereInput
        none?: Role_has_permissionsWhereInput
    }

    export type Model_has_permissionsOrderByRelationAggregateInput = {
        _count?: SortOrder
    }

    export type Role_has_permissionsOrderByRelationAggregateInput = {
        _count?: SortOrder
    }

    export type PermissionsCountOrderByAggregateInput = {
        uuid?: SortOrder
        name?: SortOrder
        guard_name?: SortOrder
        created_at?: SortOrder
        updated_at?: SortOrder
    }

    export type PermissionsMaxOrderByAggregateInput = {
        uuid?: SortOrder
        name?: SortOrder
        guard_name?: SortOrder
        created_at?: SortOrder
        updated_at?: SortOrder
    }

    export type PermissionsMinOrderByAggregateInput = {
        uuid?: SortOrder
        name?: SortOrder
        guard_name?: SortOrder
        created_at?: SortOrder
        updated_at?: SortOrder
    }

    export type Personal_access_tokensCountOrderByAggregateInput = {
        id?: SortOrder
        tokenable_type?: SortOrder
        tokenable_id?: SortOrder
        name?: SortOrder
        token?: SortOrder
        abilities?: SortOrder
        last_used_at?: SortOrder
        expires_at?: SortOrder
        created_at?: SortOrder
        updated_at?: SortOrder
    }

    export type Personal_access_tokensMaxOrderByAggregateInput = {
        id?: SortOrder
        tokenable_type?: SortOrder
        tokenable_id?: SortOrder
        name?: SortOrder
        token?: SortOrder
        abilities?: SortOrder
        last_used_at?: SortOrder
        expires_at?: SortOrder
        created_at?: SortOrder
        updated_at?: SortOrder
    }

    export type Personal_access_tokensMinOrderByAggregateInput = {
        id?: SortOrder
        tokenable_type?: SortOrder
        tokenable_id?: SortOrder
        name?: SortOrder
        token?: SortOrder
        abilities?: SortOrder
        last_used_at?: SortOrder
        expires_at?: SortOrder
        created_at?: SortOrder
        updated_at?: SortOrder
    }

    export type Role_has_permissionsPermission_idRole_idCompoundUniqueInput = {
        permission_id: string
        role_id: string
    }

    export type Role_has_permissionsCountOrderByAggregateInput = {
        permission_id?: SortOrder
        role_id?: SortOrder
    }

    export type Role_has_permissionsMaxOrderByAggregateInput = {
        permission_id?: SortOrder
        role_id?: SortOrder
    }

    export type Role_has_permissionsMinOrderByAggregateInput = {
        permission_id?: SortOrder
        role_id?: SortOrder
    }

    export type Model_has_rolesListRelationFilter = {
        every?: Model_has_rolesWhereInput
        some?: Model_has_rolesWhereInput
        none?: Model_has_rolesWhereInput
    }

    export type Model_has_rolesOrderByRelationAggregateInput = {
        _count?: SortOrder
    }

    export type RolesCountOrderByAggregateInput = {
        uuid?: SortOrder
        name?: SortOrder
        guard_name?: SortOrder
        created_at?: SortOrder
        updated_at?: SortOrder
    }

    export type RolesMaxOrderByAggregateInput = {
        uuid?: SortOrder
        name?: SortOrder
        guard_name?: SortOrder
        created_at?: SortOrder
        updated_at?: SortOrder
    }

    export type RolesMinOrderByAggregateInput = {
        uuid?: SortOrder
        name?: SortOrder
        guard_name?: SortOrder
        created_at?: SortOrder
        updated_at?: SortOrder
    }

    export type Second_sponsorsCountOrderByAggregateInput = {
        id?: SortOrder
        first_name?: SortOrder
        last_name?: SortOrder
        degree_of_kinship?: SortOrder
        phone_number?: SortOrder
        address?: SortOrder
        income?: SortOrder
        family_id?: SortOrder
        tenant_id?: SortOrder
        deleted_at?: SortOrder
        created_at?: SortOrder
        updated_at?: SortOrder
    }

    export type Second_sponsorsAvgOrderByAggregateInput = {
        income?: SortOrder
    }

    export type Second_sponsorsMaxOrderByAggregateInput = {
        id?: SortOrder
        first_name?: SortOrder
        last_name?: SortOrder
        degree_of_kinship?: SortOrder
        phone_number?: SortOrder
        address?: SortOrder
        income?: SortOrder
        family_id?: SortOrder
        tenant_id?: SortOrder
        deleted_at?: SortOrder
        created_at?: SortOrder
        updated_at?: SortOrder
    }

    export type Second_sponsorsMinOrderByAggregateInput = {
        id?: SortOrder
        first_name?: SortOrder
        last_name?: SortOrder
        degree_of_kinship?: SortOrder
        phone_number?: SortOrder
        address?: SortOrder
        income?: SortOrder
        family_id?: SortOrder
        tenant_id?: SortOrder
        deleted_at?: SortOrder
        created_at?: SortOrder
        updated_at?: SortOrder
    }

    export type Second_sponsorsSumOrderByAggregateInput = {
        income?: SortOrder
    }

    export type SessionsCountOrderByAggregateInput = {
        id?: SortOrder
        user_id?: SortOrder
        ip_address?: SortOrder
        user_agent?: SortOrder
        payload?: SortOrder
        last_activity?: SortOrder
    }

    export type SessionsAvgOrderByAggregateInput = {
        last_activity?: SortOrder
    }

    export type SessionsMaxOrderByAggregateInput = {
        id?: SortOrder
        user_id?: SortOrder
        ip_address?: SortOrder
        user_agent?: SortOrder
        payload?: SortOrder
        last_activity?: SortOrder
    }

    export type SessionsMinOrderByAggregateInput = {
        id?: SortOrder
        user_id?: SortOrder
        ip_address?: SortOrder
        user_agent?: SortOrder
        payload?: SortOrder
        last_activity?: SortOrder
    }

    export type SessionsSumOrderByAggregateInput = {
        last_activity?: SortOrder
    }

    export type EnumthemeFilter = {
        equals?: theme
        in?: Enumerable<theme>
        notIn?: Enumerable<theme>
        not?: NestedEnumthemeFilter | theme
    }

    export type Enumcolor_schemeFilter = {
        equals?: color_scheme
        in?: Enumerable<color_scheme>
        notIn?: Enumerable<color_scheme>
        not?: NestedEnumcolor_schemeFilter | color_scheme
    }

    export type EnumlayoutFilter = {
        equals?: layout
        in?: Enumerable<layout>
        notIn?: Enumerable<layout>
        not?: NestedEnumlayoutFilter | layout
    }

    export type EnumappearanceFilter = {
        equals?: appearance
        in?: Enumerable<appearance>
        notIn?: Enumerable<appearance>
        not?: NestedEnumappearanceFilter | appearance
    }
    export type JsonNullableFilter =
        | PatchUndefined<
              Either<Required<JsonNullableFilterBase>, Exclude<keyof Required<JsonNullableFilterBase>, 'path'>>,
              Required<JsonNullableFilterBase>
          >
        | OptionalFlat<Omit<Required<JsonNullableFilterBase>, 'path'>>

    export type JsonNullableFilterBase = {
        equals?: InputJsonValue | JsonNullValueFilter
        path?: Array<string>
        string_contains?: string
        string_starts_with?: string
        string_ends_with?: string
        array_contains?: InputJsonValue | null
        array_starts_with?: InputJsonValue | null
        array_ends_with?: InputJsonValue | null
        lt?: InputJsonValue
        lte?: InputJsonValue
        gt?: InputJsonValue
        gte?: InputJsonValue
        not?: InputJsonValue | JsonNullValueFilter
    }

    export type SettingsCountOrderByAggregateInput = {
        id?: SortOrder
        user_id?: SortOrder
        theme?: SortOrder
        color_scheme?: SortOrder
        layout?: SortOrder
        appearance?: SortOrder
        notifications?: SortOrder
        created_at?: SortOrder
        updated_at?: SortOrder
    }

    export type SettingsMaxOrderByAggregateInput = {
        id?: SortOrder
        user_id?: SortOrder
        theme?: SortOrder
        color_scheme?: SortOrder
        layout?: SortOrder
        appearance?: SortOrder
        created_at?: SortOrder
        updated_at?: SortOrder
    }

    export type SettingsMinOrderByAggregateInput = {
        id?: SortOrder
        user_id?: SortOrder
        theme?: SortOrder
        color_scheme?: SortOrder
        layout?: SortOrder
        appearance?: SortOrder
        created_at?: SortOrder
        updated_at?: SortOrder
    }

    export type EnumthemeWithAggregatesFilter = {
        equals?: theme
        in?: Enumerable<theme>
        notIn?: Enumerable<theme>
        not?: NestedEnumthemeWithAggregatesFilter | theme
        _count?: NestedIntFilter
        _min?: NestedEnumthemeFilter
        _max?: NestedEnumthemeFilter
    }

    export type Enumcolor_schemeWithAggregatesFilter = {
        equals?: color_scheme
        in?: Enumerable<color_scheme>
        notIn?: Enumerable<color_scheme>
        not?: NestedEnumcolor_schemeWithAggregatesFilter | color_scheme
        _count?: NestedIntFilter
        _min?: NestedEnumcolor_schemeFilter
        _max?: NestedEnumcolor_schemeFilter
    }

    export type EnumlayoutWithAggregatesFilter = {
        equals?: layout
        in?: Enumerable<layout>
        notIn?: Enumerable<layout>
        not?: NestedEnumlayoutWithAggregatesFilter | layout
        _count?: NestedIntFilter
        _min?: NestedEnumlayoutFilter
        _max?: NestedEnumlayoutFilter
    }

    export type EnumappearanceWithAggregatesFilter = {
        equals?: appearance
        in?: Enumerable<appearance>
        notIn?: Enumerable<appearance>
        not?: NestedEnumappearanceWithAggregatesFilter | appearance
        _count?: NestedIntFilter
        _min?: NestedEnumappearanceFilter
        _max?: NestedEnumappearanceFilter
    }
    export type JsonNullableWithAggregatesFilter =
        | PatchUndefined<
              Either<
                  Required<JsonNullableWithAggregatesFilterBase>,
                  Exclude<keyof Required<JsonNullableWithAggregatesFilterBase>, 'path'>
              >,
              Required<JsonNullableWithAggregatesFilterBase>
          >
        | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase>, 'path'>>

    export type JsonNullableWithAggregatesFilterBase = {
        equals?: InputJsonValue | JsonNullValueFilter
        path?: Array<string>
        string_contains?: string
        string_starts_with?: string
        string_ends_with?: string
        array_contains?: InputJsonValue | null
        array_starts_with?: InputJsonValue | null
        array_ends_with?: InputJsonValue | null
        lt?: InputJsonValue
        lte?: InputJsonValue
        gt?: InputJsonValue
        gte?: InputJsonValue
        not?: InputJsonValue | JsonNullValueFilter
        _count?: NestedIntNullableFilter
        _min?: NestedJsonNullableFilter
        _max?: NestedJsonNullableFilter
    }

    export type Enumsponsor_sponsorship_typeFilter = {
        equals?: sponsor_sponsorship_type
        in?: Enumerable<sponsor_sponsorship_type>
        notIn?: Enumerable<sponsor_sponsorship_type>
        not?: NestedEnumsponsor_sponsorship_typeFilter | sponsor_sponsorship_type
    }

    export type Sponsor_sponsorshipCountOrderByAggregateInput = {
        id?: SortOrder
        sponsor_id?: SortOrder
        type?: SortOrder
        value?: SortOrder
        tenant_id?: SortOrder
        created_at?: SortOrder
        updated_at?: SortOrder
    }

    export type Sponsor_sponsorshipMaxOrderByAggregateInput = {
        id?: SortOrder
        sponsor_id?: SortOrder
        type?: SortOrder
        value?: SortOrder
        tenant_id?: SortOrder
        created_at?: SortOrder
        updated_at?: SortOrder
    }

    export type Sponsor_sponsorshipMinOrderByAggregateInput = {
        id?: SortOrder
        sponsor_id?: SortOrder
        type?: SortOrder
        value?: SortOrder
        tenant_id?: SortOrder
        created_at?: SortOrder
        updated_at?: SortOrder
    }

    export type Enumsponsor_sponsorship_typeWithAggregatesFilter = {
        equals?: sponsor_sponsorship_type
        in?: Enumerable<sponsor_sponsorship_type>
        notIn?: Enumerable<sponsor_sponsorship_type>
        not?: NestedEnumsponsor_sponsorship_typeWithAggregatesFilter | sponsor_sponsorship_type
        _count?: NestedIntFilter
        _min?: NestedEnumsponsor_sponsorship_typeFilter
        _max?: NestedEnumsponsor_sponsorship_typeFilter
    }

    export type Sponsor_sponsorshipListRelationFilter = {
        every?: Sponsor_sponsorshipWhereInput
        some?: Sponsor_sponsorshipWhereInput
        none?: Sponsor_sponsorshipWhereInput
    }

    export type Sponsor_sponsorshipOrderByRelationAggregateInput = {
        _count?: SortOrder
    }

    export type SponsorsCountOrderByAggregateInput = {
        id?: SortOrder
        zone_id?: SortOrder
        file_number?: SortOrder
        start_date?: SortOrder
        name?: SortOrder
        address?: SortOrder
        phone_number?: SortOrder
        sponsorship_type?: SortOrder
        birth_date?: SortOrder
        father_name?: SortOrder
        mother_name?: SortOrder
        birth_certificate_number?: SortOrder
        academic_level?: SortOrder
        function?: SortOrder
        health_status?: SortOrder
        diploma?: SortOrder
        card_number?: SortOrder
        tenant_id?: SortOrder
        created_by?: SortOrder
        deleted_by?: SortOrder
        deleted_at?: SortOrder
        created_at?: SortOrder
        updated_at?: SortOrder
    }

    export type SponsorsAvgOrderByAggregateInput = {
        file_number?: SortOrder
    }

    export type SponsorsMaxOrderByAggregateInput = {
        id?: SortOrder
        zone_id?: SortOrder
        file_number?: SortOrder
        start_date?: SortOrder
        name?: SortOrder
        address?: SortOrder
        phone_number?: SortOrder
        sponsorship_type?: SortOrder
        birth_date?: SortOrder
        father_name?: SortOrder
        mother_name?: SortOrder
        birth_certificate_number?: SortOrder
        academic_level?: SortOrder
        function?: SortOrder
        health_status?: SortOrder
        diploma?: SortOrder
        card_number?: SortOrder
        tenant_id?: SortOrder
        created_by?: SortOrder
        deleted_by?: SortOrder
        deleted_at?: SortOrder
        created_at?: SortOrder
        updated_at?: SortOrder
    }

    export type SponsorsMinOrderByAggregateInput = {
        id?: SortOrder
        zone_id?: SortOrder
        file_number?: SortOrder
        start_date?: SortOrder
        name?: SortOrder
        address?: SortOrder
        phone_number?: SortOrder
        sponsorship_type?: SortOrder
        birth_date?: SortOrder
        father_name?: SortOrder
        mother_name?: SortOrder
        birth_certificate_number?: SortOrder
        academic_level?: SortOrder
        function?: SortOrder
        health_status?: SortOrder
        diploma?: SortOrder
        card_number?: SortOrder
        tenant_id?: SortOrder
        created_by?: SortOrder
        deleted_by?: SortOrder
        deleted_at?: SortOrder
        created_at?: SortOrder
        updated_at?: SortOrder
    }

    export type SponsorsSumOrderByAggregateInput = {
        file_number?: SortOrder
    }

    export type Enumsponsorship_typeFilter = {
        equals?: sponsorship_type
        in?: Enumerable<sponsorship_type>
        notIn?: Enumerable<sponsorship_type>
        not?: NestedEnumsponsorship_typeFilter | sponsorship_type
    }

    export type SponsorshipsCountOrderByAggregateInput = {
        id?: SortOrder
        type?: SortOrder
        name?: SortOrder
        tenant_id?: SortOrder
        deleted_at?: SortOrder
        created_at?: SortOrder
        updated_at?: SortOrder
    }

    export type SponsorshipsMaxOrderByAggregateInput = {
        id?: SortOrder
        type?: SortOrder
        name?: SortOrder
        tenant_id?: SortOrder
        deleted_at?: SortOrder
        created_at?: SortOrder
        updated_at?: SortOrder
    }

    export type SponsorshipsMinOrderByAggregateInput = {
        id?: SortOrder
        type?: SortOrder
        name?: SortOrder
        tenant_id?: SortOrder
        deleted_at?: SortOrder
        created_at?: SortOrder
        updated_at?: SortOrder
    }

    export type Enumsponsorship_typeWithAggregatesFilter = {
        equals?: sponsorship_type
        in?: Enumerable<sponsorship_type>
        notIn?: Enumerable<sponsorship_type>
        not?: NestedEnumsponsorship_typeWithAggregatesFilter | sponsorship_type
        _count?: NestedIntFilter
        _min?: NestedEnumsponsorship_typeFilter
        _max?: NestedEnumsponsorship_typeFilter
    }

    export type SpousesCountOrderByAggregateInput = {
        id?: SortOrder
        first_name?: SortOrder
        last_name?: SortOrder
        birth_date?: SortOrder
        death_date?: SortOrder
        function?: SortOrder
        income?: SortOrder
        family_id?: SortOrder
        tenant_id?: SortOrder
        created_at?: SortOrder
        updated_at?: SortOrder
    }

    export type SpousesAvgOrderByAggregateInput = {
        income?: SortOrder
    }

    export type SpousesMaxOrderByAggregateInput = {
        id?: SortOrder
        first_name?: SortOrder
        last_name?: SortOrder
        birth_date?: SortOrder
        death_date?: SortOrder
        function?: SortOrder
        income?: SortOrder
        family_id?: SortOrder
        tenant_id?: SortOrder
        created_at?: SortOrder
        updated_at?: SortOrder
    }

    export type SpousesMinOrderByAggregateInput = {
        id?: SortOrder
        first_name?: SortOrder
        last_name?: SortOrder
        birth_date?: SortOrder
        death_date?: SortOrder
        function?: SortOrder
        income?: SortOrder
        family_id?: SortOrder
        tenant_id?: SortOrder
        created_at?: SortOrder
        updated_at?: SortOrder
    }

    export type SpousesSumOrderByAggregateInput = {
        income?: SortOrder
    }

    export type BenefactorsListRelationFilter = {
        every?: BenefactorsWhereInput
        some?: BenefactorsWhereInput
        none?: BenefactorsWhereInput
    }

    export type DomainsListRelationFilter = {
        every?: DomainsWhereInput
        some?: DomainsWhereInput
        none?: DomainsWhereInput
    }

    export type FamiliesListRelationFilter = {
        every?: FamiliesWhereInput
        some?: FamiliesWhereInput
        none?: FamiliesWhereInput
    }

    export type SponsorsListRelationFilter = {
        every?: SponsorsWhereInput
        some?: SponsorsWhereInput
        none?: SponsorsWhereInput
    }

    export type SponsorshipsListRelationFilter = {
        every?: SponsorshipsWhereInput
        some?: SponsorshipsWhereInput
        none?: SponsorshipsWhereInput
    }

    export type UsersListRelationFilter = {
        every?: UsersWhereInput
        some?: UsersWhereInput
        none?: UsersWhereInput
    }

    export type BenefactorsOrderByRelationAggregateInput = {
        _count?: SortOrder
    }

    export type DomainsOrderByRelationAggregateInput = {
        _count?: SortOrder
    }

    export type FamiliesOrderByRelationAggregateInput = {
        _count?: SortOrder
    }

    export type SponsorsOrderByRelationAggregateInput = {
        _count?: SortOrder
    }

    export type SponsorshipsOrderByRelationAggregateInput = {
        _count?: SortOrder
    }

    export type UsersOrderByRelationAggregateInput = {
        _count?: SortOrder
    }

    export type TenantsCountOrderByAggregateInput = {
        id?: SortOrder
        data?: SortOrder
        created_at?: SortOrder
        updated_at?: SortOrder
    }

    export type TenantsMaxOrderByAggregateInput = {
        id?: SortOrder
        created_at?: SortOrder
        updated_at?: SortOrder
    }

    export type TenantsMinOrderByAggregateInput = {
        id?: SortOrder
        created_at?: SortOrder
        updated_at?: SortOrder
    }

    export type SessionsListRelationFilter = {
        every?: SessionsWhereInput
        some?: SessionsWhereInput
        none?: SessionsWhereInput
    }

    export type SettingsListRelationFilter = {
        every?: SettingsWhereInput
        some?: SettingsWhereInput
        none?: SettingsWhereInput
    }

    export type SessionsOrderByRelationAggregateInput = {
        _count?: SortOrder
    }

    export type SettingsOrderByRelationAggregateInput = {
        _count?: SortOrder
    }

    export type UsersCountOrderByAggregateInput = {
        id?: SortOrder
        first_name?: SortOrder
        last_name?: SortOrder
        phone?: SortOrder
        email?: SortOrder
        email_verified_at?: SortOrder
        password?: SortOrder
        remember_token?: SortOrder
        tenant_id?: SortOrder
        created_at?: SortOrder
        updated_at?: SortOrder
    }

    export type UsersMaxOrderByAggregateInput = {
        id?: SortOrder
        first_name?: SortOrder
        last_name?: SortOrder
        phone?: SortOrder
        email?: SortOrder
        email_verified_at?: SortOrder
        password?: SortOrder
        remember_token?: SortOrder
        tenant_id?: SortOrder
        created_at?: SortOrder
        updated_at?: SortOrder
    }

    export type UsersMinOrderByAggregateInput = {
        id?: SortOrder
        first_name?: SortOrder
        last_name?: SortOrder
        phone?: SortOrder
        email?: SortOrder
        email_verified_at?: SortOrder
        password?: SortOrder
        remember_token?: SortOrder
        tenant_id?: SortOrder
        created_at?: SortOrder
        updated_at?: SortOrder
    }

    export type TenantsCreateNestedOneWithoutBenefactorsInput = {
        create?: XOR<TenantsCreateWithoutBenefactorsInput, TenantsUncheckedCreateWithoutBenefactorsInput>
        connectOrCreate?: TenantsCreateOrConnectWithoutBenefactorsInput
        connect?: TenantsWhereUniqueInput
    }

    export type StringFieldUpdateOperationsInput = {
        set?: string
    }

    export type NullableDateTimeFieldUpdateOperationsInput = {
        set?: Date | string | null
    }

    export type TenantsUpdateOneRequiredWithoutBenefactorsNestedInput = {
        create?: XOR<TenantsCreateWithoutBenefactorsInput, TenantsUncheckedCreateWithoutBenefactorsInput>
        connectOrCreate?: TenantsCreateOrConnectWithoutBenefactorsInput
        upsert?: TenantsUpsertWithoutBenefactorsInput
        connect?: TenantsWhereUniqueInput
        update?: XOR<TenantsUpdateWithoutBenefactorsInput, TenantsUncheckedUpdateWithoutBenefactorsInput>
    }

    export type IntFieldUpdateOperationsInput = {
        set?: number
        increment?: number
        decrement?: number
        multiply?: number
        divide?: number
    }

    export type TenantsCreateNestedOneWithoutDomainsInput = {
        create?: XOR<TenantsCreateWithoutDomainsInput, TenantsUncheckedCreateWithoutDomainsInput>
        connectOrCreate?: TenantsCreateOrConnectWithoutDomainsInput
        connect?: TenantsWhereUniqueInput
    }

    export type TenantsUpdateOneRequiredWithoutDomainsNestedInput = {
        create?: XOR<TenantsCreateWithoutDomainsInput, TenantsUncheckedCreateWithoutDomainsInput>
        connectOrCreate?: TenantsCreateOrConnectWithoutDomainsInput
        upsert?: TenantsUpsertWithoutDomainsInput
        connect?: TenantsWhereUniqueInput
        update?: XOR<TenantsUpdateWithoutDomainsInput, TenantsUncheckedUpdateWithoutDomainsInput>
    }

    export type TenantsCreateNestedOneWithoutFamiliesInput = {
        create?: XOR<TenantsCreateWithoutFamiliesInput, TenantsUncheckedCreateWithoutFamiliesInput>
        connectOrCreate?: TenantsCreateOrConnectWithoutFamiliesInput
        connect?: TenantsWhereUniqueInput
    }

    export type Family_furnishingCreateNestedManyWithoutFamiliesInput = {
        create?: XOR<
            Enumerable<Family_furnishingCreateWithoutFamiliesInput>,
            Enumerable<Family_furnishingUncheckedCreateWithoutFamiliesInput>
        >
        connectOrCreate?: Enumerable<Family_furnishingCreateOrConnectWithoutFamiliesInput>
        createMany?: Family_furnishingCreateManyFamiliesInputEnvelope
        connect?: Enumerable<Family_furnishingWhereUniqueInput>
    }

    export type Family_housingCreateNestedManyWithoutFamiliesInput = {
        create?: XOR<
            Enumerable<Family_housingCreateWithoutFamiliesInput>,
            Enumerable<Family_housingUncheckedCreateWithoutFamiliesInput>
        >
        connectOrCreate?: Enumerable<Family_housingCreateOrConnectWithoutFamiliesInput>
        createMany?: Family_housingCreateManyFamiliesInputEnvelope
        connect?: Enumerable<Family_housingWhereUniqueInput>
    }

    export type Family_sponsorshipCreateNestedManyWithoutFamiliesInput = {
        create?: XOR<
            Enumerable<Family_sponsorshipCreateWithoutFamiliesInput>,
            Enumerable<Family_sponsorshipUncheckedCreateWithoutFamiliesInput>
        >
        connectOrCreate?: Enumerable<Family_sponsorshipCreateOrConnectWithoutFamiliesInput>
        createMany?: Family_sponsorshipCreateManyFamiliesInputEnvelope
        connect?: Enumerable<Family_sponsorshipWhereUniqueInput>
    }

    export type OrphansCreateNestedManyWithoutFamiliesInput = {
        create?: XOR<
            Enumerable<OrphansCreateWithoutFamiliesInput>,
            Enumerable<OrphansUncheckedCreateWithoutFamiliesInput>
        >
        connectOrCreate?: Enumerable<OrphansCreateOrConnectWithoutFamiliesInput>
        createMany?: OrphansCreateManyFamiliesInputEnvelope
        connect?: Enumerable<OrphansWhereUniqueInput>
    }

    export type Second_sponsorsCreateNestedManyWithoutFamiliesInput = {
        create?: XOR<
            Enumerable<Second_sponsorsCreateWithoutFamiliesInput>,
            Enumerable<Second_sponsorsUncheckedCreateWithoutFamiliesInput>
        >
        connectOrCreate?: Enumerable<Second_sponsorsCreateOrConnectWithoutFamiliesInput>
        createMany?: Second_sponsorsCreateManyFamiliesInputEnvelope
        connect?: Enumerable<Second_sponsorsWhereUniqueInput>
    }

    export type SpousesCreateNestedManyWithoutFamiliesInput = {
        create?: XOR<
            Enumerable<SpousesCreateWithoutFamiliesInput>,
            Enumerable<SpousesUncheckedCreateWithoutFamiliesInput>
        >
        connectOrCreate?: Enumerable<SpousesCreateOrConnectWithoutFamiliesInput>
        createMany?: SpousesCreateManyFamiliesInputEnvelope
        connect?: Enumerable<SpousesWhereUniqueInput>
    }

    export type Family_furnishingUncheckedCreateNestedManyWithoutFamiliesInput = {
        create?: XOR<
            Enumerable<Family_furnishingCreateWithoutFamiliesInput>,
            Enumerable<Family_furnishingUncheckedCreateWithoutFamiliesInput>
        >
        connectOrCreate?: Enumerable<Family_furnishingCreateOrConnectWithoutFamiliesInput>
        createMany?: Family_furnishingCreateManyFamiliesInputEnvelope
        connect?: Enumerable<Family_furnishingWhereUniqueInput>
    }

    export type Family_housingUncheckedCreateNestedManyWithoutFamiliesInput = {
        create?: XOR<
            Enumerable<Family_housingCreateWithoutFamiliesInput>,
            Enumerable<Family_housingUncheckedCreateWithoutFamiliesInput>
        >
        connectOrCreate?: Enumerable<Family_housingCreateOrConnectWithoutFamiliesInput>
        createMany?: Family_housingCreateManyFamiliesInputEnvelope
        connect?: Enumerable<Family_housingWhereUniqueInput>
    }

    export type Family_sponsorshipUncheckedCreateNestedManyWithoutFamiliesInput = {
        create?: XOR<
            Enumerable<Family_sponsorshipCreateWithoutFamiliesInput>,
            Enumerable<Family_sponsorshipUncheckedCreateWithoutFamiliesInput>
        >
        connectOrCreate?: Enumerable<Family_sponsorshipCreateOrConnectWithoutFamiliesInput>
        createMany?: Family_sponsorshipCreateManyFamiliesInputEnvelope
        connect?: Enumerable<Family_sponsorshipWhereUniqueInput>
    }

    export type OrphansUncheckedCreateNestedManyWithoutFamiliesInput = {
        create?: XOR<
            Enumerable<OrphansCreateWithoutFamiliesInput>,
            Enumerable<OrphansUncheckedCreateWithoutFamiliesInput>
        >
        connectOrCreate?: Enumerable<OrphansCreateOrConnectWithoutFamiliesInput>
        createMany?: OrphansCreateManyFamiliesInputEnvelope
        connect?: Enumerable<OrphansWhereUniqueInput>
    }

    export type Second_sponsorsUncheckedCreateNestedManyWithoutFamiliesInput = {
        create?: XOR<
            Enumerable<Second_sponsorsCreateWithoutFamiliesInput>,
            Enumerable<Second_sponsorsUncheckedCreateWithoutFamiliesInput>
        >
        connectOrCreate?: Enumerable<Second_sponsorsCreateOrConnectWithoutFamiliesInput>
        createMany?: Second_sponsorsCreateManyFamiliesInputEnvelope
        connect?: Enumerable<Second_sponsorsWhereUniqueInput>
    }

    export type SpousesUncheckedCreateNestedManyWithoutFamiliesInput = {
        create?: XOR<
            Enumerable<SpousesCreateWithoutFamiliesInput>,
            Enumerable<SpousesUncheckedCreateWithoutFamiliesInput>
        >
        connectOrCreate?: Enumerable<SpousesCreateOrConnectWithoutFamiliesInput>
        createMany?: SpousesCreateManyFamiliesInputEnvelope
        connect?: Enumerable<SpousesWhereUniqueInput>
    }

    export type TenantsUpdateOneRequiredWithoutFamiliesNestedInput = {
        create?: XOR<TenantsCreateWithoutFamiliesInput, TenantsUncheckedCreateWithoutFamiliesInput>
        connectOrCreate?: TenantsCreateOrConnectWithoutFamiliesInput
        upsert?: TenantsUpsertWithoutFamiliesInput
        connect?: TenantsWhereUniqueInput
        update?: XOR<TenantsUpdateWithoutFamiliesInput, TenantsUncheckedUpdateWithoutFamiliesInput>
    }

    export type Family_furnishingUpdateManyWithoutFamiliesNestedInput = {
        create?: XOR<
            Enumerable<Family_furnishingCreateWithoutFamiliesInput>,
            Enumerable<Family_furnishingUncheckedCreateWithoutFamiliesInput>
        >
        connectOrCreate?: Enumerable<Family_furnishingCreateOrConnectWithoutFamiliesInput>
        upsert?: Enumerable<Family_furnishingUpsertWithWhereUniqueWithoutFamiliesInput>
        createMany?: Family_furnishingCreateManyFamiliesInputEnvelope
        set?: Enumerable<Family_furnishingWhereUniqueInput>
        disconnect?: Enumerable<Family_furnishingWhereUniqueInput>
        delete?: Enumerable<Family_furnishingWhereUniqueInput>
        connect?: Enumerable<Family_furnishingWhereUniqueInput>
        update?: Enumerable<Family_furnishingUpdateWithWhereUniqueWithoutFamiliesInput>
        updateMany?: Enumerable<Family_furnishingUpdateManyWithWhereWithoutFamiliesInput>
        deleteMany?: Enumerable<Family_furnishingScalarWhereInput>
    }

    export type Family_housingUpdateManyWithoutFamiliesNestedInput = {
        create?: XOR<
            Enumerable<Family_housingCreateWithoutFamiliesInput>,
            Enumerable<Family_housingUncheckedCreateWithoutFamiliesInput>
        >
        connectOrCreate?: Enumerable<Family_housingCreateOrConnectWithoutFamiliesInput>
        upsert?: Enumerable<Family_housingUpsertWithWhereUniqueWithoutFamiliesInput>
        createMany?: Family_housingCreateManyFamiliesInputEnvelope
        set?: Enumerable<Family_housingWhereUniqueInput>
        disconnect?: Enumerable<Family_housingWhereUniqueInput>
        delete?: Enumerable<Family_housingWhereUniqueInput>
        connect?: Enumerable<Family_housingWhereUniqueInput>
        update?: Enumerable<Family_housingUpdateWithWhereUniqueWithoutFamiliesInput>
        updateMany?: Enumerable<Family_housingUpdateManyWithWhereWithoutFamiliesInput>
        deleteMany?: Enumerable<Family_housingScalarWhereInput>
    }

    export type Family_sponsorshipUpdateManyWithoutFamiliesNestedInput = {
        create?: XOR<
            Enumerable<Family_sponsorshipCreateWithoutFamiliesInput>,
            Enumerable<Family_sponsorshipUncheckedCreateWithoutFamiliesInput>
        >
        connectOrCreate?: Enumerable<Family_sponsorshipCreateOrConnectWithoutFamiliesInput>
        upsert?: Enumerable<Family_sponsorshipUpsertWithWhereUniqueWithoutFamiliesInput>
        createMany?: Family_sponsorshipCreateManyFamiliesInputEnvelope
        set?: Enumerable<Family_sponsorshipWhereUniqueInput>
        disconnect?: Enumerable<Family_sponsorshipWhereUniqueInput>
        delete?: Enumerable<Family_sponsorshipWhereUniqueInput>
        connect?: Enumerable<Family_sponsorshipWhereUniqueInput>
        update?: Enumerable<Family_sponsorshipUpdateWithWhereUniqueWithoutFamiliesInput>
        updateMany?: Enumerable<Family_sponsorshipUpdateManyWithWhereWithoutFamiliesInput>
        deleteMany?: Enumerable<Family_sponsorshipScalarWhereInput>
    }

    export type OrphansUpdateManyWithoutFamiliesNestedInput = {
        create?: XOR<
            Enumerable<OrphansCreateWithoutFamiliesInput>,
            Enumerable<OrphansUncheckedCreateWithoutFamiliesInput>
        >
        connectOrCreate?: Enumerable<OrphansCreateOrConnectWithoutFamiliesInput>
        upsert?: Enumerable<OrphansUpsertWithWhereUniqueWithoutFamiliesInput>
        createMany?: OrphansCreateManyFamiliesInputEnvelope
        set?: Enumerable<OrphansWhereUniqueInput>
        disconnect?: Enumerable<OrphansWhereUniqueInput>
        delete?: Enumerable<OrphansWhereUniqueInput>
        connect?: Enumerable<OrphansWhereUniqueInput>
        update?: Enumerable<OrphansUpdateWithWhereUniqueWithoutFamiliesInput>
        updateMany?: Enumerable<OrphansUpdateManyWithWhereWithoutFamiliesInput>
        deleteMany?: Enumerable<OrphansScalarWhereInput>
    }

    export type Second_sponsorsUpdateManyWithoutFamiliesNestedInput = {
        create?: XOR<
            Enumerable<Second_sponsorsCreateWithoutFamiliesInput>,
            Enumerable<Second_sponsorsUncheckedCreateWithoutFamiliesInput>
        >
        connectOrCreate?: Enumerable<Second_sponsorsCreateOrConnectWithoutFamiliesInput>
        upsert?: Enumerable<Second_sponsorsUpsertWithWhereUniqueWithoutFamiliesInput>
        createMany?: Second_sponsorsCreateManyFamiliesInputEnvelope
        set?: Enumerable<Second_sponsorsWhereUniqueInput>
        disconnect?: Enumerable<Second_sponsorsWhereUniqueInput>
        delete?: Enumerable<Second_sponsorsWhereUniqueInput>
        connect?: Enumerable<Second_sponsorsWhereUniqueInput>
        update?: Enumerable<Second_sponsorsUpdateWithWhereUniqueWithoutFamiliesInput>
        updateMany?: Enumerable<Second_sponsorsUpdateManyWithWhereWithoutFamiliesInput>
        deleteMany?: Enumerable<Second_sponsorsScalarWhereInput>
    }

    export type SpousesUpdateManyWithoutFamiliesNestedInput = {
        create?: XOR<
            Enumerable<SpousesCreateWithoutFamiliesInput>,
            Enumerable<SpousesUncheckedCreateWithoutFamiliesInput>
        >
        connectOrCreate?: Enumerable<SpousesCreateOrConnectWithoutFamiliesInput>
        upsert?: Enumerable<SpousesUpsertWithWhereUniqueWithoutFamiliesInput>
        createMany?: SpousesCreateManyFamiliesInputEnvelope
        set?: Enumerable<SpousesWhereUniqueInput>
        disconnect?: Enumerable<SpousesWhereUniqueInput>
        delete?: Enumerable<SpousesWhereUniqueInput>
        connect?: Enumerable<SpousesWhereUniqueInput>
        update?: Enumerable<SpousesUpdateWithWhereUniqueWithoutFamiliesInput>
        updateMany?: Enumerable<SpousesUpdateManyWithWhereWithoutFamiliesInput>
        deleteMany?: Enumerable<SpousesScalarWhereInput>
    }

    export type Family_furnishingUncheckedUpdateManyWithoutFamiliesNestedInput = {
        create?: XOR<
            Enumerable<Family_furnishingCreateWithoutFamiliesInput>,
            Enumerable<Family_furnishingUncheckedCreateWithoutFamiliesInput>
        >
        connectOrCreate?: Enumerable<Family_furnishingCreateOrConnectWithoutFamiliesInput>
        upsert?: Enumerable<Family_furnishingUpsertWithWhereUniqueWithoutFamiliesInput>
        createMany?: Family_furnishingCreateManyFamiliesInputEnvelope
        set?: Enumerable<Family_furnishingWhereUniqueInput>
        disconnect?: Enumerable<Family_furnishingWhereUniqueInput>
        delete?: Enumerable<Family_furnishingWhereUniqueInput>
        connect?: Enumerable<Family_furnishingWhereUniqueInput>
        update?: Enumerable<Family_furnishingUpdateWithWhereUniqueWithoutFamiliesInput>
        updateMany?: Enumerable<Family_furnishingUpdateManyWithWhereWithoutFamiliesInput>
        deleteMany?: Enumerable<Family_furnishingScalarWhereInput>
    }

    export type Family_housingUncheckedUpdateManyWithoutFamiliesNestedInput = {
        create?: XOR<
            Enumerable<Family_housingCreateWithoutFamiliesInput>,
            Enumerable<Family_housingUncheckedCreateWithoutFamiliesInput>
        >
        connectOrCreate?: Enumerable<Family_housingCreateOrConnectWithoutFamiliesInput>
        upsert?: Enumerable<Family_housingUpsertWithWhereUniqueWithoutFamiliesInput>
        createMany?: Family_housingCreateManyFamiliesInputEnvelope
        set?: Enumerable<Family_housingWhereUniqueInput>
        disconnect?: Enumerable<Family_housingWhereUniqueInput>
        delete?: Enumerable<Family_housingWhereUniqueInput>
        connect?: Enumerable<Family_housingWhereUniqueInput>
        update?: Enumerable<Family_housingUpdateWithWhereUniqueWithoutFamiliesInput>
        updateMany?: Enumerable<Family_housingUpdateManyWithWhereWithoutFamiliesInput>
        deleteMany?: Enumerable<Family_housingScalarWhereInput>
    }

    export type Family_sponsorshipUncheckedUpdateManyWithoutFamiliesNestedInput = {
        create?: XOR<
            Enumerable<Family_sponsorshipCreateWithoutFamiliesInput>,
            Enumerable<Family_sponsorshipUncheckedCreateWithoutFamiliesInput>
        >
        connectOrCreate?: Enumerable<Family_sponsorshipCreateOrConnectWithoutFamiliesInput>
        upsert?: Enumerable<Family_sponsorshipUpsertWithWhereUniqueWithoutFamiliesInput>
        createMany?: Family_sponsorshipCreateManyFamiliesInputEnvelope
        set?: Enumerable<Family_sponsorshipWhereUniqueInput>
        disconnect?: Enumerable<Family_sponsorshipWhereUniqueInput>
        delete?: Enumerable<Family_sponsorshipWhereUniqueInput>
        connect?: Enumerable<Family_sponsorshipWhereUniqueInput>
        update?: Enumerable<Family_sponsorshipUpdateWithWhereUniqueWithoutFamiliesInput>
        updateMany?: Enumerable<Family_sponsorshipUpdateManyWithWhereWithoutFamiliesInput>
        deleteMany?: Enumerable<Family_sponsorshipScalarWhereInput>
    }

    export type OrphansUncheckedUpdateManyWithoutFamiliesNestedInput = {
        create?: XOR<
            Enumerable<OrphansCreateWithoutFamiliesInput>,
            Enumerable<OrphansUncheckedCreateWithoutFamiliesInput>
        >
        connectOrCreate?: Enumerable<OrphansCreateOrConnectWithoutFamiliesInput>
        upsert?: Enumerable<OrphansUpsertWithWhereUniqueWithoutFamiliesInput>
        createMany?: OrphansCreateManyFamiliesInputEnvelope
        set?: Enumerable<OrphansWhereUniqueInput>
        disconnect?: Enumerable<OrphansWhereUniqueInput>
        delete?: Enumerable<OrphansWhereUniqueInput>
        connect?: Enumerable<OrphansWhereUniqueInput>
        update?: Enumerable<OrphansUpdateWithWhereUniqueWithoutFamiliesInput>
        updateMany?: Enumerable<OrphansUpdateManyWithWhereWithoutFamiliesInput>
        deleteMany?: Enumerable<OrphansScalarWhereInput>
    }

    export type Second_sponsorsUncheckedUpdateManyWithoutFamiliesNestedInput = {
        create?: XOR<
            Enumerable<Second_sponsorsCreateWithoutFamiliesInput>,
            Enumerable<Second_sponsorsUncheckedCreateWithoutFamiliesInput>
        >
        connectOrCreate?: Enumerable<Second_sponsorsCreateOrConnectWithoutFamiliesInput>
        upsert?: Enumerable<Second_sponsorsUpsertWithWhereUniqueWithoutFamiliesInput>
        createMany?: Second_sponsorsCreateManyFamiliesInputEnvelope
        set?: Enumerable<Second_sponsorsWhereUniqueInput>
        disconnect?: Enumerable<Second_sponsorsWhereUniqueInput>
        delete?: Enumerable<Second_sponsorsWhereUniqueInput>
        connect?: Enumerable<Second_sponsorsWhereUniqueInput>
        update?: Enumerable<Second_sponsorsUpdateWithWhereUniqueWithoutFamiliesInput>
        updateMany?: Enumerable<Second_sponsorsUpdateManyWithWhereWithoutFamiliesInput>
        deleteMany?: Enumerable<Second_sponsorsScalarWhereInput>
    }

    export type SpousesUncheckedUpdateManyWithoutFamiliesNestedInput = {
        create?: XOR<
            Enumerable<SpousesCreateWithoutFamiliesInput>,
            Enumerable<SpousesUncheckedCreateWithoutFamiliesInput>
        >
        connectOrCreate?: Enumerable<SpousesCreateOrConnectWithoutFamiliesInput>
        upsert?: Enumerable<SpousesUpsertWithWhereUniqueWithoutFamiliesInput>
        createMany?: SpousesCreateManyFamiliesInputEnvelope
        set?: Enumerable<SpousesWhereUniqueInput>
        disconnect?: Enumerable<SpousesWhereUniqueInput>
        delete?: Enumerable<SpousesWhereUniqueInput>
        connect?: Enumerable<SpousesWhereUniqueInput>
        update?: Enumerable<SpousesUpdateWithWhereUniqueWithoutFamiliesInput>
        updateMany?: Enumerable<SpousesUpdateManyWithWhereWithoutFamiliesInput>
        deleteMany?: Enumerable<SpousesScalarWhereInput>
    }

    export type FamiliesCreateNestedOneWithoutFamily_furnishingInput = {
        create?: XOR<FamiliesCreateWithoutFamily_furnishingInput, FamiliesUncheckedCreateWithoutFamily_furnishingInput>
        connectOrCreate?: FamiliesCreateOrConnectWithoutFamily_furnishingInput
        connect?: FamiliesWhereUniqueInput
    }

    export type FurnishingsCreateNestedOneWithoutFamily_furnishingInput = {
        create?: XOR<
            FurnishingsCreateWithoutFamily_furnishingInput,
            FurnishingsUncheckedCreateWithoutFamily_furnishingInput
        >
        connectOrCreate?: FurnishingsCreateOrConnectWithoutFamily_furnishingInput
        connect?: FurnishingsWhereUniqueInput
    }

    export type FamiliesUpdateOneRequiredWithoutFamily_furnishingNestedInput = {
        create?: XOR<FamiliesCreateWithoutFamily_furnishingInput, FamiliesUncheckedCreateWithoutFamily_furnishingInput>
        connectOrCreate?: FamiliesCreateOrConnectWithoutFamily_furnishingInput
        upsert?: FamiliesUpsertWithoutFamily_furnishingInput
        connect?: FamiliesWhereUniqueInput
        update?: XOR<FamiliesUpdateWithoutFamily_furnishingInput, FamiliesUncheckedUpdateWithoutFamily_furnishingInput>
    }

    export type FurnishingsUpdateOneRequiredWithoutFamily_furnishingNestedInput = {
        create?: XOR<
            FurnishingsCreateWithoutFamily_furnishingInput,
            FurnishingsUncheckedCreateWithoutFamily_furnishingInput
        >
        connectOrCreate?: FurnishingsCreateOrConnectWithoutFamily_furnishingInput
        upsert?: FurnishingsUpsertWithoutFamily_furnishingInput
        connect?: FurnishingsWhereUniqueInput
        update?: XOR<
            FurnishingsUpdateWithoutFamily_furnishingInput,
            FurnishingsUncheckedUpdateWithoutFamily_furnishingInput
        >
    }

    export type FamiliesCreateNestedOneWithoutFamily_housingInput = {
        create?: XOR<FamiliesCreateWithoutFamily_housingInput, FamiliesUncheckedCreateWithoutFamily_housingInput>
        connectOrCreate?: FamiliesCreateOrConnectWithoutFamily_housingInput
        connect?: FamiliesWhereUniqueInput
    }

    export type HousingsCreateNestedOneWithoutFamily_housingInput = {
        create?: XOR<HousingsCreateWithoutFamily_housingInput, HousingsUncheckedCreateWithoutFamily_housingInput>
        connectOrCreate?: HousingsCreateOrConnectWithoutFamily_housingInput
        connect?: HousingsWhereUniqueInput
    }

    export type FamiliesUpdateOneRequiredWithoutFamily_housingNestedInput = {
        create?: XOR<FamiliesCreateWithoutFamily_housingInput, FamiliesUncheckedCreateWithoutFamily_housingInput>
        connectOrCreate?: FamiliesCreateOrConnectWithoutFamily_housingInput
        upsert?: FamiliesUpsertWithoutFamily_housingInput
        connect?: FamiliesWhereUniqueInput
        update?: XOR<FamiliesUpdateWithoutFamily_housingInput, FamiliesUncheckedUpdateWithoutFamily_housingInput>
    }

    export type HousingsUpdateOneRequiredWithoutFamily_housingNestedInput = {
        create?: XOR<HousingsCreateWithoutFamily_housingInput, HousingsUncheckedCreateWithoutFamily_housingInput>
        connectOrCreate?: HousingsCreateOrConnectWithoutFamily_housingInput
        upsert?: HousingsUpsertWithoutFamily_housingInput
        connect?: HousingsWhereUniqueInput
        update?: XOR<HousingsUpdateWithoutFamily_housingInput, HousingsUncheckedUpdateWithoutFamily_housingInput>
    }

    export type FamiliesCreateNestedOneWithoutFamily_sponsorshipInput = {
        create?: XOR<
            FamiliesCreateWithoutFamily_sponsorshipInput,
            FamiliesUncheckedCreateWithoutFamily_sponsorshipInput
        >
        connectOrCreate?: FamiliesCreateOrConnectWithoutFamily_sponsorshipInput
        connect?: FamiliesWhereUniqueInput
    }

    export type TenantsCreateNestedOneWithoutFamily_sponsorshipInput = {
        create?: XOR<TenantsCreateWithoutFamily_sponsorshipInput, TenantsUncheckedCreateWithoutFamily_sponsorshipInput>
        connectOrCreate?: TenantsCreateOrConnectWithoutFamily_sponsorshipInput
        connect?: TenantsWhereUniqueInput
    }

    export type Enumfamily_sponsorship_typeFieldUpdateOperationsInput = {
        set?: family_sponsorship_type
    }

    export type FamiliesUpdateOneRequiredWithoutFamily_sponsorshipNestedInput = {
        create?: XOR<
            FamiliesCreateWithoutFamily_sponsorshipInput,
            FamiliesUncheckedCreateWithoutFamily_sponsorshipInput
        >
        connectOrCreate?: FamiliesCreateOrConnectWithoutFamily_sponsorshipInput
        upsert?: FamiliesUpsertWithoutFamily_sponsorshipInput
        connect?: FamiliesWhereUniqueInput
        update?: XOR<
            FamiliesUpdateWithoutFamily_sponsorshipInput,
            FamiliesUncheckedUpdateWithoutFamily_sponsorshipInput
        >
    }

    export type TenantsUpdateOneRequiredWithoutFamily_sponsorshipNestedInput = {
        create?: XOR<TenantsCreateWithoutFamily_sponsorshipInput, TenantsUncheckedCreateWithoutFamily_sponsorshipInput>
        connectOrCreate?: TenantsCreateOrConnectWithoutFamily_sponsorshipInput
        upsert?: TenantsUpsertWithoutFamily_sponsorshipInput
        connect?: TenantsWhereUniqueInput
        update?: XOR<TenantsUpdateWithoutFamily_sponsorshipInput, TenantsUncheckedUpdateWithoutFamily_sponsorshipInput>
    }

    export type Family_furnishingCreateNestedManyWithoutFurnishingsInput = {
        create?: XOR<
            Enumerable<Family_furnishingCreateWithoutFurnishingsInput>,
            Enumerable<Family_furnishingUncheckedCreateWithoutFurnishingsInput>
        >
        connectOrCreate?: Enumerable<Family_furnishingCreateOrConnectWithoutFurnishingsInput>
        createMany?: Family_furnishingCreateManyFurnishingsInputEnvelope
        connect?: Enumerable<Family_furnishingWhereUniqueInput>
    }

    export type Family_furnishingUncheckedCreateNestedManyWithoutFurnishingsInput = {
        create?: XOR<
            Enumerable<Family_furnishingCreateWithoutFurnishingsInput>,
            Enumerable<Family_furnishingUncheckedCreateWithoutFurnishingsInput>
        >
        connectOrCreate?: Enumerable<Family_furnishingCreateOrConnectWithoutFurnishingsInput>
        createMany?: Family_furnishingCreateManyFurnishingsInputEnvelope
        connect?: Enumerable<Family_furnishingWhereUniqueInput>
    }

    export type Family_furnishingUpdateManyWithoutFurnishingsNestedInput = {
        create?: XOR<
            Enumerable<Family_furnishingCreateWithoutFurnishingsInput>,
            Enumerable<Family_furnishingUncheckedCreateWithoutFurnishingsInput>
        >
        connectOrCreate?: Enumerable<Family_furnishingCreateOrConnectWithoutFurnishingsInput>
        upsert?: Enumerable<Family_furnishingUpsertWithWhereUniqueWithoutFurnishingsInput>
        createMany?: Family_furnishingCreateManyFurnishingsInputEnvelope
        set?: Enumerable<Family_furnishingWhereUniqueInput>
        disconnect?: Enumerable<Family_furnishingWhereUniqueInput>
        delete?: Enumerable<Family_furnishingWhereUniqueInput>
        connect?: Enumerable<Family_furnishingWhereUniqueInput>
        update?: Enumerable<Family_furnishingUpdateWithWhereUniqueWithoutFurnishingsInput>
        updateMany?: Enumerable<Family_furnishingUpdateManyWithWhereWithoutFurnishingsInput>
        deleteMany?: Enumerable<Family_furnishingScalarWhereInput>
    }

    export type Family_furnishingUncheckedUpdateManyWithoutFurnishingsNestedInput = {
        create?: XOR<
            Enumerable<Family_furnishingCreateWithoutFurnishingsInput>,
            Enumerable<Family_furnishingUncheckedCreateWithoutFurnishingsInput>
        >
        connectOrCreate?: Enumerable<Family_furnishingCreateOrConnectWithoutFurnishingsInput>
        upsert?: Enumerable<Family_furnishingUpsertWithWhereUniqueWithoutFurnishingsInput>
        createMany?: Family_furnishingCreateManyFurnishingsInputEnvelope
        set?: Enumerable<Family_furnishingWhereUniqueInput>
        disconnect?: Enumerable<Family_furnishingWhereUniqueInput>
        delete?: Enumerable<Family_furnishingWhereUniqueInput>
        connect?: Enumerable<Family_furnishingWhereUniqueInput>
        update?: Enumerable<Family_furnishingUpdateWithWhereUniqueWithoutFurnishingsInput>
        updateMany?: Enumerable<Family_furnishingUpdateManyWithWhereWithoutFurnishingsInput>
        deleteMany?: Enumerable<Family_furnishingScalarWhereInput>
    }

    export type Family_housingCreateNestedManyWithoutHousingsInput = {
        create?: XOR<
            Enumerable<Family_housingCreateWithoutHousingsInput>,
            Enumerable<Family_housingUncheckedCreateWithoutHousingsInput>
        >
        connectOrCreate?: Enumerable<Family_housingCreateOrConnectWithoutHousingsInput>
        createMany?: Family_housingCreateManyHousingsInputEnvelope
        connect?: Enumerable<Family_housingWhereUniqueInput>
    }

    export type Family_housingUncheckedCreateNestedManyWithoutHousingsInput = {
        create?: XOR<
            Enumerable<Family_housingCreateWithoutHousingsInput>,
            Enumerable<Family_housingUncheckedCreateWithoutHousingsInput>
        >
        connectOrCreate?: Enumerable<Family_housingCreateOrConnectWithoutHousingsInput>
        createMany?: Family_housingCreateManyHousingsInputEnvelope
        connect?: Enumerable<Family_housingWhereUniqueInput>
    }

    export type Family_housingUpdateManyWithoutHousingsNestedInput = {
        create?: XOR<
            Enumerable<Family_housingCreateWithoutHousingsInput>,
            Enumerable<Family_housingUncheckedCreateWithoutHousingsInput>
        >
        connectOrCreate?: Enumerable<Family_housingCreateOrConnectWithoutHousingsInput>
        upsert?: Enumerable<Family_housingUpsertWithWhereUniqueWithoutHousingsInput>
        createMany?: Family_housingCreateManyHousingsInputEnvelope
        set?: Enumerable<Family_housingWhereUniqueInput>
        disconnect?: Enumerable<Family_housingWhereUniqueInput>
        delete?: Enumerable<Family_housingWhereUniqueInput>
        connect?: Enumerable<Family_housingWhereUniqueInput>
        update?: Enumerable<Family_housingUpdateWithWhereUniqueWithoutHousingsInput>
        updateMany?: Enumerable<Family_housingUpdateManyWithWhereWithoutHousingsInput>
        deleteMany?: Enumerable<Family_housingScalarWhereInput>
    }

    export type Family_housingUncheckedUpdateManyWithoutHousingsNestedInput = {
        create?: XOR<
            Enumerable<Family_housingCreateWithoutHousingsInput>,
            Enumerable<Family_housingUncheckedCreateWithoutHousingsInput>
        >
        connectOrCreate?: Enumerable<Family_housingCreateOrConnectWithoutHousingsInput>
        upsert?: Enumerable<Family_housingUpsertWithWhereUniqueWithoutHousingsInput>
        createMany?: Family_housingCreateManyHousingsInputEnvelope
        set?: Enumerable<Family_housingWhereUniqueInput>
        disconnect?: Enumerable<Family_housingWhereUniqueInput>
        delete?: Enumerable<Family_housingWhereUniqueInput>
        connect?: Enumerable<Family_housingWhereUniqueInput>
        update?: Enumerable<Family_housingUpdateWithWhereUniqueWithoutHousingsInput>
        updateMany?: Enumerable<Family_housingUpdateManyWithWhereWithoutHousingsInput>
        deleteMany?: Enumerable<Family_housingScalarWhereInput>
    }

    export type IncomesCreateNestedOneWithoutIncome_sponsorInput = {
        create?: XOR<IncomesCreateWithoutIncome_sponsorInput, IncomesUncheckedCreateWithoutIncome_sponsorInput>
        connectOrCreate?: IncomesCreateOrConnectWithoutIncome_sponsorInput
        connect?: IncomesWhereUniqueInput
    }

    export type SponsorsCreateNestedOneWithoutIncome_sponsorInput = {
        create?: XOR<SponsorsCreateWithoutIncome_sponsorInput, SponsorsUncheckedCreateWithoutIncome_sponsorInput>
        connectOrCreate?: SponsorsCreateOrConnectWithoutIncome_sponsorInput
        connect?: SponsorsWhereUniqueInput
    }

    export type TenantsCreateNestedOneWithoutIncome_sponsorInput = {
        create?: XOR<TenantsCreateWithoutIncome_sponsorInput, TenantsUncheckedCreateWithoutIncome_sponsorInput>
        connectOrCreate?: TenantsCreateOrConnectWithoutIncome_sponsorInput
        connect?: TenantsWhereUniqueInput
    }

    export type FloatFieldUpdateOperationsInput = {
        set?: number
        increment?: number
        decrement?: number
        multiply?: number
        divide?: number
    }

    export type IncomesUpdateOneRequiredWithoutIncome_sponsorNestedInput = {
        create?: XOR<IncomesCreateWithoutIncome_sponsorInput, IncomesUncheckedCreateWithoutIncome_sponsorInput>
        connectOrCreate?: IncomesCreateOrConnectWithoutIncome_sponsorInput
        upsert?: IncomesUpsertWithoutIncome_sponsorInput
        connect?: IncomesWhereUniqueInput
        update?: XOR<IncomesUpdateWithoutIncome_sponsorInput, IncomesUncheckedUpdateWithoutIncome_sponsorInput>
    }

    export type SponsorsUpdateOneRequiredWithoutIncome_sponsorNestedInput = {
        create?: XOR<SponsorsCreateWithoutIncome_sponsorInput, SponsorsUncheckedCreateWithoutIncome_sponsorInput>
        connectOrCreate?: SponsorsCreateOrConnectWithoutIncome_sponsorInput
        upsert?: SponsorsUpsertWithoutIncome_sponsorInput
        connect?: SponsorsWhereUniqueInput
        update?: XOR<SponsorsUpdateWithoutIncome_sponsorInput, SponsorsUncheckedUpdateWithoutIncome_sponsorInput>
    }

    export type TenantsUpdateOneRequiredWithoutIncome_sponsorNestedInput = {
        create?: XOR<TenantsCreateWithoutIncome_sponsorInput, TenantsUncheckedCreateWithoutIncome_sponsorInput>
        connectOrCreate?: TenantsCreateOrConnectWithoutIncome_sponsorInput
        upsert?: TenantsUpsertWithoutIncome_sponsorInput
        connect?: TenantsWhereUniqueInput
        update?: XOR<TenantsUpdateWithoutIncome_sponsorInput, TenantsUncheckedUpdateWithoutIncome_sponsorInput>
    }

    export type Income_sponsorCreateNestedManyWithoutIncomesInput = {
        create?: XOR<
            Enumerable<Income_sponsorCreateWithoutIncomesInput>,
            Enumerable<Income_sponsorUncheckedCreateWithoutIncomesInput>
        >
        connectOrCreate?: Enumerable<Income_sponsorCreateOrConnectWithoutIncomesInput>
        createMany?: Income_sponsorCreateManyIncomesInputEnvelope
        connect?: Enumerable<Income_sponsorWhereUniqueInput>
    }

    export type Income_sponsorUncheckedCreateNestedManyWithoutIncomesInput = {
        create?: XOR<
            Enumerable<Income_sponsorCreateWithoutIncomesInput>,
            Enumerable<Income_sponsorUncheckedCreateWithoutIncomesInput>
        >
        connectOrCreate?: Enumerable<Income_sponsorCreateOrConnectWithoutIncomesInput>
        createMany?: Income_sponsorCreateManyIncomesInputEnvelope
        connect?: Enumerable<Income_sponsorWhereUniqueInput>
    }

    export type Income_sponsorUpdateManyWithoutIncomesNestedInput = {
        create?: XOR<
            Enumerable<Income_sponsorCreateWithoutIncomesInput>,
            Enumerable<Income_sponsorUncheckedCreateWithoutIncomesInput>
        >
        connectOrCreate?: Enumerable<Income_sponsorCreateOrConnectWithoutIncomesInput>
        upsert?: Enumerable<Income_sponsorUpsertWithWhereUniqueWithoutIncomesInput>
        createMany?: Income_sponsorCreateManyIncomesInputEnvelope
        set?: Enumerable<Income_sponsorWhereUniqueInput>
        disconnect?: Enumerable<Income_sponsorWhereUniqueInput>
        delete?: Enumerable<Income_sponsorWhereUniqueInput>
        connect?: Enumerable<Income_sponsorWhereUniqueInput>
        update?: Enumerable<Income_sponsorUpdateWithWhereUniqueWithoutIncomesInput>
        updateMany?: Enumerable<Income_sponsorUpdateManyWithWhereWithoutIncomesInput>
        deleteMany?: Enumerable<Income_sponsorScalarWhereInput>
    }

    export type Income_sponsorUncheckedUpdateManyWithoutIncomesNestedInput = {
        create?: XOR<
            Enumerable<Income_sponsorCreateWithoutIncomesInput>,
            Enumerable<Income_sponsorUncheckedCreateWithoutIncomesInput>
        >
        connectOrCreate?: Enumerable<Income_sponsorCreateOrConnectWithoutIncomesInput>
        upsert?: Enumerable<Income_sponsorUpsertWithWhereUniqueWithoutIncomesInput>
        createMany?: Income_sponsorCreateManyIncomesInputEnvelope
        set?: Enumerable<Income_sponsorWhereUniqueInput>
        disconnect?: Enumerable<Income_sponsorWhereUniqueInput>
        delete?: Enumerable<Income_sponsorWhereUniqueInput>
        connect?: Enumerable<Income_sponsorWhereUniqueInput>
        update?: Enumerable<Income_sponsorUpdateWithWhereUniqueWithoutIncomesInput>
        updateMany?: Enumerable<Income_sponsorUpdateManyWithWhereWithoutIncomesInput>
        deleteMany?: Enumerable<Income_sponsorScalarWhereInput>
    }

    export type BigIntFieldUpdateOperationsInput = {
        set?: bigint | number
        increment?: bigint | number
        decrement?: bigint | number
        multiply?: bigint | number
        divide?: bigint | number
    }

    export type NullableStringFieldUpdateOperationsInput = {
        set?: string | null
    }

    export type NullableIntFieldUpdateOperationsInput = {
        set?: number | null
        increment?: number
        decrement?: number
        multiply?: number
        divide?: number
    }

    export type PermissionsCreateNestedOneWithoutModel_has_permissionsInput = {
        create?: XOR<
            PermissionsCreateWithoutModel_has_permissionsInput,
            PermissionsUncheckedCreateWithoutModel_has_permissionsInput
        >
        connectOrCreate?: PermissionsCreateOrConnectWithoutModel_has_permissionsInput
        connect?: PermissionsWhereUniqueInput
    }

    export type PermissionsUpdateOneRequiredWithoutModel_has_permissionsNestedInput = {
        create?: XOR<
            PermissionsCreateWithoutModel_has_permissionsInput,
            PermissionsUncheckedCreateWithoutModel_has_permissionsInput
        >
        connectOrCreate?: PermissionsCreateOrConnectWithoutModel_has_permissionsInput
        upsert?: PermissionsUpsertWithoutModel_has_permissionsInput
        connect?: PermissionsWhereUniqueInput
        update?: XOR<
            PermissionsUpdateWithoutModel_has_permissionsInput,
            PermissionsUncheckedUpdateWithoutModel_has_permissionsInput
        >
    }

    export type RolesCreateNestedOneWithoutModel_has_rolesInput = {
        create?: XOR<RolesCreateWithoutModel_has_rolesInput, RolesUncheckedCreateWithoutModel_has_rolesInput>
        connectOrCreate?: RolesCreateOrConnectWithoutModel_has_rolesInput
        connect?: RolesWhereUniqueInput
    }

    export type RolesUpdateOneRequiredWithoutModel_has_rolesNestedInput = {
        create?: XOR<RolesCreateWithoutModel_has_rolesInput, RolesUncheckedCreateWithoutModel_has_rolesInput>
        connectOrCreate?: RolesCreateOrConnectWithoutModel_has_rolesInput
        upsert?: RolesUpsertWithoutModel_has_rolesInput
        connect?: RolesWhereUniqueInput
        update?: XOR<RolesUpdateWithoutModel_has_rolesInput, RolesUncheckedUpdateWithoutModel_has_rolesInput>
    }

    export type OrphansCreateNestedOneWithoutOrphan_sponsorshipInput = {
        create?: XOR<OrphansCreateWithoutOrphan_sponsorshipInput, OrphansUncheckedCreateWithoutOrphan_sponsorshipInput>
        connectOrCreate?: OrphansCreateOrConnectWithoutOrphan_sponsorshipInput
        connect?: OrphansWhereUniqueInput
    }

    export type TenantsCreateNestedOneWithoutOrphan_sponsorshipInput = {
        create?: XOR<TenantsCreateWithoutOrphan_sponsorshipInput, TenantsUncheckedCreateWithoutOrphan_sponsorshipInput>
        connectOrCreate?: TenantsCreateOrConnectWithoutOrphan_sponsorshipInput
        connect?: TenantsWhereUniqueInput
    }

    export type Enumorphan_sponsorship_typeFieldUpdateOperationsInput = {
        set?: orphan_sponsorship_type
    }

    export type OrphansUpdateOneRequiredWithoutOrphan_sponsorshipNestedInput = {
        create?: XOR<OrphansCreateWithoutOrphan_sponsorshipInput, OrphansUncheckedCreateWithoutOrphan_sponsorshipInput>
        connectOrCreate?: OrphansCreateOrConnectWithoutOrphan_sponsorshipInput
        upsert?: OrphansUpsertWithoutOrphan_sponsorshipInput
        connect?: OrphansWhereUniqueInput
        update?: XOR<OrphansUpdateWithoutOrphan_sponsorshipInput, OrphansUncheckedUpdateWithoutOrphan_sponsorshipInput>
    }

    export type TenantsUpdateOneRequiredWithoutOrphan_sponsorshipNestedInput = {
        create?: XOR<TenantsCreateWithoutOrphan_sponsorshipInput, TenantsUncheckedCreateWithoutOrphan_sponsorshipInput>
        connectOrCreate?: TenantsCreateOrConnectWithoutOrphan_sponsorshipInput
        upsert?: TenantsUpsertWithoutOrphan_sponsorshipInput
        connect?: TenantsWhereUniqueInput
        update?: XOR<TenantsUpdateWithoutOrphan_sponsorshipInput, TenantsUncheckedUpdateWithoutOrphan_sponsorshipInput>
    }

    export type Orphan_sponsorshipCreateNestedManyWithoutOrphansInput = {
        create?: XOR<
            Enumerable<Orphan_sponsorshipCreateWithoutOrphansInput>,
            Enumerable<Orphan_sponsorshipUncheckedCreateWithoutOrphansInput>
        >
        connectOrCreate?: Enumerable<Orphan_sponsorshipCreateOrConnectWithoutOrphansInput>
        createMany?: Orphan_sponsorshipCreateManyOrphansInputEnvelope
        connect?: Enumerable<Orphan_sponsorshipWhereUniqueInput>
    }

    export type UsersCreateNestedOneWithoutOrphans_orphans_created_byTousersInput = {
        create?: XOR<
            UsersCreateWithoutOrphans_orphans_created_byTousersInput,
            UsersUncheckedCreateWithoutOrphans_orphans_created_byTousersInput
        >
        connectOrCreate?: UsersCreateOrConnectWithoutOrphans_orphans_created_byTousersInput
        connect?: UsersWhereUniqueInput
    }

    export type UsersCreateNestedOneWithoutOrphans_orphans_deleted_byTousersInput = {
        create?: XOR<
            UsersCreateWithoutOrphans_orphans_deleted_byTousersInput,
            UsersUncheckedCreateWithoutOrphans_orphans_deleted_byTousersInput
        >
        connectOrCreate?: UsersCreateOrConnectWithoutOrphans_orphans_deleted_byTousersInput
        connect?: UsersWhereUniqueInput
    }

    export type FamiliesCreateNestedOneWithoutOrphansInput = {
        create?: XOR<FamiliesCreateWithoutOrphansInput, FamiliesUncheckedCreateWithoutOrphansInput>
        connectOrCreate?: FamiliesCreateOrConnectWithoutOrphansInput
        connect?: FamiliesWhereUniqueInput
    }

    export type TenantsCreateNestedOneWithoutOrphansInput = {
        create?: XOR<TenantsCreateWithoutOrphansInput, TenantsUncheckedCreateWithoutOrphansInput>
        connectOrCreate?: TenantsCreateOrConnectWithoutOrphansInput
        connect?: TenantsWhereUniqueInput
    }

    export type Orphan_sponsorshipUncheckedCreateNestedManyWithoutOrphansInput = {
        create?: XOR<
            Enumerable<Orphan_sponsorshipCreateWithoutOrphansInput>,
            Enumerable<Orphan_sponsorshipUncheckedCreateWithoutOrphansInput>
        >
        connectOrCreate?: Enumerable<Orphan_sponsorshipCreateOrConnectWithoutOrphansInput>
        createMany?: Orphan_sponsorshipCreateManyOrphansInputEnvelope
        connect?: Enumerable<Orphan_sponsorshipWhereUniqueInput>
    }

    export type DateTimeFieldUpdateOperationsInput = {
        set?: Date | string
    }

    export type Orphan_sponsorshipUpdateManyWithoutOrphansNestedInput = {
        create?: XOR<
            Enumerable<Orphan_sponsorshipCreateWithoutOrphansInput>,
            Enumerable<Orphan_sponsorshipUncheckedCreateWithoutOrphansInput>
        >
        connectOrCreate?: Enumerable<Orphan_sponsorshipCreateOrConnectWithoutOrphansInput>
        upsert?: Enumerable<Orphan_sponsorshipUpsertWithWhereUniqueWithoutOrphansInput>
        createMany?: Orphan_sponsorshipCreateManyOrphansInputEnvelope
        set?: Enumerable<Orphan_sponsorshipWhereUniqueInput>
        disconnect?: Enumerable<Orphan_sponsorshipWhereUniqueInput>
        delete?: Enumerable<Orphan_sponsorshipWhereUniqueInput>
        connect?: Enumerable<Orphan_sponsorshipWhereUniqueInput>
        update?: Enumerable<Orphan_sponsorshipUpdateWithWhereUniqueWithoutOrphansInput>
        updateMany?: Enumerable<Orphan_sponsorshipUpdateManyWithWhereWithoutOrphansInput>
        deleteMany?: Enumerable<Orphan_sponsorshipScalarWhereInput>
    }

    export type UsersUpdateOneRequiredWithoutOrphans_orphans_created_byTousersNestedInput = {
        create?: XOR<
            UsersCreateWithoutOrphans_orphans_created_byTousersInput,
            UsersUncheckedCreateWithoutOrphans_orphans_created_byTousersInput
        >
        connectOrCreate?: UsersCreateOrConnectWithoutOrphans_orphans_created_byTousersInput
        upsert?: UsersUpsertWithoutOrphans_orphans_created_byTousersInput
        connect?: UsersWhereUniqueInput
        update?: XOR<
            UsersUpdateWithoutOrphans_orphans_created_byTousersInput,
            UsersUncheckedUpdateWithoutOrphans_orphans_created_byTousersInput
        >
    }

    export type UsersUpdateOneWithoutOrphans_orphans_deleted_byTousersNestedInput = {
        create?: XOR<
            UsersCreateWithoutOrphans_orphans_deleted_byTousersInput,
            UsersUncheckedCreateWithoutOrphans_orphans_deleted_byTousersInput
        >
        connectOrCreate?: UsersCreateOrConnectWithoutOrphans_orphans_deleted_byTousersInput
        upsert?: UsersUpsertWithoutOrphans_orphans_deleted_byTousersInput
        disconnect?: boolean
        delete?: boolean
        connect?: UsersWhereUniqueInput
        update?: XOR<
            UsersUpdateWithoutOrphans_orphans_deleted_byTousersInput,
            UsersUncheckedUpdateWithoutOrphans_orphans_deleted_byTousersInput
        >
    }

    export type FamiliesUpdateOneRequiredWithoutOrphansNestedInput = {
        create?: XOR<FamiliesCreateWithoutOrphansInput, FamiliesUncheckedCreateWithoutOrphansInput>
        connectOrCreate?: FamiliesCreateOrConnectWithoutOrphansInput
        upsert?: FamiliesUpsertWithoutOrphansInput
        connect?: FamiliesWhereUniqueInput
        update?: XOR<FamiliesUpdateWithoutOrphansInput, FamiliesUncheckedUpdateWithoutOrphansInput>
    }

    export type TenantsUpdateOneRequiredWithoutOrphansNestedInput = {
        create?: XOR<TenantsCreateWithoutOrphansInput, TenantsUncheckedCreateWithoutOrphansInput>
        connectOrCreate?: TenantsCreateOrConnectWithoutOrphansInput
        upsert?: TenantsUpsertWithoutOrphansInput
        connect?: TenantsWhereUniqueInput
        update?: XOR<TenantsUpdateWithoutOrphansInput, TenantsUncheckedUpdateWithoutOrphansInput>
    }

    export type Orphan_sponsorshipUncheckedUpdateManyWithoutOrphansNestedInput = {
        create?: XOR<
            Enumerable<Orphan_sponsorshipCreateWithoutOrphansInput>,
            Enumerable<Orphan_sponsorshipUncheckedCreateWithoutOrphansInput>
        >
        connectOrCreate?: Enumerable<Orphan_sponsorshipCreateOrConnectWithoutOrphansInput>
        upsert?: Enumerable<Orphan_sponsorshipUpsertWithWhereUniqueWithoutOrphansInput>
        createMany?: Orphan_sponsorshipCreateManyOrphansInputEnvelope
        set?: Enumerable<Orphan_sponsorshipWhereUniqueInput>
        disconnect?: Enumerable<Orphan_sponsorshipWhereUniqueInput>
        delete?: Enumerable<Orphan_sponsorshipWhereUniqueInput>
        connect?: Enumerable<Orphan_sponsorshipWhereUniqueInput>
        update?: Enumerable<Orphan_sponsorshipUpdateWithWhereUniqueWithoutOrphansInput>
        updateMany?: Enumerable<Orphan_sponsorshipUpdateManyWithWhereWithoutOrphansInput>
        deleteMany?: Enumerable<Orphan_sponsorshipScalarWhereInput>
    }

    export type Model_has_permissionsCreateNestedManyWithoutPermissionsInput = {
        create?: XOR<
            Enumerable<Model_has_permissionsCreateWithoutPermissionsInput>,
            Enumerable<Model_has_permissionsUncheckedCreateWithoutPermissionsInput>
        >
        connectOrCreate?: Enumerable<Model_has_permissionsCreateOrConnectWithoutPermissionsInput>
        createMany?: Model_has_permissionsCreateManyPermissionsInputEnvelope
        connect?: Enumerable<Model_has_permissionsWhereUniqueInput>
    }

    export type Role_has_permissionsCreateNestedManyWithoutPermissionsInput = {
        create?: XOR<
            Enumerable<Role_has_permissionsCreateWithoutPermissionsInput>,
            Enumerable<Role_has_permissionsUncheckedCreateWithoutPermissionsInput>
        >
        connectOrCreate?: Enumerable<Role_has_permissionsCreateOrConnectWithoutPermissionsInput>
        createMany?: Role_has_permissionsCreateManyPermissionsInputEnvelope
        connect?: Enumerable<Role_has_permissionsWhereUniqueInput>
    }

    export type Model_has_permissionsUncheckedCreateNestedManyWithoutPermissionsInput = {
        create?: XOR<
            Enumerable<Model_has_permissionsCreateWithoutPermissionsInput>,
            Enumerable<Model_has_permissionsUncheckedCreateWithoutPermissionsInput>
        >
        connectOrCreate?: Enumerable<Model_has_permissionsCreateOrConnectWithoutPermissionsInput>
        createMany?: Model_has_permissionsCreateManyPermissionsInputEnvelope
        connect?: Enumerable<Model_has_permissionsWhereUniqueInput>
    }

    export type Role_has_permissionsUncheckedCreateNestedManyWithoutPermissionsInput = {
        create?: XOR<
            Enumerable<Role_has_permissionsCreateWithoutPermissionsInput>,
            Enumerable<Role_has_permissionsUncheckedCreateWithoutPermissionsInput>
        >
        connectOrCreate?: Enumerable<Role_has_permissionsCreateOrConnectWithoutPermissionsInput>
        createMany?: Role_has_permissionsCreateManyPermissionsInputEnvelope
        connect?: Enumerable<Role_has_permissionsWhereUniqueInput>
    }

    export type Model_has_permissionsUpdateManyWithoutPermissionsNestedInput = {
        create?: XOR<
            Enumerable<Model_has_permissionsCreateWithoutPermissionsInput>,
            Enumerable<Model_has_permissionsUncheckedCreateWithoutPermissionsInput>
        >
        connectOrCreate?: Enumerable<Model_has_permissionsCreateOrConnectWithoutPermissionsInput>
        upsert?: Enumerable<Model_has_permissionsUpsertWithWhereUniqueWithoutPermissionsInput>
        createMany?: Model_has_permissionsCreateManyPermissionsInputEnvelope
        set?: Enumerable<Model_has_permissionsWhereUniqueInput>
        disconnect?: Enumerable<Model_has_permissionsWhereUniqueInput>
        delete?: Enumerable<Model_has_permissionsWhereUniqueInput>
        connect?: Enumerable<Model_has_permissionsWhereUniqueInput>
        update?: Enumerable<Model_has_permissionsUpdateWithWhereUniqueWithoutPermissionsInput>
        updateMany?: Enumerable<Model_has_permissionsUpdateManyWithWhereWithoutPermissionsInput>
        deleteMany?: Enumerable<Model_has_permissionsScalarWhereInput>
    }

    export type Role_has_permissionsUpdateManyWithoutPermissionsNestedInput = {
        create?: XOR<
            Enumerable<Role_has_permissionsCreateWithoutPermissionsInput>,
            Enumerable<Role_has_permissionsUncheckedCreateWithoutPermissionsInput>
        >
        connectOrCreate?: Enumerable<Role_has_permissionsCreateOrConnectWithoutPermissionsInput>
        upsert?: Enumerable<Role_has_permissionsUpsertWithWhereUniqueWithoutPermissionsInput>
        createMany?: Role_has_permissionsCreateManyPermissionsInputEnvelope
        set?: Enumerable<Role_has_permissionsWhereUniqueInput>
        disconnect?: Enumerable<Role_has_permissionsWhereUniqueInput>
        delete?: Enumerable<Role_has_permissionsWhereUniqueInput>
        connect?: Enumerable<Role_has_permissionsWhereUniqueInput>
        update?: Enumerable<Role_has_permissionsUpdateWithWhereUniqueWithoutPermissionsInput>
        updateMany?: Enumerable<Role_has_permissionsUpdateManyWithWhereWithoutPermissionsInput>
        deleteMany?: Enumerable<Role_has_permissionsScalarWhereInput>
    }

    export type Model_has_permissionsUncheckedUpdateManyWithoutPermissionsNestedInput = {
        create?: XOR<
            Enumerable<Model_has_permissionsCreateWithoutPermissionsInput>,
            Enumerable<Model_has_permissionsUncheckedCreateWithoutPermissionsInput>
        >
        connectOrCreate?: Enumerable<Model_has_permissionsCreateOrConnectWithoutPermissionsInput>
        upsert?: Enumerable<Model_has_permissionsUpsertWithWhereUniqueWithoutPermissionsInput>
        createMany?: Model_has_permissionsCreateManyPermissionsInputEnvelope
        set?: Enumerable<Model_has_permissionsWhereUniqueInput>
        disconnect?: Enumerable<Model_has_permissionsWhereUniqueInput>
        delete?: Enumerable<Model_has_permissionsWhereUniqueInput>
        connect?: Enumerable<Model_has_permissionsWhereUniqueInput>
        update?: Enumerable<Model_has_permissionsUpdateWithWhereUniqueWithoutPermissionsInput>
        updateMany?: Enumerable<Model_has_permissionsUpdateManyWithWhereWithoutPermissionsInput>
        deleteMany?: Enumerable<Model_has_permissionsScalarWhereInput>
    }

    export type Role_has_permissionsUncheckedUpdateManyWithoutPermissionsNestedInput = {
        create?: XOR<
            Enumerable<Role_has_permissionsCreateWithoutPermissionsInput>,
            Enumerable<Role_has_permissionsUncheckedCreateWithoutPermissionsInput>
        >
        connectOrCreate?: Enumerable<Role_has_permissionsCreateOrConnectWithoutPermissionsInput>
        upsert?: Enumerable<Role_has_permissionsUpsertWithWhereUniqueWithoutPermissionsInput>
        createMany?: Role_has_permissionsCreateManyPermissionsInputEnvelope
        set?: Enumerable<Role_has_permissionsWhereUniqueInput>
        disconnect?: Enumerable<Role_has_permissionsWhereUniqueInput>
        delete?: Enumerable<Role_has_permissionsWhereUniqueInput>
        connect?: Enumerable<Role_has_permissionsWhereUniqueInput>
        update?: Enumerable<Role_has_permissionsUpdateWithWhereUniqueWithoutPermissionsInput>
        updateMany?: Enumerable<Role_has_permissionsUpdateManyWithWhereWithoutPermissionsInput>
        deleteMany?: Enumerable<Role_has_permissionsScalarWhereInput>
    }

    export type PermissionsCreateNestedOneWithoutRole_has_permissionsInput = {
        create?: XOR<
            PermissionsCreateWithoutRole_has_permissionsInput,
            PermissionsUncheckedCreateWithoutRole_has_permissionsInput
        >
        connectOrCreate?: PermissionsCreateOrConnectWithoutRole_has_permissionsInput
        connect?: PermissionsWhereUniqueInput
    }

    export type RolesCreateNestedOneWithoutRole_has_permissionsInput = {
        create?: XOR<RolesCreateWithoutRole_has_permissionsInput, RolesUncheckedCreateWithoutRole_has_permissionsInput>
        connectOrCreate?: RolesCreateOrConnectWithoutRole_has_permissionsInput
        connect?: RolesWhereUniqueInput
    }

    export type PermissionsUpdateOneRequiredWithoutRole_has_permissionsNestedInput = {
        create?: XOR<
            PermissionsCreateWithoutRole_has_permissionsInput,
            PermissionsUncheckedCreateWithoutRole_has_permissionsInput
        >
        connectOrCreate?: PermissionsCreateOrConnectWithoutRole_has_permissionsInput
        upsert?: PermissionsUpsertWithoutRole_has_permissionsInput
        connect?: PermissionsWhereUniqueInput
        update?: XOR<
            PermissionsUpdateWithoutRole_has_permissionsInput,
            PermissionsUncheckedUpdateWithoutRole_has_permissionsInput
        >
    }

    export type RolesUpdateOneRequiredWithoutRole_has_permissionsNestedInput = {
        create?: XOR<RolesCreateWithoutRole_has_permissionsInput, RolesUncheckedCreateWithoutRole_has_permissionsInput>
        connectOrCreate?: RolesCreateOrConnectWithoutRole_has_permissionsInput
        upsert?: RolesUpsertWithoutRole_has_permissionsInput
        connect?: RolesWhereUniqueInput
        update?: XOR<RolesUpdateWithoutRole_has_permissionsInput, RolesUncheckedUpdateWithoutRole_has_permissionsInput>
    }

    export type Model_has_rolesCreateNestedManyWithoutRolesInput = {
        create?: XOR<
            Enumerable<Model_has_rolesCreateWithoutRolesInput>,
            Enumerable<Model_has_rolesUncheckedCreateWithoutRolesInput>
        >
        connectOrCreate?: Enumerable<Model_has_rolesCreateOrConnectWithoutRolesInput>
        createMany?: Model_has_rolesCreateManyRolesInputEnvelope
        connect?: Enumerable<Model_has_rolesWhereUniqueInput>
    }

    export type Role_has_permissionsCreateNestedManyWithoutRolesInput = {
        create?: XOR<
            Enumerable<Role_has_permissionsCreateWithoutRolesInput>,
            Enumerable<Role_has_permissionsUncheckedCreateWithoutRolesInput>
        >
        connectOrCreate?: Enumerable<Role_has_permissionsCreateOrConnectWithoutRolesInput>
        createMany?: Role_has_permissionsCreateManyRolesInputEnvelope
        connect?: Enumerable<Role_has_permissionsWhereUniqueInput>
    }

    export type Model_has_rolesUncheckedCreateNestedManyWithoutRolesInput = {
        create?: XOR<
            Enumerable<Model_has_rolesCreateWithoutRolesInput>,
            Enumerable<Model_has_rolesUncheckedCreateWithoutRolesInput>
        >
        connectOrCreate?: Enumerable<Model_has_rolesCreateOrConnectWithoutRolesInput>
        createMany?: Model_has_rolesCreateManyRolesInputEnvelope
        connect?: Enumerable<Model_has_rolesWhereUniqueInput>
    }

    export type Role_has_permissionsUncheckedCreateNestedManyWithoutRolesInput = {
        create?: XOR<
            Enumerable<Role_has_permissionsCreateWithoutRolesInput>,
            Enumerable<Role_has_permissionsUncheckedCreateWithoutRolesInput>
        >
        connectOrCreate?: Enumerable<Role_has_permissionsCreateOrConnectWithoutRolesInput>
        createMany?: Role_has_permissionsCreateManyRolesInputEnvelope
        connect?: Enumerable<Role_has_permissionsWhereUniqueInput>
    }

    export type Model_has_rolesUpdateManyWithoutRolesNestedInput = {
        create?: XOR<
            Enumerable<Model_has_rolesCreateWithoutRolesInput>,
            Enumerable<Model_has_rolesUncheckedCreateWithoutRolesInput>
        >
        connectOrCreate?: Enumerable<Model_has_rolesCreateOrConnectWithoutRolesInput>
        upsert?: Enumerable<Model_has_rolesUpsertWithWhereUniqueWithoutRolesInput>
        createMany?: Model_has_rolesCreateManyRolesInputEnvelope
        set?: Enumerable<Model_has_rolesWhereUniqueInput>
        disconnect?: Enumerable<Model_has_rolesWhereUniqueInput>
        delete?: Enumerable<Model_has_rolesWhereUniqueInput>
        connect?: Enumerable<Model_has_rolesWhereUniqueInput>
        update?: Enumerable<Model_has_rolesUpdateWithWhereUniqueWithoutRolesInput>
        updateMany?: Enumerable<Model_has_rolesUpdateManyWithWhereWithoutRolesInput>
        deleteMany?: Enumerable<Model_has_rolesScalarWhereInput>
    }

    export type Role_has_permissionsUpdateManyWithoutRolesNestedInput = {
        create?: XOR<
            Enumerable<Role_has_permissionsCreateWithoutRolesInput>,
            Enumerable<Role_has_permissionsUncheckedCreateWithoutRolesInput>
        >
        connectOrCreate?: Enumerable<Role_has_permissionsCreateOrConnectWithoutRolesInput>
        upsert?: Enumerable<Role_has_permissionsUpsertWithWhereUniqueWithoutRolesInput>
        createMany?: Role_has_permissionsCreateManyRolesInputEnvelope
        set?: Enumerable<Role_has_permissionsWhereUniqueInput>
        disconnect?: Enumerable<Role_has_permissionsWhereUniqueInput>
        delete?: Enumerable<Role_has_permissionsWhereUniqueInput>
        connect?: Enumerable<Role_has_permissionsWhereUniqueInput>
        update?: Enumerable<Role_has_permissionsUpdateWithWhereUniqueWithoutRolesInput>
        updateMany?: Enumerable<Role_has_permissionsUpdateManyWithWhereWithoutRolesInput>
        deleteMany?: Enumerable<Role_has_permissionsScalarWhereInput>
    }

    export type Model_has_rolesUncheckedUpdateManyWithoutRolesNestedInput = {
        create?: XOR<
            Enumerable<Model_has_rolesCreateWithoutRolesInput>,
            Enumerable<Model_has_rolesUncheckedCreateWithoutRolesInput>
        >
        connectOrCreate?: Enumerable<Model_has_rolesCreateOrConnectWithoutRolesInput>
        upsert?: Enumerable<Model_has_rolesUpsertWithWhereUniqueWithoutRolesInput>
        createMany?: Model_has_rolesCreateManyRolesInputEnvelope
        set?: Enumerable<Model_has_rolesWhereUniqueInput>
        disconnect?: Enumerable<Model_has_rolesWhereUniqueInput>
        delete?: Enumerable<Model_has_rolesWhereUniqueInput>
        connect?: Enumerable<Model_has_rolesWhereUniqueInput>
        update?: Enumerable<Model_has_rolesUpdateWithWhereUniqueWithoutRolesInput>
        updateMany?: Enumerable<Model_has_rolesUpdateManyWithWhereWithoutRolesInput>
        deleteMany?: Enumerable<Model_has_rolesScalarWhereInput>
    }

    export type Role_has_permissionsUncheckedUpdateManyWithoutRolesNestedInput = {
        create?: XOR<
            Enumerable<Role_has_permissionsCreateWithoutRolesInput>,
            Enumerable<Role_has_permissionsUncheckedCreateWithoutRolesInput>
        >
        connectOrCreate?: Enumerable<Role_has_permissionsCreateOrConnectWithoutRolesInput>
        upsert?: Enumerable<Role_has_permissionsUpsertWithWhereUniqueWithoutRolesInput>
        createMany?: Role_has_permissionsCreateManyRolesInputEnvelope
        set?: Enumerable<Role_has_permissionsWhereUniqueInput>
        disconnect?: Enumerable<Role_has_permissionsWhereUniqueInput>
        delete?: Enumerable<Role_has_permissionsWhereUniqueInput>
        connect?: Enumerable<Role_has_permissionsWhereUniqueInput>
        update?: Enumerable<Role_has_permissionsUpdateWithWhereUniqueWithoutRolesInput>
        updateMany?: Enumerable<Role_has_permissionsUpdateManyWithWhereWithoutRolesInput>
        deleteMany?: Enumerable<Role_has_permissionsScalarWhereInput>
    }

    export type FamiliesCreateNestedOneWithoutSecond_sponsorsInput = {
        create?: XOR<FamiliesCreateWithoutSecond_sponsorsInput, FamiliesUncheckedCreateWithoutSecond_sponsorsInput>
        connectOrCreate?: FamiliesCreateOrConnectWithoutSecond_sponsorsInput
        connect?: FamiliesWhereUniqueInput
    }

    export type TenantsCreateNestedOneWithoutSecond_sponsorsInput = {
        create?: XOR<TenantsCreateWithoutSecond_sponsorsInput, TenantsUncheckedCreateWithoutSecond_sponsorsInput>
        connectOrCreate?: TenantsCreateOrConnectWithoutSecond_sponsorsInput
        connect?: TenantsWhereUniqueInput
    }

    export type FamiliesUpdateOneRequiredWithoutSecond_sponsorsNestedInput = {
        create?: XOR<FamiliesCreateWithoutSecond_sponsorsInput, FamiliesUncheckedCreateWithoutSecond_sponsorsInput>
        connectOrCreate?: FamiliesCreateOrConnectWithoutSecond_sponsorsInput
        upsert?: FamiliesUpsertWithoutSecond_sponsorsInput
        connect?: FamiliesWhereUniqueInput
        update?: XOR<FamiliesUpdateWithoutSecond_sponsorsInput, FamiliesUncheckedUpdateWithoutSecond_sponsorsInput>
    }

    export type TenantsUpdateOneRequiredWithoutSecond_sponsorsNestedInput = {
        create?: XOR<TenantsCreateWithoutSecond_sponsorsInput, TenantsUncheckedCreateWithoutSecond_sponsorsInput>
        connectOrCreate?: TenantsCreateOrConnectWithoutSecond_sponsorsInput
        upsert?: TenantsUpsertWithoutSecond_sponsorsInput
        connect?: TenantsWhereUniqueInput
        update?: XOR<TenantsUpdateWithoutSecond_sponsorsInput, TenantsUncheckedUpdateWithoutSecond_sponsorsInput>
    }

    export type UsersCreateNestedOneWithoutSessionsInput = {
        create?: XOR<UsersCreateWithoutSessionsInput, UsersUncheckedCreateWithoutSessionsInput>
        connectOrCreate?: UsersCreateOrConnectWithoutSessionsInput
        connect?: UsersWhereUniqueInput
    }

    export type UsersUpdateOneWithoutSessionsNestedInput = {
        create?: XOR<UsersCreateWithoutSessionsInput, UsersUncheckedCreateWithoutSessionsInput>
        connectOrCreate?: UsersCreateOrConnectWithoutSessionsInput
        upsert?: UsersUpsertWithoutSessionsInput
        disconnect?: boolean
        delete?: boolean
        connect?: UsersWhereUniqueInput
        update?: XOR<UsersUpdateWithoutSessionsInput, UsersUncheckedUpdateWithoutSessionsInput>
    }

    export type UsersCreateNestedOneWithoutSettingsInput = {
        create?: XOR<UsersCreateWithoutSettingsInput, UsersUncheckedCreateWithoutSettingsInput>
        connectOrCreate?: UsersCreateOrConnectWithoutSettingsInput
        connect?: UsersWhereUniqueInput
    }

    export type EnumthemeFieldUpdateOperationsInput = {
        set?: theme
    }

    export type Enumcolor_schemeFieldUpdateOperationsInput = {
        set?: color_scheme
    }

    export type EnumlayoutFieldUpdateOperationsInput = {
        set?: layout
    }

    export type EnumappearanceFieldUpdateOperationsInput = {
        set?: appearance
    }

    export type UsersUpdateOneRequiredWithoutSettingsNestedInput = {
        create?: XOR<UsersCreateWithoutSettingsInput, UsersUncheckedCreateWithoutSettingsInput>
        connectOrCreate?: UsersCreateOrConnectWithoutSettingsInput
        upsert?: UsersUpsertWithoutSettingsInput
        connect?: UsersWhereUniqueInput
        update?: XOR<UsersUpdateWithoutSettingsInput, UsersUncheckedUpdateWithoutSettingsInput>
    }

    export type SponsorsCreateNestedOneWithoutSponsor_sponsorshipInput = {
        create?: XOR<
            SponsorsCreateWithoutSponsor_sponsorshipInput,
            SponsorsUncheckedCreateWithoutSponsor_sponsorshipInput
        >
        connectOrCreate?: SponsorsCreateOrConnectWithoutSponsor_sponsorshipInput
        connect?: SponsorsWhereUniqueInput
    }

    export type TenantsCreateNestedOneWithoutSponsor_sponsorshipInput = {
        create?: XOR<
            TenantsCreateWithoutSponsor_sponsorshipInput,
            TenantsUncheckedCreateWithoutSponsor_sponsorshipInput
        >
        connectOrCreate?: TenantsCreateOrConnectWithoutSponsor_sponsorshipInput
        connect?: TenantsWhereUniqueInput
    }

    export type Enumsponsor_sponsorship_typeFieldUpdateOperationsInput = {
        set?: sponsor_sponsorship_type
    }

    export type SponsorsUpdateOneRequiredWithoutSponsor_sponsorshipNestedInput = {
        create?: XOR<
            SponsorsCreateWithoutSponsor_sponsorshipInput,
            SponsorsUncheckedCreateWithoutSponsor_sponsorshipInput
        >
        connectOrCreate?: SponsorsCreateOrConnectWithoutSponsor_sponsorshipInput
        upsert?: SponsorsUpsertWithoutSponsor_sponsorshipInput
        connect?: SponsorsWhereUniqueInput
        update?: XOR<
            SponsorsUpdateWithoutSponsor_sponsorshipInput,
            SponsorsUncheckedUpdateWithoutSponsor_sponsorshipInput
        >
    }

    export type TenantsUpdateOneRequiredWithoutSponsor_sponsorshipNestedInput = {
        create?: XOR<
            TenantsCreateWithoutSponsor_sponsorshipInput,
            TenantsUncheckedCreateWithoutSponsor_sponsorshipInput
        >
        connectOrCreate?: TenantsCreateOrConnectWithoutSponsor_sponsorshipInput
        upsert?: TenantsUpsertWithoutSponsor_sponsorshipInput
        connect?: TenantsWhereUniqueInput
        update?: XOR<
            TenantsUpdateWithoutSponsor_sponsorshipInput,
            TenantsUncheckedUpdateWithoutSponsor_sponsorshipInput
        >
    }

    export type Income_sponsorCreateNestedManyWithoutSponsorsInput = {
        create?: XOR<
            Enumerable<Income_sponsorCreateWithoutSponsorsInput>,
            Enumerable<Income_sponsorUncheckedCreateWithoutSponsorsInput>
        >
        connectOrCreate?: Enumerable<Income_sponsorCreateOrConnectWithoutSponsorsInput>
        createMany?: Income_sponsorCreateManySponsorsInputEnvelope
        connect?: Enumerable<Income_sponsorWhereUniqueInput>
    }

    export type Sponsor_sponsorshipCreateNestedManyWithoutSponsorsInput = {
        create?: XOR<
            Enumerable<Sponsor_sponsorshipCreateWithoutSponsorsInput>,
            Enumerable<Sponsor_sponsorshipUncheckedCreateWithoutSponsorsInput>
        >
        connectOrCreate?: Enumerable<Sponsor_sponsorshipCreateOrConnectWithoutSponsorsInput>
        createMany?: Sponsor_sponsorshipCreateManySponsorsInputEnvelope
        connect?: Enumerable<Sponsor_sponsorshipWhereUniqueInput>
    }

    export type UsersCreateNestedOneWithoutSponsors_sponsors_created_byTousersInput = {
        create?: XOR<
            UsersCreateWithoutSponsors_sponsors_created_byTousersInput,
            UsersUncheckedCreateWithoutSponsors_sponsors_created_byTousersInput
        >
        connectOrCreate?: UsersCreateOrConnectWithoutSponsors_sponsors_created_byTousersInput
        connect?: UsersWhereUniqueInput
    }

    export type UsersCreateNestedOneWithoutSponsors_sponsors_deleted_byTousersInput = {
        create?: XOR<
            UsersCreateWithoutSponsors_sponsors_deleted_byTousersInput,
            UsersUncheckedCreateWithoutSponsors_sponsors_deleted_byTousersInput
        >
        connectOrCreate?: UsersCreateOrConnectWithoutSponsors_sponsors_deleted_byTousersInput
        connect?: UsersWhereUniqueInput
    }

    export type TenantsCreateNestedOneWithoutSponsorsInput = {
        create?: XOR<TenantsCreateWithoutSponsorsInput, TenantsUncheckedCreateWithoutSponsorsInput>
        connectOrCreate?: TenantsCreateOrConnectWithoutSponsorsInput
        connect?: TenantsWhereUniqueInput
    }

    export type Income_sponsorUncheckedCreateNestedManyWithoutSponsorsInput = {
        create?: XOR<
            Enumerable<Income_sponsorCreateWithoutSponsorsInput>,
            Enumerable<Income_sponsorUncheckedCreateWithoutSponsorsInput>
        >
        connectOrCreate?: Enumerable<Income_sponsorCreateOrConnectWithoutSponsorsInput>
        createMany?: Income_sponsorCreateManySponsorsInputEnvelope
        connect?: Enumerable<Income_sponsorWhereUniqueInput>
    }

    export type Sponsor_sponsorshipUncheckedCreateNestedManyWithoutSponsorsInput = {
        create?: XOR<
            Enumerable<Sponsor_sponsorshipCreateWithoutSponsorsInput>,
            Enumerable<Sponsor_sponsorshipUncheckedCreateWithoutSponsorsInput>
        >
        connectOrCreate?: Enumerable<Sponsor_sponsorshipCreateOrConnectWithoutSponsorsInput>
        createMany?: Sponsor_sponsorshipCreateManySponsorsInputEnvelope
        connect?: Enumerable<Sponsor_sponsorshipWhereUniqueInput>
    }

    export type Income_sponsorUpdateManyWithoutSponsorsNestedInput = {
        create?: XOR<
            Enumerable<Income_sponsorCreateWithoutSponsorsInput>,
            Enumerable<Income_sponsorUncheckedCreateWithoutSponsorsInput>
        >
        connectOrCreate?: Enumerable<Income_sponsorCreateOrConnectWithoutSponsorsInput>
        upsert?: Enumerable<Income_sponsorUpsertWithWhereUniqueWithoutSponsorsInput>
        createMany?: Income_sponsorCreateManySponsorsInputEnvelope
        set?: Enumerable<Income_sponsorWhereUniqueInput>
        disconnect?: Enumerable<Income_sponsorWhereUniqueInput>
        delete?: Enumerable<Income_sponsorWhereUniqueInput>
        connect?: Enumerable<Income_sponsorWhereUniqueInput>
        update?: Enumerable<Income_sponsorUpdateWithWhereUniqueWithoutSponsorsInput>
        updateMany?: Enumerable<Income_sponsorUpdateManyWithWhereWithoutSponsorsInput>
        deleteMany?: Enumerable<Income_sponsorScalarWhereInput>
    }

    export type Sponsor_sponsorshipUpdateManyWithoutSponsorsNestedInput = {
        create?: XOR<
            Enumerable<Sponsor_sponsorshipCreateWithoutSponsorsInput>,
            Enumerable<Sponsor_sponsorshipUncheckedCreateWithoutSponsorsInput>
        >
        connectOrCreate?: Enumerable<Sponsor_sponsorshipCreateOrConnectWithoutSponsorsInput>
        upsert?: Enumerable<Sponsor_sponsorshipUpsertWithWhereUniqueWithoutSponsorsInput>
        createMany?: Sponsor_sponsorshipCreateManySponsorsInputEnvelope
        set?: Enumerable<Sponsor_sponsorshipWhereUniqueInput>
        disconnect?: Enumerable<Sponsor_sponsorshipWhereUniqueInput>
        delete?: Enumerable<Sponsor_sponsorshipWhereUniqueInput>
        connect?: Enumerable<Sponsor_sponsorshipWhereUniqueInput>
        update?: Enumerable<Sponsor_sponsorshipUpdateWithWhereUniqueWithoutSponsorsInput>
        updateMany?: Enumerable<Sponsor_sponsorshipUpdateManyWithWhereWithoutSponsorsInput>
        deleteMany?: Enumerable<Sponsor_sponsorshipScalarWhereInput>
    }

    export type UsersUpdateOneRequiredWithoutSponsors_sponsors_created_byTousersNestedInput = {
        create?: XOR<
            UsersCreateWithoutSponsors_sponsors_created_byTousersInput,
            UsersUncheckedCreateWithoutSponsors_sponsors_created_byTousersInput
        >
        connectOrCreate?: UsersCreateOrConnectWithoutSponsors_sponsors_created_byTousersInput
        upsert?: UsersUpsertWithoutSponsors_sponsors_created_byTousersInput
        connect?: UsersWhereUniqueInput
        update?: XOR<
            UsersUpdateWithoutSponsors_sponsors_created_byTousersInput,
            UsersUncheckedUpdateWithoutSponsors_sponsors_created_byTousersInput
        >
    }

    export type UsersUpdateOneWithoutSponsors_sponsors_deleted_byTousersNestedInput = {
        create?: XOR<
            UsersCreateWithoutSponsors_sponsors_deleted_byTousersInput,
            UsersUncheckedCreateWithoutSponsors_sponsors_deleted_byTousersInput
        >
        connectOrCreate?: UsersCreateOrConnectWithoutSponsors_sponsors_deleted_byTousersInput
        upsert?: UsersUpsertWithoutSponsors_sponsors_deleted_byTousersInput
        disconnect?: boolean
        delete?: boolean
        connect?: UsersWhereUniqueInput
        update?: XOR<
            UsersUpdateWithoutSponsors_sponsors_deleted_byTousersInput,
            UsersUncheckedUpdateWithoutSponsors_sponsors_deleted_byTousersInput
        >
    }

    export type TenantsUpdateOneRequiredWithoutSponsorsNestedInput = {
        create?: XOR<TenantsCreateWithoutSponsorsInput, TenantsUncheckedCreateWithoutSponsorsInput>
        connectOrCreate?: TenantsCreateOrConnectWithoutSponsorsInput
        upsert?: TenantsUpsertWithoutSponsorsInput
        connect?: TenantsWhereUniqueInput
        update?: XOR<TenantsUpdateWithoutSponsorsInput, TenantsUncheckedUpdateWithoutSponsorsInput>
    }

    export type Income_sponsorUncheckedUpdateManyWithoutSponsorsNestedInput = {
        create?: XOR<
            Enumerable<Income_sponsorCreateWithoutSponsorsInput>,
            Enumerable<Income_sponsorUncheckedCreateWithoutSponsorsInput>
        >
        connectOrCreate?: Enumerable<Income_sponsorCreateOrConnectWithoutSponsorsInput>
        upsert?: Enumerable<Income_sponsorUpsertWithWhereUniqueWithoutSponsorsInput>
        createMany?: Income_sponsorCreateManySponsorsInputEnvelope
        set?: Enumerable<Income_sponsorWhereUniqueInput>
        disconnect?: Enumerable<Income_sponsorWhereUniqueInput>
        delete?: Enumerable<Income_sponsorWhereUniqueInput>
        connect?: Enumerable<Income_sponsorWhereUniqueInput>
        update?: Enumerable<Income_sponsorUpdateWithWhereUniqueWithoutSponsorsInput>
        updateMany?: Enumerable<Income_sponsorUpdateManyWithWhereWithoutSponsorsInput>
        deleteMany?: Enumerable<Income_sponsorScalarWhereInput>
    }

    export type Sponsor_sponsorshipUncheckedUpdateManyWithoutSponsorsNestedInput = {
        create?: XOR<
            Enumerable<Sponsor_sponsorshipCreateWithoutSponsorsInput>,
            Enumerable<Sponsor_sponsorshipUncheckedCreateWithoutSponsorsInput>
        >
        connectOrCreate?: Enumerable<Sponsor_sponsorshipCreateOrConnectWithoutSponsorsInput>
        upsert?: Enumerable<Sponsor_sponsorshipUpsertWithWhereUniqueWithoutSponsorsInput>
        createMany?: Sponsor_sponsorshipCreateManySponsorsInputEnvelope
        set?: Enumerable<Sponsor_sponsorshipWhereUniqueInput>
        disconnect?: Enumerable<Sponsor_sponsorshipWhereUniqueInput>
        delete?: Enumerable<Sponsor_sponsorshipWhereUniqueInput>
        connect?: Enumerable<Sponsor_sponsorshipWhereUniqueInput>
        update?: Enumerable<Sponsor_sponsorshipUpdateWithWhereUniqueWithoutSponsorsInput>
        updateMany?: Enumerable<Sponsor_sponsorshipUpdateManyWithWhereWithoutSponsorsInput>
        deleteMany?: Enumerable<Sponsor_sponsorshipScalarWhereInput>
    }

    export type TenantsCreateNestedOneWithoutSponsorshipsInput = {
        create?: XOR<TenantsCreateWithoutSponsorshipsInput, TenantsUncheckedCreateWithoutSponsorshipsInput>
        connectOrCreate?: TenantsCreateOrConnectWithoutSponsorshipsInput
        connect?: TenantsWhereUniqueInput
    }

    export type Enumsponsorship_typeFieldUpdateOperationsInput = {
        set?: sponsorship_type
    }

    export type TenantsUpdateOneRequiredWithoutSponsorshipsNestedInput = {
        create?: XOR<TenantsCreateWithoutSponsorshipsInput, TenantsUncheckedCreateWithoutSponsorshipsInput>
        connectOrCreate?: TenantsCreateOrConnectWithoutSponsorshipsInput
        upsert?: TenantsUpsertWithoutSponsorshipsInput
        connect?: TenantsWhereUniqueInput
        update?: XOR<TenantsUpdateWithoutSponsorshipsInput, TenantsUncheckedUpdateWithoutSponsorshipsInput>
    }

    export type FamiliesCreateNestedOneWithoutSpousesInput = {
        create?: XOR<FamiliesCreateWithoutSpousesInput, FamiliesUncheckedCreateWithoutSpousesInput>
        connectOrCreate?: FamiliesCreateOrConnectWithoutSpousesInput
        connect?: FamiliesWhereUniqueInput
    }

    export type TenantsCreateNestedOneWithoutSpousesInput = {
        create?: XOR<TenantsCreateWithoutSpousesInput, TenantsUncheckedCreateWithoutSpousesInput>
        connectOrCreate?: TenantsCreateOrConnectWithoutSpousesInput
        connect?: TenantsWhereUniqueInput
    }

    export type FamiliesUpdateOneRequiredWithoutSpousesNestedInput = {
        create?: XOR<FamiliesCreateWithoutSpousesInput, FamiliesUncheckedCreateWithoutSpousesInput>
        connectOrCreate?: FamiliesCreateOrConnectWithoutSpousesInput
        upsert?: FamiliesUpsertWithoutSpousesInput
        connect?: FamiliesWhereUniqueInput
        update?: XOR<FamiliesUpdateWithoutSpousesInput, FamiliesUncheckedUpdateWithoutSpousesInput>
    }

    export type TenantsUpdateOneRequiredWithoutSpousesNestedInput = {
        create?: XOR<TenantsCreateWithoutSpousesInput, TenantsUncheckedCreateWithoutSpousesInput>
        connectOrCreate?: TenantsCreateOrConnectWithoutSpousesInput
        upsert?: TenantsUpsertWithoutSpousesInput
        connect?: TenantsWhereUniqueInput
        update?: XOR<TenantsUpdateWithoutSpousesInput, TenantsUncheckedUpdateWithoutSpousesInput>
    }

    export type BenefactorsCreateNestedManyWithoutTenantsInput = {
        create?: XOR<
            Enumerable<BenefactorsCreateWithoutTenantsInput>,
            Enumerable<BenefactorsUncheckedCreateWithoutTenantsInput>
        >
        connectOrCreate?: Enumerable<BenefactorsCreateOrConnectWithoutTenantsInput>
        createMany?: BenefactorsCreateManyTenantsInputEnvelope
        connect?: Enumerable<BenefactorsWhereUniqueInput>
    }

    export type DomainsCreateNestedManyWithoutTenantsInput = {
        create?: XOR<
            Enumerable<DomainsCreateWithoutTenantsInput>,
            Enumerable<DomainsUncheckedCreateWithoutTenantsInput>
        >
        connectOrCreate?: Enumerable<DomainsCreateOrConnectWithoutTenantsInput>
        createMany?: DomainsCreateManyTenantsInputEnvelope
        connect?: Enumerable<DomainsWhereUniqueInput>
    }

    export type FamiliesCreateNestedManyWithoutTenantsInput = {
        create?: XOR<
            Enumerable<FamiliesCreateWithoutTenantsInput>,
            Enumerable<FamiliesUncheckedCreateWithoutTenantsInput>
        >
        connectOrCreate?: Enumerable<FamiliesCreateOrConnectWithoutTenantsInput>
        createMany?: FamiliesCreateManyTenantsInputEnvelope
        connect?: Enumerable<FamiliesWhereUniqueInput>
    }

    export type Family_sponsorshipCreateNestedManyWithoutTenantsInput = {
        create?: XOR<
            Enumerable<Family_sponsorshipCreateWithoutTenantsInput>,
            Enumerable<Family_sponsorshipUncheckedCreateWithoutTenantsInput>
        >
        connectOrCreate?: Enumerable<Family_sponsorshipCreateOrConnectWithoutTenantsInput>
        createMany?: Family_sponsorshipCreateManyTenantsInputEnvelope
        connect?: Enumerable<Family_sponsorshipWhereUniqueInput>
    }

    export type Income_sponsorCreateNestedManyWithoutTenantsInput = {
        create?: XOR<
            Enumerable<Income_sponsorCreateWithoutTenantsInput>,
            Enumerable<Income_sponsorUncheckedCreateWithoutTenantsInput>
        >
        connectOrCreate?: Enumerable<Income_sponsorCreateOrConnectWithoutTenantsInput>
        createMany?: Income_sponsorCreateManyTenantsInputEnvelope
        connect?: Enumerable<Income_sponsorWhereUniqueInput>
    }

    export type Orphan_sponsorshipCreateNestedManyWithoutTenantsInput = {
        create?: XOR<
            Enumerable<Orphan_sponsorshipCreateWithoutTenantsInput>,
            Enumerable<Orphan_sponsorshipUncheckedCreateWithoutTenantsInput>
        >
        connectOrCreate?: Enumerable<Orphan_sponsorshipCreateOrConnectWithoutTenantsInput>
        createMany?: Orphan_sponsorshipCreateManyTenantsInputEnvelope
        connect?: Enumerable<Orphan_sponsorshipWhereUniqueInput>
    }

    export type OrphansCreateNestedManyWithoutTenantsInput = {
        create?: XOR<
            Enumerable<OrphansCreateWithoutTenantsInput>,
            Enumerable<OrphansUncheckedCreateWithoutTenantsInput>
        >
        connectOrCreate?: Enumerable<OrphansCreateOrConnectWithoutTenantsInput>
        createMany?: OrphansCreateManyTenantsInputEnvelope
        connect?: Enumerable<OrphansWhereUniqueInput>
    }

    export type Second_sponsorsCreateNestedManyWithoutTenantsInput = {
        create?: XOR<
            Enumerable<Second_sponsorsCreateWithoutTenantsInput>,
            Enumerable<Second_sponsorsUncheckedCreateWithoutTenantsInput>
        >
        connectOrCreate?: Enumerable<Second_sponsorsCreateOrConnectWithoutTenantsInput>
        createMany?: Second_sponsorsCreateManyTenantsInputEnvelope
        connect?: Enumerable<Second_sponsorsWhereUniqueInput>
    }

    export type Sponsor_sponsorshipCreateNestedManyWithoutTenantsInput = {
        create?: XOR<
            Enumerable<Sponsor_sponsorshipCreateWithoutTenantsInput>,
            Enumerable<Sponsor_sponsorshipUncheckedCreateWithoutTenantsInput>
        >
        connectOrCreate?: Enumerable<Sponsor_sponsorshipCreateOrConnectWithoutTenantsInput>
        createMany?: Sponsor_sponsorshipCreateManyTenantsInputEnvelope
        connect?: Enumerable<Sponsor_sponsorshipWhereUniqueInput>
    }

    export type SponsorsCreateNestedManyWithoutTenantsInput = {
        create?: XOR<
            Enumerable<SponsorsCreateWithoutTenantsInput>,
            Enumerable<SponsorsUncheckedCreateWithoutTenantsInput>
        >
        connectOrCreate?: Enumerable<SponsorsCreateOrConnectWithoutTenantsInput>
        createMany?: SponsorsCreateManyTenantsInputEnvelope
        connect?: Enumerable<SponsorsWhereUniqueInput>
    }

    export type SponsorshipsCreateNestedManyWithoutTenantsInput = {
        create?: XOR<
            Enumerable<SponsorshipsCreateWithoutTenantsInput>,
            Enumerable<SponsorshipsUncheckedCreateWithoutTenantsInput>
        >
        connectOrCreate?: Enumerable<SponsorshipsCreateOrConnectWithoutTenantsInput>
        createMany?: SponsorshipsCreateManyTenantsInputEnvelope
        connect?: Enumerable<SponsorshipsWhereUniqueInput>
    }

    export type SpousesCreateNestedManyWithoutTenantsInput = {
        create?: XOR<
            Enumerable<SpousesCreateWithoutTenantsInput>,
            Enumerable<SpousesUncheckedCreateWithoutTenantsInput>
        >
        connectOrCreate?: Enumerable<SpousesCreateOrConnectWithoutTenantsInput>
        createMany?: SpousesCreateManyTenantsInputEnvelope
        connect?: Enumerable<SpousesWhereUniqueInput>
    }

    export type UsersCreateNestedManyWithoutTenantsInput = {
        create?: XOR<Enumerable<UsersCreateWithoutTenantsInput>, Enumerable<UsersUncheckedCreateWithoutTenantsInput>>
        connectOrCreate?: Enumerable<UsersCreateOrConnectWithoutTenantsInput>
        createMany?: UsersCreateManyTenantsInputEnvelope
        connect?: Enumerable<UsersWhereUniqueInput>
    }

    export type BenefactorsUncheckedCreateNestedManyWithoutTenantsInput = {
        create?: XOR<
            Enumerable<BenefactorsCreateWithoutTenantsInput>,
            Enumerable<BenefactorsUncheckedCreateWithoutTenantsInput>
        >
        connectOrCreate?: Enumerable<BenefactorsCreateOrConnectWithoutTenantsInput>
        createMany?: BenefactorsCreateManyTenantsInputEnvelope
        connect?: Enumerable<BenefactorsWhereUniqueInput>
    }

    export type DomainsUncheckedCreateNestedManyWithoutTenantsInput = {
        create?: XOR<
            Enumerable<DomainsCreateWithoutTenantsInput>,
            Enumerable<DomainsUncheckedCreateWithoutTenantsInput>
        >
        connectOrCreate?: Enumerable<DomainsCreateOrConnectWithoutTenantsInput>
        createMany?: DomainsCreateManyTenantsInputEnvelope
        connect?: Enumerable<DomainsWhereUniqueInput>
    }

    export type FamiliesUncheckedCreateNestedManyWithoutTenantsInput = {
        create?: XOR<
            Enumerable<FamiliesCreateWithoutTenantsInput>,
            Enumerable<FamiliesUncheckedCreateWithoutTenantsInput>
        >
        connectOrCreate?: Enumerable<FamiliesCreateOrConnectWithoutTenantsInput>
        createMany?: FamiliesCreateManyTenantsInputEnvelope
        connect?: Enumerable<FamiliesWhereUniqueInput>
    }

    export type Family_sponsorshipUncheckedCreateNestedManyWithoutTenantsInput = {
        create?: XOR<
            Enumerable<Family_sponsorshipCreateWithoutTenantsInput>,
            Enumerable<Family_sponsorshipUncheckedCreateWithoutTenantsInput>
        >
        connectOrCreate?: Enumerable<Family_sponsorshipCreateOrConnectWithoutTenantsInput>
        createMany?: Family_sponsorshipCreateManyTenantsInputEnvelope
        connect?: Enumerable<Family_sponsorshipWhereUniqueInput>
    }

    export type Income_sponsorUncheckedCreateNestedManyWithoutTenantsInput = {
        create?: XOR<
            Enumerable<Income_sponsorCreateWithoutTenantsInput>,
            Enumerable<Income_sponsorUncheckedCreateWithoutTenantsInput>
        >
        connectOrCreate?: Enumerable<Income_sponsorCreateOrConnectWithoutTenantsInput>
        createMany?: Income_sponsorCreateManyTenantsInputEnvelope
        connect?: Enumerable<Income_sponsorWhereUniqueInput>
    }

    export type Orphan_sponsorshipUncheckedCreateNestedManyWithoutTenantsInput = {
        create?: XOR<
            Enumerable<Orphan_sponsorshipCreateWithoutTenantsInput>,
            Enumerable<Orphan_sponsorshipUncheckedCreateWithoutTenantsInput>
        >
        connectOrCreate?: Enumerable<Orphan_sponsorshipCreateOrConnectWithoutTenantsInput>
        createMany?: Orphan_sponsorshipCreateManyTenantsInputEnvelope
        connect?: Enumerable<Orphan_sponsorshipWhereUniqueInput>
    }

    export type OrphansUncheckedCreateNestedManyWithoutTenantsInput = {
        create?: XOR<
            Enumerable<OrphansCreateWithoutTenantsInput>,
            Enumerable<OrphansUncheckedCreateWithoutTenantsInput>
        >
        connectOrCreate?: Enumerable<OrphansCreateOrConnectWithoutTenantsInput>
        createMany?: OrphansCreateManyTenantsInputEnvelope
        connect?: Enumerable<OrphansWhereUniqueInput>
    }

    export type Second_sponsorsUncheckedCreateNestedManyWithoutTenantsInput = {
        create?: XOR<
            Enumerable<Second_sponsorsCreateWithoutTenantsInput>,
            Enumerable<Second_sponsorsUncheckedCreateWithoutTenantsInput>
        >
        connectOrCreate?: Enumerable<Second_sponsorsCreateOrConnectWithoutTenantsInput>
        createMany?: Second_sponsorsCreateManyTenantsInputEnvelope
        connect?: Enumerable<Second_sponsorsWhereUniqueInput>
    }

    export type Sponsor_sponsorshipUncheckedCreateNestedManyWithoutTenantsInput = {
        create?: XOR<
            Enumerable<Sponsor_sponsorshipCreateWithoutTenantsInput>,
            Enumerable<Sponsor_sponsorshipUncheckedCreateWithoutTenantsInput>
        >
        connectOrCreate?: Enumerable<Sponsor_sponsorshipCreateOrConnectWithoutTenantsInput>
        createMany?: Sponsor_sponsorshipCreateManyTenantsInputEnvelope
        connect?: Enumerable<Sponsor_sponsorshipWhereUniqueInput>
    }

    export type SponsorsUncheckedCreateNestedManyWithoutTenantsInput = {
        create?: XOR<
            Enumerable<SponsorsCreateWithoutTenantsInput>,
            Enumerable<SponsorsUncheckedCreateWithoutTenantsInput>
        >
        connectOrCreate?: Enumerable<SponsorsCreateOrConnectWithoutTenantsInput>
        createMany?: SponsorsCreateManyTenantsInputEnvelope
        connect?: Enumerable<SponsorsWhereUniqueInput>
    }

    export type SponsorshipsUncheckedCreateNestedManyWithoutTenantsInput = {
        create?: XOR<
            Enumerable<SponsorshipsCreateWithoutTenantsInput>,
            Enumerable<SponsorshipsUncheckedCreateWithoutTenantsInput>
        >
        connectOrCreate?: Enumerable<SponsorshipsCreateOrConnectWithoutTenantsInput>
        createMany?: SponsorshipsCreateManyTenantsInputEnvelope
        connect?: Enumerable<SponsorshipsWhereUniqueInput>
    }

    export type SpousesUncheckedCreateNestedManyWithoutTenantsInput = {
        create?: XOR<
            Enumerable<SpousesCreateWithoutTenantsInput>,
            Enumerable<SpousesUncheckedCreateWithoutTenantsInput>
        >
        connectOrCreate?: Enumerable<SpousesCreateOrConnectWithoutTenantsInput>
        createMany?: SpousesCreateManyTenantsInputEnvelope
        connect?: Enumerable<SpousesWhereUniqueInput>
    }

    export type UsersUncheckedCreateNestedManyWithoutTenantsInput = {
        create?: XOR<Enumerable<UsersCreateWithoutTenantsInput>, Enumerable<UsersUncheckedCreateWithoutTenantsInput>>
        connectOrCreate?: Enumerable<UsersCreateOrConnectWithoutTenantsInput>
        createMany?: UsersCreateManyTenantsInputEnvelope
        connect?: Enumerable<UsersWhereUniqueInput>
    }

    export type BenefactorsUpdateManyWithoutTenantsNestedInput = {
        create?: XOR<
            Enumerable<BenefactorsCreateWithoutTenantsInput>,
            Enumerable<BenefactorsUncheckedCreateWithoutTenantsInput>
        >
        connectOrCreate?: Enumerable<BenefactorsCreateOrConnectWithoutTenantsInput>
        upsert?: Enumerable<BenefactorsUpsertWithWhereUniqueWithoutTenantsInput>
        createMany?: BenefactorsCreateManyTenantsInputEnvelope
        set?: Enumerable<BenefactorsWhereUniqueInput>
        disconnect?: Enumerable<BenefactorsWhereUniqueInput>
        delete?: Enumerable<BenefactorsWhereUniqueInput>
        connect?: Enumerable<BenefactorsWhereUniqueInput>
        update?: Enumerable<BenefactorsUpdateWithWhereUniqueWithoutTenantsInput>
        updateMany?: Enumerable<BenefactorsUpdateManyWithWhereWithoutTenantsInput>
        deleteMany?: Enumerable<BenefactorsScalarWhereInput>
    }

    export type DomainsUpdateManyWithoutTenantsNestedInput = {
        create?: XOR<
            Enumerable<DomainsCreateWithoutTenantsInput>,
            Enumerable<DomainsUncheckedCreateWithoutTenantsInput>
        >
        connectOrCreate?: Enumerable<DomainsCreateOrConnectWithoutTenantsInput>
        upsert?: Enumerable<DomainsUpsertWithWhereUniqueWithoutTenantsInput>
        createMany?: DomainsCreateManyTenantsInputEnvelope
        set?: Enumerable<DomainsWhereUniqueInput>
        disconnect?: Enumerable<DomainsWhereUniqueInput>
        delete?: Enumerable<DomainsWhereUniqueInput>
        connect?: Enumerable<DomainsWhereUniqueInput>
        update?: Enumerable<DomainsUpdateWithWhereUniqueWithoutTenantsInput>
        updateMany?: Enumerable<DomainsUpdateManyWithWhereWithoutTenantsInput>
        deleteMany?: Enumerable<DomainsScalarWhereInput>
    }

    export type FamiliesUpdateManyWithoutTenantsNestedInput = {
        create?: XOR<
            Enumerable<FamiliesCreateWithoutTenantsInput>,
            Enumerable<FamiliesUncheckedCreateWithoutTenantsInput>
        >
        connectOrCreate?: Enumerable<FamiliesCreateOrConnectWithoutTenantsInput>
        upsert?: Enumerable<FamiliesUpsertWithWhereUniqueWithoutTenantsInput>
        createMany?: FamiliesCreateManyTenantsInputEnvelope
        set?: Enumerable<FamiliesWhereUniqueInput>
        disconnect?: Enumerable<FamiliesWhereUniqueInput>
        delete?: Enumerable<FamiliesWhereUniqueInput>
        connect?: Enumerable<FamiliesWhereUniqueInput>
        update?: Enumerable<FamiliesUpdateWithWhereUniqueWithoutTenantsInput>
        updateMany?: Enumerable<FamiliesUpdateManyWithWhereWithoutTenantsInput>
        deleteMany?: Enumerable<FamiliesScalarWhereInput>
    }

    export type Family_sponsorshipUpdateManyWithoutTenantsNestedInput = {
        create?: XOR<
            Enumerable<Family_sponsorshipCreateWithoutTenantsInput>,
            Enumerable<Family_sponsorshipUncheckedCreateWithoutTenantsInput>
        >
        connectOrCreate?: Enumerable<Family_sponsorshipCreateOrConnectWithoutTenantsInput>
        upsert?: Enumerable<Family_sponsorshipUpsertWithWhereUniqueWithoutTenantsInput>
        createMany?: Family_sponsorshipCreateManyTenantsInputEnvelope
        set?: Enumerable<Family_sponsorshipWhereUniqueInput>
        disconnect?: Enumerable<Family_sponsorshipWhereUniqueInput>
        delete?: Enumerable<Family_sponsorshipWhereUniqueInput>
        connect?: Enumerable<Family_sponsorshipWhereUniqueInput>
        update?: Enumerable<Family_sponsorshipUpdateWithWhereUniqueWithoutTenantsInput>
        updateMany?: Enumerable<Family_sponsorshipUpdateManyWithWhereWithoutTenantsInput>
        deleteMany?: Enumerable<Family_sponsorshipScalarWhereInput>
    }

    export type Income_sponsorUpdateManyWithoutTenantsNestedInput = {
        create?: XOR<
            Enumerable<Income_sponsorCreateWithoutTenantsInput>,
            Enumerable<Income_sponsorUncheckedCreateWithoutTenantsInput>
        >
        connectOrCreate?: Enumerable<Income_sponsorCreateOrConnectWithoutTenantsInput>
        upsert?: Enumerable<Income_sponsorUpsertWithWhereUniqueWithoutTenantsInput>
        createMany?: Income_sponsorCreateManyTenantsInputEnvelope
        set?: Enumerable<Income_sponsorWhereUniqueInput>
        disconnect?: Enumerable<Income_sponsorWhereUniqueInput>
        delete?: Enumerable<Income_sponsorWhereUniqueInput>
        connect?: Enumerable<Income_sponsorWhereUniqueInput>
        update?: Enumerable<Income_sponsorUpdateWithWhereUniqueWithoutTenantsInput>
        updateMany?: Enumerable<Income_sponsorUpdateManyWithWhereWithoutTenantsInput>
        deleteMany?: Enumerable<Income_sponsorScalarWhereInput>
    }

    export type Orphan_sponsorshipUpdateManyWithoutTenantsNestedInput = {
        create?: XOR<
            Enumerable<Orphan_sponsorshipCreateWithoutTenantsInput>,
            Enumerable<Orphan_sponsorshipUncheckedCreateWithoutTenantsInput>
        >
        connectOrCreate?: Enumerable<Orphan_sponsorshipCreateOrConnectWithoutTenantsInput>
        upsert?: Enumerable<Orphan_sponsorshipUpsertWithWhereUniqueWithoutTenantsInput>
        createMany?: Orphan_sponsorshipCreateManyTenantsInputEnvelope
        set?: Enumerable<Orphan_sponsorshipWhereUniqueInput>
        disconnect?: Enumerable<Orphan_sponsorshipWhereUniqueInput>
        delete?: Enumerable<Orphan_sponsorshipWhereUniqueInput>
        connect?: Enumerable<Orphan_sponsorshipWhereUniqueInput>
        update?: Enumerable<Orphan_sponsorshipUpdateWithWhereUniqueWithoutTenantsInput>
        updateMany?: Enumerable<Orphan_sponsorshipUpdateManyWithWhereWithoutTenantsInput>
        deleteMany?: Enumerable<Orphan_sponsorshipScalarWhereInput>
    }

    export type OrphansUpdateManyWithoutTenantsNestedInput = {
        create?: XOR<
            Enumerable<OrphansCreateWithoutTenantsInput>,
            Enumerable<OrphansUncheckedCreateWithoutTenantsInput>
        >
        connectOrCreate?: Enumerable<OrphansCreateOrConnectWithoutTenantsInput>
        upsert?: Enumerable<OrphansUpsertWithWhereUniqueWithoutTenantsInput>
        createMany?: OrphansCreateManyTenantsInputEnvelope
        set?: Enumerable<OrphansWhereUniqueInput>
        disconnect?: Enumerable<OrphansWhereUniqueInput>
        delete?: Enumerable<OrphansWhereUniqueInput>
        connect?: Enumerable<OrphansWhereUniqueInput>
        update?: Enumerable<OrphansUpdateWithWhereUniqueWithoutTenantsInput>
        updateMany?: Enumerable<OrphansUpdateManyWithWhereWithoutTenantsInput>
        deleteMany?: Enumerable<OrphansScalarWhereInput>
    }

    export type Second_sponsorsUpdateManyWithoutTenantsNestedInput = {
        create?: XOR<
            Enumerable<Second_sponsorsCreateWithoutTenantsInput>,
            Enumerable<Second_sponsorsUncheckedCreateWithoutTenantsInput>
        >
        connectOrCreate?: Enumerable<Second_sponsorsCreateOrConnectWithoutTenantsInput>
        upsert?: Enumerable<Second_sponsorsUpsertWithWhereUniqueWithoutTenantsInput>
        createMany?: Second_sponsorsCreateManyTenantsInputEnvelope
        set?: Enumerable<Second_sponsorsWhereUniqueInput>
        disconnect?: Enumerable<Second_sponsorsWhereUniqueInput>
        delete?: Enumerable<Second_sponsorsWhereUniqueInput>
        connect?: Enumerable<Second_sponsorsWhereUniqueInput>
        update?: Enumerable<Second_sponsorsUpdateWithWhereUniqueWithoutTenantsInput>
        updateMany?: Enumerable<Second_sponsorsUpdateManyWithWhereWithoutTenantsInput>
        deleteMany?: Enumerable<Second_sponsorsScalarWhereInput>
    }

    export type Sponsor_sponsorshipUpdateManyWithoutTenantsNestedInput = {
        create?: XOR<
            Enumerable<Sponsor_sponsorshipCreateWithoutTenantsInput>,
            Enumerable<Sponsor_sponsorshipUncheckedCreateWithoutTenantsInput>
        >
        connectOrCreate?: Enumerable<Sponsor_sponsorshipCreateOrConnectWithoutTenantsInput>
        upsert?: Enumerable<Sponsor_sponsorshipUpsertWithWhereUniqueWithoutTenantsInput>
        createMany?: Sponsor_sponsorshipCreateManyTenantsInputEnvelope
        set?: Enumerable<Sponsor_sponsorshipWhereUniqueInput>
        disconnect?: Enumerable<Sponsor_sponsorshipWhereUniqueInput>
        delete?: Enumerable<Sponsor_sponsorshipWhereUniqueInput>
        connect?: Enumerable<Sponsor_sponsorshipWhereUniqueInput>
        update?: Enumerable<Sponsor_sponsorshipUpdateWithWhereUniqueWithoutTenantsInput>
        updateMany?: Enumerable<Sponsor_sponsorshipUpdateManyWithWhereWithoutTenantsInput>
        deleteMany?: Enumerable<Sponsor_sponsorshipScalarWhereInput>
    }

    export type SponsorsUpdateManyWithoutTenantsNestedInput = {
        create?: XOR<
            Enumerable<SponsorsCreateWithoutTenantsInput>,
            Enumerable<SponsorsUncheckedCreateWithoutTenantsInput>
        >
        connectOrCreate?: Enumerable<SponsorsCreateOrConnectWithoutTenantsInput>
        upsert?: Enumerable<SponsorsUpsertWithWhereUniqueWithoutTenantsInput>
        createMany?: SponsorsCreateManyTenantsInputEnvelope
        set?: Enumerable<SponsorsWhereUniqueInput>
        disconnect?: Enumerable<SponsorsWhereUniqueInput>
        delete?: Enumerable<SponsorsWhereUniqueInput>
        connect?: Enumerable<SponsorsWhereUniqueInput>
        update?: Enumerable<SponsorsUpdateWithWhereUniqueWithoutTenantsInput>
        updateMany?: Enumerable<SponsorsUpdateManyWithWhereWithoutTenantsInput>
        deleteMany?: Enumerable<SponsorsScalarWhereInput>
    }

    export type SponsorshipsUpdateManyWithoutTenantsNestedInput = {
        create?: XOR<
            Enumerable<SponsorshipsCreateWithoutTenantsInput>,
            Enumerable<SponsorshipsUncheckedCreateWithoutTenantsInput>
        >
        connectOrCreate?: Enumerable<SponsorshipsCreateOrConnectWithoutTenantsInput>
        upsert?: Enumerable<SponsorshipsUpsertWithWhereUniqueWithoutTenantsInput>
        createMany?: SponsorshipsCreateManyTenantsInputEnvelope
        set?: Enumerable<SponsorshipsWhereUniqueInput>
        disconnect?: Enumerable<SponsorshipsWhereUniqueInput>
        delete?: Enumerable<SponsorshipsWhereUniqueInput>
        connect?: Enumerable<SponsorshipsWhereUniqueInput>
        update?: Enumerable<SponsorshipsUpdateWithWhereUniqueWithoutTenantsInput>
        updateMany?: Enumerable<SponsorshipsUpdateManyWithWhereWithoutTenantsInput>
        deleteMany?: Enumerable<SponsorshipsScalarWhereInput>
    }

    export type SpousesUpdateManyWithoutTenantsNestedInput = {
        create?: XOR<
            Enumerable<SpousesCreateWithoutTenantsInput>,
            Enumerable<SpousesUncheckedCreateWithoutTenantsInput>
        >
        connectOrCreate?: Enumerable<SpousesCreateOrConnectWithoutTenantsInput>
        upsert?: Enumerable<SpousesUpsertWithWhereUniqueWithoutTenantsInput>
        createMany?: SpousesCreateManyTenantsInputEnvelope
        set?: Enumerable<SpousesWhereUniqueInput>
        disconnect?: Enumerable<SpousesWhereUniqueInput>
        delete?: Enumerable<SpousesWhereUniqueInput>
        connect?: Enumerable<SpousesWhereUniqueInput>
        update?: Enumerable<SpousesUpdateWithWhereUniqueWithoutTenantsInput>
        updateMany?: Enumerable<SpousesUpdateManyWithWhereWithoutTenantsInput>
        deleteMany?: Enumerable<SpousesScalarWhereInput>
    }

    export type UsersUpdateManyWithoutTenantsNestedInput = {
        create?: XOR<Enumerable<UsersCreateWithoutTenantsInput>, Enumerable<UsersUncheckedCreateWithoutTenantsInput>>
        connectOrCreate?: Enumerable<UsersCreateOrConnectWithoutTenantsInput>
        upsert?: Enumerable<UsersUpsertWithWhereUniqueWithoutTenantsInput>
        createMany?: UsersCreateManyTenantsInputEnvelope
        set?: Enumerable<UsersWhereUniqueInput>
        disconnect?: Enumerable<UsersWhereUniqueInput>
        delete?: Enumerable<UsersWhereUniqueInput>
        connect?: Enumerable<UsersWhereUniqueInput>
        update?: Enumerable<UsersUpdateWithWhereUniqueWithoutTenantsInput>
        updateMany?: Enumerable<UsersUpdateManyWithWhereWithoutTenantsInput>
        deleteMany?: Enumerable<UsersScalarWhereInput>
    }

    export type BenefactorsUncheckedUpdateManyWithoutTenantsNestedInput = {
        create?: XOR<
            Enumerable<BenefactorsCreateWithoutTenantsInput>,
            Enumerable<BenefactorsUncheckedCreateWithoutTenantsInput>
        >
        connectOrCreate?: Enumerable<BenefactorsCreateOrConnectWithoutTenantsInput>
        upsert?: Enumerable<BenefactorsUpsertWithWhereUniqueWithoutTenantsInput>
        createMany?: BenefactorsCreateManyTenantsInputEnvelope
        set?: Enumerable<BenefactorsWhereUniqueInput>
        disconnect?: Enumerable<BenefactorsWhereUniqueInput>
        delete?: Enumerable<BenefactorsWhereUniqueInput>
        connect?: Enumerable<BenefactorsWhereUniqueInput>
        update?: Enumerable<BenefactorsUpdateWithWhereUniqueWithoutTenantsInput>
        updateMany?: Enumerable<BenefactorsUpdateManyWithWhereWithoutTenantsInput>
        deleteMany?: Enumerable<BenefactorsScalarWhereInput>
    }

    export type DomainsUncheckedUpdateManyWithoutTenantsNestedInput = {
        create?: XOR<
            Enumerable<DomainsCreateWithoutTenantsInput>,
            Enumerable<DomainsUncheckedCreateWithoutTenantsInput>
        >
        connectOrCreate?: Enumerable<DomainsCreateOrConnectWithoutTenantsInput>
        upsert?: Enumerable<DomainsUpsertWithWhereUniqueWithoutTenantsInput>
        createMany?: DomainsCreateManyTenantsInputEnvelope
        set?: Enumerable<DomainsWhereUniqueInput>
        disconnect?: Enumerable<DomainsWhereUniqueInput>
        delete?: Enumerable<DomainsWhereUniqueInput>
        connect?: Enumerable<DomainsWhereUniqueInput>
        update?: Enumerable<DomainsUpdateWithWhereUniqueWithoutTenantsInput>
        updateMany?: Enumerable<DomainsUpdateManyWithWhereWithoutTenantsInput>
        deleteMany?: Enumerable<DomainsScalarWhereInput>
    }

    export type FamiliesUncheckedUpdateManyWithoutTenantsNestedInput = {
        create?: XOR<
            Enumerable<FamiliesCreateWithoutTenantsInput>,
            Enumerable<FamiliesUncheckedCreateWithoutTenantsInput>
        >
        connectOrCreate?: Enumerable<FamiliesCreateOrConnectWithoutTenantsInput>
        upsert?: Enumerable<FamiliesUpsertWithWhereUniqueWithoutTenantsInput>
        createMany?: FamiliesCreateManyTenantsInputEnvelope
        set?: Enumerable<FamiliesWhereUniqueInput>
        disconnect?: Enumerable<FamiliesWhereUniqueInput>
        delete?: Enumerable<FamiliesWhereUniqueInput>
        connect?: Enumerable<FamiliesWhereUniqueInput>
        update?: Enumerable<FamiliesUpdateWithWhereUniqueWithoutTenantsInput>
        updateMany?: Enumerable<FamiliesUpdateManyWithWhereWithoutTenantsInput>
        deleteMany?: Enumerable<FamiliesScalarWhereInput>
    }

    export type Family_sponsorshipUncheckedUpdateManyWithoutTenantsNestedInput = {
        create?: XOR<
            Enumerable<Family_sponsorshipCreateWithoutTenantsInput>,
            Enumerable<Family_sponsorshipUncheckedCreateWithoutTenantsInput>
        >
        connectOrCreate?: Enumerable<Family_sponsorshipCreateOrConnectWithoutTenantsInput>
        upsert?: Enumerable<Family_sponsorshipUpsertWithWhereUniqueWithoutTenantsInput>
        createMany?: Family_sponsorshipCreateManyTenantsInputEnvelope
        set?: Enumerable<Family_sponsorshipWhereUniqueInput>
        disconnect?: Enumerable<Family_sponsorshipWhereUniqueInput>
        delete?: Enumerable<Family_sponsorshipWhereUniqueInput>
        connect?: Enumerable<Family_sponsorshipWhereUniqueInput>
        update?: Enumerable<Family_sponsorshipUpdateWithWhereUniqueWithoutTenantsInput>
        updateMany?: Enumerable<Family_sponsorshipUpdateManyWithWhereWithoutTenantsInput>
        deleteMany?: Enumerable<Family_sponsorshipScalarWhereInput>
    }

    export type Income_sponsorUncheckedUpdateManyWithoutTenantsNestedInput = {
        create?: XOR<
            Enumerable<Income_sponsorCreateWithoutTenantsInput>,
            Enumerable<Income_sponsorUncheckedCreateWithoutTenantsInput>
        >
        connectOrCreate?: Enumerable<Income_sponsorCreateOrConnectWithoutTenantsInput>
        upsert?: Enumerable<Income_sponsorUpsertWithWhereUniqueWithoutTenantsInput>
        createMany?: Income_sponsorCreateManyTenantsInputEnvelope
        set?: Enumerable<Income_sponsorWhereUniqueInput>
        disconnect?: Enumerable<Income_sponsorWhereUniqueInput>
        delete?: Enumerable<Income_sponsorWhereUniqueInput>
        connect?: Enumerable<Income_sponsorWhereUniqueInput>
        update?: Enumerable<Income_sponsorUpdateWithWhereUniqueWithoutTenantsInput>
        updateMany?: Enumerable<Income_sponsorUpdateManyWithWhereWithoutTenantsInput>
        deleteMany?: Enumerable<Income_sponsorScalarWhereInput>
    }

    export type Orphan_sponsorshipUncheckedUpdateManyWithoutTenantsNestedInput = {
        create?: XOR<
            Enumerable<Orphan_sponsorshipCreateWithoutTenantsInput>,
            Enumerable<Orphan_sponsorshipUncheckedCreateWithoutTenantsInput>
        >
        connectOrCreate?: Enumerable<Orphan_sponsorshipCreateOrConnectWithoutTenantsInput>
        upsert?: Enumerable<Orphan_sponsorshipUpsertWithWhereUniqueWithoutTenantsInput>
        createMany?: Orphan_sponsorshipCreateManyTenantsInputEnvelope
        set?: Enumerable<Orphan_sponsorshipWhereUniqueInput>
        disconnect?: Enumerable<Orphan_sponsorshipWhereUniqueInput>
        delete?: Enumerable<Orphan_sponsorshipWhereUniqueInput>
        connect?: Enumerable<Orphan_sponsorshipWhereUniqueInput>
        update?: Enumerable<Orphan_sponsorshipUpdateWithWhereUniqueWithoutTenantsInput>
        updateMany?: Enumerable<Orphan_sponsorshipUpdateManyWithWhereWithoutTenantsInput>
        deleteMany?: Enumerable<Orphan_sponsorshipScalarWhereInput>
    }

    export type OrphansUncheckedUpdateManyWithoutTenantsNestedInput = {
        create?: XOR<
            Enumerable<OrphansCreateWithoutTenantsInput>,
            Enumerable<OrphansUncheckedCreateWithoutTenantsInput>
        >
        connectOrCreate?: Enumerable<OrphansCreateOrConnectWithoutTenantsInput>
        upsert?: Enumerable<OrphansUpsertWithWhereUniqueWithoutTenantsInput>
        createMany?: OrphansCreateManyTenantsInputEnvelope
        set?: Enumerable<OrphansWhereUniqueInput>
        disconnect?: Enumerable<OrphansWhereUniqueInput>
        delete?: Enumerable<OrphansWhereUniqueInput>
        connect?: Enumerable<OrphansWhereUniqueInput>
        update?: Enumerable<OrphansUpdateWithWhereUniqueWithoutTenantsInput>
        updateMany?: Enumerable<OrphansUpdateManyWithWhereWithoutTenantsInput>
        deleteMany?: Enumerable<OrphansScalarWhereInput>
    }

    export type Second_sponsorsUncheckedUpdateManyWithoutTenantsNestedInput = {
        create?: XOR<
            Enumerable<Second_sponsorsCreateWithoutTenantsInput>,
            Enumerable<Second_sponsorsUncheckedCreateWithoutTenantsInput>
        >
        connectOrCreate?: Enumerable<Second_sponsorsCreateOrConnectWithoutTenantsInput>
        upsert?: Enumerable<Second_sponsorsUpsertWithWhereUniqueWithoutTenantsInput>
        createMany?: Second_sponsorsCreateManyTenantsInputEnvelope
        set?: Enumerable<Second_sponsorsWhereUniqueInput>
        disconnect?: Enumerable<Second_sponsorsWhereUniqueInput>
        delete?: Enumerable<Second_sponsorsWhereUniqueInput>
        connect?: Enumerable<Second_sponsorsWhereUniqueInput>
        update?: Enumerable<Second_sponsorsUpdateWithWhereUniqueWithoutTenantsInput>
        updateMany?: Enumerable<Second_sponsorsUpdateManyWithWhereWithoutTenantsInput>
        deleteMany?: Enumerable<Second_sponsorsScalarWhereInput>
    }

    export type Sponsor_sponsorshipUncheckedUpdateManyWithoutTenantsNestedInput = {
        create?: XOR<
            Enumerable<Sponsor_sponsorshipCreateWithoutTenantsInput>,
            Enumerable<Sponsor_sponsorshipUncheckedCreateWithoutTenantsInput>
        >
        connectOrCreate?: Enumerable<Sponsor_sponsorshipCreateOrConnectWithoutTenantsInput>
        upsert?: Enumerable<Sponsor_sponsorshipUpsertWithWhereUniqueWithoutTenantsInput>
        createMany?: Sponsor_sponsorshipCreateManyTenantsInputEnvelope
        set?: Enumerable<Sponsor_sponsorshipWhereUniqueInput>
        disconnect?: Enumerable<Sponsor_sponsorshipWhereUniqueInput>
        delete?: Enumerable<Sponsor_sponsorshipWhereUniqueInput>
        connect?: Enumerable<Sponsor_sponsorshipWhereUniqueInput>
        update?: Enumerable<Sponsor_sponsorshipUpdateWithWhereUniqueWithoutTenantsInput>
        updateMany?: Enumerable<Sponsor_sponsorshipUpdateManyWithWhereWithoutTenantsInput>
        deleteMany?: Enumerable<Sponsor_sponsorshipScalarWhereInput>
    }

    export type SponsorsUncheckedUpdateManyWithoutTenantsNestedInput = {
        create?: XOR<
            Enumerable<SponsorsCreateWithoutTenantsInput>,
            Enumerable<SponsorsUncheckedCreateWithoutTenantsInput>
        >
        connectOrCreate?: Enumerable<SponsorsCreateOrConnectWithoutTenantsInput>
        upsert?: Enumerable<SponsorsUpsertWithWhereUniqueWithoutTenantsInput>
        createMany?: SponsorsCreateManyTenantsInputEnvelope
        set?: Enumerable<SponsorsWhereUniqueInput>
        disconnect?: Enumerable<SponsorsWhereUniqueInput>
        delete?: Enumerable<SponsorsWhereUniqueInput>
        connect?: Enumerable<SponsorsWhereUniqueInput>
        update?: Enumerable<SponsorsUpdateWithWhereUniqueWithoutTenantsInput>
        updateMany?: Enumerable<SponsorsUpdateManyWithWhereWithoutTenantsInput>
        deleteMany?: Enumerable<SponsorsScalarWhereInput>
    }

    export type SponsorshipsUncheckedUpdateManyWithoutTenantsNestedInput = {
        create?: XOR<
            Enumerable<SponsorshipsCreateWithoutTenantsInput>,
            Enumerable<SponsorshipsUncheckedCreateWithoutTenantsInput>
        >
        connectOrCreate?: Enumerable<SponsorshipsCreateOrConnectWithoutTenantsInput>
        upsert?: Enumerable<SponsorshipsUpsertWithWhereUniqueWithoutTenantsInput>
        createMany?: SponsorshipsCreateManyTenantsInputEnvelope
        set?: Enumerable<SponsorshipsWhereUniqueInput>
        disconnect?: Enumerable<SponsorshipsWhereUniqueInput>
        delete?: Enumerable<SponsorshipsWhereUniqueInput>
        connect?: Enumerable<SponsorshipsWhereUniqueInput>
        update?: Enumerable<SponsorshipsUpdateWithWhereUniqueWithoutTenantsInput>
        updateMany?: Enumerable<SponsorshipsUpdateManyWithWhereWithoutTenantsInput>
        deleteMany?: Enumerable<SponsorshipsScalarWhereInput>
    }

    export type SpousesUncheckedUpdateManyWithoutTenantsNestedInput = {
        create?: XOR<
            Enumerable<SpousesCreateWithoutTenantsInput>,
            Enumerable<SpousesUncheckedCreateWithoutTenantsInput>
        >
        connectOrCreate?: Enumerable<SpousesCreateOrConnectWithoutTenantsInput>
        upsert?: Enumerable<SpousesUpsertWithWhereUniqueWithoutTenantsInput>
        createMany?: SpousesCreateManyTenantsInputEnvelope
        set?: Enumerable<SpousesWhereUniqueInput>
        disconnect?: Enumerable<SpousesWhereUniqueInput>
        delete?: Enumerable<SpousesWhereUniqueInput>
        connect?: Enumerable<SpousesWhereUniqueInput>
        update?: Enumerable<SpousesUpdateWithWhereUniqueWithoutTenantsInput>
        updateMany?: Enumerable<SpousesUpdateManyWithWhereWithoutTenantsInput>
        deleteMany?: Enumerable<SpousesScalarWhereInput>
    }

    export type UsersUncheckedUpdateManyWithoutTenantsNestedInput = {
        create?: XOR<Enumerable<UsersCreateWithoutTenantsInput>, Enumerable<UsersUncheckedCreateWithoutTenantsInput>>
        connectOrCreate?: Enumerable<UsersCreateOrConnectWithoutTenantsInput>
        upsert?: Enumerable<UsersUpsertWithWhereUniqueWithoutTenantsInput>
        createMany?: UsersCreateManyTenantsInputEnvelope
        set?: Enumerable<UsersWhereUniqueInput>
        disconnect?: Enumerable<UsersWhereUniqueInput>
        delete?: Enumerable<UsersWhereUniqueInput>
        connect?: Enumerable<UsersWhereUniqueInput>
        update?: Enumerable<UsersUpdateWithWhereUniqueWithoutTenantsInput>
        updateMany?: Enumerable<UsersUpdateManyWithWhereWithoutTenantsInput>
        deleteMany?: Enumerable<UsersScalarWhereInput>
    }

    export type OrphansCreateNestedManyWithoutUsers_orphans_created_byTousersInput = {
        create?: XOR<
            Enumerable<OrphansCreateWithoutUsers_orphans_created_byTousersInput>,
            Enumerable<OrphansUncheckedCreateWithoutUsers_orphans_created_byTousersInput>
        >
        connectOrCreate?: Enumerable<OrphansCreateOrConnectWithoutUsers_orphans_created_byTousersInput>
        createMany?: OrphansCreateManyUsers_orphans_created_byTousersInputEnvelope
        connect?: Enumerable<OrphansWhereUniqueInput>
    }

    export type OrphansCreateNestedManyWithoutUsers_orphans_deleted_byTousersInput = {
        create?: XOR<
            Enumerable<OrphansCreateWithoutUsers_orphans_deleted_byTousersInput>,
            Enumerable<OrphansUncheckedCreateWithoutUsers_orphans_deleted_byTousersInput>
        >
        connectOrCreate?: Enumerable<OrphansCreateOrConnectWithoutUsers_orphans_deleted_byTousersInput>
        createMany?: OrphansCreateManyUsers_orphans_deleted_byTousersInputEnvelope
        connect?: Enumerable<OrphansWhereUniqueInput>
    }

    export type SessionsCreateNestedManyWithoutUsersInput = {
        create?: XOR<Enumerable<SessionsCreateWithoutUsersInput>, Enumerable<SessionsUncheckedCreateWithoutUsersInput>>
        connectOrCreate?: Enumerable<SessionsCreateOrConnectWithoutUsersInput>
        createMany?: SessionsCreateManyUsersInputEnvelope
        connect?: Enumerable<SessionsWhereUniqueInput>
    }

    export type SettingsCreateNestedManyWithoutUsersInput = {
        create?: XOR<Enumerable<SettingsCreateWithoutUsersInput>, Enumerable<SettingsUncheckedCreateWithoutUsersInput>>
        connectOrCreate?: Enumerable<SettingsCreateOrConnectWithoutUsersInput>
        createMany?: SettingsCreateManyUsersInputEnvelope
        connect?: Enumerable<SettingsWhereUniqueInput>
    }

    export type SponsorsCreateNestedManyWithoutUsers_sponsors_created_byTousersInput = {
        create?: XOR<
            Enumerable<SponsorsCreateWithoutUsers_sponsors_created_byTousersInput>,
            Enumerable<SponsorsUncheckedCreateWithoutUsers_sponsors_created_byTousersInput>
        >
        connectOrCreate?: Enumerable<SponsorsCreateOrConnectWithoutUsers_sponsors_created_byTousersInput>
        createMany?: SponsorsCreateManyUsers_sponsors_created_byTousersInputEnvelope
        connect?: Enumerable<SponsorsWhereUniqueInput>
    }

    export type SponsorsCreateNestedManyWithoutUsers_sponsors_deleted_byTousersInput = {
        create?: XOR<
            Enumerable<SponsorsCreateWithoutUsers_sponsors_deleted_byTousersInput>,
            Enumerable<SponsorsUncheckedCreateWithoutUsers_sponsors_deleted_byTousersInput>
        >
        connectOrCreate?: Enumerable<SponsorsCreateOrConnectWithoutUsers_sponsors_deleted_byTousersInput>
        createMany?: SponsorsCreateManyUsers_sponsors_deleted_byTousersInputEnvelope
        connect?: Enumerable<SponsorsWhereUniqueInput>
    }

    export type TenantsCreateNestedOneWithoutUsersInput = {
        create?: XOR<TenantsCreateWithoutUsersInput, TenantsUncheckedCreateWithoutUsersInput>
        connectOrCreate?: TenantsCreateOrConnectWithoutUsersInput
        connect?: TenantsWhereUniqueInput
    }

    export type OrphansUncheckedCreateNestedManyWithoutUsers_orphans_created_byTousersInput = {
        create?: XOR<
            Enumerable<OrphansCreateWithoutUsers_orphans_created_byTousersInput>,
            Enumerable<OrphansUncheckedCreateWithoutUsers_orphans_created_byTousersInput>
        >
        connectOrCreate?: Enumerable<OrphansCreateOrConnectWithoutUsers_orphans_created_byTousersInput>
        createMany?: OrphansCreateManyUsers_orphans_created_byTousersInputEnvelope
        connect?: Enumerable<OrphansWhereUniqueInput>
    }

    export type OrphansUncheckedCreateNestedManyWithoutUsers_orphans_deleted_byTousersInput = {
        create?: XOR<
            Enumerable<OrphansCreateWithoutUsers_orphans_deleted_byTousersInput>,
            Enumerable<OrphansUncheckedCreateWithoutUsers_orphans_deleted_byTousersInput>
        >
        connectOrCreate?: Enumerable<OrphansCreateOrConnectWithoutUsers_orphans_deleted_byTousersInput>
        createMany?: OrphansCreateManyUsers_orphans_deleted_byTousersInputEnvelope
        connect?: Enumerable<OrphansWhereUniqueInput>
    }

    export type SessionsUncheckedCreateNestedManyWithoutUsersInput = {
        create?: XOR<Enumerable<SessionsCreateWithoutUsersInput>, Enumerable<SessionsUncheckedCreateWithoutUsersInput>>
        connectOrCreate?: Enumerable<SessionsCreateOrConnectWithoutUsersInput>
        createMany?: SessionsCreateManyUsersInputEnvelope
        connect?: Enumerable<SessionsWhereUniqueInput>
    }

    export type SettingsUncheckedCreateNestedManyWithoutUsersInput = {
        create?: XOR<Enumerable<SettingsCreateWithoutUsersInput>, Enumerable<SettingsUncheckedCreateWithoutUsersInput>>
        connectOrCreate?: Enumerable<SettingsCreateOrConnectWithoutUsersInput>
        createMany?: SettingsCreateManyUsersInputEnvelope
        connect?: Enumerable<SettingsWhereUniqueInput>
    }

    export type SponsorsUncheckedCreateNestedManyWithoutUsers_sponsors_created_byTousersInput = {
        create?: XOR<
            Enumerable<SponsorsCreateWithoutUsers_sponsors_created_byTousersInput>,
            Enumerable<SponsorsUncheckedCreateWithoutUsers_sponsors_created_byTousersInput>
        >
        connectOrCreate?: Enumerable<SponsorsCreateOrConnectWithoutUsers_sponsors_created_byTousersInput>
        createMany?: SponsorsCreateManyUsers_sponsors_created_byTousersInputEnvelope
        connect?: Enumerable<SponsorsWhereUniqueInput>
    }

    export type SponsorsUncheckedCreateNestedManyWithoutUsers_sponsors_deleted_byTousersInput = {
        create?: XOR<
            Enumerable<SponsorsCreateWithoutUsers_sponsors_deleted_byTousersInput>,
            Enumerable<SponsorsUncheckedCreateWithoutUsers_sponsors_deleted_byTousersInput>
        >
        connectOrCreate?: Enumerable<SponsorsCreateOrConnectWithoutUsers_sponsors_deleted_byTousersInput>
        createMany?: SponsorsCreateManyUsers_sponsors_deleted_byTousersInputEnvelope
        connect?: Enumerable<SponsorsWhereUniqueInput>
    }

    export type OrphansUpdateManyWithoutUsers_orphans_created_byTousersNestedInput = {
        create?: XOR<
            Enumerable<OrphansCreateWithoutUsers_orphans_created_byTousersInput>,
            Enumerable<OrphansUncheckedCreateWithoutUsers_orphans_created_byTousersInput>
        >
        connectOrCreate?: Enumerable<OrphansCreateOrConnectWithoutUsers_orphans_created_byTousersInput>
        upsert?: Enumerable<OrphansUpsertWithWhereUniqueWithoutUsers_orphans_created_byTousersInput>
        createMany?: OrphansCreateManyUsers_orphans_created_byTousersInputEnvelope
        set?: Enumerable<OrphansWhereUniqueInput>
        disconnect?: Enumerable<OrphansWhereUniqueInput>
        delete?: Enumerable<OrphansWhereUniqueInput>
        connect?: Enumerable<OrphansWhereUniqueInput>
        update?: Enumerable<OrphansUpdateWithWhereUniqueWithoutUsers_orphans_created_byTousersInput>
        updateMany?: Enumerable<OrphansUpdateManyWithWhereWithoutUsers_orphans_created_byTousersInput>
        deleteMany?: Enumerable<OrphansScalarWhereInput>
    }

    export type OrphansUpdateManyWithoutUsers_orphans_deleted_byTousersNestedInput = {
        create?: XOR<
            Enumerable<OrphansCreateWithoutUsers_orphans_deleted_byTousersInput>,
            Enumerable<OrphansUncheckedCreateWithoutUsers_orphans_deleted_byTousersInput>
        >
        connectOrCreate?: Enumerable<OrphansCreateOrConnectWithoutUsers_orphans_deleted_byTousersInput>
        upsert?: Enumerable<OrphansUpsertWithWhereUniqueWithoutUsers_orphans_deleted_byTousersInput>
        createMany?: OrphansCreateManyUsers_orphans_deleted_byTousersInputEnvelope
        set?: Enumerable<OrphansWhereUniqueInput>
        disconnect?: Enumerable<OrphansWhereUniqueInput>
        delete?: Enumerable<OrphansWhereUniqueInput>
        connect?: Enumerable<OrphansWhereUniqueInput>
        update?: Enumerable<OrphansUpdateWithWhereUniqueWithoutUsers_orphans_deleted_byTousersInput>
        updateMany?: Enumerable<OrphansUpdateManyWithWhereWithoutUsers_orphans_deleted_byTousersInput>
        deleteMany?: Enumerable<OrphansScalarWhereInput>
    }

    export type SessionsUpdateManyWithoutUsersNestedInput = {
        create?: XOR<Enumerable<SessionsCreateWithoutUsersInput>, Enumerable<SessionsUncheckedCreateWithoutUsersInput>>
        connectOrCreate?: Enumerable<SessionsCreateOrConnectWithoutUsersInput>
        upsert?: Enumerable<SessionsUpsertWithWhereUniqueWithoutUsersInput>
        createMany?: SessionsCreateManyUsersInputEnvelope
        set?: Enumerable<SessionsWhereUniqueInput>
        disconnect?: Enumerable<SessionsWhereUniqueInput>
        delete?: Enumerable<SessionsWhereUniqueInput>
        connect?: Enumerable<SessionsWhereUniqueInput>
        update?: Enumerable<SessionsUpdateWithWhereUniqueWithoutUsersInput>
        updateMany?: Enumerable<SessionsUpdateManyWithWhereWithoutUsersInput>
        deleteMany?: Enumerable<SessionsScalarWhereInput>
    }

    export type SettingsUpdateManyWithoutUsersNestedInput = {
        create?: XOR<Enumerable<SettingsCreateWithoutUsersInput>, Enumerable<SettingsUncheckedCreateWithoutUsersInput>>
        connectOrCreate?: Enumerable<SettingsCreateOrConnectWithoutUsersInput>
        upsert?: Enumerable<SettingsUpsertWithWhereUniqueWithoutUsersInput>
        createMany?: SettingsCreateManyUsersInputEnvelope
        set?: Enumerable<SettingsWhereUniqueInput>
        disconnect?: Enumerable<SettingsWhereUniqueInput>
        delete?: Enumerable<SettingsWhereUniqueInput>
        connect?: Enumerable<SettingsWhereUniqueInput>
        update?: Enumerable<SettingsUpdateWithWhereUniqueWithoutUsersInput>
        updateMany?: Enumerable<SettingsUpdateManyWithWhereWithoutUsersInput>
        deleteMany?: Enumerable<SettingsScalarWhereInput>
    }

    export type SponsorsUpdateManyWithoutUsers_sponsors_created_byTousersNestedInput = {
        create?: XOR<
            Enumerable<SponsorsCreateWithoutUsers_sponsors_created_byTousersInput>,
            Enumerable<SponsorsUncheckedCreateWithoutUsers_sponsors_created_byTousersInput>
        >
        connectOrCreate?: Enumerable<SponsorsCreateOrConnectWithoutUsers_sponsors_created_byTousersInput>
        upsert?: Enumerable<SponsorsUpsertWithWhereUniqueWithoutUsers_sponsors_created_byTousersInput>
        createMany?: SponsorsCreateManyUsers_sponsors_created_byTousersInputEnvelope
        set?: Enumerable<SponsorsWhereUniqueInput>
        disconnect?: Enumerable<SponsorsWhereUniqueInput>
        delete?: Enumerable<SponsorsWhereUniqueInput>
        connect?: Enumerable<SponsorsWhereUniqueInput>
        update?: Enumerable<SponsorsUpdateWithWhereUniqueWithoutUsers_sponsors_created_byTousersInput>
        updateMany?: Enumerable<SponsorsUpdateManyWithWhereWithoutUsers_sponsors_created_byTousersInput>
        deleteMany?: Enumerable<SponsorsScalarWhereInput>
    }

    export type SponsorsUpdateManyWithoutUsers_sponsors_deleted_byTousersNestedInput = {
        create?: XOR<
            Enumerable<SponsorsCreateWithoutUsers_sponsors_deleted_byTousersInput>,
            Enumerable<SponsorsUncheckedCreateWithoutUsers_sponsors_deleted_byTousersInput>
        >
        connectOrCreate?: Enumerable<SponsorsCreateOrConnectWithoutUsers_sponsors_deleted_byTousersInput>
        upsert?: Enumerable<SponsorsUpsertWithWhereUniqueWithoutUsers_sponsors_deleted_byTousersInput>
        createMany?: SponsorsCreateManyUsers_sponsors_deleted_byTousersInputEnvelope
        set?: Enumerable<SponsorsWhereUniqueInput>
        disconnect?: Enumerable<SponsorsWhereUniqueInput>
        delete?: Enumerable<SponsorsWhereUniqueInput>
        connect?: Enumerable<SponsorsWhereUniqueInput>
        update?: Enumerable<SponsorsUpdateWithWhereUniqueWithoutUsers_sponsors_deleted_byTousersInput>
        updateMany?: Enumerable<SponsorsUpdateManyWithWhereWithoutUsers_sponsors_deleted_byTousersInput>
        deleteMany?: Enumerable<SponsorsScalarWhereInput>
    }

    export type TenantsUpdateOneRequiredWithoutUsersNestedInput = {
        create?: XOR<TenantsCreateWithoutUsersInput, TenantsUncheckedCreateWithoutUsersInput>
        connectOrCreate?: TenantsCreateOrConnectWithoutUsersInput
        upsert?: TenantsUpsertWithoutUsersInput
        connect?: TenantsWhereUniqueInput
        update?: XOR<TenantsUpdateWithoutUsersInput, TenantsUncheckedUpdateWithoutUsersInput>
    }

    export type OrphansUncheckedUpdateManyWithoutUsers_orphans_created_byTousersNestedInput = {
        create?: XOR<
            Enumerable<OrphansCreateWithoutUsers_orphans_created_byTousersInput>,
            Enumerable<OrphansUncheckedCreateWithoutUsers_orphans_created_byTousersInput>
        >
        connectOrCreate?: Enumerable<OrphansCreateOrConnectWithoutUsers_orphans_created_byTousersInput>
        upsert?: Enumerable<OrphansUpsertWithWhereUniqueWithoutUsers_orphans_created_byTousersInput>
        createMany?: OrphansCreateManyUsers_orphans_created_byTousersInputEnvelope
        set?: Enumerable<OrphansWhereUniqueInput>
        disconnect?: Enumerable<OrphansWhereUniqueInput>
        delete?: Enumerable<OrphansWhereUniqueInput>
        connect?: Enumerable<OrphansWhereUniqueInput>
        update?: Enumerable<OrphansUpdateWithWhereUniqueWithoutUsers_orphans_created_byTousersInput>
        updateMany?: Enumerable<OrphansUpdateManyWithWhereWithoutUsers_orphans_created_byTousersInput>
        deleteMany?: Enumerable<OrphansScalarWhereInput>
    }

    export type OrphansUncheckedUpdateManyWithoutUsers_orphans_deleted_byTousersNestedInput = {
        create?: XOR<
            Enumerable<OrphansCreateWithoutUsers_orphans_deleted_byTousersInput>,
            Enumerable<OrphansUncheckedCreateWithoutUsers_orphans_deleted_byTousersInput>
        >
        connectOrCreate?: Enumerable<OrphansCreateOrConnectWithoutUsers_orphans_deleted_byTousersInput>
        upsert?: Enumerable<OrphansUpsertWithWhereUniqueWithoutUsers_orphans_deleted_byTousersInput>
        createMany?: OrphansCreateManyUsers_orphans_deleted_byTousersInputEnvelope
        set?: Enumerable<OrphansWhereUniqueInput>
        disconnect?: Enumerable<OrphansWhereUniqueInput>
        delete?: Enumerable<OrphansWhereUniqueInput>
        connect?: Enumerable<OrphansWhereUniqueInput>
        update?: Enumerable<OrphansUpdateWithWhereUniqueWithoutUsers_orphans_deleted_byTousersInput>
        updateMany?: Enumerable<OrphansUpdateManyWithWhereWithoutUsers_orphans_deleted_byTousersInput>
        deleteMany?: Enumerable<OrphansScalarWhereInput>
    }

    export type SessionsUncheckedUpdateManyWithoutUsersNestedInput = {
        create?: XOR<Enumerable<SessionsCreateWithoutUsersInput>, Enumerable<SessionsUncheckedCreateWithoutUsersInput>>
        connectOrCreate?: Enumerable<SessionsCreateOrConnectWithoutUsersInput>
        upsert?: Enumerable<SessionsUpsertWithWhereUniqueWithoutUsersInput>
        createMany?: SessionsCreateManyUsersInputEnvelope
        set?: Enumerable<SessionsWhereUniqueInput>
        disconnect?: Enumerable<SessionsWhereUniqueInput>
        delete?: Enumerable<SessionsWhereUniqueInput>
        connect?: Enumerable<SessionsWhereUniqueInput>
        update?: Enumerable<SessionsUpdateWithWhereUniqueWithoutUsersInput>
        updateMany?: Enumerable<SessionsUpdateManyWithWhereWithoutUsersInput>
        deleteMany?: Enumerable<SessionsScalarWhereInput>
    }

    export type SettingsUncheckedUpdateManyWithoutUsersNestedInput = {
        create?: XOR<Enumerable<SettingsCreateWithoutUsersInput>, Enumerable<SettingsUncheckedCreateWithoutUsersInput>>
        connectOrCreate?: Enumerable<SettingsCreateOrConnectWithoutUsersInput>
        upsert?: Enumerable<SettingsUpsertWithWhereUniqueWithoutUsersInput>
        createMany?: SettingsCreateManyUsersInputEnvelope
        set?: Enumerable<SettingsWhereUniqueInput>
        disconnect?: Enumerable<SettingsWhereUniqueInput>
        delete?: Enumerable<SettingsWhereUniqueInput>
        connect?: Enumerable<SettingsWhereUniqueInput>
        update?: Enumerable<SettingsUpdateWithWhereUniqueWithoutUsersInput>
        updateMany?: Enumerable<SettingsUpdateManyWithWhereWithoutUsersInput>
        deleteMany?: Enumerable<SettingsScalarWhereInput>
    }

    export type SponsorsUncheckedUpdateManyWithoutUsers_sponsors_created_byTousersNestedInput = {
        create?: XOR<
            Enumerable<SponsorsCreateWithoutUsers_sponsors_created_byTousersInput>,
            Enumerable<SponsorsUncheckedCreateWithoutUsers_sponsors_created_byTousersInput>
        >
        connectOrCreate?: Enumerable<SponsorsCreateOrConnectWithoutUsers_sponsors_created_byTousersInput>
        upsert?: Enumerable<SponsorsUpsertWithWhereUniqueWithoutUsers_sponsors_created_byTousersInput>
        createMany?: SponsorsCreateManyUsers_sponsors_created_byTousersInputEnvelope
        set?: Enumerable<SponsorsWhereUniqueInput>
        disconnect?: Enumerable<SponsorsWhereUniqueInput>
        delete?: Enumerable<SponsorsWhereUniqueInput>
        connect?: Enumerable<SponsorsWhereUniqueInput>
        update?: Enumerable<SponsorsUpdateWithWhereUniqueWithoutUsers_sponsors_created_byTousersInput>
        updateMany?: Enumerable<SponsorsUpdateManyWithWhereWithoutUsers_sponsors_created_byTousersInput>
        deleteMany?: Enumerable<SponsorsScalarWhereInput>
    }

    export type SponsorsUncheckedUpdateManyWithoutUsers_sponsors_deleted_byTousersNestedInput = {
        create?: XOR<
            Enumerable<SponsorsCreateWithoutUsers_sponsors_deleted_byTousersInput>,
            Enumerable<SponsorsUncheckedCreateWithoutUsers_sponsors_deleted_byTousersInput>
        >
        connectOrCreate?: Enumerable<SponsorsCreateOrConnectWithoutUsers_sponsors_deleted_byTousersInput>
        upsert?: Enumerable<SponsorsUpsertWithWhereUniqueWithoutUsers_sponsors_deleted_byTousersInput>
        createMany?: SponsorsCreateManyUsers_sponsors_deleted_byTousersInputEnvelope
        set?: Enumerable<SponsorsWhereUniqueInput>
        disconnect?: Enumerable<SponsorsWhereUniqueInput>
        delete?: Enumerable<SponsorsWhereUniqueInput>
        connect?: Enumerable<SponsorsWhereUniqueInput>
        update?: Enumerable<SponsorsUpdateWithWhereUniqueWithoutUsers_sponsors_deleted_byTousersInput>
        updateMany?: Enumerable<SponsorsUpdateManyWithWhereWithoutUsers_sponsors_deleted_byTousersInput>
        deleteMany?: Enumerable<SponsorsScalarWhereInput>
    }

    export type NestedUuidFilter = {
        equals?: string
        in?: Enumerable<string>
        notIn?: Enumerable<string>
        lt?: string
        lte?: string
        gt?: string
        gte?: string
        not?: NestedUuidFilter | string
    }

    export type NestedStringFilter = {
        equals?: string
        in?: Enumerable<string>
        notIn?: Enumerable<string>
        lt?: string
        lte?: string
        gt?: string
        gte?: string
        contains?: string
        startsWith?: string
        endsWith?: string
        not?: NestedStringFilter | string
    }

    export type NestedDateTimeNullableFilter = {
        equals?: Date | string | null
        in?: Enumerable<Date> | Enumerable<string> | null
        notIn?: Enumerable<Date> | Enumerable<string> | null
        lt?: Date | string
        lte?: Date | string
        gt?: Date | string
        gte?: Date | string
        not?: NestedDateTimeNullableFilter | Date | string | null
    }

    export type NestedUuidWithAggregatesFilter = {
        equals?: string
        in?: Enumerable<string>
        notIn?: Enumerable<string>
        lt?: string
        lte?: string
        gt?: string
        gte?: string
        not?: NestedUuidWithAggregatesFilter | string
        _count?: NestedIntFilter
        _min?: NestedStringFilter
        _max?: NestedStringFilter
    }

    export type NestedIntFilter = {
        equals?: number
        in?: Enumerable<number>
        notIn?: Enumerable<number>
        lt?: number
        lte?: number
        gt?: number
        gte?: number
        not?: NestedIntFilter | number
    }

    export type NestedStringWithAggregatesFilter = {
        equals?: string
        in?: Enumerable<string>
        notIn?: Enumerable<string>
        lt?: string
        lte?: string
        gt?: string
        gte?: string
        contains?: string
        startsWith?: string
        endsWith?: string
        not?: NestedStringWithAggregatesFilter | string
        _count?: NestedIntFilter
        _min?: NestedStringFilter
        _max?: NestedStringFilter
    }

    export type NestedDateTimeNullableWithAggregatesFilter = {
        equals?: Date | string | null
        in?: Enumerable<Date> | Enumerable<string> | null
        notIn?: Enumerable<Date> | Enumerable<string> | null
        lt?: Date | string
        lte?: Date | string
        gt?: Date | string
        gte?: Date | string
        not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
        _count?: NestedIntNullableFilter
        _min?: NestedDateTimeNullableFilter
        _max?: NestedDateTimeNullableFilter
    }

    export type NestedIntNullableFilter = {
        equals?: number | null
        in?: Enumerable<number> | null
        notIn?: Enumerable<number> | null
        lt?: number
        lte?: number
        gt?: number
        gte?: number
        not?: NestedIntNullableFilter | number | null
    }

    export type NestedIntWithAggregatesFilter = {
        equals?: number
        in?: Enumerable<number>
        notIn?: Enumerable<number>
        lt?: number
        lte?: number
        gt?: number
        gte?: number
        not?: NestedIntWithAggregatesFilter | number
        _count?: NestedIntFilter
        _avg?: NestedFloatFilter
        _sum?: NestedIntFilter
        _min?: NestedIntFilter
        _max?: NestedIntFilter
    }

    export type NestedFloatFilter = {
        equals?: number
        in?: Enumerable<number>
        notIn?: Enumerable<number>
        lt?: number
        lte?: number
        gt?: number
        gte?: number
        not?: NestedFloatFilter | number
    }

    export type NestedEnumfamily_sponsorship_typeFilter = {
        equals?: family_sponsorship_type
        in?: Enumerable<family_sponsorship_type>
        notIn?: Enumerable<family_sponsorship_type>
        not?: NestedEnumfamily_sponsorship_typeFilter | family_sponsorship_type
    }

    export type NestedEnumfamily_sponsorship_typeWithAggregatesFilter = {
        equals?: family_sponsorship_type
        in?: Enumerable<family_sponsorship_type>
        notIn?: Enumerable<family_sponsorship_type>
        not?: NestedEnumfamily_sponsorship_typeWithAggregatesFilter | family_sponsorship_type
        _count?: NestedIntFilter
        _min?: NestedEnumfamily_sponsorship_typeFilter
        _max?: NestedEnumfamily_sponsorship_typeFilter
    }

    export type NestedFloatWithAggregatesFilter = {
        equals?: number
        in?: Enumerable<number>
        notIn?: Enumerable<number>
        lt?: number
        lte?: number
        gt?: number
        gte?: number
        not?: NestedFloatWithAggregatesFilter | number
        _count?: NestedIntFilter
        _avg?: NestedFloatFilter
        _sum?: NestedFloatFilter
        _min?: NestedFloatFilter
        _max?: NestedFloatFilter
    }

    export type NestedBigIntFilter = {
        equals?: bigint | number
        in?: Enumerable<bigint> | Enumerable<number>
        notIn?: Enumerable<bigint> | Enumerable<number>
        lt?: bigint | number
        lte?: bigint | number
        gt?: bigint | number
        gte?: bigint | number
        not?: NestedBigIntFilter | bigint | number
    }

    export type NestedUuidNullableFilter = {
        equals?: string | null
        in?: Enumerable<string> | null
        notIn?: Enumerable<string> | null
        lt?: string
        lte?: string
        gt?: string
        gte?: string
        not?: NestedUuidNullableFilter | string | null
    }

    export type NestedStringNullableFilter = {
        equals?: string | null
        in?: Enumerable<string> | null
        notIn?: Enumerable<string> | null
        lt?: string
        lte?: string
        gt?: string
        gte?: string
        contains?: string
        startsWith?: string
        endsWith?: string
        not?: NestedStringNullableFilter | string | null
    }

    export type NestedBigIntWithAggregatesFilter = {
        equals?: bigint | number
        in?: Enumerable<bigint> | Enumerable<number>
        notIn?: Enumerable<bigint> | Enumerable<number>
        lt?: bigint | number
        lte?: bigint | number
        gt?: bigint | number
        gte?: bigint | number
        not?: NestedBigIntWithAggregatesFilter | bigint | number
        _count?: NestedIntFilter
        _avg?: NestedFloatFilter
        _sum?: NestedBigIntFilter
        _min?: NestedBigIntFilter
        _max?: NestedBigIntFilter
    }

    export type NestedUuidNullableWithAggregatesFilter = {
        equals?: string | null
        in?: Enumerable<string> | null
        notIn?: Enumerable<string> | null
        lt?: string
        lte?: string
        gt?: string
        gte?: string
        not?: NestedUuidNullableWithAggregatesFilter | string | null
        _count?: NestedIntNullableFilter
        _min?: NestedStringNullableFilter
        _max?: NestedStringNullableFilter
    }

    export type NestedStringNullableWithAggregatesFilter = {
        equals?: string | null
        in?: Enumerable<string> | null
        notIn?: Enumerable<string> | null
        lt?: string
        lte?: string
        gt?: string
        gte?: string
        contains?: string
        startsWith?: string
        endsWith?: string
        not?: NestedStringNullableWithAggregatesFilter | string | null
        _count?: NestedIntNullableFilter
        _min?: NestedStringNullableFilter
        _max?: NestedStringNullableFilter
    }
    export type NestedJsonFilter =
        | PatchUndefined<
              Either<Required<NestedJsonFilterBase>, Exclude<keyof Required<NestedJsonFilterBase>, 'path'>>,
              Required<NestedJsonFilterBase>
          >
        | OptionalFlat<Omit<Required<NestedJsonFilterBase>, 'path'>>

    export type NestedJsonFilterBase = {
        equals?: InputJsonValue | JsonNullValueFilter
        path?: Array<string>
        string_contains?: string
        string_starts_with?: string
        string_ends_with?: string
        array_contains?: InputJsonValue | null
        array_starts_with?: InputJsonValue | null
        array_ends_with?: InputJsonValue | null
        lt?: InputJsonValue
        lte?: InputJsonValue
        gt?: InputJsonValue
        gte?: InputJsonValue
        not?: InputJsonValue | JsonNullValueFilter
    }

    export type NestedIntNullableWithAggregatesFilter = {
        equals?: number | null
        in?: Enumerable<number> | null
        notIn?: Enumerable<number> | null
        lt?: number
        lte?: number
        gt?: number
        gte?: number
        not?: NestedIntNullableWithAggregatesFilter | number | null
        _count?: NestedIntNullableFilter
        _avg?: NestedFloatNullableFilter
        _sum?: NestedIntNullableFilter
        _min?: NestedIntNullableFilter
        _max?: NestedIntNullableFilter
    }

    export type NestedFloatNullableFilter = {
        equals?: number | null
        in?: Enumerable<number> | null
        notIn?: Enumerable<number> | null
        lt?: number
        lte?: number
        gt?: number
        gte?: number
        not?: NestedFloatNullableFilter | number | null
    }

    export type NestedEnumorphan_sponsorship_typeFilter = {
        equals?: orphan_sponsorship_type
        in?: Enumerable<orphan_sponsorship_type>
        notIn?: Enumerable<orphan_sponsorship_type>
        not?: NestedEnumorphan_sponsorship_typeFilter | orphan_sponsorship_type
    }

    export type NestedEnumorphan_sponsorship_typeWithAggregatesFilter = {
        equals?: orphan_sponsorship_type
        in?: Enumerable<orphan_sponsorship_type>
        notIn?: Enumerable<orphan_sponsorship_type>
        not?: NestedEnumorphan_sponsorship_typeWithAggregatesFilter | orphan_sponsorship_type
        _count?: NestedIntFilter
        _min?: NestedEnumorphan_sponsorship_typeFilter
        _max?: NestedEnumorphan_sponsorship_typeFilter
    }

    export type NestedDateTimeFilter = {
        equals?: Date | string
        in?: Enumerable<Date> | Enumerable<string>
        notIn?: Enumerable<Date> | Enumerable<string>
        lt?: Date | string
        lte?: Date | string
        gt?: Date | string
        gte?: Date | string
        not?: NestedDateTimeFilter | Date | string
    }

    export type NestedDateTimeWithAggregatesFilter = {
        equals?: Date | string
        in?: Enumerable<Date> | Enumerable<string>
        notIn?: Enumerable<Date> | Enumerable<string>
        lt?: Date | string
        lte?: Date | string
        gt?: Date | string
        gte?: Date | string
        not?: NestedDateTimeWithAggregatesFilter | Date | string
        _count?: NestedIntFilter
        _min?: NestedDateTimeFilter
        _max?: NestedDateTimeFilter
    }

    export type NestedEnumthemeFilter = {
        equals?: theme
        in?: Enumerable<theme>
        notIn?: Enumerable<theme>
        not?: NestedEnumthemeFilter | theme
    }

    export type NestedEnumcolor_schemeFilter = {
        equals?: color_scheme
        in?: Enumerable<color_scheme>
        notIn?: Enumerable<color_scheme>
        not?: NestedEnumcolor_schemeFilter | color_scheme
    }

    export type NestedEnumlayoutFilter = {
        equals?: layout
        in?: Enumerable<layout>
        notIn?: Enumerable<layout>
        not?: NestedEnumlayoutFilter | layout
    }

    export type NestedEnumappearanceFilter = {
        equals?: appearance
        in?: Enumerable<appearance>
        notIn?: Enumerable<appearance>
        not?: NestedEnumappearanceFilter | appearance
    }

    export type NestedEnumthemeWithAggregatesFilter = {
        equals?: theme
        in?: Enumerable<theme>
        notIn?: Enumerable<theme>
        not?: NestedEnumthemeWithAggregatesFilter | theme
        _count?: NestedIntFilter
        _min?: NestedEnumthemeFilter
        _max?: NestedEnumthemeFilter
    }

    export type NestedEnumcolor_schemeWithAggregatesFilter = {
        equals?: color_scheme
        in?: Enumerable<color_scheme>
        notIn?: Enumerable<color_scheme>
        not?: NestedEnumcolor_schemeWithAggregatesFilter | color_scheme
        _count?: NestedIntFilter
        _min?: NestedEnumcolor_schemeFilter
        _max?: NestedEnumcolor_schemeFilter
    }

    export type NestedEnumlayoutWithAggregatesFilter = {
        equals?: layout
        in?: Enumerable<layout>
        notIn?: Enumerable<layout>
        not?: NestedEnumlayoutWithAggregatesFilter | layout
        _count?: NestedIntFilter
        _min?: NestedEnumlayoutFilter
        _max?: NestedEnumlayoutFilter
    }

    export type NestedEnumappearanceWithAggregatesFilter = {
        equals?: appearance
        in?: Enumerable<appearance>
        notIn?: Enumerable<appearance>
        not?: NestedEnumappearanceWithAggregatesFilter | appearance
        _count?: NestedIntFilter
        _min?: NestedEnumappearanceFilter
        _max?: NestedEnumappearanceFilter
    }
    export type NestedJsonNullableFilter =
        | PatchUndefined<
              Either<
                  Required<NestedJsonNullableFilterBase>,
                  Exclude<keyof Required<NestedJsonNullableFilterBase>, 'path'>
              >,
              Required<NestedJsonNullableFilterBase>
          >
        | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase>, 'path'>>

    export type NestedJsonNullableFilterBase = {
        equals?: InputJsonValue | JsonNullValueFilter
        path?: Array<string>
        string_contains?: string
        string_starts_with?: string
        string_ends_with?: string
        array_contains?: InputJsonValue | null
        array_starts_with?: InputJsonValue | null
        array_ends_with?: InputJsonValue | null
        lt?: InputJsonValue
        lte?: InputJsonValue
        gt?: InputJsonValue
        gte?: InputJsonValue
        not?: InputJsonValue | JsonNullValueFilter
    }

    export type NestedEnumsponsor_sponsorship_typeFilter = {
        equals?: sponsor_sponsorship_type
        in?: Enumerable<sponsor_sponsorship_type>
        notIn?: Enumerable<sponsor_sponsorship_type>
        not?: NestedEnumsponsor_sponsorship_typeFilter | sponsor_sponsorship_type
    }

    export type NestedEnumsponsor_sponsorship_typeWithAggregatesFilter = {
        equals?: sponsor_sponsorship_type
        in?: Enumerable<sponsor_sponsorship_type>
        notIn?: Enumerable<sponsor_sponsorship_type>
        not?: NestedEnumsponsor_sponsorship_typeWithAggregatesFilter | sponsor_sponsorship_type
        _count?: NestedIntFilter
        _min?: NestedEnumsponsor_sponsorship_typeFilter
        _max?: NestedEnumsponsor_sponsorship_typeFilter
    }

    export type NestedEnumsponsorship_typeFilter = {
        equals?: sponsorship_type
        in?: Enumerable<sponsorship_type>
        notIn?: Enumerable<sponsorship_type>
        not?: NestedEnumsponsorship_typeFilter | sponsorship_type
    }

    export type NestedEnumsponsorship_typeWithAggregatesFilter = {
        equals?: sponsorship_type
        in?: Enumerable<sponsorship_type>
        notIn?: Enumerable<sponsorship_type>
        not?: NestedEnumsponsorship_typeWithAggregatesFilter | sponsorship_type
        _count?: NestedIntFilter
        _min?: NestedEnumsponsorship_typeFilter
        _max?: NestedEnumsponsorship_typeFilter
    }

    export type TenantsCreateWithoutBenefactorsInput = {
        id: string
        data?: NullableJsonNullValueInput | InputJsonValue
        created_at?: Date | string | null
        updated_at?: Date | string | null
        domains?: DomainsCreateNestedManyWithoutTenantsInput
        families?: FamiliesCreateNestedManyWithoutTenantsInput
        family_sponsorship?: Family_sponsorshipCreateNestedManyWithoutTenantsInput
        income_sponsor?: Income_sponsorCreateNestedManyWithoutTenantsInput
        orphan_sponsorship?: Orphan_sponsorshipCreateNestedManyWithoutTenantsInput
        orphans?: OrphansCreateNestedManyWithoutTenantsInput
        second_sponsors?: Second_sponsorsCreateNestedManyWithoutTenantsInput
        sponsor_sponsorship?: Sponsor_sponsorshipCreateNestedManyWithoutTenantsInput
        sponsors?: SponsorsCreateNestedManyWithoutTenantsInput
        sponsorships?: SponsorshipsCreateNestedManyWithoutTenantsInput
        spouses?: SpousesCreateNestedManyWithoutTenantsInput
        users?: UsersCreateNestedManyWithoutTenantsInput
    }

    export type TenantsUncheckedCreateWithoutBenefactorsInput = {
        id: string
        data?: NullableJsonNullValueInput | InputJsonValue
        created_at?: Date | string | null
        updated_at?: Date | string | null
        domains?: DomainsUncheckedCreateNestedManyWithoutTenantsInput
        families?: FamiliesUncheckedCreateNestedManyWithoutTenantsInput
        family_sponsorship?: Family_sponsorshipUncheckedCreateNestedManyWithoutTenantsInput
        income_sponsor?: Income_sponsorUncheckedCreateNestedManyWithoutTenantsInput
        orphan_sponsorship?: Orphan_sponsorshipUncheckedCreateNestedManyWithoutTenantsInput
        orphans?: OrphansUncheckedCreateNestedManyWithoutTenantsInput
        second_sponsors?: Second_sponsorsUncheckedCreateNestedManyWithoutTenantsInput
        sponsor_sponsorship?: Sponsor_sponsorshipUncheckedCreateNestedManyWithoutTenantsInput
        sponsors?: SponsorsUncheckedCreateNestedManyWithoutTenantsInput
        sponsorships?: SponsorshipsUncheckedCreateNestedManyWithoutTenantsInput
        spouses?: SpousesUncheckedCreateNestedManyWithoutTenantsInput
        users?: UsersUncheckedCreateNestedManyWithoutTenantsInput
    }

    export type TenantsCreateOrConnectWithoutBenefactorsInput = {
        where: TenantsWhereUniqueInput
        create: XOR<TenantsCreateWithoutBenefactorsInput, TenantsUncheckedCreateWithoutBenefactorsInput>
    }

    export type TenantsUpsertWithoutBenefactorsInput = {
        update: XOR<TenantsUpdateWithoutBenefactorsInput, TenantsUncheckedUpdateWithoutBenefactorsInput>
        create: XOR<TenantsCreateWithoutBenefactorsInput, TenantsUncheckedCreateWithoutBenefactorsInput>
    }

    export type TenantsUpdateWithoutBenefactorsInput = {
        id?: StringFieldUpdateOperationsInput | string
        data?: NullableJsonNullValueInput | InputJsonValue
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        domains?: DomainsUpdateManyWithoutTenantsNestedInput
        families?: FamiliesUpdateManyWithoutTenantsNestedInput
        family_sponsorship?: Family_sponsorshipUpdateManyWithoutTenantsNestedInput
        income_sponsor?: Income_sponsorUpdateManyWithoutTenantsNestedInput
        orphan_sponsorship?: Orphan_sponsorshipUpdateManyWithoutTenantsNestedInput
        orphans?: OrphansUpdateManyWithoutTenantsNestedInput
        second_sponsors?: Second_sponsorsUpdateManyWithoutTenantsNestedInput
        sponsor_sponsorship?: Sponsor_sponsorshipUpdateManyWithoutTenantsNestedInput
        sponsors?: SponsorsUpdateManyWithoutTenantsNestedInput
        sponsorships?: SponsorshipsUpdateManyWithoutTenantsNestedInput
        spouses?: SpousesUpdateManyWithoutTenantsNestedInput
        users?: UsersUpdateManyWithoutTenantsNestedInput
    }

    export type TenantsUncheckedUpdateWithoutBenefactorsInput = {
        id?: StringFieldUpdateOperationsInput | string
        data?: NullableJsonNullValueInput | InputJsonValue
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        domains?: DomainsUncheckedUpdateManyWithoutTenantsNestedInput
        families?: FamiliesUncheckedUpdateManyWithoutTenantsNestedInput
        family_sponsorship?: Family_sponsorshipUncheckedUpdateManyWithoutTenantsNestedInput
        income_sponsor?: Income_sponsorUncheckedUpdateManyWithoutTenantsNestedInput
        orphan_sponsorship?: Orphan_sponsorshipUncheckedUpdateManyWithoutTenantsNestedInput
        orphans?: OrphansUncheckedUpdateManyWithoutTenantsNestedInput
        second_sponsors?: Second_sponsorsUncheckedUpdateManyWithoutTenantsNestedInput
        sponsor_sponsorship?: Sponsor_sponsorshipUncheckedUpdateManyWithoutTenantsNestedInput
        sponsors?: SponsorsUncheckedUpdateManyWithoutTenantsNestedInput
        sponsorships?: SponsorshipsUncheckedUpdateManyWithoutTenantsNestedInput
        spouses?: SpousesUncheckedUpdateManyWithoutTenantsNestedInput
        users?: UsersUncheckedUpdateManyWithoutTenantsNestedInput
    }

    export type TenantsCreateWithoutDomainsInput = {
        id: string
        data?: NullableJsonNullValueInput | InputJsonValue
        created_at?: Date | string | null
        updated_at?: Date | string | null
        benefactors?: BenefactorsCreateNestedManyWithoutTenantsInput
        families?: FamiliesCreateNestedManyWithoutTenantsInput
        family_sponsorship?: Family_sponsorshipCreateNestedManyWithoutTenantsInput
        income_sponsor?: Income_sponsorCreateNestedManyWithoutTenantsInput
        orphan_sponsorship?: Orphan_sponsorshipCreateNestedManyWithoutTenantsInput
        orphans?: OrphansCreateNestedManyWithoutTenantsInput
        second_sponsors?: Second_sponsorsCreateNestedManyWithoutTenantsInput
        sponsor_sponsorship?: Sponsor_sponsorshipCreateNestedManyWithoutTenantsInput
        sponsors?: SponsorsCreateNestedManyWithoutTenantsInput
        sponsorships?: SponsorshipsCreateNestedManyWithoutTenantsInput
        spouses?: SpousesCreateNestedManyWithoutTenantsInput
        users?: UsersCreateNestedManyWithoutTenantsInput
    }

    export type TenantsUncheckedCreateWithoutDomainsInput = {
        id: string
        data?: NullableJsonNullValueInput | InputJsonValue
        created_at?: Date | string | null
        updated_at?: Date | string | null
        benefactors?: BenefactorsUncheckedCreateNestedManyWithoutTenantsInput
        families?: FamiliesUncheckedCreateNestedManyWithoutTenantsInput
        family_sponsorship?: Family_sponsorshipUncheckedCreateNestedManyWithoutTenantsInput
        income_sponsor?: Income_sponsorUncheckedCreateNestedManyWithoutTenantsInput
        orphan_sponsorship?: Orphan_sponsorshipUncheckedCreateNestedManyWithoutTenantsInput
        orphans?: OrphansUncheckedCreateNestedManyWithoutTenantsInput
        second_sponsors?: Second_sponsorsUncheckedCreateNestedManyWithoutTenantsInput
        sponsor_sponsorship?: Sponsor_sponsorshipUncheckedCreateNestedManyWithoutTenantsInput
        sponsors?: SponsorsUncheckedCreateNestedManyWithoutTenantsInput
        sponsorships?: SponsorshipsUncheckedCreateNestedManyWithoutTenantsInput
        spouses?: SpousesUncheckedCreateNestedManyWithoutTenantsInput
        users?: UsersUncheckedCreateNestedManyWithoutTenantsInput
    }

    export type TenantsCreateOrConnectWithoutDomainsInput = {
        where: TenantsWhereUniqueInput
        create: XOR<TenantsCreateWithoutDomainsInput, TenantsUncheckedCreateWithoutDomainsInput>
    }

    export type TenantsUpsertWithoutDomainsInput = {
        update: XOR<TenantsUpdateWithoutDomainsInput, TenantsUncheckedUpdateWithoutDomainsInput>
        create: XOR<TenantsCreateWithoutDomainsInput, TenantsUncheckedCreateWithoutDomainsInput>
    }

    export type TenantsUpdateWithoutDomainsInput = {
        id?: StringFieldUpdateOperationsInput | string
        data?: NullableJsonNullValueInput | InputJsonValue
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        benefactors?: BenefactorsUpdateManyWithoutTenantsNestedInput
        families?: FamiliesUpdateManyWithoutTenantsNestedInput
        family_sponsorship?: Family_sponsorshipUpdateManyWithoutTenantsNestedInput
        income_sponsor?: Income_sponsorUpdateManyWithoutTenantsNestedInput
        orphan_sponsorship?: Orphan_sponsorshipUpdateManyWithoutTenantsNestedInput
        orphans?: OrphansUpdateManyWithoutTenantsNestedInput
        second_sponsors?: Second_sponsorsUpdateManyWithoutTenantsNestedInput
        sponsor_sponsorship?: Sponsor_sponsorshipUpdateManyWithoutTenantsNestedInput
        sponsors?: SponsorsUpdateManyWithoutTenantsNestedInput
        sponsorships?: SponsorshipsUpdateManyWithoutTenantsNestedInput
        spouses?: SpousesUpdateManyWithoutTenantsNestedInput
        users?: UsersUpdateManyWithoutTenantsNestedInput
    }

    export type TenantsUncheckedUpdateWithoutDomainsInput = {
        id?: StringFieldUpdateOperationsInput | string
        data?: NullableJsonNullValueInput | InputJsonValue
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        benefactors?: BenefactorsUncheckedUpdateManyWithoutTenantsNestedInput
        families?: FamiliesUncheckedUpdateManyWithoutTenantsNestedInput
        family_sponsorship?: Family_sponsorshipUncheckedUpdateManyWithoutTenantsNestedInput
        income_sponsor?: Income_sponsorUncheckedUpdateManyWithoutTenantsNestedInput
        orphan_sponsorship?: Orphan_sponsorshipUncheckedUpdateManyWithoutTenantsNestedInput
        orphans?: OrphansUncheckedUpdateManyWithoutTenantsNestedInput
        second_sponsors?: Second_sponsorsUncheckedUpdateManyWithoutTenantsNestedInput
        sponsor_sponsorship?: Sponsor_sponsorshipUncheckedUpdateManyWithoutTenantsNestedInput
        sponsors?: SponsorsUncheckedUpdateManyWithoutTenantsNestedInput
        sponsorships?: SponsorshipsUncheckedUpdateManyWithoutTenantsNestedInput
        spouses?: SpousesUncheckedUpdateManyWithoutTenantsNestedInput
        users?: UsersUncheckedUpdateManyWithoutTenantsNestedInput
    }

    export type TenantsCreateWithoutFamiliesInput = {
        id: string
        data?: NullableJsonNullValueInput | InputJsonValue
        created_at?: Date | string | null
        updated_at?: Date | string | null
        benefactors?: BenefactorsCreateNestedManyWithoutTenantsInput
        domains?: DomainsCreateNestedManyWithoutTenantsInput
        family_sponsorship?: Family_sponsorshipCreateNestedManyWithoutTenantsInput
        income_sponsor?: Income_sponsorCreateNestedManyWithoutTenantsInput
        orphan_sponsorship?: Orphan_sponsorshipCreateNestedManyWithoutTenantsInput
        orphans?: OrphansCreateNestedManyWithoutTenantsInput
        second_sponsors?: Second_sponsorsCreateNestedManyWithoutTenantsInput
        sponsor_sponsorship?: Sponsor_sponsorshipCreateNestedManyWithoutTenantsInput
        sponsors?: SponsorsCreateNestedManyWithoutTenantsInput
        sponsorships?: SponsorshipsCreateNestedManyWithoutTenantsInput
        spouses?: SpousesCreateNestedManyWithoutTenantsInput
        users?: UsersCreateNestedManyWithoutTenantsInput
    }

    export type TenantsUncheckedCreateWithoutFamiliesInput = {
        id: string
        data?: NullableJsonNullValueInput | InputJsonValue
        created_at?: Date | string | null
        updated_at?: Date | string | null
        benefactors?: BenefactorsUncheckedCreateNestedManyWithoutTenantsInput
        domains?: DomainsUncheckedCreateNestedManyWithoutTenantsInput
        family_sponsorship?: Family_sponsorshipUncheckedCreateNestedManyWithoutTenantsInput
        income_sponsor?: Income_sponsorUncheckedCreateNestedManyWithoutTenantsInput
        orphan_sponsorship?: Orphan_sponsorshipUncheckedCreateNestedManyWithoutTenantsInput
        orphans?: OrphansUncheckedCreateNestedManyWithoutTenantsInput
        second_sponsors?: Second_sponsorsUncheckedCreateNestedManyWithoutTenantsInput
        sponsor_sponsorship?: Sponsor_sponsorshipUncheckedCreateNestedManyWithoutTenantsInput
        sponsors?: SponsorsUncheckedCreateNestedManyWithoutTenantsInput
        sponsorships?: SponsorshipsUncheckedCreateNestedManyWithoutTenantsInput
        spouses?: SpousesUncheckedCreateNestedManyWithoutTenantsInput
        users?: UsersUncheckedCreateNestedManyWithoutTenantsInput
    }

    export type TenantsCreateOrConnectWithoutFamiliesInput = {
        where: TenantsWhereUniqueInput
        create: XOR<TenantsCreateWithoutFamiliesInput, TenantsUncheckedCreateWithoutFamiliesInput>
    }

    export type Family_furnishingCreateWithoutFamiliesInput = {
        id: string
        value: string
        furnishings: FurnishingsCreateNestedOneWithoutFamily_furnishingInput
    }

    export type Family_furnishingUncheckedCreateWithoutFamiliesInput = {
        id: string
        furnishing_id: string
        value: string
    }

    export type Family_furnishingCreateOrConnectWithoutFamiliesInput = {
        where: Family_furnishingWhereUniqueInput
        create: XOR<Family_furnishingCreateWithoutFamiliesInput, Family_furnishingUncheckedCreateWithoutFamiliesInput>
    }

    export type Family_furnishingCreateManyFamiliesInputEnvelope = {
        data: Enumerable<Family_furnishingCreateManyFamiliesInput>
        skipDuplicates?: boolean
    }

    export type Family_housingCreateWithoutFamiliesInput = {
        id: string
        value: string
        housings: HousingsCreateNestedOneWithoutFamily_housingInput
    }

    export type Family_housingUncheckedCreateWithoutFamiliesInput = {
        id: string
        housing_id: string
        value: string
    }

    export type Family_housingCreateOrConnectWithoutFamiliesInput = {
        where: Family_housingWhereUniqueInput
        create: XOR<Family_housingCreateWithoutFamiliesInput, Family_housingUncheckedCreateWithoutFamiliesInput>
    }

    export type Family_housingCreateManyFamiliesInputEnvelope = {
        data: Enumerable<Family_housingCreateManyFamiliesInput>
        skipDuplicates?: boolean
    }

    export type Family_sponsorshipCreateWithoutFamiliesInput = {
        id: string
        type: family_sponsorship_type
        value: string
        created_at?: Date | string | null
        updated_at?: Date | string | null
        tenants: TenantsCreateNestedOneWithoutFamily_sponsorshipInput
    }

    export type Family_sponsorshipUncheckedCreateWithoutFamiliesInput = {
        id: string
        type: family_sponsorship_type
        value: string
        tenant_id: string
        created_at?: Date | string | null
        updated_at?: Date | string | null
    }

    export type Family_sponsorshipCreateOrConnectWithoutFamiliesInput = {
        where: Family_sponsorshipWhereUniqueInput
        create: XOR<Family_sponsorshipCreateWithoutFamiliesInput, Family_sponsorshipUncheckedCreateWithoutFamiliesInput>
    }

    export type Family_sponsorshipCreateManyFamiliesInputEnvelope = {
        data: Enumerable<Family_sponsorshipCreateManyFamiliesInput>
        skipDuplicates?: boolean
    }

    export type OrphansCreateWithoutFamiliesInput = {
        id: string
        first_name: string
        last_name: string
        birth_date: Date | string
        family_status: string
        health_status: string
        academic_level: string
        shoes_size: string
        pants_size: string
        shirt_size: string
        note: string
        created_at?: Date | string | null
        updated_at?: Date | string | null
        orphan_sponsorship?: Orphan_sponsorshipCreateNestedManyWithoutOrphansInput
        users_orphans_created_byTousers: UsersCreateNestedOneWithoutOrphans_orphans_created_byTousersInput
        users_orphans_deleted_byTousers?: UsersCreateNestedOneWithoutOrphans_orphans_deleted_byTousersInput
        tenants: TenantsCreateNestedOneWithoutOrphansInput
    }

    export type OrphansUncheckedCreateWithoutFamiliesInput = {
        id: string
        first_name: string
        last_name: string
        birth_date: Date | string
        family_status: string
        health_status: string
        academic_level: string
        shoes_size: string
        pants_size: string
        shirt_size: string
        note: string
        tenant_id: string
        created_by: string
        deleted_by?: string | null
        created_at?: Date | string | null
        updated_at?: Date | string | null
        orphan_sponsorship?: Orphan_sponsorshipUncheckedCreateNestedManyWithoutOrphansInput
    }

    export type OrphansCreateOrConnectWithoutFamiliesInput = {
        where: OrphansWhereUniqueInput
        create: XOR<OrphansCreateWithoutFamiliesInput, OrphansUncheckedCreateWithoutFamiliesInput>
    }

    export type OrphansCreateManyFamiliesInputEnvelope = {
        data: Enumerable<OrphansCreateManyFamiliesInput>
        skipDuplicates?: boolean
    }

    export type Second_sponsorsCreateWithoutFamiliesInput = {
        id: string
        first_name: string
        last_name: string
        degree_of_kinship: string
        phone_number: string
        address: string
        income: number
        deleted_at?: Date | string | null
        created_at?: Date | string | null
        updated_at?: Date | string | null
        tenants: TenantsCreateNestedOneWithoutSecond_sponsorsInput
    }

    export type Second_sponsorsUncheckedCreateWithoutFamiliesInput = {
        id: string
        first_name: string
        last_name: string
        degree_of_kinship: string
        phone_number: string
        address: string
        income: number
        tenant_id: string
        deleted_at?: Date | string | null
        created_at?: Date | string | null
        updated_at?: Date | string | null
    }

    export type Second_sponsorsCreateOrConnectWithoutFamiliesInput = {
        where: Second_sponsorsWhereUniqueInput
        create: XOR<Second_sponsorsCreateWithoutFamiliesInput, Second_sponsorsUncheckedCreateWithoutFamiliesInput>
    }

    export type Second_sponsorsCreateManyFamiliesInputEnvelope = {
        data: Enumerable<Second_sponsorsCreateManyFamiliesInput>
        skipDuplicates?: boolean
    }

    export type SpousesCreateWithoutFamiliesInput = {
        id: string
        first_name: string
        last_name: string
        birth_date: Date | string
        death_date: Date | string
        function: string
        income: number
        created_at?: Date | string | null
        updated_at?: Date | string | null
        tenants: TenantsCreateNestedOneWithoutSpousesInput
    }

    export type SpousesUncheckedCreateWithoutFamiliesInput = {
        id: string
        first_name: string
        last_name: string
        birth_date: Date | string
        death_date: Date | string
        function: string
        income: number
        tenant_id: string
        created_at?: Date | string | null
        updated_at?: Date | string | null
    }

    export type SpousesCreateOrConnectWithoutFamiliesInput = {
        where: SpousesWhereUniqueInput
        create: XOR<SpousesCreateWithoutFamiliesInput, SpousesUncheckedCreateWithoutFamiliesInput>
    }

    export type SpousesCreateManyFamiliesInputEnvelope = {
        data: Enumerable<SpousesCreateManyFamiliesInput>
        skipDuplicates?: boolean
    }

    export type TenantsUpsertWithoutFamiliesInput = {
        update: XOR<TenantsUpdateWithoutFamiliesInput, TenantsUncheckedUpdateWithoutFamiliesInput>
        create: XOR<TenantsCreateWithoutFamiliesInput, TenantsUncheckedCreateWithoutFamiliesInput>
    }

    export type TenantsUpdateWithoutFamiliesInput = {
        id?: StringFieldUpdateOperationsInput | string
        data?: NullableJsonNullValueInput | InputJsonValue
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        benefactors?: BenefactorsUpdateManyWithoutTenantsNestedInput
        domains?: DomainsUpdateManyWithoutTenantsNestedInput
        family_sponsorship?: Family_sponsorshipUpdateManyWithoutTenantsNestedInput
        income_sponsor?: Income_sponsorUpdateManyWithoutTenantsNestedInput
        orphan_sponsorship?: Orphan_sponsorshipUpdateManyWithoutTenantsNestedInput
        orphans?: OrphansUpdateManyWithoutTenantsNestedInput
        second_sponsors?: Second_sponsorsUpdateManyWithoutTenantsNestedInput
        sponsor_sponsorship?: Sponsor_sponsorshipUpdateManyWithoutTenantsNestedInput
        sponsors?: SponsorsUpdateManyWithoutTenantsNestedInput
        sponsorships?: SponsorshipsUpdateManyWithoutTenantsNestedInput
        spouses?: SpousesUpdateManyWithoutTenantsNestedInput
        users?: UsersUpdateManyWithoutTenantsNestedInput
    }

    export type TenantsUncheckedUpdateWithoutFamiliesInput = {
        id?: StringFieldUpdateOperationsInput | string
        data?: NullableJsonNullValueInput | InputJsonValue
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        benefactors?: BenefactorsUncheckedUpdateManyWithoutTenantsNestedInput
        domains?: DomainsUncheckedUpdateManyWithoutTenantsNestedInput
        family_sponsorship?: Family_sponsorshipUncheckedUpdateManyWithoutTenantsNestedInput
        income_sponsor?: Income_sponsorUncheckedUpdateManyWithoutTenantsNestedInput
        orphan_sponsorship?: Orphan_sponsorshipUncheckedUpdateManyWithoutTenantsNestedInput
        orphans?: OrphansUncheckedUpdateManyWithoutTenantsNestedInput
        second_sponsors?: Second_sponsorsUncheckedUpdateManyWithoutTenantsNestedInput
        sponsor_sponsorship?: Sponsor_sponsorshipUncheckedUpdateManyWithoutTenantsNestedInput
        sponsors?: SponsorsUncheckedUpdateManyWithoutTenantsNestedInput
        sponsorships?: SponsorshipsUncheckedUpdateManyWithoutTenantsNestedInput
        spouses?: SpousesUncheckedUpdateManyWithoutTenantsNestedInput
        users?: UsersUncheckedUpdateManyWithoutTenantsNestedInput
    }

    export type Family_furnishingUpsertWithWhereUniqueWithoutFamiliesInput = {
        where: Family_furnishingWhereUniqueInput
        update: XOR<Family_furnishingUpdateWithoutFamiliesInput, Family_furnishingUncheckedUpdateWithoutFamiliesInput>
        create: XOR<Family_furnishingCreateWithoutFamiliesInput, Family_furnishingUncheckedCreateWithoutFamiliesInput>
    }

    export type Family_furnishingUpdateWithWhereUniqueWithoutFamiliesInput = {
        where: Family_furnishingWhereUniqueInput
        data: XOR<Family_furnishingUpdateWithoutFamiliesInput, Family_furnishingUncheckedUpdateWithoutFamiliesInput>
    }

    export type Family_furnishingUpdateManyWithWhereWithoutFamiliesInput = {
        where: Family_furnishingScalarWhereInput
        data: XOR<
            Family_furnishingUpdateManyMutationInput,
            Family_furnishingUncheckedUpdateManyWithoutFamily_furnishingInput
        >
    }

    export type Family_furnishingScalarWhereInput = {
        AND?: Enumerable<Family_furnishingScalarWhereInput>
        OR?: Enumerable<Family_furnishingScalarWhereInput>
        NOT?: Enumerable<Family_furnishingScalarWhereInput>
        id?: UuidFilter | string
        family_id?: UuidFilter | string
        furnishing_id?: UuidFilter | string
        value?: StringFilter | string
    }

    export type Family_housingUpsertWithWhereUniqueWithoutFamiliesInput = {
        where: Family_housingWhereUniqueInput
        update: XOR<Family_housingUpdateWithoutFamiliesInput, Family_housingUncheckedUpdateWithoutFamiliesInput>
        create: XOR<Family_housingCreateWithoutFamiliesInput, Family_housingUncheckedCreateWithoutFamiliesInput>
    }

    export type Family_housingUpdateWithWhereUniqueWithoutFamiliesInput = {
        where: Family_housingWhereUniqueInput
        data: XOR<Family_housingUpdateWithoutFamiliesInput, Family_housingUncheckedUpdateWithoutFamiliesInput>
    }

    export type Family_housingUpdateManyWithWhereWithoutFamiliesInput = {
        where: Family_housingScalarWhereInput
        data: XOR<Family_housingUpdateManyMutationInput, Family_housingUncheckedUpdateManyWithoutFamily_housingInput>
    }

    export type Family_housingScalarWhereInput = {
        AND?: Enumerable<Family_housingScalarWhereInput>
        OR?: Enumerable<Family_housingScalarWhereInput>
        NOT?: Enumerable<Family_housingScalarWhereInput>
        id?: UuidFilter | string
        family_id?: UuidFilter | string
        housing_id?: UuidFilter | string
        value?: StringFilter | string
    }

    export type Family_sponsorshipUpsertWithWhereUniqueWithoutFamiliesInput = {
        where: Family_sponsorshipWhereUniqueInput
        update: XOR<Family_sponsorshipUpdateWithoutFamiliesInput, Family_sponsorshipUncheckedUpdateWithoutFamiliesInput>
        create: XOR<Family_sponsorshipCreateWithoutFamiliesInput, Family_sponsorshipUncheckedCreateWithoutFamiliesInput>
    }

    export type Family_sponsorshipUpdateWithWhereUniqueWithoutFamiliesInput = {
        where: Family_sponsorshipWhereUniqueInput
        data: XOR<Family_sponsorshipUpdateWithoutFamiliesInput, Family_sponsorshipUncheckedUpdateWithoutFamiliesInput>
    }

    export type Family_sponsorshipUpdateManyWithWhereWithoutFamiliesInput = {
        where: Family_sponsorshipScalarWhereInput
        data: XOR<
            Family_sponsorshipUpdateManyMutationInput,
            Family_sponsorshipUncheckedUpdateManyWithoutFamily_sponsorshipInput
        >
    }

    export type Family_sponsorshipScalarWhereInput = {
        AND?: Enumerable<Family_sponsorshipScalarWhereInput>
        OR?: Enumerable<Family_sponsorshipScalarWhereInput>
        NOT?: Enumerable<Family_sponsorshipScalarWhereInput>
        id?: UuidFilter | string
        family_id?: UuidFilter | string
        type?: Enumfamily_sponsorship_typeFilter | family_sponsorship_type
        value?: StringFilter | string
        tenant_id?: StringFilter | string
        created_at?: DateTimeNullableFilter | Date | string | null
        updated_at?: DateTimeNullableFilter | Date | string | null
    }

    export type OrphansUpsertWithWhereUniqueWithoutFamiliesInput = {
        where: OrphansWhereUniqueInput
        update: XOR<OrphansUpdateWithoutFamiliesInput, OrphansUncheckedUpdateWithoutFamiliesInput>
        create: XOR<OrphansCreateWithoutFamiliesInput, OrphansUncheckedCreateWithoutFamiliesInput>
    }

    export type OrphansUpdateWithWhereUniqueWithoutFamiliesInput = {
        where: OrphansWhereUniqueInput
        data: XOR<OrphansUpdateWithoutFamiliesInput, OrphansUncheckedUpdateWithoutFamiliesInput>
    }

    export type OrphansUpdateManyWithWhereWithoutFamiliesInput = {
        where: OrphansScalarWhereInput
        data: XOR<OrphansUpdateManyMutationInput, OrphansUncheckedUpdateManyWithoutOrphansInput>
    }

    export type OrphansScalarWhereInput = {
        AND?: Enumerable<OrphansScalarWhereInput>
        OR?: Enumerable<OrphansScalarWhereInput>
        NOT?: Enumerable<OrphansScalarWhereInput>
        id?: UuidFilter | string
        first_name?: StringFilter | string
        last_name?: StringFilter | string
        birth_date?: DateTimeFilter | Date | string
        family_status?: StringFilter | string
        health_status?: StringFilter | string
        academic_level?: StringFilter | string
        shoes_size?: StringFilter | string
        pants_size?: StringFilter | string
        shirt_size?: StringFilter | string
        note?: StringFilter | string
        tenant_id?: StringFilter | string
        family_id?: UuidFilter | string
        created_by?: UuidFilter | string
        deleted_by?: UuidNullableFilter | string | null
        created_at?: DateTimeNullableFilter | Date | string | null
        updated_at?: DateTimeNullableFilter | Date | string | null
    }

    export type Second_sponsorsUpsertWithWhereUniqueWithoutFamiliesInput = {
        where: Second_sponsorsWhereUniqueInput
        update: XOR<Second_sponsorsUpdateWithoutFamiliesInput, Second_sponsorsUncheckedUpdateWithoutFamiliesInput>
        create: XOR<Second_sponsorsCreateWithoutFamiliesInput, Second_sponsorsUncheckedCreateWithoutFamiliesInput>
    }

    export type Second_sponsorsUpdateWithWhereUniqueWithoutFamiliesInput = {
        where: Second_sponsorsWhereUniqueInput
        data: XOR<Second_sponsorsUpdateWithoutFamiliesInput, Second_sponsorsUncheckedUpdateWithoutFamiliesInput>
    }

    export type Second_sponsorsUpdateManyWithWhereWithoutFamiliesInput = {
        where: Second_sponsorsScalarWhereInput
        data: XOR<Second_sponsorsUpdateManyMutationInput, Second_sponsorsUncheckedUpdateManyWithoutSecond_sponsorsInput>
    }

    export type Second_sponsorsScalarWhereInput = {
        AND?: Enumerable<Second_sponsorsScalarWhereInput>
        OR?: Enumerable<Second_sponsorsScalarWhereInput>
        NOT?: Enumerable<Second_sponsorsScalarWhereInput>
        id?: UuidFilter | string
        first_name?: StringFilter | string
        last_name?: StringFilter | string
        degree_of_kinship?: StringFilter | string
        phone_number?: StringFilter | string
        address?: StringFilter | string
        income?: FloatFilter | number
        family_id?: UuidFilter | string
        tenant_id?: StringFilter | string
        deleted_at?: DateTimeNullableFilter | Date | string | null
        created_at?: DateTimeNullableFilter | Date | string | null
        updated_at?: DateTimeNullableFilter | Date | string | null
    }

    export type SpousesUpsertWithWhereUniqueWithoutFamiliesInput = {
        where: SpousesWhereUniqueInput
        update: XOR<SpousesUpdateWithoutFamiliesInput, SpousesUncheckedUpdateWithoutFamiliesInput>
        create: XOR<SpousesCreateWithoutFamiliesInput, SpousesUncheckedCreateWithoutFamiliesInput>
    }

    export type SpousesUpdateWithWhereUniqueWithoutFamiliesInput = {
        where: SpousesWhereUniqueInput
        data: XOR<SpousesUpdateWithoutFamiliesInput, SpousesUncheckedUpdateWithoutFamiliesInput>
    }

    export type SpousesUpdateManyWithWhereWithoutFamiliesInput = {
        where: SpousesScalarWhereInput
        data: XOR<SpousesUpdateManyMutationInput, SpousesUncheckedUpdateManyWithoutSpousesInput>
    }

    export type SpousesScalarWhereInput = {
        AND?: Enumerable<SpousesScalarWhereInput>
        OR?: Enumerable<SpousesScalarWhereInput>
        NOT?: Enumerable<SpousesScalarWhereInput>
        id?: UuidFilter | string
        first_name?: StringFilter | string
        last_name?: StringFilter | string
        birth_date?: DateTimeFilter | Date | string
        death_date?: DateTimeFilter | Date | string
        function?: StringFilter | string
        income?: FloatFilter | number
        family_id?: UuidFilter | string
        tenant_id?: StringFilter | string
        created_at?: DateTimeNullableFilter | Date | string | null
        updated_at?: DateTimeNullableFilter | Date | string | null
    }

    export type FamiliesCreateWithoutFamily_furnishingInput = {
        id: string
        name: string
        report: string
        created_at?: Date | string | null
        updated_at?: Date | string | null
        tenants: TenantsCreateNestedOneWithoutFamiliesInput
        family_housing?: Family_housingCreateNestedManyWithoutFamiliesInput
        family_sponsorship?: Family_sponsorshipCreateNestedManyWithoutFamiliesInput
        orphans?: OrphansCreateNestedManyWithoutFamiliesInput
        second_sponsors?: Second_sponsorsCreateNestedManyWithoutFamiliesInput
        spouses?: SpousesCreateNestedManyWithoutFamiliesInput
    }

    export type FamiliesUncheckedCreateWithoutFamily_furnishingInput = {
        id: string
        name: string
        report: string
        tenant_id: string
        created_at?: Date | string | null
        updated_at?: Date | string | null
        family_housing?: Family_housingUncheckedCreateNestedManyWithoutFamiliesInput
        family_sponsorship?: Family_sponsorshipUncheckedCreateNestedManyWithoutFamiliesInput
        orphans?: OrphansUncheckedCreateNestedManyWithoutFamiliesInput
        second_sponsors?: Second_sponsorsUncheckedCreateNestedManyWithoutFamiliesInput
        spouses?: SpousesUncheckedCreateNestedManyWithoutFamiliesInput
    }

    export type FamiliesCreateOrConnectWithoutFamily_furnishingInput = {
        where: FamiliesWhereUniqueInput
        create: XOR<FamiliesCreateWithoutFamily_furnishingInput, FamiliesUncheckedCreateWithoutFamily_furnishingInput>
    }

    export type FurnishingsCreateWithoutFamily_furnishingInput = {
        id: string
        name: string
    }

    export type FurnishingsUncheckedCreateWithoutFamily_furnishingInput = {
        id: string
        name: string
    }

    export type FurnishingsCreateOrConnectWithoutFamily_furnishingInput = {
        where: FurnishingsWhereUniqueInput
        create: XOR<
            FurnishingsCreateWithoutFamily_furnishingInput,
            FurnishingsUncheckedCreateWithoutFamily_furnishingInput
        >
    }

    export type FamiliesUpsertWithoutFamily_furnishingInput = {
        update: XOR<FamiliesUpdateWithoutFamily_furnishingInput, FamiliesUncheckedUpdateWithoutFamily_furnishingInput>
        create: XOR<FamiliesCreateWithoutFamily_furnishingInput, FamiliesUncheckedCreateWithoutFamily_furnishingInput>
    }

    export type FamiliesUpdateWithoutFamily_furnishingInput = {
        id?: StringFieldUpdateOperationsInput | string
        name?: StringFieldUpdateOperationsInput | string
        report?: StringFieldUpdateOperationsInput | string
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        tenants?: TenantsUpdateOneRequiredWithoutFamiliesNestedInput
        family_housing?: Family_housingUpdateManyWithoutFamiliesNestedInput
        family_sponsorship?: Family_sponsorshipUpdateManyWithoutFamiliesNestedInput
        orphans?: OrphansUpdateManyWithoutFamiliesNestedInput
        second_sponsors?: Second_sponsorsUpdateManyWithoutFamiliesNestedInput
        spouses?: SpousesUpdateManyWithoutFamiliesNestedInput
    }

    export type FamiliesUncheckedUpdateWithoutFamily_furnishingInput = {
        id?: StringFieldUpdateOperationsInput | string
        name?: StringFieldUpdateOperationsInput | string
        report?: StringFieldUpdateOperationsInput | string
        tenant_id?: StringFieldUpdateOperationsInput | string
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        family_housing?: Family_housingUncheckedUpdateManyWithoutFamiliesNestedInput
        family_sponsorship?: Family_sponsorshipUncheckedUpdateManyWithoutFamiliesNestedInput
        orphans?: OrphansUncheckedUpdateManyWithoutFamiliesNestedInput
        second_sponsors?: Second_sponsorsUncheckedUpdateManyWithoutFamiliesNestedInput
        spouses?: SpousesUncheckedUpdateManyWithoutFamiliesNestedInput
    }

    export type FurnishingsUpsertWithoutFamily_furnishingInput = {
        update: XOR<
            FurnishingsUpdateWithoutFamily_furnishingInput,
            FurnishingsUncheckedUpdateWithoutFamily_furnishingInput
        >
        create: XOR<
            FurnishingsCreateWithoutFamily_furnishingInput,
            FurnishingsUncheckedCreateWithoutFamily_furnishingInput
        >
    }

    export type FurnishingsUpdateWithoutFamily_furnishingInput = {
        id?: StringFieldUpdateOperationsInput | string
        name?: StringFieldUpdateOperationsInput | string
    }

    export type FurnishingsUncheckedUpdateWithoutFamily_furnishingInput = {
        id?: StringFieldUpdateOperationsInput | string
        name?: StringFieldUpdateOperationsInput | string
    }

    export type FamiliesCreateWithoutFamily_housingInput = {
        id: string
        name: string
        report: string
        created_at?: Date | string | null
        updated_at?: Date | string | null
        tenants: TenantsCreateNestedOneWithoutFamiliesInput
        family_furnishing?: Family_furnishingCreateNestedManyWithoutFamiliesInput
        family_sponsorship?: Family_sponsorshipCreateNestedManyWithoutFamiliesInput
        orphans?: OrphansCreateNestedManyWithoutFamiliesInput
        second_sponsors?: Second_sponsorsCreateNestedManyWithoutFamiliesInput
        spouses?: SpousesCreateNestedManyWithoutFamiliesInput
    }

    export type FamiliesUncheckedCreateWithoutFamily_housingInput = {
        id: string
        name: string
        report: string
        tenant_id: string
        created_at?: Date | string | null
        updated_at?: Date | string | null
        family_furnishing?: Family_furnishingUncheckedCreateNestedManyWithoutFamiliesInput
        family_sponsorship?: Family_sponsorshipUncheckedCreateNestedManyWithoutFamiliesInput
        orphans?: OrphansUncheckedCreateNestedManyWithoutFamiliesInput
        second_sponsors?: Second_sponsorsUncheckedCreateNestedManyWithoutFamiliesInput
        spouses?: SpousesUncheckedCreateNestedManyWithoutFamiliesInput
    }

    export type FamiliesCreateOrConnectWithoutFamily_housingInput = {
        where: FamiliesWhereUniqueInput
        create: XOR<FamiliesCreateWithoutFamily_housingInput, FamiliesUncheckedCreateWithoutFamily_housingInput>
    }

    export type HousingsCreateWithoutFamily_housingInput = {
        id: string
        name: string
    }

    export type HousingsUncheckedCreateWithoutFamily_housingInput = {
        id: string
        name: string
    }

    export type HousingsCreateOrConnectWithoutFamily_housingInput = {
        where: HousingsWhereUniqueInput
        create: XOR<HousingsCreateWithoutFamily_housingInput, HousingsUncheckedCreateWithoutFamily_housingInput>
    }

    export type FamiliesUpsertWithoutFamily_housingInput = {
        update: XOR<FamiliesUpdateWithoutFamily_housingInput, FamiliesUncheckedUpdateWithoutFamily_housingInput>
        create: XOR<FamiliesCreateWithoutFamily_housingInput, FamiliesUncheckedCreateWithoutFamily_housingInput>
    }

    export type FamiliesUpdateWithoutFamily_housingInput = {
        id?: StringFieldUpdateOperationsInput | string
        name?: StringFieldUpdateOperationsInput | string
        report?: StringFieldUpdateOperationsInput | string
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        tenants?: TenantsUpdateOneRequiredWithoutFamiliesNestedInput
        family_furnishing?: Family_furnishingUpdateManyWithoutFamiliesNestedInput
        family_sponsorship?: Family_sponsorshipUpdateManyWithoutFamiliesNestedInput
        orphans?: OrphansUpdateManyWithoutFamiliesNestedInput
        second_sponsors?: Second_sponsorsUpdateManyWithoutFamiliesNestedInput
        spouses?: SpousesUpdateManyWithoutFamiliesNestedInput
    }

    export type FamiliesUncheckedUpdateWithoutFamily_housingInput = {
        id?: StringFieldUpdateOperationsInput | string
        name?: StringFieldUpdateOperationsInput | string
        report?: StringFieldUpdateOperationsInput | string
        tenant_id?: StringFieldUpdateOperationsInput | string
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        family_furnishing?: Family_furnishingUncheckedUpdateManyWithoutFamiliesNestedInput
        family_sponsorship?: Family_sponsorshipUncheckedUpdateManyWithoutFamiliesNestedInput
        orphans?: OrphansUncheckedUpdateManyWithoutFamiliesNestedInput
        second_sponsors?: Second_sponsorsUncheckedUpdateManyWithoutFamiliesNestedInput
        spouses?: SpousesUncheckedUpdateManyWithoutFamiliesNestedInput
    }

    export type HousingsUpsertWithoutFamily_housingInput = {
        update: XOR<HousingsUpdateWithoutFamily_housingInput, HousingsUncheckedUpdateWithoutFamily_housingInput>
        create: XOR<HousingsCreateWithoutFamily_housingInput, HousingsUncheckedCreateWithoutFamily_housingInput>
    }

    export type HousingsUpdateWithoutFamily_housingInput = {
        id?: StringFieldUpdateOperationsInput | string
        name?: StringFieldUpdateOperationsInput | string
    }

    export type HousingsUncheckedUpdateWithoutFamily_housingInput = {
        id?: StringFieldUpdateOperationsInput | string
        name?: StringFieldUpdateOperationsInput | string
    }

    export type FamiliesCreateWithoutFamily_sponsorshipInput = {
        id: string
        name: string
        report: string
        created_at?: Date | string | null
        updated_at?: Date | string | null
        tenants: TenantsCreateNestedOneWithoutFamiliesInput
        family_furnishing?: Family_furnishingCreateNestedManyWithoutFamiliesInput
        family_housing?: Family_housingCreateNestedManyWithoutFamiliesInput
        orphans?: OrphansCreateNestedManyWithoutFamiliesInput
        second_sponsors?: Second_sponsorsCreateNestedManyWithoutFamiliesInput
        spouses?: SpousesCreateNestedManyWithoutFamiliesInput
    }

    export type FamiliesUncheckedCreateWithoutFamily_sponsorshipInput = {
        id: string
        name: string
        report: string
        tenant_id: string
        created_at?: Date | string | null
        updated_at?: Date | string | null
        family_furnishing?: Family_furnishingUncheckedCreateNestedManyWithoutFamiliesInput
        family_housing?: Family_housingUncheckedCreateNestedManyWithoutFamiliesInput
        orphans?: OrphansUncheckedCreateNestedManyWithoutFamiliesInput
        second_sponsors?: Second_sponsorsUncheckedCreateNestedManyWithoutFamiliesInput
        spouses?: SpousesUncheckedCreateNestedManyWithoutFamiliesInput
    }

    export type FamiliesCreateOrConnectWithoutFamily_sponsorshipInput = {
        where: FamiliesWhereUniqueInput
        create: XOR<FamiliesCreateWithoutFamily_sponsorshipInput, FamiliesUncheckedCreateWithoutFamily_sponsorshipInput>
    }

    export type TenantsCreateWithoutFamily_sponsorshipInput = {
        id: string
        data?: NullableJsonNullValueInput | InputJsonValue
        created_at?: Date | string | null
        updated_at?: Date | string | null
        benefactors?: BenefactorsCreateNestedManyWithoutTenantsInput
        domains?: DomainsCreateNestedManyWithoutTenantsInput
        families?: FamiliesCreateNestedManyWithoutTenantsInput
        income_sponsor?: Income_sponsorCreateNestedManyWithoutTenantsInput
        orphan_sponsorship?: Orphan_sponsorshipCreateNestedManyWithoutTenantsInput
        orphans?: OrphansCreateNestedManyWithoutTenantsInput
        second_sponsors?: Second_sponsorsCreateNestedManyWithoutTenantsInput
        sponsor_sponsorship?: Sponsor_sponsorshipCreateNestedManyWithoutTenantsInput
        sponsors?: SponsorsCreateNestedManyWithoutTenantsInput
        sponsorships?: SponsorshipsCreateNestedManyWithoutTenantsInput
        spouses?: SpousesCreateNestedManyWithoutTenantsInput
        users?: UsersCreateNestedManyWithoutTenantsInput
    }

    export type TenantsUncheckedCreateWithoutFamily_sponsorshipInput = {
        id: string
        data?: NullableJsonNullValueInput | InputJsonValue
        created_at?: Date | string | null
        updated_at?: Date | string | null
        benefactors?: BenefactorsUncheckedCreateNestedManyWithoutTenantsInput
        domains?: DomainsUncheckedCreateNestedManyWithoutTenantsInput
        families?: FamiliesUncheckedCreateNestedManyWithoutTenantsInput
        income_sponsor?: Income_sponsorUncheckedCreateNestedManyWithoutTenantsInput
        orphan_sponsorship?: Orphan_sponsorshipUncheckedCreateNestedManyWithoutTenantsInput
        orphans?: OrphansUncheckedCreateNestedManyWithoutTenantsInput
        second_sponsors?: Second_sponsorsUncheckedCreateNestedManyWithoutTenantsInput
        sponsor_sponsorship?: Sponsor_sponsorshipUncheckedCreateNestedManyWithoutTenantsInput
        sponsors?: SponsorsUncheckedCreateNestedManyWithoutTenantsInput
        sponsorships?: SponsorshipsUncheckedCreateNestedManyWithoutTenantsInput
        spouses?: SpousesUncheckedCreateNestedManyWithoutTenantsInput
        users?: UsersUncheckedCreateNestedManyWithoutTenantsInput
    }

    export type TenantsCreateOrConnectWithoutFamily_sponsorshipInput = {
        where: TenantsWhereUniqueInput
        create: XOR<TenantsCreateWithoutFamily_sponsorshipInput, TenantsUncheckedCreateWithoutFamily_sponsorshipInput>
    }

    export type FamiliesUpsertWithoutFamily_sponsorshipInput = {
        update: XOR<FamiliesUpdateWithoutFamily_sponsorshipInput, FamiliesUncheckedUpdateWithoutFamily_sponsorshipInput>
        create: XOR<FamiliesCreateWithoutFamily_sponsorshipInput, FamiliesUncheckedCreateWithoutFamily_sponsorshipInput>
    }

    export type FamiliesUpdateWithoutFamily_sponsorshipInput = {
        id?: StringFieldUpdateOperationsInput | string
        name?: StringFieldUpdateOperationsInput | string
        report?: StringFieldUpdateOperationsInput | string
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        tenants?: TenantsUpdateOneRequiredWithoutFamiliesNestedInput
        family_furnishing?: Family_furnishingUpdateManyWithoutFamiliesNestedInput
        family_housing?: Family_housingUpdateManyWithoutFamiliesNestedInput
        orphans?: OrphansUpdateManyWithoutFamiliesNestedInput
        second_sponsors?: Second_sponsorsUpdateManyWithoutFamiliesNestedInput
        spouses?: SpousesUpdateManyWithoutFamiliesNestedInput
    }

    export type FamiliesUncheckedUpdateWithoutFamily_sponsorshipInput = {
        id?: StringFieldUpdateOperationsInput | string
        name?: StringFieldUpdateOperationsInput | string
        report?: StringFieldUpdateOperationsInput | string
        tenant_id?: StringFieldUpdateOperationsInput | string
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        family_furnishing?: Family_furnishingUncheckedUpdateManyWithoutFamiliesNestedInput
        family_housing?: Family_housingUncheckedUpdateManyWithoutFamiliesNestedInput
        orphans?: OrphansUncheckedUpdateManyWithoutFamiliesNestedInput
        second_sponsors?: Second_sponsorsUncheckedUpdateManyWithoutFamiliesNestedInput
        spouses?: SpousesUncheckedUpdateManyWithoutFamiliesNestedInput
    }

    export type TenantsUpsertWithoutFamily_sponsorshipInput = {
        update: XOR<TenantsUpdateWithoutFamily_sponsorshipInput, TenantsUncheckedUpdateWithoutFamily_sponsorshipInput>
        create: XOR<TenantsCreateWithoutFamily_sponsorshipInput, TenantsUncheckedCreateWithoutFamily_sponsorshipInput>
    }

    export type TenantsUpdateWithoutFamily_sponsorshipInput = {
        id?: StringFieldUpdateOperationsInput | string
        data?: NullableJsonNullValueInput | InputJsonValue
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        benefactors?: BenefactorsUpdateManyWithoutTenantsNestedInput
        domains?: DomainsUpdateManyWithoutTenantsNestedInput
        families?: FamiliesUpdateManyWithoutTenantsNestedInput
        income_sponsor?: Income_sponsorUpdateManyWithoutTenantsNestedInput
        orphan_sponsorship?: Orphan_sponsorshipUpdateManyWithoutTenantsNestedInput
        orphans?: OrphansUpdateManyWithoutTenantsNestedInput
        second_sponsors?: Second_sponsorsUpdateManyWithoutTenantsNestedInput
        sponsor_sponsorship?: Sponsor_sponsorshipUpdateManyWithoutTenantsNestedInput
        sponsors?: SponsorsUpdateManyWithoutTenantsNestedInput
        sponsorships?: SponsorshipsUpdateManyWithoutTenantsNestedInput
        spouses?: SpousesUpdateManyWithoutTenantsNestedInput
        users?: UsersUpdateManyWithoutTenantsNestedInput
    }

    export type TenantsUncheckedUpdateWithoutFamily_sponsorshipInput = {
        id?: StringFieldUpdateOperationsInput | string
        data?: NullableJsonNullValueInput | InputJsonValue
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        benefactors?: BenefactorsUncheckedUpdateManyWithoutTenantsNestedInput
        domains?: DomainsUncheckedUpdateManyWithoutTenantsNestedInput
        families?: FamiliesUncheckedUpdateManyWithoutTenantsNestedInput
        income_sponsor?: Income_sponsorUncheckedUpdateManyWithoutTenantsNestedInput
        orphan_sponsorship?: Orphan_sponsorshipUncheckedUpdateManyWithoutTenantsNestedInput
        orphans?: OrphansUncheckedUpdateManyWithoutTenantsNestedInput
        second_sponsors?: Second_sponsorsUncheckedUpdateManyWithoutTenantsNestedInput
        sponsor_sponsorship?: Sponsor_sponsorshipUncheckedUpdateManyWithoutTenantsNestedInput
        sponsors?: SponsorsUncheckedUpdateManyWithoutTenantsNestedInput
        sponsorships?: SponsorshipsUncheckedUpdateManyWithoutTenantsNestedInput
        spouses?: SpousesUncheckedUpdateManyWithoutTenantsNestedInput
        users?: UsersUncheckedUpdateManyWithoutTenantsNestedInput
    }

    export type Family_furnishingCreateWithoutFurnishingsInput = {
        id: string
        value: string
        families: FamiliesCreateNestedOneWithoutFamily_furnishingInput
    }

    export type Family_furnishingUncheckedCreateWithoutFurnishingsInput = {
        id: string
        family_id: string
        value: string
    }

    export type Family_furnishingCreateOrConnectWithoutFurnishingsInput = {
        where: Family_furnishingWhereUniqueInput
        create: XOR<
            Family_furnishingCreateWithoutFurnishingsInput,
            Family_furnishingUncheckedCreateWithoutFurnishingsInput
        >
    }

    export type Family_furnishingCreateManyFurnishingsInputEnvelope = {
        data: Enumerable<Family_furnishingCreateManyFurnishingsInput>
        skipDuplicates?: boolean
    }

    export type Family_furnishingUpsertWithWhereUniqueWithoutFurnishingsInput = {
        where: Family_furnishingWhereUniqueInput
        update: XOR<
            Family_furnishingUpdateWithoutFurnishingsInput,
            Family_furnishingUncheckedUpdateWithoutFurnishingsInput
        >
        create: XOR<
            Family_furnishingCreateWithoutFurnishingsInput,
            Family_furnishingUncheckedCreateWithoutFurnishingsInput
        >
    }

    export type Family_furnishingUpdateWithWhereUniqueWithoutFurnishingsInput = {
        where: Family_furnishingWhereUniqueInput
        data: XOR<
            Family_furnishingUpdateWithoutFurnishingsInput,
            Family_furnishingUncheckedUpdateWithoutFurnishingsInput
        >
    }

    export type Family_furnishingUpdateManyWithWhereWithoutFurnishingsInput = {
        where: Family_furnishingScalarWhereInput
        data: XOR<
            Family_furnishingUpdateManyMutationInput,
            Family_furnishingUncheckedUpdateManyWithoutFamily_furnishingInput
        >
    }

    export type Family_housingCreateWithoutHousingsInput = {
        id: string
        value: string
        families: FamiliesCreateNestedOneWithoutFamily_housingInput
    }

    export type Family_housingUncheckedCreateWithoutHousingsInput = {
        id: string
        family_id: string
        value: string
    }

    export type Family_housingCreateOrConnectWithoutHousingsInput = {
        where: Family_housingWhereUniqueInput
        create: XOR<Family_housingCreateWithoutHousingsInput, Family_housingUncheckedCreateWithoutHousingsInput>
    }

    export type Family_housingCreateManyHousingsInputEnvelope = {
        data: Enumerable<Family_housingCreateManyHousingsInput>
        skipDuplicates?: boolean
    }

    export type Family_housingUpsertWithWhereUniqueWithoutHousingsInput = {
        where: Family_housingWhereUniqueInput
        update: XOR<Family_housingUpdateWithoutHousingsInput, Family_housingUncheckedUpdateWithoutHousingsInput>
        create: XOR<Family_housingCreateWithoutHousingsInput, Family_housingUncheckedCreateWithoutHousingsInput>
    }

    export type Family_housingUpdateWithWhereUniqueWithoutHousingsInput = {
        where: Family_housingWhereUniqueInput
        data: XOR<Family_housingUpdateWithoutHousingsInput, Family_housingUncheckedUpdateWithoutHousingsInput>
    }

    export type Family_housingUpdateManyWithWhereWithoutHousingsInput = {
        where: Family_housingScalarWhereInput
        data: XOR<Family_housingUpdateManyMutationInput, Family_housingUncheckedUpdateManyWithoutFamily_housingInput>
    }

    export type IncomesCreateWithoutIncome_sponsorInput = {
        id: string
        name: string
    }

    export type IncomesUncheckedCreateWithoutIncome_sponsorInput = {
        id: string
        name: string
    }

    export type IncomesCreateOrConnectWithoutIncome_sponsorInput = {
        where: IncomesWhereUniqueInput
        create: XOR<IncomesCreateWithoutIncome_sponsorInput, IncomesUncheckedCreateWithoutIncome_sponsorInput>
    }

    export type SponsorsCreateWithoutIncome_sponsorInput = {
        id: string
        zone_id: string
        file_number: number
        start_date: Date | string
        name: string
        address: string
        phone_number: string
        sponsorship_type: string
        birth_date: Date | string
        father_name: string
        mother_name: string
        birth_certificate_number: string
        academic_level: string
        function: string
        health_status: string
        diploma?: string | null
        card_number?: string | null
        deleted_at?: Date | string | null
        created_at?: Date | string | null
        updated_at?: Date | string | null
        sponsor_sponsorship?: Sponsor_sponsorshipCreateNestedManyWithoutSponsorsInput
        users_sponsors_created_byTousers: UsersCreateNestedOneWithoutSponsors_sponsors_created_byTousersInput
        users_sponsors_deleted_byTousers?: UsersCreateNestedOneWithoutSponsors_sponsors_deleted_byTousersInput
        tenants: TenantsCreateNestedOneWithoutSponsorsInput
    }

    export type SponsorsUncheckedCreateWithoutIncome_sponsorInput = {
        id: string
        zone_id: string
        file_number: number
        start_date: Date | string
        name: string
        address: string
        phone_number: string
        sponsorship_type: string
        birth_date: Date | string
        father_name: string
        mother_name: string
        birth_certificate_number: string
        academic_level: string
        function: string
        health_status: string
        diploma?: string | null
        card_number?: string | null
        tenant_id: string
        created_by: string
        deleted_by?: string | null
        deleted_at?: Date | string | null
        created_at?: Date | string | null
        updated_at?: Date | string | null
        sponsor_sponsorship?: Sponsor_sponsorshipUncheckedCreateNestedManyWithoutSponsorsInput
    }

    export type SponsorsCreateOrConnectWithoutIncome_sponsorInput = {
        where: SponsorsWhereUniqueInput
        create: XOR<SponsorsCreateWithoutIncome_sponsorInput, SponsorsUncheckedCreateWithoutIncome_sponsorInput>
    }

    export type TenantsCreateWithoutIncome_sponsorInput = {
        id: string
        data?: NullableJsonNullValueInput | InputJsonValue
        created_at?: Date | string | null
        updated_at?: Date | string | null
        benefactors?: BenefactorsCreateNestedManyWithoutTenantsInput
        domains?: DomainsCreateNestedManyWithoutTenantsInput
        families?: FamiliesCreateNestedManyWithoutTenantsInput
        family_sponsorship?: Family_sponsorshipCreateNestedManyWithoutTenantsInput
        orphan_sponsorship?: Orphan_sponsorshipCreateNestedManyWithoutTenantsInput
        orphans?: OrphansCreateNestedManyWithoutTenantsInput
        second_sponsors?: Second_sponsorsCreateNestedManyWithoutTenantsInput
        sponsor_sponsorship?: Sponsor_sponsorshipCreateNestedManyWithoutTenantsInput
        sponsors?: SponsorsCreateNestedManyWithoutTenantsInput
        sponsorships?: SponsorshipsCreateNestedManyWithoutTenantsInput
        spouses?: SpousesCreateNestedManyWithoutTenantsInput
        users?: UsersCreateNestedManyWithoutTenantsInput
    }

    export type TenantsUncheckedCreateWithoutIncome_sponsorInput = {
        id: string
        data?: NullableJsonNullValueInput | InputJsonValue
        created_at?: Date | string | null
        updated_at?: Date | string | null
        benefactors?: BenefactorsUncheckedCreateNestedManyWithoutTenantsInput
        domains?: DomainsUncheckedCreateNestedManyWithoutTenantsInput
        families?: FamiliesUncheckedCreateNestedManyWithoutTenantsInput
        family_sponsorship?: Family_sponsorshipUncheckedCreateNestedManyWithoutTenantsInput
        orphan_sponsorship?: Orphan_sponsorshipUncheckedCreateNestedManyWithoutTenantsInput
        orphans?: OrphansUncheckedCreateNestedManyWithoutTenantsInput
        second_sponsors?: Second_sponsorsUncheckedCreateNestedManyWithoutTenantsInput
        sponsor_sponsorship?: Sponsor_sponsorshipUncheckedCreateNestedManyWithoutTenantsInput
        sponsors?: SponsorsUncheckedCreateNestedManyWithoutTenantsInput
        sponsorships?: SponsorshipsUncheckedCreateNestedManyWithoutTenantsInput
        spouses?: SpousesUncheckedCreateNestedManyWithoutTenantsInput
        users?: UsersUncheckedCreateNestedManyWithoutTenantsInput
    }

    export type TenantsCreateOrConnectWithoutIncome_sponsorInput = {
        where: TenantsWhereUniqueInput
        create: XOR<TenantsCreateWithoutIncome_sponsorInput, TenantsUncheckedCreateWithoutIncome_sponsorInput>
    }

    export type IncomesUpsertWithoutIncome_sponsorInput = {
        update: XOR<IncomesUpdateWithoutIncome_sponsorInput, IncomesUncheckedUpdateWithoutIncome_sponsorInput>
        create: XOR<IncomesCreateWithoutIncome_sponsorInput, IncomesUncheckedCreateWithoutIncome_sponsorInput>
    }

    export type IncomesUpdateWithoutIncome_sponsorInput = {
        id?: StringFieldUpdateOperationsInput | string
        name?: StringFieldUpdateOperationsInput | string
    }

    export type IncomesUncheckedUpdateWithoutIncome_sponsorInput = {
        id?: StringFieldUpdateOperationsInput | string
        name?: StringFieldUpdateOperationsInput | string
    }

    export type SponsorsUpsertWithoutIncome_sponsorInput = {
        update: XOR<SponsorsUpdateWithoutIncome_sponsorInput, SponsorsUncheckedUpdateWithoutIncome_sponsorInput>
        create: XOR<SponsorsCreateWithoutIncome_sponsorInput, SponsorsUncheckedCreateWithoutIncome_sponsorInput>
    }

    export type SponsorsUpdateWithoutIncome_sponsorInput = {
        id?: StringFieldUpdateOperationsInput | string
        zone_id?: StringFieldUpdateOperationsInput | string
        file_number?: IntFieldUpdateOperationsInput | number
        start_date?: DateTimeFieldUpdateOperationsInput | Date | string
        name?: StringFieldUpdateOperationsInput | string
        address?: StringFieldUpdateOperationsInput | string
        phone_number?: StringFieldUpdateOperationsInput | string
        sponsorship_type?: StringFieldUpdateOperationsInput | string
        birth_date?: DateTimeFieldUpdateOperationsInput | Date | string
        father_name?: StringFieldUpdateOperationsInput | string
        mother_name?: StringFieldUpdateOperationsInput | string
        birth_certificate_number?: StringFieldUpdateOperationsInput | string
        academic_level?: StringFieldUpdateOperationsInput | string
        function?: StringFieldUpdateOperationsInput | string
        health_status?: StringFieldUpdateOperationsInput | string
        diploma?: NullableStringFieldUpdateOperationsInput | string | null
        card_number?: NullableStringFieldUpdateOperationsInput | string | null
        deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        sponsor_sponsorship?: Sponsor_sponsorshipUpdateManyWithoutSponsorsNestedInput
        users_sponsors_created_byTousers?: UsersUpdateOneRequiredWithoutSponsors_sponsors_created_byTousersNestedInput
        users_sponsors_deleted_byTousers?: UsersUpdateOneWithoutSponsors_sponsors_deleted_byTousersNestedInput
        tenants?: TenantsUpdateOneRequiredWithoutSponsorsNestedInput
    }

    export type SponsorsUncheckedUpdateWithoutIncome_sponsorInput = {
        id?: StringFieldUpdateOperationsInput | string
        zone_id?: StringFieldUpdateOperationsInput | string
        file_number?: IntFieldUpdateOperationsInput | number
        start_date?: DateTimeFieldUpdateOperationsInput | Date | string
        name?: StringFieldUpdateOperationsInput | string
        address?: StringFieldUpdateOperationsInput | string
        phone_number?: StringFieldUpdateOperationsInput | string
        sponsorship_type?: StringFieldUpdateOperationsInput | string
        birth_date?: DateTimeFieldUpdateOperationsInput | Date | string
        father_name?: StringFieldUpdateOperationsInput | string
        mother_name?: StringFieldUpdateOperationsInput | string
        birth_certificate_number?: StringFieldUpdateOperationsInput | string
        academic_level?: StringFieldUpdateOperationsInput | string
        function?: StringFieldUpdateOperationsInput | string
        health_status?: StringFieldUpdateOperationsInput | string
        diploma?: NullableStringFieldUpdateOperationsInput | string | null
        card_number?: NullableStringFieldUpdateOperationsInput | string | null
        tenant_id?: StringFieldUpdateOperationsInput | string
        created_by?: StringFieldUpdateOperationsInput | string
        deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
        deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        sponsor_sponsorship?: Sponsor_sponsorshipUncheckedUpdateManyWithoutSponsorsNestedInput
    }

    export type TenantsUpsertWithoutIncome_sponsorInput = {
        update: XOR<TenantsUpdateWithoutIncome_sponsorInput, TenantsUncheckedUpdateWithoutIncome_sponsorInput>
        create: XOR<TenantsCreateWithoutIncome_sponsorInput, TenantsUncheckedCreateWithoutIncome_sponsorInput>
    }

    export type TenantsUpdateWithoutIncome_sponsorInput = {
        id?: StringFieldUpdateOperationsInput | string
        data?: NullableJsonNullValueInput | InputJsonValue
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        benefactors?: BenefactorsUpdateManyWithoutTenantsNestedInput
        domains?: DomainsUpdateManyWithoutTenantsNestedInput
        families?: FamiliesUpdateManyWithoutTenantsNestedInput
        family_sponsorship?: Family_sponsorshipUpdateManyWithoutTenantsNestedInput
        orphan_sponsorship?: Orphan_sponsorshipUpdateManyWithoutTenantsNestedInput
        orphans?: OrphansUpdateManyWithoutTenantsNestedInput
        second_sponsors?: Second_sponsorsUpdateManyWithoutTenantsNestedInput
        sponsor_sponsorship?: Sponsor_sponsorshipUpdateManyWithoutTenantsNestedInput
        sponsors?: SponsorsUpdateManyWithoutTenantsNestedInput
        sponsorships?: SponsorshipsUpdateManyWithoutTenantsNestedInput
        spouses?: SpousesUpdateManyWithoutTenantsNestedInput
        users?: UsersUpdateManyWithoutTenantsNestedInput
    }

    export type TenantsUncheckedUpdateWithoutIncome_sponsorInput = {
        id?: StringFieldUpdateOperationsInput | string
        data?: NullableJsonNullValueInput | InputJsonValue
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        benefactors?: BenefactorsUncheckedUpdateManyWithoutTenantsNestedInput
        domains?: DomainsUncheckedUpdateManyWithoutTenantsNestedInput
        families?: FamiliesUncheckedUpdateManyWithoutTenantsNestedInput
        family_sponsorship?: Family_sponsorshipUncheckedUpdateManyWithoutTenantsNestedInput
        orphan_sponsorship?: Orphan_sponsorshipUncheckedUpdateManyWithoutTenantsNestedInput
        orphans?: OrphansUncheckedUpdateManyWithoutTenantsNestedInput
        second_sponsors?: Second_sponsorsUncheckedUpdateManyWithoutTenantsNestedInput
        sponsor_sponsorship?: Sponsor_sponsorshipUncheckedUpdateManyWithoutTenantsNestedInput
        sponsors?: SponsorsUncheckedUpdateManyWithoutTenantsNestedInput
        sponsorships?: SponsorshipsUncheckedUpdateManyWithoutTenantsNestedInput
        spouses?: SpousesUncheckedUpdateManyWithoutTenantsNestedInput
        users?: UsersUncheckedUpdateManyWithoutTenantsNestedInput
    }

    export type Income_sponsorCreateWithoutIncomesInput = {
        id: string
        value: number
        created_at?: Date | string | null
        updated_at?: Date | string | null
        sponsors: SponsorsCreateNestedOneWithoutIncome_sponsorInput
        tenants: TenantsCreateNestedOneWithoutIncome_sponsorInput
    }

    export type Income_sponsorUncheckedCreateWithoutIncomesInput = {
        id: string
        sponsor_id: string
        tenant_id: string
        value: number
        created_at?: Date | string | null
        updated_at?: Date | string | null
    }

    export type Income_sponsorCreateOrConnectWithoutIncomesInput = {
        where: Income_sponsorWhereUniqueInput
        create: XOR<Income_sponsorCreateWithoutIncomesInput, Income_sponsorUncheckedCreateWithoutIncomesInput>
    }

    export type Income_sponsorCreateManyIncomesInputEnvelope = {
        data: Enumerable<Income_sponsorCreateManyIncomesInput>
        skipDuplicates?: boolean
    }

    export type Income_sponsorUpsertWithWhereUniqueWithoutIncomesInput = {
        where: Income_sponsorWhereUniqueInput
        update: XOR<Income_sponsorUpdateWithoutIncomesInput, Income_sponsorUncheckedUpdateWithoutIncomesInput>
        create: XOR<Income_sponsorCreateWithoutIncomesInput, Income_sponsorUncheckedCreateWithoutIncomesInput>
    }

    export type Income_sponsorUpdateWithWhereUniqueWithoutIncomesInput = {
        where: Income_sponsorWhereUniqueInput
        data: XOR<Income_sponsorUpdateWithoutIncomesInput, Income_sponsorUncheckedUpdateWithoutIncomesInput>
    }

    export type Income_sponsorUpdateManyWithWhereWithoutIncomesInput = {
        where: Income_sponsorScalarWhereInput
        data: XOR<Income_sponsorUpdateManyMutationInput, Income_sponsorUncheckedUpdateManyWithoutIncome_sponsorInput>
    }

    export type Income_sponsorScalarWhereInput = {
        AND?: Enumerable<Income_sponsorScalarWhereInput>
        OR?: Enumerable<Income_sponsorScalarWhereInput>
        NOT?: Enumerable<Income_sponsorScalarWhereInput>
        id?: UuidFilter | string
        income_id?: UuidFilter | string
        sponsor_id?: UuidFilter | string
        tenant_id?: StringFilter | string
        value?: FloatFilter | number
        created_at?: DateTimeNullableFilter | Date | string | null
        updated_at?: DateTimeNullableFilter | Date | string | null
    }

    export type PermissionsCreateWithoutModel_has_permissionsInput = {
        uuid: string
        name: string
        guard_name: string
        created_at?: Date | string | null
        updated_at?: Date | string | null
        role_has_permissions?: Role_has_permissionsCreateNestedManyWithoutPermissionsInput
    }

    export type PermissionsUncheckedCreateWithoutModel_has_permissionsInput = {
        uuid: string
        name: string
        guard_name: string
        created_at?: Date | string | null
        updated_at?: Date | string | null
        role_has_permissions?: Role_has_permissionsUncheckedCreateNestedManyWithoutPermissionsInput
    }

    export type PermissionsCreateOrConnectWithoutModel_has_permissionsInput = {
        where: PermissionsWhereUniqueInput
        create: XOR<
            PermissionsCreateWithoutModel_has_permissionsInput,
            PermissionsUncheckedCreateWithoutModel_has_permissionsInput
        >
    }

    export type PermissionsUpsertWithoutModel_has_permissionsInput = {
        update: XOR<
            PermissionsUpdateWithoutModel_has_permissionsInput,
            PermissionsUncheckedUpdateWithoutModel_has_permissionsInput
        >
        create: XOR<
            PermissionsCreateWithoutModel_has_permissionsInput,
            PermissionsUncheckedCreateWithoutModel_has_permissionsInput
        >
    }

    export type PermissionsUpdateWithoutModel_has_permissionsInput = {
        uuid?: StringFieldUpdateOperationsInput | string
        name?: StringFieldUpdateOperationsInput | string
        guard_name?: StringFieldUpdateOperationsInput | string
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        role_has_permissions?: Role_has_permissionsUpdateManyWithoutPermissionsNestedInput
    }

    export type PermissionsUncheckedUpdateWithoutModel_has_permissionsInput = {
        uuid?: StringFieldUpdateOperationsInput | string
        name?: StringFieldUpdateOperationsInput | string
        guard_name?: StringFieldUpdateOperationsInput | string
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        role_has_permissions?: Role_has_permissionsUncheckedUpdateManyWithoutPermissionsNestedInput
    }

    export type RolesCreateWithoutModel_has_rolesInput = {
        uuid: string
        name: string
        guard_name: string
        created_at?: Date | string | null
        updated_at?: Date | string | null
        role_has_permissions?: Role_has_permissionsCreateNestedManyWithoutRolesInput
    }

    export type RolesUncheckedCreateWithoutModel_has_rolesInput = {
        uuid: string
        name: string
        guard_name: string
        created_at?: Date | string | null
        updated_at?: Date | string | null
        role_has_permissions?: Role_has_permissionsUncheckedCreateNestedManyWithoutRolesInput
    }

    export type RolesCreateOrConnectWithoutModel_has_rolesInput = {
        where: RolesWhereUniqueInput
        create: XOR<RolesCreateWithoutModel_has_rolesInput, RolesUncheckedCreateWithoutModel_has_rolesInput>
    }

    export type RolesUpsertWithoutModel_has_rolesInput = {
        update: XOR<RolesUpdateWithoutModel_has_rolesInput, RolesUncheckedUpdateWithoutModel_has_rolesInput>
        create: XOR<RolesCreateWithoutModel_has_rolesInput, RolesUncheckedCreateWithoutModel_has_rolesInput>
    }

    export type RolesUpdateWithoutModel_has_rolesInput = {
        uuid?: StringFieldUpdateOperationsInput | string
        name?: StringFieldUpdateOperationsInput | string
        guard_name?: StringFieldUpdateOperationsInput | string
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        role_has_permissions?: Role_has_permissionsUpdateManyWithoutRolesNestedInput
    }

    export type RolesUncheckedUpdateWithoutModel_has_rolesInput = {
        uuid?: StringFieldUpdateOperationsInput | string
        name?: StringFieldUpdateOperationsInput | string
        guard_name?: StringFieldUpdateOperationsInput | string
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        role_has_permissions?: Role_has_permissionsUncheckedUpdateManyWithoutRolesNestedInput
    }

    export type OrphansCreateWithoutOrphan_sponsorshipInput = {
        id: string
        first_name: string
        last_name: string
        birth_date: Date | string
        family_status: string
        health_status: string
        academic_level: string
        shoes_size: string
        pants_size: string
        shirt_size: string
        note: string
        created_at?: Date | string | null
        updated_at?: Date | string | null
        users_orphans_created_byTousers: UsersCreateNestedOneWithoutOrphans_orphans_created_byTousersInput
        users_orphans_deleted_byTousers?: UsersCreateNestedOneWithoutOrphans_orphans_deleted_byTousersInput
        families: FamiliesCreateNestedOneWithoutOrphansInput
        tenants: TenantsCreateNestedOneWithoutOrphansInput
    }

    export type OrphansUncheckedCreateWithoutOrphan_sponsorshipInput = {
        id: string
        first_name: string
        last_name: string
        birth_date: Date | string
        family_status: string
        health_status: string
        academic_level: string
        shoes_size: string
        pants_size: string
        shirt_size: string
        note: string
        tenant_id: string
        family_id: string
        created_by: string
        deleted_by?: string | null
        created_at?: Date | string | null
        updated_at?: Date | string | null
    }

    export type OrphansCreateOrConnectWithoutOrphan_sponsorshipInput = {
        where: OrphansWhereUniqueInput
        create: XOR<OrphansCreateWithoutOrphan_sponsorshipInput, OrphansUncheckedCreateWithoutOrphan_sponsorshipInput>
    }

    export type TenantsCreateWithoutOrphan_sponsorshipInput = {
        id: string
        data?: NullableJsonNullValueInput | InputJsonValue
        created_at?: Date | string | null
        updated_at?: Date | string | null
        benefactors?: BenefactorsCreateNestedManyWithoutTenantsInput
        domains?: DomainsCreateNestedManyWithoutTenantsInput
        families?: FamiliesCreateNestedManyWithoutTenantsInput
        family_sponsorship?: Family_sponsorshipCreateNestedManyWithoutTenantsInput
        income_sponsor?: Income_sponsorCreateNestedManyWithoutTenantsInput
        orphans?: OrphansCreateNestedManyWithoutTenantsInput
        second_sponsors?: Second_sponsorsCreateNestedManyWithoutTenantsInput
        sponsor_sponsorship?: Sponsor_sponsorshipCreateNestedManyWithoutTenantsInput
        sponsors?: SponsorsCreateNestedManyWithoutTenantsInput
        sponsorships?: SponsorshipsCreateNestedManyWithoutTenantsInput
        spouses?: SpousesCreateNestedManyWithoutTenantsInput
        users?: UsersCreateNestedManyWithoutTenantsInput
    }

    export type TenantsUncheckedCreateWithoutOrphan_sponsorshipInput = {
        id: string
        data?: NullableJsonNullValueInput | InputJsonValue
        created_at?: Date | string | null
        updated_at?: Date | string | null
        benefactors?: BenefactorsUncheckedCreateNestedManyWithoutTenantsInput
        domains?: DomainsUncheckedCreateNestedManyWithoutTenantsInput
        families?: FamiliesUncheckedCreateNestedManyWithoutTenantsInput
        family_sponsorship?: Family_sponsorshipUncheckedCreateNestedManyWithoutTenantsInput
        income_sponsor?: Income_sponsorUncheckedCreateNestedManyWithoutTenantsInput
        orphans?: OrphansUncheckedCreateNestedManyWithoutTenantsInput
        second_sponsors?: Second_sponsorsUncheckedCreateNestedManyWithoutTenantsInput
        sponsor_sponsorship?: Sponsor_sponsorshipUncheckedCreateNestedManyWithoutTenantsInput
        sponsors?: SponsorsUncheckedCreateNestedManyWithoutTenantsInput
        sponsorships?: SponsorshipsUncheckedCreateNestedManyWithoutTenantsInput
        spouses?: SpousesUncheckedCreateNestedManyWithoutTenantsInput
        users?: UsersUncheckedCreateNestedManyWithoutTenantsInput
    }

    export type TenantsCreateOrConnectWithoutOrphan_sponsorshipInput = {
        where: TenantsWhereUniqueInput
        create: XOR<TenantsCreateWithoutOrphan_sponsorshipInput, TenantsUncheckedCreateWithoutOrphan_sponsorshipInput>
    }

    export type OrphansUpsertWithoutOrphan_sponsorshipInput = {
        update: XOR<OrphansUpdateWithoutOrphan_sponsorshipInput, OrphansUncheckedUpdateWithoutOrphan_sponsorshipInput>
        create: XOR<OrphansCreateWithoutOrphan_sponsorshipInput, OrphansUncheckedCreateWithoutOrphan_sponsorshipInput>
    }

    export type OrphansUpdateWithoutOrphan_sponsorshipInput = {
        id?: StringFieldUpdateOperationsInput | string
        first_name?: StringFieldUpdateOperationsInput | string
        last_name?: StringFieldUpdateOperationsInput | string
        birth_date?: DateTimeFieldUpdateOperationsInput | Date | string
        family_status?: StringFieldUpdateOperationsInput | string
        health_status?: StringFieldUpdateOperationsInput | string
        academic_level?: StringFieldUpdateOperationsInput | string
        shoes_size?: StringFieldUpdateOperationsInput | string
        pants_size?: StringFieldUpdateOperationsInput | string
        shirt_size?: StringFieldUpdateOperationsInput | string
        note?: StringFieldUpdateOperationsInput | string
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        users_orphans_created_byTousers?: UsersUpdateOneRequiredWithoutOrphans_orphans_created_byTousersNestedInput
        users_orphans_deleted_byTousers?: UsersUpdateOneWithoutOrphans_orphans_deleted_byTousersNestedInput
        families?: FamiliesUpdateOneRequiredWithoutOrphansNestedInput
        tenants?: TenantsUpdateOneRequiredWithoutOrphansNestedInput
    }

    export type OrphansUncheckedUpdateWithoutOrphan_sponsorshipInput = {
        id?: StringFieldUpdateOperationsInput | string
        first_name?: StringFieldUpdateOperationsInput | string
        last_name?: StringFieldUpdateOperationsInput | string
        birth_date?: DateTimeFieldUpdateOperationsInput | Date | string
        family_status?: StringFieldUpdateOperationsInput | string
        health_status?: StringFieldUpdateOperationsInput | string
        academic_level?: StringFieldUpdateOperationsInput | string
        shoes_size?: StringFieldUpdateOperationsInput | string
        pants_size?: StringFieldUpdateOperationsInput | string
        shirt_size?: StringFieldUpdateOperationsInput | string
        note?: StringFieldUpdateOperationsInput | string
        tenant_id?: StringFieldUpdateOperationsInput | string
        family_id?: StringFieldUpdateOperationsInput | string
        created_by?: StringFieldUpdateOperationsInput | string
        deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    }

    export type TenantsUpsertWithoutOrphan_sponsorshipInput = {
        update: XOR<TenantsUpdateWithoutOrphan_sponsorshipInput, TenantsUncheckedUpdateWithoutOrphan_sponsorshipInput>
        create: XOR<TenantsCreateWithoutOrphan_sponsorshipInput, TenantsUncheckedCreateWithoutOrphan_sponsorshipInput>
    }

    export type TenantsUpdateWithoutOrphan_sponsorshipInput = {
        id?: StringFieldUpdateOperationsInput | string
        data?: NullableJsonNullValueInput | InputJsonValue
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        benefactors?: BenefactorsUpdateManyWithoutTenantsNestedInput
        domains?: DomainsUpdateManyWithoutTenantsNestedInput
        families?: FamiliesUpdateManyWithoutTenantsNestedInput
        family_sponsorship?: Family_sponsorshipUpdateManyWithoutTenantsNestedInput
        income_sponsor?: Income_sponsorUpdateManyWithoutTenantsNestedInput
        orphans?: OrphansUpdateManyWithoutTenantsNestedInput
        second_sponsors?: Second_sponsorsUpdateManyWithoutTenantsNestedInput
        sponsor_sponsorship?: Sponsor_sponsorshipUpdateManyWithoutTenantsNestedInput
        sponsors?: SponsorsUpdateManyWithoutTenantsNestedInput
        sponsorships?: SponsorshipsUpdateManyWithoutTenantsNestedInput
        spouses?: SpousesUpdateManyWithoutTenantsNestedInput
        users?: UsersUpdateManyWithoutTenantsNestedInput
    }

    export type TenantsUncheckedUpdateWithoutOrphan_sponsorshipInput = {
        id?: StringFieldUpdateOperationsInput | string
        data?: NullableJsonNullValueInput | InputJsonValue
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        benefactors?: BenefactorsUncheckedUpdateManyWithoutTenantsNestedInput
        domains?: DomainsUncheckedUpdateManyWithoutTenantsNestedInput
        families?: FamiliesUncheckedUpdateManyWithoutTenantsNestedInput
        family_sponsorship?: Family_sponsorshipUncheckedUpdateManyWithoutTenantsNestedInput
        income_sponsor?: Income_sponsorUncheckedUpdateManyWithoutTenantsNestedInput
        orphans?: OrphansUncheckedUpdateManyWithoutTenantsNestedInput
        second_sponsors?: Second_sponsorsUncheckedUpdateManyWithoutTenantsNestedInput
        sponsor_sponsorship?: Sponsor_sponsorshipUncheckedUpdateManyWithoutTenantsNestedInput
        sponsors?: SponsorsUncheckedUpdateManyWithoutTenantsNestedInput
        sponsorships?: SponsorshipsUncheckedUpdateManyWithoutTenantsNestedInput
        spouses?: SpousesUncheckedUpdateManyWithoutTenantsNestedInput
        users?: UsersUncheckedUpdateManyWithoutTenantsNestedInput
    }

    export type Orphan_sponsorshipCreateWithoutOrphansInput = {
        id: string
        type: orphan_sponsorship_type
        value?: string | null
        created_at?: Date | string | null
        updated_at?: Date | string | null
        tenants: TenantsCreateNestedOneWithoutOrphan_sponsorshipInput
    }

    export type Orphan_sponsorshipUncheckedCreateWithoutOrphansInput = {
        id: string
        type: orphan_sponsorship_type
        value?: string | null
        tenant_id: string
        created_at?: Date | string | null
        updated_at?: Date | string | null
    }

    export type Orphan_sponsorshipCreateOrConnectWithoutOrphansInput = {
        where: Orphan_sponsorshipWhereUniqueInput
        create: XOR<Orphan_sponsorshipCreateWithoutOrphansInput, Orphan_sponsorshipUncheckedCreateWithoutOrphansInput>
    }

    export type Orphan_sponsorshipCreateManyOrphansInputEnvelope = {
        data: Enumerable<Orphan_sponsorshipCreateManyOrphansInput>
        skipDuplicates?: boolean
    }

    export type UsersCreateWithoutOrphans_orphans_created_byTousersInput = {
        id: string
        first_name: string
        last_name: string
        phone: string
        email: string
        email_verified_at?: Date | string | null
        password: string
        remember_token?: string | null
        created_at?: Date | string | null
        updated_at?: Date | string | null
        orphans_orphans_deleted_byTousers?: OrphansCreateNestedManyWithoutUsers_orphans_deleted_byTousersInput
        sessions?: SessionsCreateNestedManyWithoutUsersInput
        settings?: SettingsCreateNestedManyWithoutUsersInput
        sponsors_sponsors_created_byTousers?: SponsorsCreateNestedManyWithoutUsers_sponsors_created_byTousersInput
        sponsors_sponsors_deleted_byTousers?: SponsorsCreateNestedManyWithoutUsers_sponsors_deleted_byTousersInput
        tenants: TenantsCreateNestedOneWithoutUsersInput
    }

    export type UsersUncheckedCreateWithoutOrphans_orphans_created_byTousersInput = {
        id: string
        first_name: string
        last_name: string
        phone: string
        email: string
        email_verified_at?: Date | string | null
        password: string
        remember_token?: string | null
        tenant_id: string
        created_at?: Date | string | null
        updated_at?: Date | string | null
        orphans_orphans_deleted_byTousers?: OrphansUncheckedCreateNestedManyWithoutUsers_orphans_deleted_byTousersInput
        sessions?: SessionsUncheckedCreateNestedManyWithoutUsersInput
        settings?: SettingsUncheckedCreateNestedManyWithoutUsersInput
        sponsors_sponsors_created_byTousers?: SponsorsUncheckedCreateNestedManyWithoutUsers_sponsors_created_byTousersInput
        sponsors_sponsors_deleted_byTousers?: SponsorsUncheckedCreateNestedManyWithoutUsers_sponsors_deleted_byTousersInput
    }

    export type UsersCreateOrConnectWithoutOrphans_orphans_created_byTousersInput = {
        where: UsersWhereUniqueInput
        create: XOR<
            UsersCreateWithoutOrphans_orphans_created_byTousersInput,
            UsersUncheckedCreateWithoutOrphans_orphans_created_byTousersInput
        >
    }

    export type UsersCreateWithoutOrphans_orphans_deleted_byTousersInput = {
        id: string
        first_name: string
        last_name: string
        phone: string
        email: string
        email_verified_at?: Date | string | null
        password: string
        remember_token?: string | null
        created_at?: Date | string | null
        updated_at?: Date | string | null
        orphans_orphans_created_byTousers?: OrphansCreateNestedManyWithoutUsers_orphans_created_byTousersInput
        sessions?: SessionsCreateNestedManyWithoutUsersInput
        settings?: SettingsCreateNestedManyWithoutUsersInput
        sponsors_sponsors_created_byTousers?: SponsorsCreateNestedManyWithoutUsers_sponsors_created_byTousersInput
        sponsors_sponsors_deleted_byTousers?: SponsorsCreateNestedManyWithoutUsers_sponsors_deleted_byTousersInput
        tenants: TenantsCreateNestedOneWithoutUsersInput
    }

    export type UsersUncheckedCreateWithoutOrphans_orphans_deleted_byTousersInput = {
        id: string
        first_name: string
        last_name: string
        phone: string
        email: string
        email_verified_at?: Date | string | null
        password: string
        remember_token?: string | null
        tenant_id: string
        created_at?: Date | string | null
        updated_at?: Date | string | null
        orphans_orphans_created_byTousers?: OrphansUncheckedCreateNestedManyWithoutUsers_orphans_created_byTousersInput
        sessions?: SessionsUncheckedCreateNestedManyWithoutUsersInput
        settings?: SettingsUncheckedCreateNestedManyWithoutUsersInput
        sponsors_sponsors_created_byTousers?: SponsorsUncheckedCreateNestedManyWithoutUsers_sponsors_created_byTousersInput
        sponsors_sponsors_deleted_byTousers?: SponsorsUncheckedCreateNestedManyWithoutUsers_sponsors_deleted_byTousersInput
    }

    export type UsersCreateOrConnectWithoutOrphans_orphans_deleted_byTousersInput = {
        where: UsersWhereUniqueInput
        create: XOR<
            UsersCreateWithoutOrphans_orphans_deleted_byTousersInput,
            UsersUncheckedCreateWithoutOrphans_orphans_deleted_byTousersInput
        >
    }

    export type FamiliesCreateWithoutOrphansInput = {
        id: string
        name: string
        report: string
        created_at?: Date | string | null
        updated_at?: Date | string | null
        tenants: TenantsCreateNestedOneWithoutFamiliesInput
        family_furnishing?: Family_furnishingCreateNestedManyWithoutFamiliesInput
        family_housing?: Family_housingCreateNestedManyWithoutFamiliesInput
        family_sponsorship?: Family_sponsorshipCreateNestedManyWithoutFamiliesInput
        second_sponsors?: Second_sponsorsCreateNestedManyWithoutFamiliesInput
        spouses?: SpousesCreateNestedManyWithoutFamiliesInput
    }

    export type FamiliesUncheckedCreateWithoutOrphansInput = {
        id: string
        name: string
        report: string
        tenant_id: string
        created_at?: Date | string | null
        updated_at?: Date | string | null
        family_furnishing?: Family_furnishingUncheckedCreateNestedManyWithoutFamiliesInput
        family_housing?: Family_housingUncheckedCreateNestedManyWithoutFamiliesInput
        family_sponsorship?: Family_sponsorshipUncheckedCreateNestedManyWithoutFamiliesInput
        second_sponsors?: Second_sponsorsUncheckedCreateNestedManyWithoutFamiliesInput
        spouses?: SpousesUncheckedCreateNestedManyWithoutFamiliesInput
    }

    export type FamiliesCreateOrConnectWithoutOrphansInput = {
        where: FamiliesWhereUniqueInput
        create: XOR<FamiliesCreateWithoutOrphansInput, FamiliesUncheckedCreateWithoutOrphansInput>
    }

    export type TenantsCreateWithoutOrphansInput = {
        id: string
        data?: NullableJsonNullValueInput | InputJsonValue
        created_at?: Date | string | null
        updated_at?: Date | string | null
        benefactors?: BenefactorsCreateNestedManyWithoutTenantsInput
        domains?: DomainsCreateNestedManyWithoutTenantsInput
        families?: FamiliesCreateNestedManyWithoutTenantsInput
        family_sponsorship?: Family_sponsorshipCreateNestedManyWithoutTenantsInput
        income_sponsor?: Income_sponsorCreateNestedManyWithoutTenantsInput
        orphan_sponsorship?: Orphan_sponsorshipCreateNestedManyWithoutTenantsInput
        second_sponsors?: Second_sponsorsCreateNestedManyWithoutTenantsInput
        sponsor_sponsorship?: Sponsor_sponsorshipCreateNestedManyWithoutTenantsInput
        sponsors?: SponsorsCreateNestedManyWithoutTenantsInput
        sponsorships?: SponsorshipsCreateNestedManyWithoutTenantsInput
        spouses?: SpousesCreateNestedManyWithoutTenantsInput
        users?: UsersCreateNestedManyWithoutTenantsInput
    }

    export type TenantsUncheckedCreateWithoutOrphansInput = {
        id: string
        data?: NullableJsonNullValueInput | InputJsonValue
        created_at?: Date | string | null
        updated_at?: Date | string | null
        benefactors?: BenefactorsUncheckedCreateNestedManyWithoutTenantsInput
        domains?: DomainsUncheckedCreateNestedManyWithoutTenantsInput
        families?: FamiliesUncheckedCreateNestedManyWithoutTenantsInput
        family_sponsorship?: Family_sponsorshipUncheckedCreateNestedManyWithoutTenantsInput
        income_sponsor?: Income_sponsorUncheckedCreateNestedManyWithoutTenantsInput
        orphan_sponsorship?: Orphan_sponsorshipUncheckedCreateNestedManyWithoutTenantsInput
        second_sponsors?: Second_sponsorsUncheckedCreateNestedManyWithoutTenantsInput
        sponsor_sponsorship?: Sponsor_sponsorshipUncheckedCreateNestedManyWithoutTenantsInput
        sponsors?: SponsorsUncheckedCreateNestedManyWithoutTenantsInput
        sponsorships?: SponsorshipsUncheckedCreateNestedManyWithoutTenantsInput
        spouses?: SpousesUncheckedCreateNestedManyWithoutTenantsInput
        users?: UsersUncheckedCreateNestedManyWithoutTenantsInput
    }

    export type TenantsCreateOrConnectWithoutOrphansInput = {
        where: TenantsWhereUniqueInput
        create: XOR<TenantsCreateWithoutOrphansInput, TenantsUncheckedCreateWithoutOrphansInput>
    }

    export type Orphan_sponsorshipUpsertWithWhereUniqueWithoutOrphansInput = {
        where: Orphan_sponsorshipWhereUniqueInput
        update: XOR<Orphan_sponsorshipUpdateWithoutOrphansInput, Orphan_sponsorshipUncheckedUpdateWithoutOrphansInput>
        create: XOR<Orphan_sponsorshipCreateWithoutOrphansInput, Orphan_sponsorshipUncheckedCreateWithoutOrphansInput>
    }

    export type Orphan_sponsorshipUpdateWithWhereUniqueWithoutOrphansInput = {
        where: Orphan_sponsorshipWhereUniqueInput
        data: XOR<Orphan_sponsorshipUpdateWithoutOrphansInput, Orphan_sponsorshipUncheckedUpdateWithoutOrphansInput>
    }

    export type Orphan_sponsorshipUpdateManyWithWhereWithoutOrphansInput = {
        where: Orphan_sponsorshipScalarWhereInput
        data: XOR<
            Orphan_sponsorshipUpdateManyMutationInput,
            Orphan_sponsorshipUncheckedUpdateManyWithoutOrphan_sponsorshipInput
        >
    }

    export type Orphan_sponsorshipScalarWhereInput = {
        AND?: Enumerable<Orphan_sponsorshipScalarWhereInput>
        OR?: Enumerable<Orphan_sponsorshipScalarWhereInput>
        NOT?: Enumerable<Orphan_sponsorshipScalarWhereInput>
        id?: UuidFilter | string
        orphan_id?: UuidFilter | string
        type?: Enumorphan_sponsorship_typeFilter | orphan_sponsorship_type
        value?: StringNullableFilter | string | null
        tenant_id?: StringFilter | string
        created_at?: DateTimeNullableFilter | Date | string | null
        updated_at?: DateTimeNullableFilter | Date | string | null
    }

    export type UsersUpsertWithoutOrphans_orphans_created_byTousersInput = {
        update: XOR<
            UsersUpdateWithoutOrphans_orphans_created_byTousersInput,
            UsersUncheckedUpdateWithoutOrphans_orphans_created_byTousersInput
        >
        create: XOR<
            UsersCreateWithoutOrphans_orphans_created_byTousersInput,
            UsersUncheckedCreateWithoutOrphans_orphans_created_byTousersInput
        >
    }

    export type UsersUpdateWithoutOrphans_orphans_created_byTousersInput = {
        id?: StringFieldUpdateOperationsInput | string
        first_name?: StringFieldUpdateOperationsInput | string
        last_name?: StringFieldUpdateOperationsInput | string
        phone?: StringFieldUpdateOperationsInput | string
        email?: StringFieldUpdateOperationsInput | string
        email_verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        password?: StringFieldUpdateOperationsInput | string
        remember_token?: NullableStringFieldUpdateOperationsInput | string | null
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        orphans_orphans_deleted_byTousers?: OrphansUpdateManyWithoutUsers_orphans_deleted_byTousersNestedInput
        sessions?: SessionsUpdateManyWithoutUsersNestedInput
        settings?: SettingsUpdateManyWithoutUsersNestedInput
        sponsors_sponsors_created_byTousers?: SponsorsUpdateManyWithoutUsers_sponsors_created_byTousersNestedInput
        sponsors_sponsors_deleted_byTousers?: SponsorsUpdateManyWithoutUsers_sponsors_deleted_byTousersNestedInput
        tenants?: TenantsUpdateOneRequiredWithoutUsersNestedInput
    }

    export type UsersUncheckedUpdateWithoutOrphans_orphans_created_byTousersInput = {
        id?: StringFieldUpdateOperationsInput | string
        first_name?: StringFieldUpdateOperationsInput | string
        last_name?: StringFieldUpdateOperationsInput | string
        phone?: StringFieldUpdateOperationsInput | string
        email?: StringFieldUpdateOperationsInput | string
        email_verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        password?: StringFieldUpdateOperationsInput | string
        remember_token?: NullableStringFieldUpdateOperationsInput | string | null
        tenant_id?: StringFieldUpdateOperationsInput | string
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        orphans_orphans_deleted_byTousers?: OrphansUncheckedUpdateManyWithoutUsers_orphans_deleted_byTousersNestedInput
        sessions?: SessionsUncheckedUpdateManyWithoutUsersNestedInput
        settings?: SettingsUncheckedUpdateManyWithoutUsersNestedInput
        sponsors_sponsors_created_byTousers?: SponsorsUncheckedUpdateManyWithoutUsers_sponsors_created_byTousersNestedInput
        sponsors_sponsors_deleted_byTousers?: SponsorsUncheckedUpdateManyWithoutUsers_sponsors_deleted_byTousersNestedInput
    }

    export type UsersUpsertWithoutOrphans_orphans_deleted_byTousersInput = {
        update: XOR<
            UsersUpdateWithoutOrphans_orphans_deleted_byTousersInput,
            UsersUncheckedUpdateWithoutOrphans_orphans_deleted_byTousersInput
        >
        create: XOR<
            UsersCreateWithoutOrphans_orphans_deleted_byTousersInput,
            UsersUncheckedCreateWithoutOrphans_orphans_deleted_byTousersInput
        >
    }

    export type UsersUpdateWithoutOrphans_orphans_deleted_byTousersInput = {
        id?: StringFieldUpdateOperationsInput | string
        first_name?: StringFieldUpdateOperationsInput | string
        last_name?: StringFieldUpdateOperationsInput | string
        phone?: StringFieldUpdateOperationsInput | string
        email?: StringFieldUpdateOperationsInput | string
        email_verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        password?: StringFieldUpdateOperationsInput | string
        remember_token?: NullableStringFieldUpdateOperationsInput | string | null
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        orphans_orphans_created_byTousers?: OrphansUpdateManyWithoutUsers_orphans_created_byTousersNestedInput
        sessions?: SessionsUpdateManyWithoutUsersNestedInput
        settings?: SettingsUpdateManyWithoutUsersNestedInput
        sponsors_sponsors_created_byTousers?: SponsorsUpdateManyWithoutUsers_sponsors_created_byTousersNestedInput
        sponsors_sponsors_deleted_byTousers?: SponsorsUpdateManyWithoutUsers_sponsors_deleted_byTousersNestedInput
        tenants?: TenantsUpdateOneRequiredWithoutUsersNestedInput
    }

    export type UsersUncheckedUpdateWithoutOrphans_orphans_deleted_byTousersInput = {
        id?: StringFieldUpdateOperationsInput | string
        first_name?: StringFieldUpdateOperationsInput | string
        last_name?: StringFieldUpdateOperationsInput | string
        phone?: StringFieldUpdateOperationsInput | string
        email?: StringFieldUpdateOperationsInput | string
        email_verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        password?: StringFieldUpdateOperationsInput | string
        remember_token?: NullableStringFieldUpdateOperationsInput | string | null
        tenant_id?: StringFieldUpdateOperationsInput | string
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        orphans_orphans_created_byTousers?: OrphansUncheckedUpdateManyWithoutUsers_orphans_created_byTousersNestedInput
        sessions?: SessionsUncheckedUpdateManyWithoutUsersNestedInput
        settings?: SettingsUncheckedUpdateManyWithoutUsersNestedInput
        sponsors_sponsors_created_byTousers?: SponsorsUncheckedUpdateManyWithoutUsers_sponsors_created_byTousersNestedInput
        sponsors_sponsors_deleted_byTousers?: SponsorsUncheckedUpdateManyWithoutUsers_sponsors_deleted_byTousersNestedInput
    }

    export type FamiliesUpsertWithoutOrphansInput = {
        update: XOR<FamiliesUpdateWithoutOrphansInput, FamiliesUncheckedUpdateWithoutOrphansInput>
        create: XOR<FamiliesCreateWithoutOrphansInput, FamiliesUncheckedCreateWithoutOrphansInput>
    }

    export type FamiliesUpdateWithoutOrphansInput = {
        id?: StringFieldUpdateOperationsInput | string
        name?: StringFieldUpdateOperationsInput | string
        report?: StringFieldUpdateOperationsInput | string
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        tenants?: TenantsUpdateOneRequiredWithoutFamiliesNestedInput
        family_furnishing?: Family_furnishingUpdateManyWithoutFamiliesNestedInput
        family_housing?: Family_housingUpdateManyWithoutFamiliesNestedInput
        family_sponsorship?: Family_sponsorshipUpdateManyWithoutFamiliesNestedInput
        second_sponsors?: Second_sponsorsUpdateManyWithoutFamiliesNestedInput
        spouses?: SpousesUpdateManyWithoutFamiliesNestedInput
    }

    export type FamiliesUncheckedUpdateWithoutOrphansInput = {
        id?: StringFieldUpdateOperationsInput | string
        name?: StringFieldUpdateOperationsInput | string
        report?: StringFieldUpdateOperationsInput | string
        tenant_id?: StringFieldUpdateOperationsInput | string
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        family_furnishing?: Family_furnishingUncheckedUpdateManyWithoutFamiliesNestedInput
        family_housing?: Family_housingUncheckedUpdateManyWithoutFamiliesNestedInput
        family_sponsorship?: Family_sponsorshipUncheckedUpdateManyWithoutFamiliesNestedInput
        second_sponsors?: Second_sponsorsUncheckedUpdateManyWithoutFamiliesNestedInput
        spouses?: SpousesUncheckedUpdateManyWithoutFamiliesNestedInput
    }

    export type TenantsUpsertWithoutOrphansInput = {
        update: XOR<TenantsUpdateWithoutOrphansInput, TenantsUncheckedUpdateWithoutOrphansInput>
        create: XOR<TenantsCreateWithoutOrphansInput, TenantsUncheckedCreateWithoutOrphansInput>
    }

    export type TenantsUpdateWithoutOrphansInput = {
        id?: StringFieldUpdateOperationsInput | string
        data?: NullableJsonNullValueInput | InputJsonValue
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        benefactors?: BenefactorsUpdateManyWithoutTenantsNestedInput
        domains?: DomainsUpdateManyWithoutTenantsNestedInput
        families?: FamiliesUpdateManyWithoutTenantsNestedInput
        family_sponsorship?: Family_sponsorshipUpdateManyWithoutTenantsNestedInput
        income_sponsor?: Income_sponsorUpdateManyWithoutTenantsNestedInput
        orphan_sponsorship?: Orphan_sponsorshipUpdateManyWithoutTenantsNestedInput
        second_sponsors?: Second_sponsorsUpdateManyWithoutTenantsNestedInput
        sponsor_sponsorship?: Sponsor_sponsorshipUpdateManyWithoutTenantsNestedInput
        sponsors?: SponsorsUpdateManyWithoutTenantsNestedInput
        sponsorships?: SponsorshipsUpdateManyWithoutTenantsNestedInput
        spouses?: SpousesUpdateManyWithoutTenantsNestedInput
        users?: UsersUpdateManyWithoutTenantsNestedInput
    }

    export type TenantsUncheckedUpdateWithoutOrphansInput = {
        id?: StringFieldUpdateOperationsInput | string
        data?: NullableJsonNullValueInput | InputJsonValue
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        benefactors?: BenefactorsUncheckedUpdateManyWithoutTenantsNestedInput
        domains?: DomainsUncheckedUpdateManyWithoutTenantsNestedInput
        families?: FamiliesUncheckedUpdateManyWithoutTenantsNestedInput
        family_sponsorship?: Family_sponsorshipUncheckedUpdateManyWithoutTenantsNestedInput
        income_sponsor?: Income_sponsorUncheckedUpdateManyWithoutTenantsNestedInput
        orphan_sponsorship?: Orphan_sponsorshipUncheckedUpdateManyWithoutTenantsNestedInput
        second_sponsors?: Second_sponsorsUncheckedUpdateManyWithoutTenantsNestedInput
        sponsor_sponsorship?: Sponsor_sponsorshipUncheckedUpdateManyWithoutTenantsNestedInput
        sponsors?: SponsorsUncheckedUpdateManyWithoutTenantsNestedInput
        sponsorships?: SponsorshipsUncheckedUpdateManyWithoutTenantsNestedInput
        spouses?: SpousesUncheckedUpdateManyWithoutTenantsNestedInput
        users?: UsersUncheckedUpdateManyWithoutTenantsNestedInput
    }

    export type Model_has_permissionsCreateWithoutPermissionsInput = {
        model_type: string
        model_uuid: string
    }

    export type Model_has_permissionsUncheckedCreateWithoutPermissionsInput = {
        model_type: string
        model_uuid: string
    }

    export type Model_has_permissionsCreateOrConnectWithoutPermissionsInput = {
        where: Model_has_permissionsWhereUniqueInput
        create: XOR<
            Model_has_permissionsCreateWithoutPermissionsInput,
            Model_has_permissionsUncheckedCreateWithoutPermissionsInput
        >
    }

    export type Model_has_permissionsCreateManyPermissionsInputEnvelope = {
        data: Enumerable<Model_has_permissionsCreateManyPermissionsInput>
        skipDuplicates?: boolean
    }

    export type Role_has_permissionsCreateWithoutPermissionsInput = {
        roles: RolesCreateNestedOneWithoutRole_has_permissionsInput
    }

    export type Role_has_permissionsUncheckedCreateWithoutPermissionsInput = {
        role_id: string
    }

    export type Role_has_permissionsCreateOrConnectWithoutPermissionsInput = {
        where: Role_has_permissionsWhereUniqueInput
        create: XOR<
            Role_has_permissionsCreateWithoutPermissionsInput,
            Role_has_permissionsUncheckedCreateWithoutPermissionsInput
        >
    }

    export type Role_has_permissionsCreateManyPermissionsInputEnvelope = {
        data: Enumerable<Role_has_permissionsCreateManyPermissionsInput>
        skipDuplicates?: boolean
    }

    export type Model_has_permissionsUpsertWithWhereUniqueWithoutPermissionsInput = {
        where: Model_has_permissionsWhereUniqueInput
        update: XOR<
            Model_has_permissionsUpdateWithoutPermissionsInput,
            Model_has_permissionsUncheckedUpdateWithoutPermissionsInput
        >
        create: XOR<
            Model_has_permissionsCreateWithoutPermissionsInput,
            Model_has_permissionsUncheckedCreateWithoutPermissionsInput
        >
    }

    export type Model_has_permissionsUpdateWithWhereUniqueWithoutPermissionsInput = {
        where: Model_has_permissionsWhereUniqueInput
        data: XOR<
            Model_has_permissionsUpdateWithoutPermissionsInput,
            Model_has_permissionsUncheckedUpdateWithoutPermissionsInput
        >
    }

    export type Model_has_permissionsUpdateManyWithWhereWithoutPermissionsInput = {
        where: Model_has_permissionsScalarWhereInput
        data: XOR<
            Model_has_permissionsUpdateManyMutationInput,
            Model_has_permissionsUncheckedUpdateManyWithoutModel_has_permissionsInput
        >
    }

    export type Model_has_permissionsScalarWhereInput = {
        AND?: Enumerable<Model_has_permissionsScalarWhereInput>
        OR?: Enumerable<Model_has_permissionsScalarWhereInput>
        NOT?: Enumerable<Model_has_permissionsScalarWhereInput>
        permission_id?: UuidFilter | string
        model_type?: StringFilter | string
        model_uuid?: UuidFilter | string
    }

    export type Role_has_permissionsUpsertWithWhereUniqueWithoutPermissionsInput = {
        where: Role_has_permissionsWhereUniqueInput
        update: XOR<
            Role_has_permissionsUpdateWithoutPermissionsInput,
            Role_has_permissionsUncheckedUpdateWithoutPermissionsInput
        >
        create: XOR<
            Role_has_permissionsCreateWithoutPermissionsInput,
            Role_has_permissionsUncheckedCreateWithoutPermissionsInput
        >
    }

    export type Role_has_permissionsUpdateWithWhereUniqueWithoutPermissionsInput = {
        where: Role_has_permissionsWhereUniqueInput
        data: XOR<
            Role_has_permissionsUpdateWithoutPermissionsInput,
            Role_has_permissionsUncheckedUpdateWithoutPermissionsInput
        >
    }

    export type Role_has_permissionsUpdateManyWithWhereWithoutPermissionsInput = {
        where: Role_has_permissionsScalarWhereInput
        data: XOR<
            Role_has_permissionsUpdateManyMutationInput,
            Role_has_permissionsUncheckedUpdateManyWithoutRole_has_permissionsInput
        >
    }

    export type Role_has_permissionsScalarWhereInput = {
        AND?: Enumerable<Role_has_permissionsScalarWhereInput>
        OR?: Enumerable<Role_has_permissionsScalarWhereInput>
        NOT?: Enumerable<Role_has_permissionsScalarWhereInput>
        permission_id?: UuidFilter | string
        role_id?: UuidFilter | string
    }

    export type PermissionsCreateWithoutRole_has_permissionsInput = {
        uuid: string
        name: string
        guard_name: string
        created_at?: Date | string | null
        updated_at?: Date | string | null
        model_has_permissions?: Model_has_permissionsCreateNestedManyWithoutPermissionsInput
    }

    export type PermissionsUncheckedCreateWithoutRole_has_permissionsInput = {
        uuid: string
        name: string
        guard_name: string
        created_at?: Date | string | null
        updated_at?: Date | string | null
        model_has_permissions?: Model_has_permissionsUncheckedCreateNestedManyWithoutPermissionsInput
    }

    export type PermissionsCreateOrConnectWithoutRole_has_permissionsInput = {
        where: PermissionsWhereUniqueInput
        create: XOR<
            PermissionsCreateWithoutRole_has_permissionsInput,
            PermissionsUncheckedCreateWithoutRole_has_permissionsInput
        >
    }

    export type RolesCreateWithoutRole_has_permissionsInput = {
        uuid: string
        name: string
        guard_name: string
        created_at?: Date | string | null
        updated_at?: Date | string | null
        model_has_roles?: Model_has_rolesCreateNestedManyWithoutRolesInput
    }

    export type RolesUncheckedCreateWithoutRole_has_permissionsInput = {
        uuid: string
        name: string
        guard_name: string
        created_at?: Date | string | null
        updated_at?: Date | string | null
        model_has_roles?: Model_has_rolesUncheckedCreateNestedManyWithoutRolesInput
    }

    export type RolesCreateOrConnectWithoutRole_has_permissionsInput = {
        where: RolesWhereUniqueInput
        create: XOR<RolesCreateWithoutRole_has_permissionsInput, RolesUncheckedCreateWithoutRole_has_permissionsInput>
    }

    export type PermissionsUpsertWithoutRole_has_permissionsInput = {
        update: XOR<
            PermissionsUpdateWithoutRole_has_permissionsInput,
            PermissionsUncheckedUpdateWithoutRole_has_permissionsInput
        >
        create: XOR<
            PermissionsCreateWithoutRole_has_permissionsInput,
            PermissionsUncheckedCreateWithoutRole_has_permissionsInput
        >
    }

    export type PermissionsUpdateWithoutRole_has_permissionsInput = {
        uuid?: StringFieldUpdateOperationsInput | string
        name?: StringFieldUpdateOperationsInput | string
        guard_name?: StringFieldUpdateOperationsInput | string
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        model_has_permissions?: Model_has_permissionsUpdateManyWithoutPermissionsNestedInput
    }

    export type PermissionsUncheckedUpdateWithoutRole_has_permissionsInput = {
        uuid?: StringFieldUpdateOperationsInput | string
        name?: StringFieldUpdateOperationsInput | string
        guard_name?: StringFieldUpdateOperationsInput | string
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        model_has_permissions?: Model_has_permissionsUncheckedUpdateManyWithoutPermissionsNestedInput
    }

    export type RolesUpsertWithoutRole_has_permissionsInput = {
        update: XOR<RolesUpdateWithoutRole_has_permissionsInput, RolesUncheckedUpdateWithoutRole_has_permissionsInput>
        create: XOR<RolesCreateWithoutRole_has_permissionsInput, RolesUncheckedCreateWithoutRole_has_permissionsInput>
    }

    export type RolesUpdateWithoutRole_has_permissionsInput = {
        uuid?: StringFieldUpdateOperationsInput | string
        name?: StringFieldUpdateOperationsInput | string
        guard_name?: StringFieldUpdateOperationsInput | string
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        model_has_roles?: Model_has_rolesUpdateManyWithoutRolesNestedInput
    }

    export type RolesUncheckedUpdateWithoutRole_has_permissionsInput = {
        uuid?: StringFieldUpdateOperationsInput | string
        name?: StringFieldUpdateOperationsInput | string
        guard_name?: StringFieldUpdateOperationsInput | string
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        model_has_roles?: Model_has_rolesUncheckedUpdateManyWithoutRolesNestedInput
    }

    export type Model_has_rolesCreateWithoutRolesInput = {
        model_type: string
        model_uuid: string
    }

    export type Model_has_rolesUncheckedCreateWithoutRolesInput = {
        model_type: string
        model_uuid: string
    }

    export type Model_has_rolesCreateOrConnectWithoutRolesInput = {
        where: Model_has_rolesWhereUniqueInput
        create: XOR<Model_has_rolesCreateWithoutRolesInput, Model_has_rolesUncheckedCreateWithoutRolesInput>
    }

    export type Model_has_rolesCreateManyRolesInputEnvelope = {
        data: Enumerable<Model_has_rolesCreateManyRolesInput>
        skipDuplicates?: boolean
    }

    export type Role_has_permissionsCreateWithoutRolesInput = {
        permissions: PermissionsCreateNestedOneWithoutRole_has_permissionsInput
    }

    export type Role_has_permissionsUncheckedCreateWithoutRolesInput = {
        permission_id: string
    }

    export type Role_has_permissionsCreateOrConnectWithoutRolesInput = {
        where: Role_has_permissionsWhereUniqueInput
        create: XOR<Role_has_permissionsCreateWithoutRolesInput, Role_has_permissionsUncheckedCreateWithoutRolesInput>
    }

    export type Role_has_permissionsCreateManyRolesInputEnvelope = {
        data: Enumerable<Role_has_permissionsCreateManyRolesInput>
        skipDuplicates?: boolean
    }

    export type Model_has_rolesUpsertWithWhereUniqueWithoutRolesInput = {
        where: Model_has_rolesWhereUniqueInput
        update: XOR<Model_has_rolesUpdateWithoutRolesInput, Model_has_rolesUncheckedUpdateWithoutRolesInput>
        create: XOR<Model_has_rolesCreateWithoutRolesInput, Model_has_rolesUncheckedCreateWithoutRolesInput>
    }

    export type Model_has_rolesUpdateWithWhereUniqueWithoutRolesInput = {
        where: Model_has_rolesWhereUniqueInput
        data: XOR<Model_has_rolesUpdateWithoutRolesInput, Model_has_rolesUncheckedUpdateWithoutRolesInput>
    }

    export type Model_has_rolesUpdateManyWithWhereWithoutRolesInput = {
        where: Model_has_rolesScalarWhereInput
        data: XOR<Model_has_rolesUpdateManyMutationInput, Model_has_rolesUncheckedUpdateManyWithoutModel_has_rolesInput>
    }

    export type Model_has_rolesScalarWhereInput = {
        AND?: Enumerable<Model_has_rolesScalarWhereInput>
        OR?: Enumerable<Model_has_rolesScalarWhereInput>
        NOT?: Enumerable<Model_has_rolesScalarWhereInput>
        role_id?: UuidFilter | string
        model_type?: StringFilter | string
        model_uuid?: UuidFilter | string
    }

    export type Role_has_permissionsUpsertWithWhereUniqueWithoutRolesInput = {
        where: Role_has_permissionsWhereUniqueInput
        update: XOR<Role_has_permissionsUpdateWithoutRolesInput, Role_has_permissionsUncheckedUpdateWithoutRolesInput>
        create: XOR<Role_has_permissionsCreateWithoutRolesInput, Role_has_permissionsUncheckedCreateWithoutRolesInput>
    }

    export type Role_has_permissionsUpdateWithWhereUniqueWithoutRolesInput = {
        where: Role_has_permissionsWhereUniqueInput
        data: XOR<Role_has_permissionsUpdateWithoutRolesInput, Role_has_permissionsUncheckedUpdateWithoutRolesInput>
    }

    export type Role_has_permissionsUpdateManyWithWhereWithoutRolesInput = {
        where: Role_has_permissionsScalarWhereInput
        data: XOR<
            Role_has_permissionsUpdateManyMutationInput,
            Role_has_permissionsUncheckedUpdateManyWithoutRole_has_permissionsInput
        >
    }

    export type FamiliesCreateWithoutSecond_sponsorsInput = {
        id: string
        name: string
        report: string
        created_at?: Date | string | null
        updated_at?: Date | string | null
        tenants: TenantsCreateNestedOneWithoutFamiliesInput
        family_furnishing?: Family_furnishingCreateNestedManyWithoutFamiliesInput
        family_housing?: Family_housingCreateNestedManyWithoutFamiliesInput
        family_sponsorship?: Family_sponsorshipCreateNestedManyWithoutFamiliesInput
        orphans?: OrphansCreateNestedManyWithoutFamiliesInput
        spouses?: SpousesCreateNestedManyWithoutFamiliesInput
    }

    export type FamiliesUncheckedCreateWithoutSecond_sponsorsInput = {
        id: string
        name: string
        report: string
        tenant_id: string
        created_at?: Date | string | null
        updated_at?: Date | string | null
        family_furnishing?: Family_furnishingUncheckedCreateNestedManyWithoutFamiliesInput
        family_housing?: Family_housingUncheckedCreateNestedManyWithoutFamiliesInput
        family_sponsorship?: Family_sponsorshipUncheckedCreateNestedManyWithoutFamiliesInput
        orphans?: OrphansUncheckedCreateNestedManyWithoutFamiliesInput
        spouses?: SpousesUncheckedCreateNestedManyWithoutFamiliesInput
    }

    export type FamiliesCreateOrConnectWithoutSecond_sponsorsInput = {
        where: FamiliesWhereUniqueInput
        create: XOR<FamiliesCreateWithoutSecond_sponsorsInput, FamiliesUncheckedCreateWithoutSecond_sponsorsInput>
    }

    export type TenantsCreateWithoutSecond_sponsorsInput = {
        id: string
        data?: NullableJsonNullValueInput | InputJsonValue
        created_at?: Date | string | null
        updated_at?: Date | string | null
        benefactors?: BenefactorsCreateNestedManyWithoutTenantsInput
        domains?: DomainsCreateNestedManyWithoutTenantsInput
        families?: FamiliesCreateNestedManyWithoutTenantsInput
        family_sponsorship?: Family_sponsorshipCreateNestedManyWithoutTenantsInput
        income_sponsor?: Income_sponsorCreateNestedManyWithoutTenantsInput
        orphan_sponsorship?: Orphan_sponsorshipCreateNestedManyWithoutTenantsInput
        orphans?: OrphansCreateNestedManyWithoutTenantsInput
        sponsor_sponsorship?: Sponsor_sponsorshipCreateNestedManyWithoutTenantsInput
        sponsors?: SponsorsCreateNestedManyWithoutTenantsInput
        sponsorships?: SponsorshipsCreateNestedManyWithoutTenantsInput
        spouses?: SpousesCreateNestedManyWithoutTenantsInput
        users?: UsersCreateNestedManyWithoutTenantsInput
    }

    export type TenantsUncheckedCreateWithoutSecond_sponsorsInput = {
        id: string
        data?: NullableJsonNullValueInput | InputJsonValue
        created_at?: Date | string | null
        updated_at?: Date | string | null
        benefactors?: BenefactorsUncheckedCreateNestedManyWithoutTenantsInput
        domains?: DomainsUncheckedCreateNestedManyWithoutTenantsInput
        families?: FamiliesUncheckedCreateNestedManyWithoutTenantsInput
        family_sponsorship?: Family_sponsorshipUncheckedCreateNestedManyWithoutTenantsInput
        income_sponsor?: Income_sponsorUncheckedCreateNestedManyWithoutTenantsInput
        orphan_sponsorship?: Orphan_sponsorshipUncheckedCreateNestedManyWithoutTenantsInput
        orphans?: OrphansUncheckedCreateNestedManyWithoutTenantsInput
        sponsor_sponsorship?: Sponsor_sponsorshipUncheckedCreateNestedManyWithoutTenantsInput
        sponsors?: SponsorsUncheckedCreateNestedManyWithoutTenantsInput
        sponsorships?: SponsorshipsUncheckedCreateNestedManyWithoutTenantsInput
        spouses?: SpousesUncheckedCreateNestedManyWithoutTenantsInput
        users?: UsersUncheckedCreateNestedManyWithoutTenantsInput
    }

    export type TenantsCreateOrConnectWithoutSecond_sponsorsInput = {
        where: TenantsWhereUniqueInput
        create: XOR<TenantsCreateWithoutSecond_sponsorsInput, TenantsUncheckedCreateWithoutSecond_sponsorsInput>
    }

    export type FamiliesUpsertWithoutSecond_sponsorsInput = {
        update: XOR<FamiliesUpdateWithoutSecond_sponsorsInput, FamiliesUncheckedUpdateWithoutSecond_sponsorsInput>
        create: XOR<FamiliesCreateWithoutSecond_sponsorsInput, FamiliesUncheckedCreateWithoutSecond_sponsorsInput>
    }

    export type FamiliesUpdateWithoutSecond_sponsorsInput = {
        id?: StringFieldUpdateOperationsInput | string
        name?: StringFieldUpdateOperationsInput | string
        report?: StringFieldUpdateOperationsInput | string
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        tenants?: TenantsUpdateOneRequiredWithoutFamiliesNestedInput
        family_furnishing?: Family_furnishingUpdateManyWithoutFamiliesNestedInput
        family_housing?: Family_housingUpdateManyWithoutFamiliesNestedInput
        family_sponsorship?: Family_sponsorshipUpdateManyWithoutFamiliesNestedInput
        orphans?: OrphansUpdateManyWithoutFamiliesNestedInput
        spouses?: SpousesUpdateManyWithoutFamiliesNestedInput
    }

    export type FamiliesUncheckedUpdateWithoutSecond_sponsorsInput = {
        id?: StringFieldUpdateOperationsInput | string
        name?: StringFieldUpdateOperationsInput | string
        report?: StringFieldUpdateOperationsInput | string
        tenant_id?: StringFieldUpdateOperationsInput | string
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        family_furnishing?: Family_furnishingUncheckedUpdateManyWithoutFamiliesNestedInput
        family_housing?: Family_housingUncheckedUpdateManyWithoutFamiliesNestedInput
        family_sponsorship?: Family_sponsorshipUncheckedUpdateManyWithoutFamiliesNestedInput
        orphans?: OrphansUncheckedUpdateManyWithoutFamiliesNestedInput
        spouses?: SpousesUncheckedUpdateManyWithoutFamiliesNestedInput
    }

    export type TenantsUpsertWithoutSecond_sponsorsInput = {
        update: XOR<TenantsUpdateWithoutSecond_sponsorsInput, TenantsUncheckedUpdateWithoutSecond_sponsorsInput>
        create: XOR<TenantsCreateWithoutSecond_sponsorsInput, TenantsUncheckedCreateWithoutSecond_sponsorsInput>
    }

    export type TenantsUpdateWithoutSecond_sponsorsInput = {
        id?: StringFieldUpdateOperationsInput | string
        data?: NullableJsonNullValueInput | InputJsonValue
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        benefactors?: BenefactorsUpdateManyWithoutTenantsNestedInput
        domains?: DomainsUpdateManyWithoutTenantsNestedInput
        families?: FamiliesUpdateManyWithoutTenantsNestedInput
        family_sponsorship?: Family_sponsorshipUpdateManyWithoutTenantsNestedInput
        income_sponsor?: Income_sponsorUpdateManyWithoutTenantsNestedInput
        orphan_sponsorship?: Orphan_sponsorshipUpdateManyWithoutTenantsNestedInput
        orphans?: OrphansUpdateManyWithoutTenantsNestedInput
        sponsor_sponsorship?: Sponsor_sponsorshipUpdateManyWithoutTenantsNestedInput
        sponsors?: SponsorsUpdateManyWithoutTenantsNestedInput
        sponsorships?: SponsorshipsUpdateManyWithoutTenantsNestedInput
        spouses?: SpousesUpdateManyWithoutTenantsNestedInput
        users?: UsersUpdateManyWithoutTenantsNestedInput
    }

    export type TenantsUncheckedUpdateWithoutSecond_sponsorsInput = {
        id?: StringFieldUpdateOperationsInput | string
        data?: NullableJsonNullValueInput | InputJsonValue
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        benefactors?: BenefactorsUncheckedUpdateManyWithoutTenantsNestedInput
        domains?: DomainsUncheckedUpdateManyWithoutTenantsNestedInput
        families?: FamiliesUncheckedUpdateManyWithoutTenantsNestedInput
        family_sponsorship?: Family_sponsorshipUncheckedUpdateManyWithoutTenantsNestedInput
        income_sponsor?: Income_sponsorUncheckedUpdateManyWithoutTenantsNestedInput
        orphan_sponsorship?: Orphan_sponsorshipUncheckedUpdateManyWithoutTenantsNestedInput
        orphans?: OrphansUncheckedUpdateManyWithoutTenantsNestedInput
        sponsor_sponsorship?: Sponsor_sponsorshipUncheckedUpdateManyWithoutTenantsNestedInput
        sponsors?: SponsorsUncheckedUpdateManyWithoutTenantsNestedInput
        sponsorships?: SponsorshipsUncheckedUpdateManyWithoutTenantsNestedInput
        spouses?: SpousesUncheckedUpdateManyWithoutTenantsNestedInput
        users?: UsersUncheckedUpdateManyWithoutTenantsNestedInput
    }

    export type UsersCreateWithoutSessionsInput = {
        id: string
        first_name: string
        last_name: string
        phone: string
        email: string
        email_verified_at?: Date | string | null
        password: string
        remember_token?: string | null
        created_at?: Date | string | null
        updated_at?: Date | string | null
        orphans_orphans_created_byTousers?: OrphansCreateNestedManyWithoutUsers_orphans_created_byTousersInput
        orphans_orphans_deleted_byTousers?: OrphansCreateNestedManyWithoutUsers_orphans_deleted_byTousersInput
        settings?: SettingsCreateNestedManyWithoutUsersInput
        sponsors_sponsors_created_byTousers?: SponsorsCreateNestedManyWithoutUsers_sponsors_created_byTousersInput
        sponsors_sponsors_deleted_byTousers?: SponsorsCreateNestedManyWithoutUsers_sponsors_deleted_byTousersInput
        tenants: TenantsCreateNestedOneWithoutUsersInput
    }

    export type UsersUncheckedCreateWithoutSessionsInput = {
        id: string
        first_name: string
        last_name: string
        phone: string
        email: string
        email_verified_at?: Date | string | null
        password: string
        remember_token?: string | null
        tenant_id: string
        created_at?: Date | string | null
        updated_at?: Date | string | null
        orphans_orphans_created_byTousers?: OrphansUncheckedCreateNestedManyWithoutUsers_orphans_created_byTousersInput
        orphans_orphans_deleted_byTousers?: OrphansUncheckedCreateNestedManyWithoutUsers_orphans_deleted_byTousersInput
        settings?: SettingsUncheckedCreateNestedManyWithoutUsersInput
        sponsors_sponsors_created_byTousers?: SponsorsUncheckedCreateNestedManyWithoutUsers_sponsors_created_byTousersInput
        sponsors_sponsors_deleted_byTousers?: SponsorsUncheckedCreateNestedManyWithoutUsers_sponsors_deleted_byTousersInput
    }

    export type UsersCreateOrConnectWithoutSessionsInput = {
        where: UsersWhereUniqueInput
        create: XOR<UsersCreateWithoutSessionsInput, UsersUncheckedCreateWithoutSessionsInput>
    }

    export type UsersUpsertWithoutSessionsInput = {
        update: XOR<UsersUpdateWithoutSessionsInput, UsersUncheckedUpdateWithoutSessionsInput>
        create: XOR<UsersCreateWithoutSessionsInput, UsersUncheckedCreateWithoutSessionsInput>
    }

    export type UsersUpdateWithoutSessionsInput = {
        id?: StringFieldUpdateOperationsInput | string
        first_name?: StringFieldUpdateOperationsInput | string
        last_name?: StringFieldUpdateOperationsInput | string
        phone?: StringFieldUpdateOperationsInput | string
        email?: StringFieldUpdateOperationsInput | string
        email_verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        password?: StringFieldUpdateOperationsInput | string
        remember_token?: NullableStringFieldUpdateOperationsInput | string | null
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        orphans_orphans_created_byTousers?: OrphansUpdateManyWithoutUsers_orphans_created_byTousersNestedInput
        orphans_orphans_deleted_byTousers?: OrphansUpdateManyWithoutUsers_orphans_deleted_byTousersNestedInput
        settings?: SettingsUpdateManyWithoutUsersNestedInput
        sponsors_sponsors_created_byTousers?: SponsorsUpdateManyWithoutUsers_sponsors_created_byTousersNestedInput
        sponsors_sponsors_deleted_byTousers?: SponsorsUpdateManyWithoutUsers_sponsors_deleted_byTousersNestedInput
        tenants?: TenantsUpdateOneRequiredWithoutUsersNestedInput
    }

    export type UsersUncheckedUpdateWithoutSessionsInput = {
        id?: StringFieldUpdateOperationsInput | string
        first_name?: StringFieldUpdateOperationsInput | string
        last_name?: StringFieldUpdateOperationsInput | string
        phone?: StringFieldUpdateOperationsInput | string
        email?: StringFieldUpdateOperationsInput | string
        email_verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        password?: StringFieldUpdateOperationsInput | string
        remember_token?: NullableStringFieldUpdateOperationsInput | string | null
        tenant_id?: StringFieldUpdateOperationsInput | string
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        orphans_orphans_created_byTousers?: OrphansUncheckedUpdateManyWithoutUsers_orphans_created_byTousersNestedInput
        orphans_orphans_deleted_byTousers?: OrphansUncheckedUpdateManyWithoutUsers_orphans_deleted_byTousersNestedInput
        settings?: SettingsUncheckedUpdateManyWithoutUsersNestedInput
        sponsors_sponsors_created_byTousers?: SponsorsUncheckedUpdateManyWithoutUsers_sponsors_created_byTousersNestedInput
        sponsors_sponsors_deleted_byTousers?: SponsorsUncheckedUpdateManyWithoutUsers_sponsors_deleted_byTousersNestedInput
    }

    export type UsersCreateWithoutSettingsInput = {
        id: string
        first_name: string
        last_name: string
        phone: string
        email: string
        email_verified_at?: Date | string | null
        password: string
        remember_token?: string | null
        created_at?: Date | string | null
        updated_at?: Date | string | null
        orphans_orphans_created_byTousers?: OrphansCreateNestedManyWithoutUsers_orphans_created_byTousersInput
        orphans_orphans_deleted_byTousers?: OrphansCreateNestedManyWithoutUsers_orphans_deleted_byTousersInput
        sessions?: SessionsCreateNestedManyWithoutUsersInput
        sponsors_sponsors_created_byTousers?: SponsorsCreateNestedManyWithoutUsers_sponsors_created_byTousersInput
        sponsors_sponsors_deleted_byTousers?: SponsorsCreateNestedManyWithoutUsers_sponsors_deleted_byTousersInput
        tenants: TenantsCreateNestedOneWithoutUsersInput
    }

    export type UsersUncheckedCreateWithoutSettingsInput = {
        id: string
        first_name: string
        last_name: string
        phone: string
        email: string
        email_verified_at?: Date | string | null
        password: string
        remember_token?: string | null
        tenant_id: string
        created_at?: Date | string | null
        updated_at?: Date | string | null
        orphans_orphans_created_byTousers?: OrphansUncheckedCreateNestedManyWithoutUsers_orphans_created_byTousersInput
        orphans_orphans_deleted_byTousers?: OrphansUncheckedCreateNestedManyWithoutUsers_orphans_deleted_byTousersInput
        sessions?: SessionsUncheckedCreateNestedManyWithoutUsersInput
        sponsors_sponsors_created_byTousers?: SponsorsUncheckedCreateNestedManyWithoutUsers_sponsors_created_byTousersInput
        sponsors_sponsors_deleted_byTousers?: SponsorsUncheckedCreateNestedManyWithoutUsers_sponsors_deleted_byTousersInput
    }

    export type UsersCreateOrConnectWithoutSettingsInput = {
        where: UsersWhereUniqueInput
        create: XOR<UsersCreateWithoutSettingsInput, UsersUncheckedCreateWithoutSettingsInput>
    }

    export type UsersUpsertWithoutSettingsInput = {
        update: XOR<UsersUpdateWithoutSettingsInput, UsersUncheckedUpdateWithoutSettingsInput>
        create: XOR<UsersCreateWithoutSettingsInput, UsersUncheckedCreateWithoutSettingsInput>
    }

    export type UsersUpdateWithoutSettingsInput = {
        id?: StringFieldUpdateOperationsInput | string
        first_name?: StringFieldUpdateOperationsInput | string
        last_name?: StringFieldUpdateOperationsInput | string
        phone?: StringFieldUpdateOperationsInput | string
        email?: StringFieldUpdateOperationsInput | string
        email_verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        password?: StringFieldUpdateOperationsInput | string
        remember_token?: NullableStringFieldUpdateOperationsInput | string | null
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        orphans_orphans_created_byTousers?: OrphansUpdateManyWithoutUsers_orphans_created_byTousersNestedInput
        orphans_orphans_deleted_byTousers?: OrphansUpdateManyWithoutUsers_orphans_deleted_byTousersNestedInput
        sessions?: SessionsUpdateManyWithoutUsersNestedInput
        sponsors_sponsors_created_byTousers?: SponsorsUpdateManyWithoutUsers_sponsors_created_byTousersNestedInput
        sponsors_sponsors_deleted_byTousers?: SponsorsUpdateManyWithoutUsers_sponsors_deleted_byTousersNestedInput
        tenants?: TenantsUpdateOneRequiredWithoutUsersNestedInput
    }

    export type UsersUncheckedUpdateWithoutSettingsInput = {
        id?: StringFieldUpdateOperationsInput | string
        first_name?: StringFieldUpdateOperationsInput | string
        last_name?: StringFieldUpdateOperationsInput | string
        phone?: StringFieldUpdateOperationsInput | string
        email?: StringFieldUpdateOperationsInput | string
        email_verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        password?: StringFieldUpdateOperationsInput | string
        remember_token?: NullableStringFieldUpdateOperationsInput | string | null
        tenant_id?: StringFieldUpdateOperationsInput | string
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        orphans_orphans_created_byTousers?: OrphansUncheckedUpdateManyWithoutUsers_orphans_created_byTousersNestedInput
        orphans_orphans_deleted_byTousers?: OrphansUncheckedUpdateManyWithoutUsers_orphans_deleted_byTousersNestedInput
        sessions?: SessionsUncheckedUpdateManyWithoutUsersNestedInput
        sponsors_sponsors_created_byTousers?: SponsorsUncheckedUpdateManyWithoutUsers_sponsors_created_byTousersNestedInput
        sponsors_sponsors_deleted_byTousers?: SponsorsUncheckedUpdateManyWithoutUsers_sponsors_deleted_byTousersNestedInput
    }

    export type SponsorsCreateWithoutSponsor_sponsorshipInput = {
        id: string
        zone_id: string
        file_number: number
        start_date: Date | string
        name: string
        address: string
        phone_number: string
        sponsorship_type: string
        birth_date: Date | string
        father_name: string
        mother_name: string
        birth_certificate_number: string
        academic_level: string
        function: string
        health_status: string
        diploma?: string | null
        card_number?: string | null
        deleted_at?: Date | string | null
        created_at?: Date | string | null
        updated_at?: Date | string | null
        income_sponsor?: Income_sponsorCreateNestedManyWithoutSponsorsInput
        users_sponsors_created_byTousers: UsersCreateNestedOneWithoutSponsors_sponsors_created_byTousersInput
        users_sponsors_deleted_byTousers?: UsersCreateNestedOneWithoutSponsors_sponsors_deleted_byTousersInput
        tenants: TenantsCreateNestedOneWithoutSponsorsInput
    }

    export type SponsorsUncheckedCreateWithoutSponsor_sponsorshipInput = {
        id: string
        zone_id: string
        file_number: number
        start_date: Date | string
        name: string
        address: string
        phone_number: string
        sponsorship_type: string
        birth_date: Date | string
        father_name: string
        mother_name: string
        birth_certificate_number: string
        academic_level: string
        function: string
        health_status: string
        diploma?: string | null
        card_number?: string | null
        tenant_id: string
        created_by: string
        deleted_by?: string | null
        deleted_at?: Date | string | null
        created_at?: Date | string | null
        updated_at?: Date | string | null
        income_sponsor?: Income_sponsorUncheckedCreateNestedManyWithoutSponsorsInput
    }

    export type SponsorsCreateOrConnectWithoutSponsor_sponsorshipInput = {
        where: SponsorsWhereUniqueInput
        create: XOR<
            SponsorsCreateWithoutSponsor_sponsorshipInput,
            SponsorsUncheckedCreateWithoutSponsor_sponsorshipInput
        >
    }

    export type TenantsCreateWithoutSponsor_sponsorshipInput = {
        id: string
        data?: NullableJsonNullValueInput | InputJsonValue
        created_at?: Date | string | null
        updated_at?: Date | string | null
        benefactors?: BenefactorsCreateNestedManyWithoutTenantsInput
        domains?: DomainsCreateNestedManyWithoutTenantsInput
        families?: FamiliesCreateNestedManyWithoutTenantsInput
        family_sponsorship?: Family_sponsorshipCreateNestedManyWithoutTenantsInput
        income_sponsor?: Income_sponsorCreateNestedManyWithoutTenantsInput
        orphan_sponsorship?: Orphan_sponsorshipCreateNestedManyWithoutTenantsInput
        orphans?: OrphansCreateNestedManyWithoutTenantsInput
        second_sponsors?: Second_sponsorsCreateNestedManyWithoutTenantsInput
        sponsors?: SponsorsCreateNestedManyWithoutTenantsInput
        sponsorships?: SponsorshipsCreateNestedManyWithoutTenantsInput
        spouses?: SpousesCreateNestedManyWithoutTenantsInput
        users?: UsersCreateNestedManyWithoutTenantsInput
    }

    export type TenantsUncheckedCreateWithoutSponsor_sponsorshipInput = {
        id: string
        data?: NullableJsonNullValueInput | InputJsonValue
        created_at?: Date | string | null
        updated_at?: Date | string | null
        benefactors?: BenefactorsUncheckedCreateNestedManyWithoutTenantsInput
        domains?: DomainsUncheckedCreateNestedManyWithoutTenantsInput
        families?: FamiliesUncheckedCreateNestedManyWithoutTenantsInput
        family_sponsorship?: Family_sponsorshipUncheckedCreateNestedManyWithoutTenantsInput
        income_sponsor?: Income_sponsorUncheckedCreateNestedManyWithoutTenantsInput
        orphan_sponsorship?: Orphan_sponsorshipUncheckedCreateNestedManyWithoutTenantsInput
        orphans?: OrphansUncheckedCreateNestedManyWithoutTenantsInput
        second_sponsors?: Second_sponsorsUncheckedCreateNestedManyWithoutTenantsInput
        sponsors?: SponsorsUncheckedCreateNestedManyWithoutTenantsInput
        sponsorships?: SponsorshipsUncheckedCreateNestedManyWithoutTenantsInput
        spouses?: SpousesUncheckedCreateNestedManyWithoutTenantsInput
        users?: UsersUncheckedCreateNestedManyWithoutTenantsInput
    }

    export type TenantsCreateOrConnectWithoutSponsor_sponsorshipInput = {
        where: TenantsWhereUniqueInput
        create: XOR<TenantsCreateWithoutSponsor_sponsorshipInput, TenantsUncheckedCreateWithoutSponsor_sponsorshipInput>
    }

    export type SponsorsUpsertWithoutSponsor_sponsorshipInput = {
        update: XOR<
            SponsorsUpdateWithoutSponsor_sponsorshipInput,
            SponsorsUncheckedUpdateWithoutSponsor_sponsorshipInput
        >
        create: XOR<
            SponsorsCreateWithoutSponsor_sponsorshipInput,
            SponsorsUncheckedCreateWithoutSponsor_sponsorshipInput
        >
    }

    export type SponsorsUpdateWithoutSponsor_sponsorshipInput = {
        id?: StringFieldUpdateOperationsInput | string
        zone_id?: StringFieldUpdateOperationsInput | string
        file_number?: IntFieldUpdateOperationsInput | number
        start_date?: DateTimeFieldUpdateOperationsInput | Date | string
        name?: StringFieldUpdateOperationsInput | string
        address?: StringFieldUpdateOperationsInput | string
        phone_number?: StringFieldUpdateOperationsInput | string
        sponsorship_type?: StringFieldUpdateOperationsInput | string
        birth_date?: DateTimeFieldUpdateOperationsInput | Date | string
        father_name?: StringFieldUpdateOperationsInput | string
        mother_name?: StringFieldUpdateOperationsInput | string
        birth_certificate_number?: StringFieldUpdateOperationsInput | string
        academic_level?: StringFieldUpdateOperationsInput | string
        function?: StringFieldUpdateOperationsInput | string
        health_status?: StringFieldUpdateOperationsInput | string
        diploma?: NullableStringFieldUpdateOperationsInput | string | null
        card_number?: NullableStringFieldUpdateOperationsInput | string | null
        deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        income_sponsor?: Income_sponsorUpdateManyWithoutSponsorsNestedInput
        users_sponsors_created_byTousers?: UsersUpdateOneRequiredWithoutSponsors_sponsors_created_byTousersNestedInput
        users_sponsors_deleted_byTousers?: UsersUpdateOneWithoutSponsors_sponsors_deleted_byTousersNestedInput
        tenants?: TenantsUpdateOneRequiredWithoutSponsorsNestedInput
    }

    export type SponsorsUncheckedUpdateWithoutSponsor_sponsorshipInput = {
        id?: StringFieldUpdateOperationsInput | string
        zone_id?: StringFieldUpdateOperationsInput | string
        file_number?: IntFieldUpdateOperationsInput | number
        start_date?: DateTimeFieldUpdateOperationsInput | Date | string
        name?: StringFieldUpdateOperationsInput | string
        address?: StringFieldUpdateOperationsInput | string
        phone_number?: StringFieldUpdateOperationsInput | string
        sponsorship_type?: StringFieldUpdateOperationsInput | string
        birth_date?: DateTimeFieldUpdateOperationsInput | Date | string
        father_name?: StringFieldUpdateOperationsInput | string
        mother_name?: StringFieldUpdateOperationsInput | string
        birth_certificate_number?: StringFieldUpdateOperationsInput | string
        academic_level?: StringFieldUpdateOperationsInput | string
        function?: StringFieldUpdateOperationsInput | string
        health_status?: StringFieldUpdateOperationsInput | string
        diploma?: NullableStringFieldUpdateOperationsInput | string | null
        card_number?: NullableStringFieldUpdateOperationsInput | string | null
        tenant_id?: StringFieldUpdateOperationsInput | string
        created_by?: StringFieldUpdateOperationsInput | string
        deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
        deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        income_sponsor?: Income_sponsorUncheckedUpdateManyWithoutSponsorsNestedInput
    }

    export type TenantsUpsertWithoutSponsor_sponsorshipInput = {
        update: XOR<TenantsUpdateWithoutSponsor_sponsorshipInput, TenantsUncheckedUpdateWithoutSponsor_sponsorshipInput>
        create: XOR<TenantsCreateWithoutSponsor_sponsorshipInput, TenantsUncheckedCreateWithoutSponsor_sponsorshipInput>
    }

    export type TenantsUpdateWithoutSponsor_sponsorshipInput = {
        id?: StringFieldUpdateOperationsInput | string
        data?: NullableJsonNullValueInput | InputJsonValue
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        benefactors?: BenefactorsUpdateManyWithoutTenantsNestedInput
        domains?: DomainsUpdateManyWithoutTenantsNestedInput
        families?: FamiliesUpdateManyWithoutTenantsNestedInput
        family_sponsorship?: Family_sponsorshipUpdateManyWithoutTenantsNestedInput
        income_sponsor?: Income_sponsorUpdateManyWithoutTenantsNestedInput
        orphan_sponsorship?: Orphan_sponsorshipUpdateManyWithoutTenantsNestedInput
        orphans?: OrphansUpdateManyWithoutTenantsNestedInput
        second_sponsors?: Second_sponsorsUpdateManyWithoutTenantsNestedInput
        sponsors?: SponsorsUpdateManyWithoutTenantsNestedInput
        sponsorships?: SponsorshipsUpdateManyWithoutTenantsNestedInput
        spouses?: SpousesUpdateManyWithoutTenantsNestedInput
        users?: UsersUpdateManyWithoutTenantsNestedInput
    }

    export type TenantsUncheckedUpdateWithoutSponsor_sponsorshipInput = {
        id?: StringFieldUpdateOperationsInput | string
        data?: NullableJsonNullValueInput | InputJsonValue
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        benefactors?: BenefactorsUncheckedUpdateManyWithoutTenantsNestedInput
        domains?: DomainsUncheckedUpdateManyWithoutTenantsNestedInput
        families?: FamiliesUncheckedUpdateManyWithoutTenantsNestedInput
        family_sponsorship?: Family_sponsorshipUncheckedUpdateManyWithoutTenantsNestedInput
        income_sponsor?: Income_sponsorUncheckedUpdateManyWithoutTenantsNestedInput
        orphan_sponsorship?: Orphan_sponsorshipUncheckedUpdateManyWithoutTenantsNestedInput
        orphans?: OrphansUncheckedUpdateManyWithoutTenantsNestedInput
        second_sponsors?: Second_sponsorsUncheckedUpdateManyWithoutTenantsNestedInput
        sponsors?: SponsorsUncheckedUpdateManyWithoutTenantsNestedInput
        sponsorships?: SponsorshipsUncheckedUpdateManyWithoutTenantsNestedInput
        spouses?: SpousesUncheckedUpdateManyWithoutTenantsNestedInput
        users?: UsersUncheckedUpdateManyWithoutTenantsNestedInput
    }

    export type Income_sponsorCreateWithoutSponsorsInput = {
        id: string
        value: number
        created_at?: Date | string | null
        updated_at?: Date | string | null
        incomes: IncomesCreateNestedOneWithoutIncome_sponsorInput
        tenants: TenantsCreateNestedOneWithoutIncome_sponsorInput
    }

    export type Income_sponsorUncheckedCreateWithoutSponsorsInput = {
        id: string
        income_id: string
        tenant_id: string
        value: number
        created_at?: Date | string | null
        updated_at?: Date | string | null
    }

    export type Income_sponsorCreateOrConnectWithoutSponsorsInput = {
        where: Income_sponsorWhereUniqueInput
        create: XOR<Income_sponsorCreateWithoutSponsorsInput, Income_sponsorUncheckedCreateWithoutSponsorsInput>
    }

    export type Income_sponsorCreateManySponsorsInputEnvelope = {
        data: Enumerable<Income_sponsorCreateManySponsorsInput>
        skipDuplicates?: boolean
    }

    export type Sponsor_sponsorshipCreateWithoutSponsorsInput = {
        id: string
        type: sponsor_sponsorship_type
        value: string
        created_at?: Date | string | null
        updated_at?: Date | string | null
        tenants: TenantsCreateNestedOneWithoutSponsor_sponsorshipInput
    }

    export type Sponsor_sponsorshipUncheckedCreateWithoutSponsorsInput = {
        id: string
        type: sponsor_sponsorship_type
        value: string
        tenant_id: string
        created_at?: Date | string | null
        updated_at?: Date | string | null
    }

    export type Sponsor_sponsorshipCreateOrConnectWithoutSponsorsInput = {
        where: Sponsor_sponsorshipWhereUniqueInput
        create: XOR<
            Sponsor_sponsorshipCreateWithoutSponsorsInput,
            Sponsor_sponsorshipUncheckedCreateWithoutSponsorsInput
        >
    }

    export type Sponsor_sponsorshipCreateManySponsorsInputEnvelope = {
        data: Enumerable<Sponsor_sponsorshipCreateManySponsorsInput>
        skipDuplicates?: boolean
    }

    export type UsersCreateWithoutSponsors_sponsors_created_byTousersInput = {
        id: string
        first_name: string
        last_name: string
        phone: string
        email: string
        email_verified_at?: Date | string | null
        password: string
        remember_token?: string | null
        created_at?: Date | string | null
        updated_at?: Date | string | null
        orphans_orphans_created_byTousers?: OrphansCreateNestedManyWithoutUsers_orphans_created_byTousersInput
        orphans_orphans_deleted_byTousers?: OrphansCreateNestedManyWithoutUsers_orphans_deleted_byTousersInput
        sessions?: SessionsCreateNestedManyWithoutUsersInput
        settings?: SettingsCreateNestedManyWithoutUsersInput
        sponsors_sponsors_deleted_byTousers?: SponsorsCreateNestedManyWithoutUsers_sponsors_deleted_byTousersInput
        tenants: TenantsCreateNestedOneWithoutUsersInput
    }

    export type UsersUncheckedCreateWithoutSponsors_sponsors_created_byTousersInput = {
        id: string
        first_name: string
        last_name: string
        phone: string
        email: string
        email_verified_at?: Date | string | null
        password: string
        remember_token?: string | null
        tenant_id: string
        created_at?: Date | string | null
        updated_at?: Date | string | null
        orphans_orphans_created_byTousers?: OrphansUncheckedCreateNestedManyWithoutUsers_orphans_created_byTousersInput
        orphans_orphans_deleted_byTousers?: OrphansUncheckedCreateNestedManyWithoutUsers_orphans_deleted_byTousersInput
        sessions?: SessionsUncheckedCreateNestedManyWithoutUsersInput
        settings?: SettingsUncheckedCreateNestedManyWithoutUsersInput
        sponsors_sponsors_deleted_byTousers?: SponsorsUncheckedCreateNestedManyWithoutUsers_sponsors_deleted_byTousersInput
    }

    export type UsersCreateOrConnectWithoutSponsors_sponsors_created_byTousersInput = {
        where: UsersWhereUniqueInput
        create: XOR<
            UsersCreateWithoutSponsors_sponsors_created_byTousersInput,
            UsersUncheckedCreateWithoutSponsors_sponsors_created_byTousersInput
        >
    }

    export type UsersCreateWithoutSponsors_sponsors_deleted_byTousersInput = {
        id: string
        first_name: string
        last_name: string
        phone: string
        email: string
        email_verified_at?: Date | string | null
        password: string
        remember_token?: string | null
        created_at?: Date | string | null
        updated_at?: Date | string | null
        orphans_orphans_created_byTousers?: OrphansCreateNestedManyWithoutUsers_orphans_created_byTousersInput
        orphans_orphans_deleted_byTousers?: OrphansCreateNestedManyWithoutUsers_orphans_deleted_byTousersInput
        sessions?: SessionsCreateNestedManyWithoutUsersInput
        settings?: SettingsCreateNestedManyWithoutUsersInput
        sponsors_sponsors_created_byTousers?: SponsorsCreateNestedManyWithoutUsers_sponsors_created_byTousersInput
        tenants: TenantsCreateNestedOneWithoutUsersInput
    }

    export type UsersUncheckedCreateWithoutSponsors_sponsors_deleted_byTousersInput = {
        id: string
        first_name: string
        last_name: string
        phone: string
        email: string
        email_verified_at?: Date | string | null
        password: string
        remember_token?: string | null
        tenant_id: string
        created_at?: Date | string | null
        updated_at?: Date | string | null
        orphans_orphans_created_byTousers?: OrphansUncheckedCreateNestedManyWithoutUsers_orphans_created_byTousersInput
        orphans_orphans_deleted_byTousers?: OrphansUncheckedCreateNestedManyWithoutUsers_orphans_deleted_byTousersInput
        sessions?: SessionsUncheckedCreateNestedManyWithoutUsersInput
        settings?: SettingsUncheckedCreateNestedManyWithoutUsersInput
        sponsors_sponsors_created_byTousers?: SponsorsUncheckedCreateNestedManyWithoutUsers_sponsors_created_byTousersInput
    }

    export type UsersCreateOrConnectWithoutSponsors_sponsors_deleted_byTousersInput = {
        where: UsersWhereUniqueInput
        create: XOR<
            UsersCreateWithoutSponsors_sponsors_deleted_byTousersInput,
            UsersUncheckedCreateWithoutSponsors_sponsors_deleted_byTousersInput
        >
    }

    export type TenantsCreateWithoutSponsorsInput = {
        id: string
        data?: NullableJsonNullValueInput | InputJsonValue
        created_at?: Date | string | null
        updated_at?: Date | string | null
        benefactors?: BenefactorsCreateNestedManyWithoutTenantsInput
        domains?: DomainsCreateNestedManyWithoutTenantsInput
        families?: FamiliesCreateNestedManyWithoutTenantsInput
        family_sponsorship?: Family_sponsorshipCreateNestedManyWithoutTenantsInput
        income_sponsor?: Income_sponsorCreateNestedManyWithoutTenantsInput
        orphan_sponsorship?: Orphan_sponsorshipCreateNestedManyWithoutTenantsInput
        orphans?: OrphansCreateNestedManyWithoutTenantsInput
        second_sponsors?: Second_sponsorsCreateNestedManyWithoutTenantsInput
        sponsor_sponsorship?: Sponsor_sponsorshipCreateNestedManyWithoutTenantsInput
        sponsorships?: SponsorshipsCreateNestedManyWithoutTenantsInput
        spouses?: SpousesCreateNestedManyWithoutTenantsInput
        users?: UsersCreateNestedManyWithoutTenantsInput
    }

    export type TenantsUncheckedCreateWithoutSponsorsInput = {
        id: string
        data?: NullableJsonNullValueInput | InputJsonValue
        created_at?: Date | string | null
        updated_at?: Date | string | null
        benefactors?: BenefactorsUncheckedCreateNestedManyWithoutTenantsInput
        domains?: DomainsUncheckedCreateNestedManyWithoutTenantsInput
        families?: FamiliesUncheckedCreateNestedManyWithoutTenantsInput
        family_sponsorship?: Family_sponsorshipUncheckedCreateNestedManyWithoutTenantsInput
        income_sponsor?: Income_sponsorUncheckedCreateNestedManyWithoutTenantsInput
        orphan_sponsorship?: Orphan_sponsorshipUncheckedCreateNestedManyWithoutTenantsInput
        orphans?: OrphansUncheckedCreateNestedManyWithoutTenantsInput
        second_sponsors?: Second_sponsorsUncheckedCreateNestedManyWithoutTenantsInput
        sponsor_sponsorship?: Sponsor_sponsorshipUncheckedCreateNestedManyWithoutTenantsInput
        sponsorships?: SponsorshipsUncheckedCreateNestedManyWithoutTenantsInput
        spouses?: SpousesUncheckedCreateNestedManyWithoutTenantsInput
        users?: UsersUncheckedCreateNestedManyWithoutTenantsInput
    }

    export type TenantsCreateOrConnectWithoutSponsorsInput = {
        where: TenantsWhereUniqueInput
        create: XOR<TenantsCreateWithoutSponsorsInput, TenantsUncheckedCreateWithoutSponsorsInput>
    }

    export type Income_sponsorUpsertWithWhereUniqueWithoutSponsorsInput = {
        where: Income_sponsorWhereUniqueInput
        update: XOR<Income_sponsorUpdateWithoutSponsorsInput, Income_sponsorUncheckedUpdateWithoutSponsorsInput>
        create: XOR<Income_sponsorCreateWithoutSponsorsInput, Income_sponsorUncheckedCreateWithoutSponsorsInput>
    }

    export type Income_sponsorUpdateWithWhereUniqueWithoutSponsorsInput = {
        where: Income_sponsorWhereUniqueInput
        data: XOR<Income_sponsorUpdateWithoutSponsorsInput, Income_sponsorUncheckedUpdateWithoutSponsorsInput>
    }

    export type Income_sponsorUpdateManyWithWhereWithoutSponsorsInput = {
        where: Income_sponsorScalarWhereInput
        data: XOR<Income_sponsorUpdateManyMutationInput, Income_sponsorUncheckedUpdateManyWithoutIncome_sponsorInput>
    }

    export type Sponsor_sponsorshipUpsertWithWhereUniqueWithoutSponsorsInput = {
        where: Sponsor_sponsorshipWhereUniqueInput
        update: XOR<
            Sponsor_sponsorshipUpdateWithoutSponsorsInput,
            Sponsor_sponsorshipUncheckedUpdateWithoutSponsorsInput
        >
        create: XOR<
            Sponsor_sponsorshipCreateWithoutSponsorsInput,
            Sponsor_sponsorshipUncheckedCreateWithoutSponsorsInput
        >
    }

    export type Sponsor_sponsorshipUpdateWithWhereUniqueWithoutSponsorsInput = {
        where: Sponsor_sponsorshipWhereUniqueInput
        data: XOR<Sponsor_sponsorshipUpdateWithoutSponsorsInput, Sponsor_sponsorshipUncheckedUpdateWithoutSponsorsInput>
    }

    export type Sponsor_sponsorshipUpdateManyWithWhereWithoutSponsorsInput = {
        where: Sponsor_sponsorshipScalarWhereInput
        data: XOR<
            Sponsor_sponsorshipUpdateManyMutationInput,
            Sponsor_sponsorshipUncheckedUpdateManyWithoutSponsor_sponsorshipInput
        >
    }

    export type Sponsor_sponsorshipScalarWhereInput = {
        AND?: Enumerable<Sponsor_sponsorshipScalarWhereInput>
        OR?: Enumerable<Sponsor_sponsorshipScalarWhereInput>
        NOT?: Enumerable<Sponsor_sponsorshipScalarWhereInput>
        id?: UuidFilter | string
        sponsor_id?: UuidFilter | string
        type?: Enumsponsor_sponsorship_typeFilter | sponsor_sponsorship_type
        value?: StringFilter | string
        tenant_id?: StringFilter | string
        created_at?: DateTimeNullableFilter | Date | string | null
        updated_at?: DateTimeNullableFilter | Date | string | null
    }

    export type UsersUpsertWithoutSponsors_sponsors_created_byTousersInput = {
        update: XOR<
            UsersUpdateWithoutSponsors_sponsors_created_byTousersInput,
            UsersUncheckedUpdateWithoutSponsors_sponsors_created_byTousersInput
        >
        create: XOR<
            UsersCreateWithoutSponsors_sponsors_created_byTousersInput,
            UsersUncheckedCreateWithoutSponsors_sponsors_created_byTousersInput
        >
    }

    export type UsersUpdateWithoutSponsors_sponsors_created_byTousersInput = {
        id?: StringFieldUpdateOperationsInput | string
        first_name?: StringFieldUpdateOperationsInput | string
        last_name?: StringFieldUpdateOperationsInput | string
        phone?: StringFieldUpdateOperationsInput | string
        email?: StringFieldUpdateOperationsInput | string
        email_verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        password?: StringFieldUpdateOperationsInput | string
        remember_token?: NullableStringFieldUpdateOperationsInput | string | null
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        orphans_orphans_created_byTousers?: OrphansUpdateManyWithoutUsers_orphans_created_byTousersNestedInput
        orphans_orphans_deleted_byTousers?: OrphansUpdateManyWithoutUsers_orphans_deleted_byTousersNestedInput
        sessions?: SessionsUpdateManyWithoutUsersNestedInput
        settings?: SettingsUpdateManyWithoutUsersNestedInput
        sponsors_sponsors_deleted_byTousers?: SponsorsUpdateManyWithoutUsers_sponsors_deleted_byTousersNestedInput
        tenants?: TenantsUpdateOneRequiredWithoutUsersNestedInput
    }

    export type UsersUncheckedUpdateWithoutSponsors_sponsors_created_byTousersInput = {
        id?: StringFieldUpdateOperationsInput | string
        first_name?: StringFieldUpdateOperationsInput | string
        last_name?: StringFieldUpdateOperationsInput | string
        phone?: StringFieldUpdateOperationsInput | string
        email?: StringFieldUpdateOperationsInput | string
        email_verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        password?: StringFieldUpdateOperationsInput | string
        remember_token?: NullableStringFieldUpdateOperationsInput | string | null
        tenant_id?: StringFieldUpdateOperationsInput | string
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        orphans_orphans_created_byTousers?: OrphansUncheckedUpdateManyWithoutUsers_orphans_created_byTousersNestedInput
        orphans_orphans_deleted_byTousers?: OrphansUncheckedUpdateManyWithoutUsers_orphans_deleted_byTousersNestedInput
        sessions?: SessionsUncheckedUpdateManyWithoutUsersNestedInput
        settings?: SettingsUncheckedUpdateManyWithoutUsersNestedInput
        sponsors_sponsors_deleted_byTousers?: SponsorsUncheckedUpdateManyWithoutUsers_sponsors_deleted_byTousersNestedInput
    }

    export type UsersUpsertWithoutSponsors_sponsors_deleted_byTousersInput = {
        update: XOR<
            UsersUpdateWithoutSponsors_sponsors_deleted_byTousersInput,
            UsersUncheckedUpdateWithoutSponsors_sponsors_deleted_byTousersInput
        >
        create: XOR<
            UsersCreateWithoutSponsors_sponsors_deleted_byTousersInput,
            UsersUncheckedCreateWithoutSponsors_sponsors_deleted_byTousersInput
        >
    }

    export type UsersUpdateWithoutSponsors_sponsors_deleted_byTousersInput = {
        id?: StringFieldUpdateOperationsInput | string
        first_name?: StringFieldUpdateOperationsInput | string
        last_name?: StringFieldUpdateOperationsInput | string
        phone?: StringFieldUpdateOperationsInput | string
        email?: StringFieldUpdateOperationsInput | string
        email_verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        password?: StringFieldUpdateOperationsInput | string
        remember_token?: NullableStringFieldUpdateOperationsInput | string | null
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        orphans_orphans_created_byTousers?: OrphansUpdateManyWithoutUsers_orphans_created_byTousersNestedInput
        orphans_orphans_deleted_byTousers?: OrphansUpdateManyWithoutUsers_orphans_deleted_byTousersNestedInput
        sessions?: SessionsUpdateManyWithoutUsersNestedInput
        settings?: SettingsUpdateManyWithoutUsersNestedInput
        sponsors_sponsors_created_byTousers?: SponsorsUpdateManyWithoutUsers_sponsors_created_byTousersNestedInput
        tenants?: TenantsUpdateOneRequiredWithoutUsersNestedInput
    }

    export type UsersUncheckedUpdateWithoutSponsors_sponsors_deleted_byTousersInput = {
        id?: StringFieldUpdateOperationsInput | string
        first_name?: StringFieldUpdateOperationsInput | string
        last_name?: StringFieldUpdateOperationsInput | string
        phone?: StringFieldUpdateOperationsInput | string
        email?: StringFieldUpdateOperationsInput | string
        email_verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        password?: StringFieldUpdateOperationsInput | string
        remember_token?: NullableStringFieldUpdateOperationsInput | string | null
        tenant_id?: StringFieldUpdateOperationsInput | string
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        orphans_orphans_created_byTousers?: OrphansUncheckedUpdateManyWithoutUsers_orphans_created_byTousersNestedInput
        orphans_orphans_deleted_byTousers?: OrphansUncheckedUpdateManyWithoutUsers_orphans_deleted_byTousersNestedInput
        sessions?: SessionsUncheckedUpdateManyWithoutUsersNestedInput
        settings?: SettingsUncheckedUpdateManyWithoutUsersNestedInput
        sponsors_sponsors_created_byTousers?: SponsorsUncheckedUpdateManyWithoutUsers_sponsors_created_byTousersNestedInput
    }

    export type TenantsUpsertWithoutSponsorsInput = {
        update: XOR<TenantsUpdateWithoutSponsorsInput, TenantsUncheckedUpdateWithoutSponsorsInput>
        create: XOR<TenantsCreateWithoutSponsorsInput, TenantsUncheckedCreateWithoutSponsorsInput>
    }

    export type TenantsUpdateWithoutSponsorsInput = {
        id?: StringFieldUpdateOperationsInput | string
        data?: NullableJsonNullValueInput | InputJsonValue
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        benefactors?: BenefactorsUpdateManyWithoutTenantsNestedInput
        domains?: DomainsUpdateManyWithoutTenantsNestedInput
        families?: FamiliesUpdateManyWithoutTenantsNestedInput
        family_sponsorship?: Family_sponsorshipUpdateManyWithoutTenantsNestedInput
        income_sponsor?: Income_sponsorUpdateManyWithoutTenantsNestedInput
        orphan_sponsorship?: Orphan_sponsorshipUpdateManyWithoutTenantsNestedInput
        orphans?: OrphansUpdateManyWithoutTenantsNestedInput
        second_sponsors?: Second_sponsorsUpdateManyWithoutTenantsNestedInput
        sponsor_sponsorship?: Sponsor_sponsorshipUpdateManyWithoutTenantsNestedInput
        sponsorships?: SponsorshipsUpdateManyWithoutTenantsNestedInput
        spouses?: SpousesUpdateManyWithoutTenantsNestedInput
        users?: UsersUpdateManyWithoutTenantsNestedInput
    }

    export type TenantsUncheckedUpdateWithoutSponsorsInput = {
        id?: StringFieldUpdateOperationsInput | string
        data?: NullableJsonNullValueInput | InputJsonValue
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        benefactors?: BenefactorsUncheckedUpdateManyWithoutTenantsNestedInput
        domains?: DomainsUncheckedUpdateManyWithoutTenantsNestedInput
        families?: FamiliesUncheckedUpdateManyWithoutTenantsNestedInput
        family_sponsorship?: Family_sponsorshipUncheckedUpdateManyWithoutTenantsNestedInput
        income_sponsor?: Income_sponsorUncheckedUpdateManyWithoutTenantsNestedInput
        orphan_sponsorship?: Orphan_sponsorshipUncheckedUpdateManyWithoutTenantsNestedInput
        orphans?: OrphansUncheckedUpdateManyWithoutTenantsNestedInput
        second_sponsors?: Second_sponsorsUncheckedUpdateManyWithoutTenantsNestedInput
        sponsor_sponsorship?: Sponsor_sponsorshipUncheckedUpdateManyWithoutTenantsNestedInput
        sponsorships?: SponsorshipsUncheckedUpdateManyWithoutTenantsNestedInput
        spouses?: SpousesUncheckedUpdateManyWithoutTenantsNestedInput
        users?: UsersUncheckedUpdateManyWithoutTenantsNestedInput
    }

    export type TenantsCreateWithoutSponsorshipsInput = {
        id: string
        data?: NullableJsonNullValueInput | InputJsonValue
        created_at?: Date | string | null
        updated_at?: Date | string | null
        benefactors?: BenefactorsCreateNestedManyWithoutTenantsInput
        domains?: DomainsCreateNestedManyWithoutTenantsInput
        families?: FamiliesCreateNestedManyWithoutTenantsInput
        family_sponsorship?: Family_sponsorshipCreateNestedManyWithoutTenantsInput
        income_sponsor?: Income_sponsorCreateNestedManyWithoutTenantsInput
        orphan_sponsorship?: Orphan_sponsorshipCreateNestedManyWithoutTenantsInput
        orphans?: OrphansCreateNestedManyWithoutTenantsInput
        second_sponsors?: Second_sponsorsCreateNestedManyWithoutTenantsInput
        sponsor_sponsorship?: Sponsor_sponsorshipCreateNestedManyWithoutTenantsInput
        sponsors?: SponsorsCreateNestedManyWithoutTenantsInput
        spouses?: SpousesCreateNestedManyWithoutTenantsInput
        users?: UsersCreateNestedManyWithoutTenantsInput
    }

    export type TenantsUncheckedCreateWithoutSponsorshipsInput = {
        id: string
        data?: NullableJsonNullValueInput | InputJsonValue
        created_at?: Date | string | null
        updated_at?: Date | string | null
        benefactors?: BenefactorsUncheckedCreateNestedManyWithoutTenantsInput
        domains?: DomainsUncheckedCreateNestedManyWithoutTenantsInput
        families?: FamiliesUncheckedCreateNestedManyWithoutTenantsInput
        family_sponsorship?: Family_sponsorshipUncheckedCreateNestedManyWithoutTenantsInput
        income_sponsor?: Income_sponsorUncheckedCreateNestedManyWithoutTenantsInput
        orphan_sponsorship?: Orphan_sponsorshipUncheckedCreateNestedManyWithoutTenantsInput
        orphans?: OrphansUncheckedCreateNestedManyWithoutTenantsInput
        second_sponsors?: Second_sponsorsUncheckedCreateNestedManyWithoutTenantsInput
        sponsor_sponsorship?: Sponsor_sponsorshipUncheckedCreateNestedManyWithoutTenantsInput
        sponsors?: SponsorsUncheckedCreateNestedManyWithoutTenantsInput
        spouses?: SpousesUncheckedCreateNestedManyWithoutTenantsInput
        users?: UsersUncheckedCreateNestedManyWithoutTenantsInput
    }

    export type TenantsCreateOrConnectWithoutSponsorshipsInput = {
        where: TenantsWhereUniqueInput
        create: XOR<TenantsCreateWithoutSponsorshipsInput, TenantsUncheckedCreateWithoutSponsorshipsInput>
    }

    export type TenantsUpsertWithoutSponsorshipsInput = {
        update: XOR<TenantsUpdateWithoutSponsorshipsInput, TenantsUncheckedUpdateWithoutSponsorshipsInput>
        create: XOR<TenantsCreateWithoutSponsorshipsInput, TenantsUncheckedCreateWithoutSponsorshipsInput>
    }

    export type TenantsUpdateWithoutSponsorshipsInput = {
        id?: StringFieldUpdateOperationsInput | string
        data?: NullableJsonNullValueInput | InputJsonValue
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        benefactors?: BenefactorsUpdateManyWithoutTenantsNestedInput
        domains?: DomainsUpdateManyWithoutTenantsNestedInput
        families?: FamiliesUpdateManyWithoutTenantsNestedInput
        family_sponsorship?: Family_sponsorshipUpdateManyWithoutTenantsNestedInput
        income_sponsor?: Income_sponsorUpdateManyWithoutTenantsNestedInput
        orphan_sponsorship?: Orphan_sponsorshipUpdateManyWithoutTenantsNestedInput
        orphans?: OrphansUpdateManyWithoutTenantsNestedInput
        second_sponsors?: Second_sponsorsUpdateManyWithoutTenantsNestedInput
        sponsor_sponsorship?: Sponsor_sponsorshipUpdateManyWithoutTenantsNestedInput
        sponsors?: SponsorsUpdateManyWithoutTenantsNestedInput
        spouses?: SpousesUpdateManyWithoutTenantsNestedInput
        users?: UsersUpdateManyWithoutTenantsNestedInput
    }

    export type TenantsUncheckedUpdateWithoutSponsorshipsInput = {
        id?: StringFieldUpdateOperationsInput | string
        data?: NullableJsonNullValueInput | InputJsonValue
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        benefactors?: BenefactorsUncheckedUpdateManyWithoutTenantsNestedInput
        domains?: DomainsUncheckedUpdateManyWithoutTenantsNestedInput
        families?: FamiliesUncheckedUpdateManyWithoutTenantsNestedInput
        family_sponsorship?: Family_sponsorshipUncheckedUpdateManyWithoutTenantsNestedInput
        income_sponsor?: Income_sponsorUncheckedUpdateManyWithoutTenantsNestedInput
        orphan_sponsorship?: Orphan_sponsorshipUncheckedUpdateManyWithoutTenantsNestedInput
        orphans?: OrphansUncheckedUpdateManyWithoutTenantsNestedInput
        second_sponsors?: Second_sponsorsUncheckedUpdateManyWithoutTenantsNestedInput
        sponsor_sponsorship?: Sponsor_sponsorshipUncheckedUpdateManyWithoutTenantsNestedInput
        sponsors?: SponsorsUncheckedUpdateManyWithoutTenantsNestedInput
        spouses?: SpousesUncheckedUpdateManyWithoutTenantsNestedInput
        users?: UsersUncheckedUpdateManyWithoutTenantsNestedInput
    }

    export type FamiliesCreateWithoutSpousesInput = {
        id: string
        name: string
        report: string
        created_at?: Date | string | null
        updated_at?: Date | string | null
        tenants: TenantsCreateNestedOneWithoutFamiliesInput
        family_furnishing?: Family_furnishingCreateNestedManyWithoutFamiliesInput
        family_housing?: Family_housingCreateNestedManyWithoutFamiliesInput
        family_sponsorship?: Family_sponsorshipCreateNestedManyWithoutFamiliesInput
        orphans?: OrphansCreateNestedManyWithoutFamiliesInput
        second_sponsors?: Second_sponsorsCreateNestedManyWithoutFamiliesInput
    }

    export type FamiliesUncheckedCreateWithoutSpousesInput = {
        id: string
        name: string
        report: string
        tenant_id: string
        created_at?: Date | string | null
        updated_at?: Date | string | null
        family_furnishing?: Family_furnishingUncheckedCreateNestedManyWithoutFamiliesInput
        family_housing?: Family_housingUncheckedCreateNestedManyWithoutFamiliesInput
        family_sponsorship?: Family_sponsorshipUncheckedCreateNestedManyWithoutFamiliesInput
        orphans?: OrphansUncheckedCreateNestedManyWithoutFamiliesInput
        second_sponsors?: Second_sponsorsUncheckedCreateNestedManyWithoutFamiliesInput
    }

    export type FamiliesCreateOrConnectWithoutSpousesInput = {
        where: FamiliesWhereUniqueInput
        create: XOR<FamiliesCreateWithoutSpousesInput, FamiliesUncheckedCreateWithoutSpousesInput>
    }

    export type TenantsCreateWithoutSpousesInput = {
        id: string
        data?: NullableJsonNullValueInput | InputJsonValue
        created_at?: Date | string | null
        updated_at?: Date | string | null
        benefactors?: BenefactorsCreateNestedManyWithoutTenantsInput
        domains?: DomainsCreateNestedManyWithoutTenantsInput
        families?: FamiliesCreateNestedManyWithoutTenantsInput
        family_sponsorship?: Family_sponsorshipCreateNestedManyWithoutTenantsInput
        income_sponsor?: Income_sponsorCreateNestedManyWithoutTenantsInput
        orphan_sponsorship?: Orphan_sponsorshipCreateNestedManyWithoutTenantsInput
        orphans?: OrphansCreateNestedManyWithoutTenantsInput
        second_sponsors?: Second_sponsorsCreateNestedManyWithoutTenantsInput
        sponsor_sponsorship?: Sponsor_sponsorshipCreateNestedManyWithoutTenantsInput
        sponsors?: SponsorsCreateNestedManyWithoutTenantsInput
        sponsorships?: SponsorshipsCreateNestedManyWithoutTenantsInput
        users?: UsersCreateNestedManyWithoutTenantsInput
    }

    export type TenantsUncheckedCreateWithoutSpousesInput = {
        id: string
        data?: NullableJsonNullValueInput | InputJsonValue
        created_at?: Date | string | null
        updated_at?: Date | string | null
        benefactors?: BenefactorsUncheckedCreateNestedManyWithoutTenantsInput
        domains?: DomainsUncheckedCreateNestedManyWithoutTenantsInput
        families?: FamiliesUncheckedCreateNestedManyWithoutTenantsInput
        family_sponsorship?: Family_sponsorshipUncheckedCreateNestedManyWithoutTenantsInput
        income_sponsor?: Income_sponsorUncheckedCreateNestedManyWithoutTenantsInput
        orphan_sponsorship?: Orphan_sponsorshipUncheckedCreateNestedManyWithoutTenantsInput
        orphans?: OrphansUncheckedCreateNestedManyWithoutTenantsInput
        second_sponsors?: Second_sponsorsUncheckedCreateNestedManyWithoutTenantsInput
        sponsor_sponsorship?: Sponsor_sponsorshipUncheckedCreateNestedManyWithoutTenantsInput
        sponsors?: SponsorsUncheckedCreateNestedManyWithoutTenantsInput
        sponsorships?: SponsorshipsUncheckedCreateNestedManyWithoutTenantsInput
        users?: UsersUncheckedCreateNestedManyWithoutTenantsInput
    }

    export type TenantsCreateOrConnectWithoutSpousesInput = {
        where: TenantsWhereUniqueInput
        create: XOR<TenantsCreateWithoutSpousesInput, TenantsUncheckedCreateWithoutSpousesInput>
    }

    export type FamiliesUpsertWithoutSpousesInput = {
        update: XOR<FamiliesUpdateWithoutSpousesInput, FamiliesUncheckedUpdateWithoutSpousesInput>
        create: XOR<FamiliesCreateWithoutSpousesInput, FamiliesUncheckedCreateWithoutSpousesInput>
    }

    export type FamiliesUpdateWithoutSpousesInput = {
        id?: StringFieldUpdateOperationsInput | string
        name?: StringFieldUpdateOperationsInput | string
        report?: StringFieldUpdateOperationsInput | string
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        tenants?: TenantsUpdateOneRequiredWithoutFamiliesNestedInput
        family_furnishing?: Family_furnishingUpdateManyWithoutFamiliesNestedInput
        family_housing?: Family_housingUpdateManyWithoutFamiliesNestedInput
        family_sponsorship?: Family_sponsorshipUpdateManyWithoutFamiliesNestedInput
        orphans?: OrphansUpdateManyWithoutFamiliesNestedInput
        second_sponsors?: Second_sponsorsUpdateManyWithoutFamiliesNestedInput
    }

    export type FamiliesUncheckedUpdateWithoutSpousesInput = {
        id?: StringFieldUpdateOperationsInput | string
        name?: StringFieldUpdateOperationsInput | string
        report?: StringFieldUpdateOperationsInput | string
        tenant_id?: StringFieldUpdateOperationsInput | string
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        family_furnishing?: Family_furnishingUncheckedUpdateManyWithoutFamiliesNestedInput
        family_housing?: Family_housingUncheckedUpdateManyWithoutFamiliesNestedInput
        family_sponsorship?: Family_sponsorshipUncheckedUpdateManyWithoutFamiliesNestedInput
        orphans?: OrphansUncheckedUpdateManyWithoutFamiliesNestedInput
        second_sponsors?: Second_sponsorsUncheckedUpdateManyWithoutFamiliesNestedInput
    }

    export type TenantsUpsertWithoutSpousesInput = {
        update: XOR<TenantsUpdateWithoutSpousesInput, TenantsUncheckedUpdateWithoutSpousesInput>
        create: XOR<TenantsCreateWithoutSpousesInput, TenantsUncheckedCreateWithoutSpousesInput>
    }

    export type TenantsUpdateWithoutSpousesInput = {
        id?: StringFieldUpdateOperationsInput | string
        data?: NullableJsonNullValueInput | InputJsonValue
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        benefactors?: BenefactorsUpdateManyWithoutTenantsNestedInput
        domains?: DomainsUpdateManyWithoutTenantsNestedInput
        families?: FamiliesUpdateManyWithoutTenantsNestedInput
        family_sponsorship?: Family_sponsorshipUpdateManyWithoutTenantsNestedInput
        income_sponsor?: Income_sponsorUpdateManyWithoutTenantsNestedInput
        orphan_sponsorship?: Orphan_sponsorshipUpdateManyWithoutTenantsNestedInput
        orphans?: OrphansUpdateManyWithoutTenantsNestedInput
        second_sponsors?: Second_sponsorsUpdateManyWithoutTenantsNestedInput
        sponsor_sponsorship?: Sponsor_sponsorshipUpdateManyWithoutTenantsNestedInput
        sponsors?: SponsorsUpdateManyWithoutTenantsNestedInput
        sponsorships?: SponsorshipsUpdateManyWithoutTenantsNestedInput
        users?: UsersUpdateManyWithoutTenantsNestedInput
    }

    export type TenantsUncheckedUpdateWithoutSpousesInput = {
        id?: StringFieldUpdateOperationsInput | string
        data?: NullableJsonNullValueInput | InputJsonValue
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        benefactors?: BenefactorsUncheckedUpdateManyWithoutTenantsNestedInput
        domains?: DomainsUncheckedUpdateManyWithoutTenantsNestedInput
        families?: FamiliesUncheckedUpdateManyWithoutTenantsNestedInput
        family_sponsorship?: Family_sponsorshipUncheckedUpdateManyWithoutTenantsNestedInput
        income_sponsor?: Income_sponsorUncheckedUpdateManyWithoutTenantsNestedInput
        orphan_sponsorship?: Orphan_sponsorshipUncheckedUpdateManyWithoutTenantsNestedInput
        orphans?: OrphansUncheckedUpdateManyWithoutTenantsNestedInput
        second_sponsors?: Second_sponsorsUncheckedUpdateManyWithoutTenantsNestedInput
        sponsor_sponsorship?: Sponsor_sponsorshipUncheckedUpdateManyWithoutTenantsNestedInput
        sponsors?: SponsorsUncheckedUpdateManyWithoutTenantsNestedInput
        sponsorships?: SponsorshipsUncheckedUpdateManyWithoutTenantsNestedInput
        users?: UsersUncheckedUpdateManyWithoutTenantsNestedInput
    }

    export type BenefactorsCreateWithoutTenantsInput = {
        id: string
        deleted_at?: Date | string | null
        created_at?: Date | string | null
        updated_at?: Date | string | null
    }

    export type BenefactorsUncheckedCreateWithoutTenantsInput = {
        id: string
        deleted_at?: Date | string | null
        created_at?: Date | string | null
        updated_at?: Date | string | null
    }

    export type BenefactorsCreateOrConnectWithoutTenantsInput = {
        where: BenefactorsWhereUniqueInput
        create: XOR<BenefactorsCreateWithoutTenantsInput, BenefactorsUncheckedCreateWithoutTenantsInput>
    }

    export type BenefactorsCreateManyTenantsInputEnvelope = {
        data: Enumerable<BenefactorsCreateManyTenantsInput>
        skipDuplicates?: boolean
    }

    export type DomainsCreateWithoutTenantsInput = {
        id: string
        domain: string
        created_at?: Date | string | null
        updated_at?: Date | string | null
    }

    export type DomainsUncheckedCreateWithoutTenantsInput = {
        id: string
        domain: string
        created_at?: Date | string | null
        updated_at?: Date | string | null
    }

    export type DomainsCreateOrConnectWithoutTenantsInput = {
        where: DomainsWhereUniqueInput
        create: XOR<DomainsCreateWithoutTenantsInput, DomainsUncheckedCreateWithoutTenantsInput>
    }

    export type DomainsCreateManyTenantsInputEnvelope = {
        data: Enumerable<DomainsCreateManyTenantsInput>
        skipDuplicates?: boolean
    }

    export type FamiliesCreateWithoutTenantsInput = {
        id: string
        name: string
        report: string
        created_at?: Date | string | null
        updated_at?: Date | string | null
        family_furnishing?: Family_furnishingCreateNestedManyWithoutFamiliesInput
        family_housing?: Family_housingCreateNestedManyWithoutFamiliesInput
        family_sponsorship?: Family_sponsorshipCreateNestedManyWithoutFamiliesInput
        orphans?: OrphansCreateNestedManyWithoutFamiliesInput
        second_sponsors?: Second_sponsorsCreateNestedManyWithoutFamiliesInput
        spouses?: SpousesCreateNestedManyWithoutFamiliesInput
    }

    export type FamiliesUncheckedCreateWithoutTenantsInput = {
        id: string
        name: string
        report: string
        created_at?: Date | string | null
        updated_at?: Date | string | null
        family_furnishing?: Family_furnishingUncheckedCreateNestedManyWithoutFamiliesInput
        family_housing?: Family_housingUncheckedCreateNestedManyWithoutFamiliesInput
        family_sponsorship?: Family_sponsorshipUncheckedCreateNestedManyWithoutFamiliesInput
        orphans?: OrphansUncheckedCreateNestedManyWithoutFamiliesInput
        second_sponsors?: Second_sponsorsUncheckedCreateNestedManyWithoutFamiliesInput
        spouses?: SpousesUncheckedCreateNestedManyWithoutFamiliesInput
    }

    export type FamiliesCreateOrConnectWithoutTenantsInput = {
        where: FamiliesWhereUniqueInput
        create: XOR<FamiliesCreateWithoutTenantsInput, FamiliesUncheckedCreateWithoutTenantsInput>
    }

    export type FamiliesCreateManyTenantsInputEnvelope = {
        data: Enumerable<FamiliesCreateManyTenantsInput>
        skipDuplicates?: boolean
    }

    export type Family_sponsorshipCreateWithoutTenantsInput = {
        id: string
        type: family_sponsorship_type
        value: string
        created_at?: Date | string | null
        updated_at?: Date | string | null
        families: FamiliesCreateNestedOneWithoutFamily_sponsorshipInput
    }

    export type Family_sponsorshipUncheckedCreateWithoutTenantsInput = {
        id: string
        family_id: string
        type: family_sponsorship_type
        value: string
        created_at?: Date | string | null
        updated_at?: Date | string | null
    }

    export type Family_sponsorshipCreateOrConnectWithoutTenantsInput = {
        where: Family_sponsorshipWhereUniqueInput
        create: XOR<Family_sponsorshipCreateWithoutTenantsInput, Family_sponsorshipUncheckedCreateWithoutTenantsInput>
    }

    export type Family_sponsorshipCreateManyTenantsInputEnvelope = {
        data: Enumerable<Family_sponsorshipCreateManyTenantsInput>
        skipDuplicates?: boolean
    }

    export type Income_sponsorCreateWithoutTenantsInput = {
        id: string
        value: number
        created_at?: Date | string | null
        updated_at?: Date | string | null
        incomes: IncomesCreateNestedOneWithoutIncome_sponsorInput
        sponsors: SponsorsCreateNestedOneWithoutIncome_sponsorInput
    }

    export type Income_sponsorUncheckedCreateWithoutTenantsInput = {
        id: string
        income_id: string
        sponsor_id: string
        value: number
        created_at?: Date | string | null
        updated_at?: Date | string | null
    }

    export type Income_sponsorCreateOrConnectWithoutTenantsInput = {
        where: Income_sponsorWhereUniqueInput
        create: XOR<Income_sponsorCreateWithoutTenantsInput, Income_sponsorUncheckedCreateWithoutTenantsInput>
    }

    export type Income_sponsorCreateManyTenantsInputEnvelope = {
        data: Enumerable<Income_sponsorCreateManyTenantsInput>
        skipDuplicates?: boolean
    }

    export type Orphan_sponsorshipCreateWithoutTenantsInput = {
        id: string
        type: orphan_sponsorship_type
        value?: string | null
        created_at?: Date | string | null
        updated_at?: Date | string | null
        orphans: OrphansCreateNestedOneWithoutOrphan_sponsorshipInput
    }

    export type Orphan_sponsorshipUncheckedCreateWithoutTenantsInput = {
        id: string
        orphan_id: string
        type: orphan_sponsorship_type
        value?: string | null
        created_at?: Date | string | null
        updated_at?: Date | string | null
    }

    export type Orphan_sponsorshipCreateOrConnectWithoutTenantsInput = {
        where: Orphan_sponsorshipWhereUniqueInput
        create: XOR<Orphan_sponsorshipCreateWithoutTenantsInput, Orphan_sponsorshipUncheckedCreateWithoutTenantsInput>
    }

    export type Orphan_sponsorshipCreateManyTenantsInputEnvelope = {
        data: Enumerable<Orphan_sponsorshipCreateManyTenantsInput>
        skipDuplicates?: boolean
    }

    export type OrphansCreateWithoutTenantsInput = {
        id: string
        first_name: string
        last_name: string
        birth_date: Date | string
        family_status: string
        health_status: string
        academic_level: string
        shoes_size: string
        pants_size: string
        shirt_size: string
        note: string
        created_at?: Date | string | null
        updated_at?: Date | string | null
        orphan_sponsorship?: Orphan_sponsorshipCreateNestedManyWithoutOrphansInput
        users_orphans_created_byTousers: UsersCreateNestedOneWithoutOrphans_orphans_created_byTousersInput
        users_orphans_deleted_byTousers?: UsersCreateNestedOneWithoutOrphans_orphans_deleted_byTousersInput
        families: FamiliesCreateNestedOneWithoutOrphansInput
    }

    export type OrphansUncheckedCreateWithoutTenantsInput = {
        id: string
        first_name: string
        last_name: string
        birth_date: Date | string
        family_status: string
        health_status: string
        academic_level: string
        shoes_size: string
        pants_size: string
        shirt_size: string
        note: string
        family_id: string
        created_by: string
        deleted_by?: string | null
        created_at?: Date | string | null
        updated_at?: Date | string | null
        orphan_sponsorship?: Orphan_sponsorshipUncheckedCreateNestedManyWithoutOrphansInput
    }

    export type OrphansCreateOrConnectWithoutTenantsInput = {
        where: OrphansWhereUniqueInput
        create: XOR<OrphansCreateWithoutTenantsInput, OrphansUncheckedCreateWithoutTenantsInput>
    }

    export type OrphansCreateManyTenantsInputEnvelope = {
        data: Enumerable<OrphansCreateManyTenantsInput>
        skipDuplicates?: boolean
    }

    export type Second_sponsorsCreateWithoutTenantsInput = {
        id: string
        first_name: string
        last_name: string
        degree_of_kinship: string
        phone_number: string
        address: string
        income: number
        deleted_at?: Date | string | null
        created_at?: Date | string | null
        updated_at?: Date | string | null
        families: FamiliesCreateNestedOneWithoutSecond_sponsorsInput
    }

    export type Second_sponsorsUncheckedCreateWithoutTenantsInput = {
        id: string
        first_name: string
        last_name: string
        degree_of_kinship: string
        phone_number: string
        address: string
        income: number
        family_id: string
        deleted_at?: Date | string | null
        created_at?: Date | string | null
        updated_at?: Date | string | null
    }

    export type Second_sponsorsCreateOrConnectWithoutTenantsInput = {
        where: Second_sponsorsWhereUniqueInput
        create: XOR<Second_sponsorsCreateWithoutTenantsInput, Second_sponsorsUncheckedCreateWithoutTenantsInput>
    }

    export type Second_sponsorsCreateManyTenantsInputEnvelope = {
        data: Enumerable<Second_sponsorsCreateManyTenantsInput>
        skipDuplicates?: boolean
    }

    export type Sponsor_sponsorshipCreateWithoutTenantsInput = {
        id: string
        type: sponsor_sponsorship_type
        value: string
        created_at?: Date | string | null
        updated_at?: Date | string | null
        sponsors: SponsorsCreateNestedOneWithoutSponsor_sponsorshipInput
    }

    export type Sponsor_sponsorshipUncheckedCreateWithoutTenantsInput = {
        id: string
        sponsor_id: string
        type: sponsor_sponsorship_type
        value: string
        created_at?: Date | string | null
        updated_at?: Date | string | null
    }

    export type Sponsor_sponsorshipCreateOrConnectWithoutTenantsInput = {
        where: Sponsor_sponsorshipWhereUniqueInput
        create: XOR<Sponsor_sponsorshipCreateWithoutTenantsInput, Sponsor_sponsorshipUncheckedCreateWithoutTenantsInput>
    }

    export type Sponsor_sponsorshipCreateManyTenantsInputEnvelope = {
        data: Enumerable<Sponsor_sponsorshipCreateManyTenantsInput>
        skipDuplicates?: boolean
    }

    export type SponsorsCreateWithoutTenantsInput = {
        id: string
        zone_id: string
        file_number: number
        start_date: Date | string
        name: string
        address: string
        phone_number: string
        sponsorship_type: string
        birth_date: Date | string
        father_name: string
        mother_name: string
        birth_certificate_number: string
        academic_level: string
        function: string
        health_status: string
        diploma?: string | null
        card_number?: string | null
        deleted_at?: Date | string | null
        created_at?: Date | string | null
        updated_at?: Date | string | null
        income_sponsor?: Income_sponsorCreateNestedManyWithoutSponsorsInput
        sponsor_sponsorship?: Sponsor_sponsorshipCreateNestedManyWithoutSponsorsInput
        users_sponsors_created_byTousers: UsersCreateNestedOneWithoutSponsors_sponsors_created_byTousersInput
        users_sponsors_deleted_byTousers?: UsersCreateNestedOneWithoutSponsors_sponsors_deleted_byTousersInput
    }

    export type SponsorsUncheckedCreateWithoutTenantsInput = {
        id: string
        zone_id: string
        file_number: number
        start_date: Date | string
        name: string
        address: string
        phone_number: string
        sponsorship_type: string
        birth_date: Date | string
        father_name: string
        mother_name: string
        birth_certificate_number: string
        academic_level: string
        function: string
        health_status: string
        diploma?: string | null
        card_number?: string | null
        created_by: string
        deleted_by?: string | null
        deleted_at?: Date | string | null
        created_at?: Date | string | null
        updated_at?: Date | string | null
        income_sponsor?: Income_sponsorUncheckedCreateNestedManyWithoutSponsorsInput
        sponsor_sponsorship?: Sponsor_sponsorshipUncheckedCreateNestedManyWithoutSponsorsInput
    }

    export type SponsorsCreateOrConnectWithoutTenantsInput = {
        where: SponsorsWhereUniqueInput
        create: XOR<SponsorsCreateWithoutTenantsInput, SponsorsUncheckedCreateWithoutTenantsInput>
    }

    export type SponsorsCreateManyTenantsInputEnvelope = {
        data: Enumerable<SponsorsCreateManyTenantsInput>
        skipDuplicates?: boolean
    }

    export type SponsorshipsCreateWithoutTenantsInput = {
        id: string
        type: sponsorship_type
        name: string
        deleted_at?: Date | string | null
        created_at?: Date | string | null
        updated_at?: Date | string | null
    }

    export type SponsorshipsUncheckedCreateWithoutTenantsInput = {
        id: string
        type: sponsorship_type
        name: string
        deleted_at?: Date | string | null
        created_at?: Date | string | null
        updated_at?: Date | string | null
    }

    export type SponsorshipsCreateOrConnectWithoutTenantsInput = {
        where: SponsorshipsWhereUniqueInput
        create: XOR<SponsorshipsCreateWithoutTenantsInput, SponsorshipsUncheckedCreateWithoutTenantsInput>
    }

    export type SponsorshipsCreateManyTenantsInputEnvelope = {
        data: Enumerable<SponsorshipsCreateManyTenantsInput>
        skipDuplicates?: boolean
    }

    export type SpousesCreateWithoutTenantsInput = {
        id: string
        first_name: string
        last_name: string
        birth_date: Date | string
        death_date: Date | string
        function: string
        income: number
        created_at?: Date | string | null
        updated_at?: Date | string | null
        families: FamiliesCreateNestedOneWithoutSpousesInput
    }

    export type SpousesUncheckedCreateWithoutTenantsInput = {
        id: string
        first_name: string
        last_name: string
        birth_date: Date | string
        death_date: Date | string
        function: string
        income: number
        family_id: string
        created_at?: Date | string | null
        updated_at?: Date | string | null
    }

    export type SpousesCreateOrConnectWithoutTenantsInput = {
        where: SpousesWhereUniqueInput
        create: XOR<SpousesCreateWithoutTenantsInput, SpousesUncheckedCreateWithoutTenantsInput>
    }

    export type SpousesCreateManyTenantsInputEnvelope = {
        data: Enumerable<SpousesCreateManyTenantsInput>
        skipDuplicates?: boolean
    }

    export type UsersCreateWithoutTenantsInput = {
        id: string
        first_name: string
        last_name: string
        phone: string
        email: string
        email_verified_at?: Date | string | null
        password: string
        remember_token?: string | null
        created_at?: Date | string | null
        updated_at?: Date | string | null
        orphans_orphans_created_byTousers?: OrphansCreateNestedManyWithoutUsers_orphans_created_byTousersInput
        orphans_orphans_deleted_byTousers?: OrphansCreateNestedManyWithoutUsers_orphans_deleted_byTousersInput
        sessions?: SessionsCreateNestedManyWithoutUsersInput
        settings?: SettingsCreateNestedManyWithoutUsersInput
        sponsors_sponsors_created_byTousers?: SponsorsCreateNestedManyWithoutUsers_sponsors_created_byTousersInput
        sponsors_sponsors_deleted_byTousers?: SponsorsCreateNestedManyWithoutUsers_sponsors_deleted_byTousersInput
    }

    export type UsersUncheckedCreateWithoutTenantsInput = {
        id: string
        first_name: string
        last_name: string
        phone: string
        email: string
        email_verified_at?: Date | string | null
        password: string
        remember_token?: string | null
        created_at?: Date | string | null
        updated_at?: Date | string | null
        orphans_orphans_created_byTousers?: OrphansUncheckedCreateNestedManyWithoutUsers_orphans_created_byTousersInput
        orphans_orphans_deleted_byTousers?: OrphansUncheckedCreateNestedManyWithoutUsers_orphans_deleted_byTousersInput
        sessions?: SessionsUncheckedCreateNestedManyWithoutUsersInput
        settings?: SettingsUncheckedCreateNestedManyWithoutUsersInput
        sponsors_sponsors_created_byTousers?: SponsorsUncheckedCreateNestedManyWithoutUsers_sponsors_created_byTousersInput
        sponsors_sponsors_deleted_byTousers?: SponsorsUncheckedCreateNestedManyWithoutUsers_sponsors_deleted_byTousersInput
    }

    export type UsersCreateOrConnectWithoutTenantsInput = {
        where: UsersWhereUniqueInput
        create: XOR<UsersCreateWithoutTenantsInput, UsersUncheckedCreateWithoutTenantsInput>
    }

    export type UsersCreateManyTenantsInputEnvelope = {
        data: Enumerable<UsersCreateManyTenantsInput>
        skipDuplicates?: boolean
    }

    export type BenefactorsUpsertWithWhereUniqueWithoutTenantsInput = {
        where: BenefactorsWhereUniqueInput
        update: XOR<BenefactorsUpdateWithoutTenantsInput, BenefactorsUncheckedUpdateWithoutTenantsInput>
        create: XOR<BenefactorsCreateWithoutTenantsInput, BenefactorsUncheckedCreateWithoutTenantsInput>
    }

    export type BenefactorsUpdateWithWhereUniqueWithoutTenantsInput = {
        where: BenefactorsWhereUniqueInput
        data: XOR<BenefactorsUpdateWithoutTenantsInput, BenefactorsUncheckedUpdateWithoutTenantsInput>
    }

    export type BenefactorsUpdateManyWithWhereWithoutTenantsInput = {
        where: BenefactorsScalarWhereInput
        data: XOR<BenefactorsUpdateManyMutationInput, BenefactorsUncheckedUpdateManyWithoutBenefactorsInput>
    }

    export type BenefactorsScalarWhereInput = {
        AND?: Enumerable<BenefactorsScalarWhereInput>
        OR?: Enumerable<BenefactorsScalarWhereInput>
        NOT?: Enumerable<BenefactorsScalarWhereInput>
        id?: UuidFilter | string
        tenant_id?: StringFilter | string
        deleted_at?: DateTimeNullableFilter | Date | string | null
        created_at?: DateTimeNullableFilter | Date | string | null
        updated_at?: DateTimeNullableFilter | Date | string | null
    }

    export type DomainsUpsertWithWhereUniqueWithoutTenantsInput = {
        where: DomainsWhereUniqueInput
        update: XOR<DomainsUpdateWithoutTenantsInput, DomainsUncheckedUpdateWithoutTenantsInput>
        create: XOR<DomainsCreateWithoutTenantsInput, DomainsUncheckedCreateWithoutTenantsInput>
    }

    export type DomainsUpdateWithWhereUniqueWithoutTenantsInput = {
        where: DomainsWhereUniqueInput
        data: XOR<DomainsUpdateWithoutTenantsInput, DomainsUncheckedUpdateWithoutTenantsInput>
    }

    export type DomainsUpdateManyWithWhereWithoutTenantsInput = {
        where: DomainsScalarWhereInput
        data: XOR<DomainsUpdateManyMutationInput, DomainsUncheckedUpdateManyWithoutDomainsInput>
    }

    export type DomainsScalarWhereInput = {
        AND?: Enumerable<DomainsScalarWhereInput>
        OR?: Enumerable<DomainsScalarWhereInput>
        NOT?: Enumerable<DomainsScalarWhereInput>
        id?: UuidFilter | string
        domain?: StringFilter | string
        tenant_id?: StringFilter | string
        created_at?: DateTimeNullableFilter | Date | string | null
        updated_at?: DateTimeNullableFilter | Date | string | null
    }

    export type FamiliesUpsertWithWhereUniqueWithoutTenantsInput = {
        where: FamiliesWhereUniqueInput
        update: XOR<FamiliesUpdateWithoutTenantsInput, FamiliesUncheckedUpdateWithoutTenantsInput>
        create: XOR<FamiliesCreateWithoutTenantsInput, FamiliesUncheckedCreateWithoutTenantsInput>
    }

    export type FamiliesUpdateWithWhereUniqueWithoutTenantsInput = {
        where: FamiliesWhereUniqueInput
        data: XOR<FamiliesUpdateWithoutTenantsInput, FamiliesUncheckedUpdateWithoutTenantsInput>
    }

    export type FamiliesUpdateManyWithWhereWithoutTenantsInput = {
        where: FamiliesScalarWhereInput
        data: XOR<FamiliesUpdateManyMutationInput, FamiliesUncheckedUpdateManyWithoutFamiliesInput>
    }

    export type FamiliesScalarWhereInput = {
        AND?: Enumerable<FamiliesScalarWhereInput>
        OR?: Enumerable<FamiliesScalarWhereInput>
        NOT?: Enumerable<FamiliesScalarWhereInput>
        id?: UuidFilter | string
        name?: StringFilter | string
        report?: StringFilter | string
        tenant_id?: StringFilter | string
        created_at?: DateTimeNullableFilter | Date | string | null
        updated_at?: DateTimeNullableFilter | Date | string | null
    }

    export type Family_sponsorshipUpsertWithWhereUniqueWithoutTenantsInput = {
        where: Family_sponsorshipWhereUniqueInput
        update: XOR<Family_sponsorshipUpdateWithoutTenantsInput, Family_sponsorshipUncheckedUpdateWithoutTenantsInput>
        create: XOR<Family_sponsorshipCreateWithoutTenantsInput, Family_sponsorshipUncheckedCreateWithoutTenantsInput>
    }

    export type Family_sponsorshipUpdateWithWhereUniqueWithoutTenantsInput = {
        where: Family_sponsorshipWhereUniqueInput
        data: XOR<Family_sponsorshipUpdateWithoutTenantsInput, Family_sponsorshipUncheckedUpdateWithoutTenantsInput>
    }

    export type Family_sponsorshipUpdateManyWithWhereWithoutTenantsInput = {
        where: Family_sponsorshipScalarWhereInput
        data: XOR<
            Family_sponsorshipUpdateManyMutationInput,
            Family_sponsorshipUncheckedUpdateManyWithoutFamily_sponsorshipInput
        >
    }

    export type Income_sponsorUpsertWithWhereUniqueWithoutTenantsInput = {
        where: Income_sponsorWhereUniqueInput
        update: XOR<Income_sponsorUpdateWithoutTenantsInput, Income_sponsorUncheckedUpdateWithoutTenantsInput>
        create: XOR<Income_sponsorCreateWithoutTenantsInput, Income_sponsorUncheckedCreateWithoutTenantsInput>
    }

    export type Income_sponsorUpdateWithWhereUniqueWithoutTenantsInput = {
        where: Income_sponsorWhereUniqueInput
        data: XOR<Income_sponsorUpdateWithoutTenantsInput, Income_sponsorUncheckedUpdateWithoutTenantsInput>
    }

    export type Income_sponsorUpdateManyWithWhereWithoutTenantsInput = {
        where: Income_sponsorScalarWhereInput
        data: XOR<Income_sponsorUpdateManyMutationInput, Income_sponsorUncheckedUpdateManyWithoutIncome_sponsorInput>
    }

    export type Orphan_sponsorshipUpsertWithWhereUniqueWithoutTenantsInput = {
        where: Orphan_sponsorshipWhereUniqueInput
        update: XOR<Orphan_sponsorshipUpdateWithoutTenantsInput, Orphan_sponsorshipUncheckedUpdateWithoutTenantsInput>
        create: XOR<Orphan_sponsorshipCreateWithoutTenantsInput, Orphan_sponsorshipUncheckedCreateWithoutTenantsInput>
    }

    export type Orphan_sponsorshipUpdateWithWhereUniqueWithoutTenantsInput = {
        where: Orphan_sponsorshipWhereUniqueInput
        data: XOR<Orphan_sponsorshipUpdateWithoutTenantsInput, Orphan_sponsorshipUncheckedUpdateWithoutTenantsInput>
    }

    export type Orphan_sponsorshipUpdateManyWithWhereWithoutTenantsInput = {
        where: Orphan_sponsorshipScalarWhereInput
        data: XOR<
            Orphan_sponsorshipUpdateManyMutationInput,
            Orphan_sponsorshipUncheckedUpdateManyWithoutOrphan_sponsorshipInput
        >
    }

    export type OrphansUpsertWithWhereUniqueWithoutTenantsInput = {
        where: OrphansWhereUniqueInput
        update: XOR<OrphansUpdateWithoutTenantsInput, OrphansUncheckedUpdateWithoutTenantsInput>
        create: XOR<OrphansCreateWithoutTenantsInput, OrphansUncheckedCreateWithoutTenantsInput>
    }

    export type OrphansUpdateWithWhereUniqueWithoutTenantsInput = {
        where: OrphansWhereUniqueInput
        data: XOR<OrphansUpdateWithoutTenantsInput, OrphansUncheckedUpdateWithoutTenantsInput>
    }

    export type OrphansUpdateManyWithWhereWithoutTenantsInput = {
        where: OrphansScalarWhereInput
        data: XOR<OrphansUpdateManyMutationInput, OrphansUncheckedUpdateManyWithoutOrphansInput>
    }

    export type Second_sponsorsUpsertWithWhereUniqueWithoutTenantsInput = {
        where: Second_sponsorsWhereUniqueInput
        update: XOR<Second_sponsorsUpdateWithoutTenantsInput, Second_sponsorsUncheckedUpdateWithoutTenantsInput>
        create: XOR<Second_sponsorsCreateWithoutTenantsInput, Second_sponsorsUncheckedCreateWithoutTenantsInput>
    }

    export type Second_sponsorsUpdateWithWhereUniqueWithoutTenantsInput = {
        where: Second_sponsorsWhereUniqueInput
        data: XOR<Second_sponsorsUpdateWithoutTenantsInput, Second_sponsorsUncheckedUpdateWithoutTenantsInput>
    }

    export type Second_sponsorsUpdateManyWithWhereWithoutTenantsInput = {
        where: Second_sponsorsScalarWhereInput
        data: XOR<Second_sponsorsUpdateManyMutationInput, Second_sponsorsUncheckedUpdateManyWithoutSecond_sponsorsInput>
    }

    export type Sponsor_sponsorshipUpsertWithWhereUniqueWithoutTenantsInput = {
        where: Sponsor_sponsorshipWhereUniqueInput
        update: XOR<Sponsor_sponsorshipUpdateWithoutTenantsInput, Sponsor_sponsorshipUncheckedUpdateWithoutTenantsInput>
        create: XOR<Sponsor_sponsorshipCreateWithoutTenantsInput, Sponsor_sponsorshipUncheckedCreateWithoutTenantsInput>
    }

    export type Sponsor_sponsorshipUpdateWithWhereUniqueWithoutTenantsInput = {
        where: Sponsor_sponsorshipWhereUniqueInput
        data: XOR<Sponsor_sponsorshipUpdateWithoutTenantsInput, Sponsor_sponsorshipUncheckedUpdateWithoutTenantsInput>
    }

    export type Sponsor_sponsorshipUpdateManyWithWhereWithoutTenantsInput = {
        where: Sponsor_sponsorshipScalarWhereInput
        data: XOR<
            Sponsor_sponsorshipUpdateManyMutationInput,
            Sponsor_sponsorshipUncheckedUpdateManyWithoutSponsor_sponsorshipInput
        >
    }

    export type SponsorsUpsertWithWhereUniqueWithoutTenantsInput = {
        where: SponsorsWhereUniqueInput
        update: XOR<SponsorsUpdateWithoutTenantsInput, SponsorsUncheckedUpdateWithoutTenantsInput>
        create: XOR<SponsorsCreateWithoutTenantsInput, SponsorsUncheckedCreateWithoutTenantsInput>
    }

    export type SponsorsUpdateWithWhereUniqueWithoutTenantsInput = {
        where: SponsorsWhereUniqueInput
        data: XOR<SponsorsUpdateWithoutTenantsInput, SponsorsUncheckedUpdateWithoutTenantsInput>
    }

    export type SponsorsUpdateManyWithWhereWithoutTenantsInput = {
        where: SponsorsScalarWhereInput
        data: XOR<SponsorsUpdateManyMutationInput, SponsorsUncheckedUpdateManyWithoutSponsorsInput>
    }

    export type SponsorsScalarWhereInput = {
        AND?: Enumerable<SponsorsScalarWhereInput>
        OR?: Enumerable<SponsorsScalarWhereInput>
        NOT?: Enumerable<SponsorsScalarWhereInput>
        id?: UuidFilter | string
        zone_id?: UuidFilter | string
        file_number?: IntFilter | number
        start_date?: DateTimeFilter | Date | string
        name?: StringFilter | string
        address?: StringFilter | string
        phone_number?: StringFilter | string
        sponsorship_type?: StringFilter | string
        birth_date?: DateTimeFilter | Date | string
        father_name?: StringFilter | string
        mother_name?: StringFilter | string
        birth_certificate_number?: StringFilter | string
        academic_level?: StringFilter | string
        function?: StringFilter | string
        health_status?: StringFilter | string
        diploma?: StringNullableFilter | string | null
        card_number?: StringNullableFilter | string | null
        tenant_id?: StringFilter | string
        created_by?: UuidFilter | string
        deleted_by?: UuidNullableFilter | string | null
        deleted_at?: DateTimeNullableFilter | Date | string | null
        created_at?: DateTimeNullableFilter | Date | string | null
        updated_at?: DateTimeNullableFilter | Date | string | null
    }

    export type SponsorshipsUpsertWithWhereUniqueWithoutTenantsInput = {
        where: SponsorshipsWhereUniqueInput
        update: XOR<SponsorshipsUpdateWithoutTenantsInput, SponsorshipsUncheckedUpdateWithoutTenantsInput>
        create: XOR<SponsorshipsCreateWithoutTenantsInput, SponsorshipsUncheckedCreateWithoutTenantsInput>
    }

    export type SponsorshipsUpdateWithWhereUniqueWithoutTenantsInput = {
        where: SponsorshipsWhereUniqueInput
        data: XOR<SponsorshipsUpdateWithoutTenantsInput, SponsorshipsUncheckedUpdateWithoutTenantsInput>
    }

    export type SponsorshipsUpdateManyWithWhereWithoutTenantsInput = {
        where: SponsorshipsScalarWhereInput
        data: XOR<SponsorshipsUpdateManyMutationInput, SponsorshipsUncheckedUpdateManyWithoutSponsorshipsInput>
    }

    export type SponsorshipsScalarWhereInput = {
        AND?: Enumerable<SponsorshipsScalarWhereInput>
        OR?: Enumerable<SponsorshipsScalarWhereInput>
        NOT?: Enumerable<SponsorshipsScalarWhereInput>
        id?: UuidFilter | string
        type?: Enumsponsorship_typeFilter | sponsorship_type
        name?: StringFilter | string
        tenant_id?: StringFilter | string
        deleted_at?: DateTimeNullableFilter | Date | string | null
        created_at?: DateTimeNullableFilter | Date | string | null
        updated_at?: DateTimeNullableFilter | Date | string | null
    }

    export type SpousesUpsertWithWhereUniqueWithoutTenantsInput = {
        where: SpousesWhereUniqueInput
        update: XOR<SpousesUpdateWithoutTenantsInput, SpousesUncheckedUpdateWithoutTenantsInput>
        create: XOR<SpousesCreateWithoutTenantsInput, SpousesUncheckedCreateWithoutTenantsInput>
    }

    export type SpousesUpdateWithWhereUniqueWithoutTenantsInput = {
        where: SpousesWhereUniqueInput
        data: XOR<SpousesUpdateWithoutTenantsInput, SpousesUncheckedUpdateWithoutTenantsInput>
    }

    export type SpousesUpdateManyWithWhereWithoutTenantsInput = {
        where: SpousesScalarWhereInput
        data: XOR<SpousesUpdateManyMutationInput, SpousesUncheckedUpdateManyWithoutSpousesInput>
    }

    export type UsersUpsertWithWhereUniqueWithoutTenantsInput = {
        where: UsersWhereUniqueInput
        update: XOR<UsersUpdateWithoutTenantsInput, UsersUncheckedUpdateWithoutTenantsInput>
        create: XOR<UsersCreateWithoutTenantsInput, UsersUncheckedCreateWithoutTenantsInput>
    }

    export type UsersUpdateWithWhereUniqueWithoutTenantsInput = {
        where: UsersWhereUniqueInput
        data: XOR<UsersUpdateWithoutTenantsInput, UsersUncheckedUpdateWithoutTenantsInput>
    }

    export type UsersUpdateManyWithWhereWithoutTenantsInput = {
        where: UsersScalarWhereInput
        data: XOR<UsersUpdateManyMutationInput, UsersUncheckedUpdateManyWithoutUsersInput>
    }

    export type UsersScalarWhereInput = {
        AND?: Enumerable<UsersScalarWhereInput>
        OR?: Enumerable<UsersScalarWhereInput>
        NOT?: Enumerable<UsersScalarWhereInput>
        id?: UuidFilter | string
        first_name?: StringFilter | string
        last_name?: StringFilter | string
        phone?: StringFilter | string
        email?: StringFilter | string
        email_verified_at?: DateTimeNullableFilter | Date | string | null
        password?: StringFilter | string
        remember_token?: StringNullableFilter | string | null
        tenant_id?: StringFilter | string
        created_at?: DateTimeNullableFilter | Date | string | null
        updated_at?: DateTimeNullableFilter | Date | string | null
    }

    export type OrphansCreateWithoutUsers_orphans_created_byTousersInput = {
        id: string
        first_name: string
        last_name: string
        birth_date: Date | string
        family_status: string
        health_status: string
        academic_level: string
        shoes_size: string
        pants_size: string
        shirt_size: string
        note: string
        created_at?: Date | string | null
        updated_at?: Date | string | null
        orphan_sponsorship?: Orphan_sponsorshipCreateNestedManyWithoutOrphansInput
        users_orphans_deleted_byTousers?: UsersCreateNestedOneWithoutOrphans_orphans_deleted_byTousersInput
        families: FamiliesCreateNestedOneWithoutOrphansInput
        tenants: TenantsCreateNestedOneWithoutOrphansInput
    }

    export type OrphansUncheckedCreateWithoutUsers_orphans_created_byTousersInput = {
        id: string
        first_name: string
        last_name: string
        birth_date: Date | string
        family_status: string
        health_status: string
        academic_level: string
        shoes_size: string
        pants_size: string
        shirt_size: string
        note: string
        tenant_id: string
        family_id: string
        deleted_by?: string | null
        created_at?: Date | string | null
        updated_at?: Date | string | null
        orphan_sponsorship?: Orphan_sponsorshipUncheckedCreateNestedManyWithoutOrphansInput
    }

    export type OrphansCreateOrConnectWithoutUsers_orphans_created_byTousersInput = {
        where: OrphansWhereUniqueInput
        create: XOR<
            OrphansCreateWithoutUsers_orphans_created_byTousersInput,
            OrphansUncheckedCreateWithoutUsers_orphans_created_byTousersInput
        >
    }

    export type OrphansCreateManyUsers_orphans_created_byTousersInputEnvelope = {
        data: Enumerable<OrphansCreateManyUsers_orphans_created_byTousersInput>
        skipDuplicates?: boolean
    }

    export type OrphansCreateWithoutUsers_orphans_deleted_byTousersInput = {
        id: string
        first_name: string
        last_name: string
        birth_date: Date | string
        family_status: string
        health_status: string
        academic_level: string
        shoes_size: string
        pants_size: string
        shirt_size: string
        note: string
        created_at?: Date | string | null
        updated_at?: Date | string | null
        orphan_sponsorship?: Orphan_sponsorshipCreateNestedManyWithoutOrphansInput
        users_orphans_created_byTousers: UsersCreateNestedOneWithoutOrphans_orphans_created_byTousersInput
        families: FamiliesCreateNestedOneWithoutOrphansInput
        tenants: TenantsCreateNestedOneWithoutOrphansInput
    }

    export type OrphansUncheckedCreateWithoutUsers_orphans_deleted_byTousersInput = {
        id: string
        first_name: string
        last_name: string
        birth_date: Date | string
        family_status: string
        health_status: string
        academic_level: string
        shoes_size: string
        pants_size: string
        shirt_size: string
        note: string
        tenant_id: string
        family_id: string
        created_by: string
        created_at?: Date | string | null
        updated_at?: Date | string | null
        orphan_sponsorship?: Orphan_sponsorshipUncheckedCreateNestedManyWithoutOrphansInput
    }

    export type OrphansCreateOrConnectWithoutUsers_orphans_deleted_byTousersInput = {
        where: OrphansWhereUniqueInput
        create: XOR<
            OrphansCreateWithoutUsers_orphans_deleted_byTousersInput,
            OrphansUncheckedCreateWithoutUsers_orphans_deleted_byTousersInput
        >
    }

    export type OrphansCreateManyUsers_orphans_deleted_byTousersInputEnvelope = {
        data: Enumerable<OrphansCreateManyUsers_orphans_deleted_byTousersInput>
        skipDuplicates?: boolean
    }

    export type SessionsCreateWithoutUsersInput = {
        id: string
        ip_address?: string | null
        user_agent?: string | null
        payload: string
        last_activity: number
    }

    export type SessionsUncheckedCreateWithoutUsersInput = {
        id: string
        ip_address?: string | null
        user_agent?: string | null
        payload: string
        last_activity: number
    }

    export type SessionsCreateOrConnectWithoutUsersInput = {
        where: SessionsWhereUniqueInput
        create: XOR<SessionsCreateWithoutUsersInput, SessionsUncheckedCreateWithoutUsersInput>
    }

    export type SessionsCreateManyUsersInputEnvelope = {
        data: Enumerable<SessionsCreateManyUsersInput>
        skipDuplicates?: boolean
    }

    export type SettingsCreateWithoutUsersInput = {
        id: string
        theme: theme
        color_scheme: color_scheme
        layout: layout
        appearance: appearance
        notifications?: NullableJsonNullValueInput | InputJsonValue
        created_at?: Date | string | null
        updated_at?: Date | string | null
    }

    export type SettingsUncheckedCreateWithoutUsersInput = {
        id: string
        theme: theme
        color_scheme: color_scheme
        layout: layout
        appearance: appearance
        notifications?: NullableJsonNullValueInput | InputJsonValue
        created_at?: Date | string | null
        updated_at?: Date | string | null
    }

    export type SettingsCreateOrConnectWithoutUsersInput = {
        where: SettingsWhereUniqueInput
        create: XOR<SettingsCreateWithoutUsersInput, SettingsUncheckedCreateWithoutUsersInput>
    }

    export type SettingsCreateManyUsersInputEnvelope = {
        data: Enumerable<SettingsCreateManyUsersInput>
        skipDuplicates?: boolean
    }

    export type SponsorsCreateWithoutUsers_sponsors_created_byTousersInput = {
        id: string
        zone_id: string
        file_number: number
        start_date: Date | string
        name: string
        address: string
        phone_number: string
        sponsorship_type: string
        birth_date: Date | string
        father_name: string
        mother_name: string
        birth_certificate_number: string
        academic_level: string
        function: string
        health_status: string
        diploma?: string | null
        card_number?: string | null
        deleted_at?: Date | string | null
        created_at?: Date | string | null
        updated_at?: Date | string | null
        income_sponsor?: Income_sponsorCreateNestedManyWithoutSponsorsInput
        sponsor_sponsorship?: Sponsor_sponsorshipCreateNestedManyWithoutSponsorsInput
        users_sponsors_deleted_byTousers?: UsersCreateNestedOneWithoutSponsors_sponsors_deleted_byTousersInput
        tenants: TenantsCreateNestedOneWithoutSponsorsInput
    }

    export type SponsorsUncheckedCreateWithoutUsers_sponsors_created_byTousersInput = {
        id: string
        zone_id: string
        file_number: number
        start_date: Date | string
        name: string
        address: string
        phone_number: string
        sponsorship_type: string
        birth_date: Date | string
        father_name: string
        mother_name: string
        birth_certificate_number: string
        academic_level: string
        function: string
        health_status: string
        diploma?: string | null
        card_number?: string | null
        tenant_id: string
        deleted_by?: string | null
        deleted_at?: Date | string | null
        created_at?: Date | string | null
        updated_at?: Date | string | null
        income_sponsor?: Income_sponsorUncheckedCreateNestedManyWithoutSponsorsInput
        sponsor_sponsorship?: Sponsor_sponsorshipUncheckedCreateNestedManyWithoutSponsorsInput
    }

    export type SponsorsCreateOrConnectWithoutUsers_sponsors_created_byTousersInput = {
        where: SponsorsWhereUniqueInput
        create: XOR<
            SponsorsCreateWithoutUsers_sponsors_created_byTousersInput,
            SponsorsUncheckedCreateWithoutUsers_sponsors_created_byTousersInput
        >
    }

    export type SponsorsCreateManyUsers_sponsors_created_byTousersInputEnvelope = {
        data: Enumerable<SponsorsCreateManyUsers_sponsors_created_byTousersInput>
        skipDuplicates?: boolean
    }

    export type SponsorsCreateWithoutUsers_sponsors_deleted_byTousersInput = {
        id: string
        zone_id: string
        file_number: number
        start_date: Date | string
        name: string
        address: string
        phone_number: string
        sponsorship_type: string
        birth_date: Date | string
        father_name: string
        mother_name: string
        birth_certificate_number: string
        academic_level: string
        function: string
        health_status: string
        diploma?: string | null
        card_number?: string | null
        deleted_at?: Date | string | null
        created_at?: Date | string | null
        updated_at?: Date | string | null
        income_sponsor?: Income_sponsorCreateNestedManyWithoutSponsorsInput
        sponsor_sponsorship?: Sponsor_sponsorshipCreateNestedManyWithoutSponsorsInput
        users_sponsors_created_byTousers: UsersCreateNestedOneWithoutSponsors_sponsors_created_byTousersInput
        tenants: TenantsCreateNestedOneWithoutSponsorsInput
    }

    export type SponsorsUncheckedCreateWithoutUsers_sponsors_deleted_byTousersInput = {
        id: string
        zone_id: string
        file_number: number
        start_date: Date | string
        name: string
        address: string
        phone_number: string
        sponsorship_type: string
        birth_date: Date | string
        father_name: string
        mother_name: string
        birth_certificate_number: string
        academic_level: string
        function: string
        health_status: string
        diploma?: string | null
        card_number?: string | null
        tenant_id: string
        created_by: string
        deleted_at?: Date | string | null
        created_at?: Date | string | null
        updated_at?: Date | string | null
        income_sponsor?: Income_sponsorUncheckedCreateNestedManyWithoutSponsorsInput
        sponsor_sponsorship?: Sponsor_sponsorshipUncheckedCreateNestedManyWithoutSponsorsInput
    }

    export type SponsorsCreateOrConnectWithoutUsers_sponsors_deleted_byTousersInput = {
        where: SponsorsWhereUniqueInput
        create: XOR<
            SponsorsCreateWithoutUsers_sponsors_deleted_byTousersInput,
            SponsorsUncheckedCreateWithoutUsers_sponsors_deleted_byTousersInput
        >
    }

    export type SponsorsCreateManyUsers_sponsors_deleted_byTousersInputEnvelope = {
        data: Enumerable<SponsorsCreateManyUsers_sponsors_deleted_byTousersInput>
        skipDuplicates?: boolean
    }

    export type TenantsCreateWithoutUsersInput = {
        id: string
        data?: NullableJsonNullValueInput | InputJsonValue
        created_at?: Date | string | null
        updated_at?: Date | string | null
        benefactors?: BenefactorsCreateNestedManyWithoutTenantsInput
        domains?: DomainsCreateNestedManyWithoutTenantsInput
        families?: FamiliesCreateNestedManyWithoutTenantsInput
        family_sponsorship?: Family_sponsorshipCreateNestedManyWithoutTenantsInput
        income_sponsor?: Income_sponsorCreateNestedManyWithoutTenantsInput
        orphan_sponsorship?: Orphan_sponsorshipCreateNestedManyWithoutTenantsInput
        orphans?: OrphansCreateNestedManyWithoutTenantsInput
        second_sponsors?: Second_sponsorsCreateNestedManyWithoutTenantsInput
        sponsor_sponsorship?: Sponsor_sponsorshipCreateNestedManyWithoutTenantsInput
        sponsors?: SponsorsCreateNestedManyWithoutTenantsInput
        sponsorships?: SponsorshipsCreateNestedManyWithoutTenantsInput
        spouses?: SpousesCreateNestedManyWithoutTenantsInput
    }

    export type TenantsUncheckedCreateWithoutUsersInput = {
        id: string
        data?: NullableJsonNullValueInput | InputJsonValue
        created_at?: Date | string | null
        updated_at?: Date | string | null
        benefactors?: BenefactorsUncheckedCreateNestedManyWithoutTenantsInput
        domains?: DomainsUncheckedCreateNestedManyWithoutTenantsInput
        families?: FamiliesUncheckedCreateNestedManyWithoutTenantsInput
        family_sponsorship?: Family_sponsorshipUncheckedCreateNestedManyWithoutTenantsInput
        income_sponsor?: Income_sponsorUncheckedCreateNestedManyWithoutTenantsInput
        orphan_sponsorship?: Orphan_sponsorshipUncheckedCreateNestedManyWithoutTenantsInput
        orphans?: OrphansUncheckedCreateNestedManyWithoutTenantsInput
        second_sponsors?: Second_sponsorsUncheckedCreateNestedManyWithoutTenantsInput
        sponsor_sponsorship?: Sponsor_sponsorshipUncheckedCreateNestedManyWithoutTenantsInput
        sponsors?: SponsorsUncheckedCreateNestedManyWithoutTenantsInput
        sponsorships?: SponsorshipsUncheckedCreateNestedManyWithoutTenantsInput
        spouses?: SpousesUncheckedCreateNestedManyWithoutTenantsInput
    }

    export type TenantsCreateOrConnectWithoutUsersInput = {
        where: TenantsWhereUniqueInput
        create: XOR<TenantsCreateWithoutUsersInput, TenantsUncheckedCreateWithoutUsersInput>
    }

    export type OrphansUpsertWithWhereUniqueWithoutUsers_orphans_created_byTousersInput = {
        where: OrphansWhereUniqueInput
        update: XOR<
            OrphansUpdateWithoutUsers_orphans_created_byTousersInput,
            OrphansUncheckedUpdateWithoutUsers_orphans_created_byTousersInput
        >
        create: XOR<
            OrphansCreateWithoutUsers_orphans_created_byTousersInput,
            OrphansUncheckedCreateWithoutUsers_orphans_created_byTousersInput
        >
    }

    export type OrphansUpdateWithWhereUniqueWithoutUsers_orphans_created_byTousersInput = {
        where: OrphansWhereUniqueInput
        data: XOR<
            OrphansUpdateWithoutUsers_orphans_created_byTousersInput,
            OrphansUncheckedUpdateWithoutUsers_orphans_created_byTousersInput
        >
    }

    export type OrphansUpdateManyWithWhereWithoutUsers_orphans_created_byTousersInput = {
        where: OrphansScalarWhereInput
        data: XOR<
            OrphansUpdateManyMutationInput,
            OrphansUncheckedUpdateManyWithoutOrphans_orphans_created_byTousersInput
        >
    }

    export type OrphansUpsertWithWhereUniqueWithoutUsers_orphans_deleted_byTousersInput = {
        where: OrphansWhereUniqueInput
        update: XOR<
            OrphansUpdateWithoutUsers_orphans_deleted_byTousersInput,
            OrphansUncheckedUpdateWithoutUsers_orphans_deleted_byTousersInput
        >
        create: XOR<
            OrphansCreateWithoutUsers_orphans_deleted_byTousersInput,
            OrphansUncheckedCreateWithoutUsers_orphans_deleted_byTousersInput
        >
    }

    export type OrphansUpdateWithWhereUniqueWithoutUsers_orphans_deleted_byTousersInput = {
        where: OrphansWhereUniqueInput
        data: XOR<
            OrphansUpdateWithoutUsers_orphans_deleted_byTousersInput,
            OrphansUncheckedUpdateWithoutUsers_orphans_deleted_byTousersInput
        >
    }

    export type OrphansUpdateManyWithWhereWithoutUsers_orphans_deleted_byTousersInput = {
        where: OrphansScalarWhereInput
        data: XOR<
            OrphansUpdateManyMutationInput,
            OrphansUncheckedUpdateManyWithoutOrphans_orphans_deleted_byTousersInput
        >
    }

    export type SessionsUpsertWithWhereUniqueWithoutUsersInput = {
        where: SessionsWhereUniqueInput
        update: XOR<SessionsUpdateWithoutUsersInput, SessionsUncheckedUpdateWithoutUsersInput>
        create: XOR<SessionsCreateWithoutUsersInput, SessionsUncheckedCreateWithoutUsersInput>
    }

    export type SessionsUpdateWithWhereUniqueWithoutUsersInput = {
        where: SessionsWhereUniqueInput
        data: XOR<SessionsUpdateWithoutUsersInput, SessionsUncheckedUpdateWithoutUsersInput>
    }

    export type SessionsUpdateManyWithWhereWithoutUsersInput = {
        where: SessionsScalarWhereInput
        data: XOR<SessionsUpdateManyMutationInput, SessionsUncheckedUpdateManyWithoutSessionsInput>
    }

    export type SessionsScalarWhereInput = {
        AND?: Enumerable<SessionsScalarWhereInput>
        OR?: Enumerable<SessionsScalarWhereInput>
        NOT?: Enumerable<SessionsScalarWhereInput>
        id?: StringFilter | string
        user_id?: UuidNullableFilter | string | null
        ip_address?: StringNullableFilter | string | null
        user_agent?: StringNullableFilter | string | null
        payload?: StringFilter | string
        last_activity?: IntFilter | number
    }

    export type SettingsUpsertWithWhereUniqueWithoutUsersInput = {
        where: SettingsWhereUniqueInput
        update: XOR<SettingsUpdateWithoutUsersInput, SettingsUncheckedUpdateWithoutUsersInput>
        create: XOR<SettingsCreateWithoutUsersInput, SettingsUncheckedCreateWithoutUsersInput>
    }

    export type SettingsUpdateWithWhereUniqueWithoutUsersInput = {
        where: SettingsWhereUniqueInput
        data: XOR<SettingsUpdateWithoutUsersInput, SettingsUncheckedUpdateWithoutUsersInput>
    }

    export type SettingsUpdateManyWithWhereWithoutUsersInput = {
        where: SettingsScalarWhereInput
        data: XOR<SettingsUpdateManyMutationInput, SettingsUncheckedUpdateManyWithoutSettingsInput>
    }

    export type SettingsScalarWhereInput = {
        AND?: Enumerable<SettingsScalarWhereInput>
        OR?: Enumerable<SettingsScalarWhereInput>
        NOT?: Enumerable<SettingsScalarWhereInput>
        id?: UuidFilter | string
        user_id?: UuidFilter | string
        theme?: EnumthemeFilter | theme
        color_scheme?: Enumcolor_schemeFilter | color_scheme
        layout?: EnumlayoutFilter | layout
        appearance?: EnumappearanceFilter | appearance
        notifications?: JsonNullableFilter
        created_at?: DateTimeNullableFilter | Date | string | null
        updated_at?: DateTimeNullableFilter | Date | string | null
    }

    export type SponsorsUpsertWithWhereUniqueWithoutUsers_sponsors_created_byTousersInput = {
        where: SponsorsWhereUniqueInput
        update: XOR<
            SponsorsUpdateWithoutUsers_sponsors_created_byTousersInput,
            SponsorsUncheckedUpdateWithoutUsers_sponsors_created_byTousersInput
        >
        create: XOR<
            SponsorsCreateWithoutUsers_sponsors_created_byTousersInput,
            SponsorsUncheckedCreateWithoutUsers_sponsors_created_byTousersInput
        >
    }

    export type SponsorsUpdateWithWhereUniqueWithoutUsers_sponsors_created_byTousersInput = {
        where: SponsorsWhereUniqueInput
        data: XOR<
            SponsorsUpdateWithoutUsers_sponsors_created_byTousersInput,
            SponsorsUncheckedUpdateWithoutUsers_sponsors_created_byTousersInput
        >
    }

    export type SponsorsUpdateManyWithWhereWithoutUsers_sponsors_created_byTousersInput = {
        where: SponsorsScalarWhereInput
        data: XOR<
            SponsorsUpdateManyMutationInput,
            SponsorsUncheckedUpdateManyWithoutSponsors_sponsors_created_byTousersInput
        >
    }

    export type SponsorsUpsertWithWhereUniqueWithoutUsers_sponsors_deleted_byTousersInput = {
        where: SponsorsWhereUniqueInput
        update: XOR<
            SponsorsUpdateWithoutUsers_sponsors_deleted_byTousersInput,
            SponsorsUncheckedUpdateWithoutUsers_sponsors_deleted_byTousersInput
        >
        create: XOR<
            SponsorsCreateWithoutUsers_sponsors_deleted_byTousersInput,
            SponsorsUncheckedCreateWithoutUsers_sponsors_deleted_byTousersInput
        >
    }

    export type SponsorsUpdateWithWhereUniqueWithoutUsers_sponsors_deleted_byTousersInput = {
        where: SponsorsWhereUniqueInput
        data: XOR<
            SponsorsUpdateWithoutUsers_sponsors_deleted_byTousersInput,
            SponsorsUncheckedUpdateWithoutUsers_sponsors_deleted_byTousersInput
        >
    }

    export type SponsorsUpdateManyWithWhereWithoutUsers_sponsors_deleted_byTousersInput = {
        where: SponsorsScalarWhereInput
        data: XOR<
            SponsorsUpdateManyMutationInput,
            SponsorsUncheckedUpdateManyWithoutSponsors_sponsors_deleted_byTousersInput
        >
    }

    export type TenantsUpsertWithoutUsersInput = {
        update: XOR<TenantsUpdateWithoutUsersInput, TenantsUncheckedUpdateWithoutUsersInput>
        create: XOR<TenantsCreateWithoutUsersInput, TenantsUncheckedCreateWithoutUsersInput>
    }

    export type TenantsUpdateWithoutUsersInput = {
        id?: StringFieldUpdateOperationsInput | string
        data?: NullableJsonNullValueInput | InputJsonValue
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        benefactors?: BenefactorsUpdateManyWithoutTenantsNestedInput
        domains?: DomainsUpdateManyWithoutTenantsNestedInput
        families?: FamiliesUpdateManyWithoutTenantsNestedInput
        family_sponsorship?: Family_sponsorshipUpdateManyWithoutTenantsNestedInput
        income_sponsor?: Income_sponsorUpdateManyWithoutTenantsNestedInput
        orphan_sponsorship?: Orphan_sponsorshipUpdateManyWithoutTenantsNestedInput
        orphans?: OrphansUpdateManyWithoutTenantsNestedInput
        second_sponsors?: Second_sponsorsUpdateManyWithoutTenantsNestedInput
        sponsor_sponsorship?: Sponsor_sponsorshipUpdateManyWithoutTenantsNestedInput
        sponsors?: SponsorsUpdateManyWithoutTenantsNestedInput
        sponsorships?: SponsorshipsUpdateManyWithoutTenantsNestedInput
        spouses?: SpousesUpdateManyWithoutTenantsNestedInput
    }

    export type TenantsUncheckedUpdateWithoutUsersInput = {
        id?: StringFieldUpdateOperationsInput | string
        data?: NullableJsonNullValueInput | InputJsonValue
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        benefactors?: BenefactorsUncheckedUpdateManyWithoutTenantsNestedInput
        domains?: DomainsUncheckedUpdateManyWithoutTenantsNestedInput
        families?: FamiliesUncheckedUpdateManyWithoutTenantsNestedInput
        family_sponsorship?: Family_sponsorshipUncheckedUpdateManyWithoutTenantsNestedInput
        income_sponsor?: Income_sponsorUncheckedUpdateManyWithoutTenantsNestedInput
        orphan_sponsorship?: Orphan_sponsorshipUncheckedUpdateManyWithoutTenantsNestedInput
        orphans?: OrphansUncheckedUpdateManyWithoutTenantsNestedInput
        second_sponsors?: Second_sponsorsUncheckedUpdateManyWithoutTenantsNestedInput
        sponsor_sponsorship?: Sponsor_sponsorshipUncheckedUpdateManyWithoutTenantsNestedInput
        sponsors?: SponsorsUncheckedUpdateManyWithoutTenantsNestedInput
        sponsorships?: SponsorshipsUncheckedUpdateManyWithoutTenantsNestedInput
        spouses?: SpousesUncheckedUpdateManyWithoutTenantsNestedInput
    }

    export type Family_furnishingCreateManyFamiliesInput = {
        id: string
        furnishing_id: string
        value: string
    }

    export type Family_housingCreateManyFamiliesInput = {
        id: string
        housing_id: string
        value: string
    }

    export type Family_sponsorshipCreateManyFamiliesInput = {
        id: string
        type: family_sponsorship_type
        value: string
        tenant_id: string
        created_at?: Date | string | null
        updated_at?: Date | string | null
    }

    export type OrphansCreateManyFamiliesInput = {
        id: string
        first_name: string
        last_name: string
        birth_date: Date | string
        family_status: string
        health_status: string
        academic_level: string
        shoes_size: string
        pants_size: string
        shirt_size: string
        note: string
        tenant_id: string
        created_by: string
        deleted_by?: string | null
        created_at?: Date | string | null
        updated_at?: Date | string | null
    }

    export type Second_sponsorsCreateManyFamiliesInput = {
        id: string
        first_name: string
        last_name: string
        degree_of_kinship: string
        phone_number: string
        address: string
        income: number
        tenant_id: string
        deleted_at?: Date | string | null
        created_at?: Date | string | null
        updated_at?: Date | string | null
    }

    export type SpousesCreateManyFamiliesInput = {
        id: string
        first_name: string
        last_name: string
        birth_date: Date | string
        death_date: Date | string
        function: string
        income: number
        tenant_id: string
        created_at?: Date | string | null
        updated_at?: Date | string | null
    }

    export type Family_furnishingUpdateWithoutFamiliesInput = {
        id?: StringFieldUpdateOperationsInput | string
        value?: StringFieldUpdateOperationsInput | string
        furnishings?: FurnishingsUpdateOneRequiredWithoutFamily_furnishingNestedInput
    }

    export type Family_furnishingUncheckedUpdateWithoutFamiliesInput = {
        id?: StringFieldUpdateOperationsInput | string
        furnishing_id?: StringFieldUpdateOperationsInput | string
        value?: StringFieldUpdateOperationsInput | string
    }

    export type Family_furnishingUncheckedUpdateManyWithoutFamily_furnishingInput = {
        id?: StringFieldUpdateOperationsInput | string
        furnishing_id?: StringFieldUpdateOperationsInput | string
        value?: StringFieldUpdateOperationsInput | string
    }

    export type Family_housingUpdateWithoutFamiliesInput = {
        id?: StringFieldUpdateOperationsInput | string
        value?: StringFieldUpdateOperationsInput | string
        housings?: HousingsUpdateOneRequiredWithoutFamily_housingNestedInput
    }

    export type Family_housingUncheckedUpdateWithoutFamiliesInput = {
        id?: StringFieldUpdateOperationsInput | string
        housing_id?: StringFieldUpdateOperationsInput | string
        value?: StringFieldUpdateOperationsInput | string
    }

    export type Family_housingUncheckedUpdateManyWithoutFamily_housingInput = {
        id?: StringFieldUpdateOperationsInput | string
        housing_id?: StringFieldUpdateOperationsInput | string
        value?: StringFieldUpdateOperationsInput | string
    }

    export type Family_sponsorshipUpdateWithoutFamiliesInput = {
        id?: StringFieldUpdateOperationsInput | string
        type?: Enumfamily_sponsorship_typeFieldUpdateOperationsInput | family_sponsorship_type
        value?: StringFieldUpdateOperationsInput | string
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        tenants?: TenantsUpdateOneRequiredWithoutFamily_sponsorshipNestedInput
    }

    export type Family_sponsorshipUncheckedUpdateWithoutFamiliesInput = {
        id?: StringFieldUpdateOperationsInput | string
        type?: Enumfamily_sponsorship_typeFieldUpdateOperationsInput | family_sponsorship_type
        value?: StringFieldUpdateOperationsInput | string
        tenant_id?: StringFieldUpdateOperationsInput | string
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    }

    export type Family_sponsorshipUncheckedUpdateManyWithoutFamily_sponsorshipInput = {
        id?: StringFieldUpdateOperationsInput | string
        type?: Enumfamily_sponsorship_typeFieldUpdateOperationsInput | family_sponsorship_type
        value?: StringFieldUpdateOperationsInput | string
        tenant_id?: StringFieldUpdateOperationsInput | string
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    }

    export type OrphansUpdateWithoutFamiliesInput = {
        id?: StringFieldUpdateOperationsInput | string
        first_name?: StringFieldUpdateOperationsInput | string
        last_name?: StringFieldUpdateOperationsInput | string
        birth_date?: DateTimeFieldUpdateOperationsInput | Date | string
        family_status?: StringFieldUpdateOperationsInput | string
        health_status?: StringFieldUpdateOperationsInput | string
        academic_level?: StringFieldUpdateOperationsInput | string
        shoes_size?: StringFieldUpdateOperationsInput | string
        pants_size?: StringFieldUpdateOperationsInput | string
        shirt_size?: StringFieldUpdateOperationsInput | string
        note?: StringFieldUpdateOperationsInput | string
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        orphan_sponsorship?: Orphan_sponsorshipUpdateManyWithoutOrphansNestedInput
        users_orphans_created_byTousers?: UsersUpdateOneRequiredWithoutOrphans_orphans_created_byTousersNestedInput
        users_orphans_deleted_byTousers?: UsersUpdateOneWithoutOrphans_orphans_deleted_byTousersNestedInput
        tenants?: TenantsUpdateOneRequiredWithoutOrphansNestedInput
    }

    export type OrphansUncheckedUpdateWithoutFamiliesInput = {
        id?: StringFieldUpdateOperationsInput | string
        first_name?: StringFieldUpdateOperationsInput | string
        last_name?: StringFieldUpdateOperationsInput | string
        birth_date?: DateTimeFieldUpdateOperationsInput | Date | string
        family_status?: StringFieldUpdateOperationsInput | string
        health_status?: StringFieldUpdateOperationsInput | string
        academic_level?: StringFieldUpdateOperationsInput | string
        shoes_size?: StringFieldUpdateOperationsInput | string
        pants_size?: StringFieldUpdateOperationsInput | string
        shirt_size?: StringFieldUpdateOperationsInput | string
        note?: StringFieldUpdateOperationsInput | string
        tenant_id?: StringFieldUpdateOperationsInput | string
        created_by?: StringFieldUpdateOperationsInput | string
        deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        orphan_sponsorship?: Orphan_sponsorshipUncheckedUpdateManyWithoutOrphansNestedInput
    }

    export type OrphansUncheckedUpdateManyWithoutOrphansInput = {
        id?: StringFieldUpdateOperationsInput | string
        first_name?: StringFieldUpdateOperationsInput | string
        last_name?: StringFieldUpdateOperationsInput | string
        birth_date?: DateTimeFieldUpdateOperationsInput | Date | string
        family_status?: StringFieldUpdateOperationsInput | string
        health_status?: StringFieldUpdateOperationsInput | string
        academic_level?: StringFieldUpdateOperationsInput | string
        shoes_size?: StringFieldUpdateOperationsInput | string
        pants_size?: StringFieldUpdateOperationsInput | string
        shirt_size?: StringFieldUpdateOperationsInput | string
        note?: StringFieldUpdateOperationsInput | string
        tenant_id?: StringFieldUpdateOperationsInput | string
        created_by?: StringFieldUpdateOperationsInput | string
        deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    }

    export type Second_sponsorsUpdateWithoutFamiliesInput = {
        id?: StringFieldUpdateOperationsInput | string
        first_name?: StringFieldUpdateOperationsInput | string
        last_name?: StringFieldUpdateOperationsInput | string
        degree_of_kinship?: StringFieldUpdateOperationsInput | string
        phone_number?: StringFieldUpdateOperationsInput | string
        address?: StringFieldUpdateOperationsInput | string
        income?: FloatFieldUpdateOperationsInput | number
        deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        tenants?: TenantsUpdateOneRequiredWithoutSecond_sponsorsNestedInput
    }

    export type Second_sponsorsUncheckedUpdateWithoutFamiliesInput = {
        id?: StringFieldUpdateOperationsInput | string
        first_name?: StringFieldUpdateOperationsInput | string
        last_name?: StringFieldUpdateOperationsInput | string
        degree_of_kinship?: StringFieldUpdateOperationsInput | string
        phone_number?: StringFieldUpdateOperationsInput | string
        address?: StringFieldUpdateOperationsInput | string
        income?: FloatFieldUpdateOperationsInput | number
        tenant_id?: StringFieldUpdateOperationsInput | string
        deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    }

    export type Second_sponsorsUncheckedUpdateManyWithoutSecond_sponsorsInput = {
        id?: StringFieldUpdateOperationsInput | string
        first_name?: StringFieldUpdateOperationsInput | string
        last_name?: StringFieldUpdateOperationsInput | string
        degree_of_kinship?: StringFieldUpdateOperationsInput | string
        phone_number?: StringFieldUpdateOperationsInput | string
        address?: StringFieldUpdateOperationsInput | string
        income?: FloatFieldUpdateOperationsInput | number
        tenant_id?: StringFieldUpdateOperationsInput | string
        deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    }

    export type SpousesUpdateWithoutFamiliesInput = {
        id?: StringFieldUpdateOperationsInput | string
        first_name?: StringFieldUpdateOperationsInput | string
        last_name?: StringFieldUpdateOperationsInput | string
        birth_date?: DateTimeFieldUpdateOperationsInput | Date | string
        death_date?: DateTimeFieldUpdateOperationsInput | Date | string
        function?: StringFieldUpdateOperationsInput | string
        income?: FloatFieldUpdateOperationsInput | number
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        tenants?: TenantsUpdateOneRequiredWithoutSpousesNestedInput
    }

    export type SpousesUncheckedUpdateWithoutFamiliesInput = {
        id?: StringFieldUpdateOperationsInput | string
        first_name?: StringFieldUpdateOperationsInput | string
        last_name?: StringFieldUpdateOperationsInput | string
        birth_date?: DateTimeFieldUpdateOperationsInput | Date | string
        death_date?: DateTimeFieldUpdateOperationsInput | Date | string
        function?: StringFieldUpdateOperationsInput | string
        income?: FloatFieldUpdateOperationsInput | number
        tenant_id?: StringFieldUpdateOperationsInput | string
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    }

    export type SpousesUncheckedUpdateManyWithoutSpousesInput = {
        id?: StringFieldUpdateOperationsInput | string
        first_name?: StringFieldUpdateOperationsInput | string
        last_name?: StringFieldUpdateOperationsInput | string
        birth_date?: DateTimeFieldUpdateOperationsInput | Date | string
        death_date?: DateTimeFieldUpdateOperationsInput | Date | string
        function?: StringFieldUpdateOperationsInput | string
        income?: FloatFieldUpdateOperationsInput | number
        tenant_id?: StringFieldUpdateOperationsInput | string
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    }

    export type Family_furnishingCreateManyFurnishingsInput = {
        id: string
        family_id: string
        value: string
    }

    export type Family_furnishingUpdateWithoutFurnishingsInput = {
        id?: StringFieldUpdateOperationsInput | string
        value?: StringFieldUpdateOperationsInput | string
        families?: FamiliesUpdateOneRequiredWithoutFamily_furnishingNestedInput
    }

    export type Family_furnishingUncheckedUpdateWithoutFurnishingsInput = {
        id?: StringFieldUpdateOperationsInput | string
        family_id?: StringFieldUpdateOperationsInput | string
        value?: StringFieldUpdateOperationsInput | string
    }

    export type Family_housingCreateManyHousingsInput = {
        id: string
        family_id: string
        value: string
    }

    export type Family_housingUpdateWithoutHousingsInput = {
        id?: StringFieldUpdateOperationsInput | string
        value?: StringFieldUpdateOperationsInput | string
        families?: FamiliesUpdateOneRequiredWithoutFamily_housingNestedInput
    }

    export type Family_housingUncheckedUpdateWithoutHousingsInput = {
        id?: StringFieldUpdateOperationsInput | string
        family_id?: StringFieldUpdateOperationsInput | string
        value?: StringFieldUpdateOperationsInput | string
    }

    export type Income_sponsorCreateManyIncomesInput = {
        id: string
        sponsor_id: string
        tenant_id: string
        value: number
        created_at?: Date | string | null
        updated_at?: Date | string | null
    }

    export type Income_sponsorUpdateWithoutIncomesInput = {
        id?: StringFieldUpdateOperationsInput | string
        value?: FloatFieldUpdateOperationsInput | number
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        sponsors?: SponsorsUpdateOneRequiredWithoutIncome_sponsorNestedInput
        tenants?: TenantsUpdateOneRequiredWithoutIncome_sponsorNestedInput
    }

    export type Income_sponsorUncheckedUpdateWithoutIncomesInput = {
        id?: StringFieldUpdateOperationsInput | string
        sponsor_id?: StringFieldUpdateOperationsInput | string
        tenant_id?: StringFieldUpdateOperationsInput | string
        value?: FloatFieldUpdateOperationsInput | number
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    }

    export type Income_sponsorUncheckedUpdateManyWithoutIncome_sponsorInput = {
        id?: StringFieldUpdateOperationsInput | string
        sponsor_id?: StringFieldUpdateOperationsInput | string
        tenant_id?: StringFieldUpdateOperationsInput | string
        value?: FloatFieldUpdateOperationsInput | number
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    }

    export type Orphan_sponsorshipCreateManyOrphansInput = {
        id: string
        type: orphan_sponsorship_type
        value?: string | null
        tenant_id: string
        created_at?: Date | string | null
        updated_at?: Date | string | null
    }

    export type Orphan_sponsorshipUpdateWithoutOrphansInput = {
        id?: StringFieldUpdateOperationsInput | string
        type?: Enumorphan_sponsorship_typeFieldUpdateOperationsInput | orphan_sponsorship_type
        value?: NullableStringFieldUpdateOperationsInput | string | null
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        tenants?: TenantsUpdateOneRequiredWithoutOrphan_sponsorshipNestedInput
    }

    export type Orphan_sponsorshipUncheckedUpdateWithoutOrphansInput = {
        id?: StringFieldUpdateOperationsInput | string
        type?: Enumorphan_sponsorship_typeFieldUpdateOperationsInput | orphan_sponsorship_type
        value?: NullableStringFieldUpdateOperationsInput | string | null
        tenant_id?: StringFieldUpdateOperationsInput | string
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    }

    export type Orphan_sponsorshipUncheckedUpdateManyWithoutOrphan_sponsorshipInput = {
        id?: StringFieldUpdateOperationsInput | string
        type?: Enumorphan_sponsorship_typeFieldUpdateOperationsInput | orphan_sponsorship_type
        value?: NullableStringFieldUpdateOperationsInput | string | null
        tenant_id?: StringFieldUpdateOperationsInput | string
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    }

    export type Model_has_permissionsCreateManyPermissionsInput = {
        model_type: string
        model_uuid: string
    }

    export type Role_has_permissionsCreateManyPermissionsInput = {
        role_id: string
    }

    export type Model_has_permissionsUpdateWithoutPermissionsInput = {
        model_type?: StringFieldUpdateOperationsInput | string
        model_uuid?: StringFieldUpdateOperationsInput | string
    }

    export type Model_has_permissionsUncheckedUpdateWithoutPermissionsInput = {
        model_type?: StringFieldUpdateOperationsInput | string
        model_uuid?: StringFieldUpdateOperationsInput | string
    }

    export type Model_has_permissionsUncheckedUpdateManyWithoutModel_has_permissionsInput = {
        model_type?: StringFieldUpdateOperationsInput | string
        model_uuid?: StringFieldUpdateOperationsInput | string
    }

    export type Role_has_permissionsUpdateWithoutPermissionsInput = {
        roles?: RolesUpdateOneRequiredWithoutRole_has_permissionsNestedInput
    }

    export type Role_has_permissionsUncheckedUpdateWithoutPermissionsInput = {
        role_id?: StringFieldUpdateOperationsInput | string
    }

    export type Role_has_permissionsUncheckedUpdateManyWithoutRole_has_permissionsInput = {
        role_id?: StringFieldUpdateOperationsInput | string
    }

    export type Model_has_rolesCreateManyRolesInput = {
        model_type: string
        model_uuid: string
    }

    export type Role_has_permissionsCreateManyRolesInput = {
        permission_id: string
    }

    export type Model_has_rolesUpdateWithoutRolesInput = {
        model_type?: StringFieldUpdateOperationsInput | string
        model_uuid?: StringFieldUpdateOperationsInput | string
    }

    export type Model_has_rolesUncheckedUpdateWithoutRolesInput = {
        model_type?: StringFieldUpdateOperationsInput | string
        model_uuid?: StringFieldUpdateOperationsInput | string
    }

    export type Model_has_rolesUncheckedUpdateManyWithoutModel_has_rolesInput = {
        model_type?: StringFieldUpdateOperationsInput | string
        model_uuid?: StringFieldUpdateOperationsInput | string
    }

    export type Role_has_permissionsUpdateWithoutRolesInput = {
        permissions?: PermissionsUpdateOneRequiredWithoutRole_has_permissionsNestedInput
    }

    export type Role_has_permissionsUncheckedUpdateWithoutRolesInput = {
        permission_id?: StringFieldUpdateOperationsInput | string
    }

    export type Income_sponsorCreateManySponsorsInput = {
        id: string
        income_id: string
        tenant_id: string
        value: number
        created_at?: Date | string | null
        updated_at?: Date | string | null
    }

    export type Sponsor_sponsorshipCreateManySponsorsInput = {
        id: string
        type: sponsor_sponsorship_type
        value: string
        tenant_id: string
        created_at?: Date | string | null
        updated_at?: Date | string | null
    }

    export type Income_sponsorUpdateWithoutSponsorsInput = {
        id?: StringFieldUpdateOperationsInput | string
        value?: FloatFieldUpdateOperationsInput | number
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        incomes?: IncomesUpdateOneRequiredWithoutIncome_sponsorNestedInput
        tenants?: TenantsUpdateOneRequiredWithoutIncome_sponsorNestedInput
    }

    export type Income_sponsorUncheckedUpdateWithoutSponsorsInput = {
        id?: StringFieldUpdateOperationsInput | string
        income_id?: StringFieldUpdateOperationsInput | string
        tenant_id?: StringFieldUpdateOperationsInput | string
        value?: FloatFieldUpdateOperationsInput | number
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    }

    export type Sponsor_sponsorshipUpdateWithoutSponsorsInput = {
        id?: StringFieldUpdateOperationsInput | string
        type?: Enumsponsor_sponsorship_typeFieldUpdateOperationsInput | sponsor_sponsorship_type
        value?: StringFieldUpdateOperationsInput | string
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        tenants?: TenantsUpdateOneRequiredWithoutSponsor_sponsorshipNestedInput
    }

    export type Sponsor_sponsorshipUncheckedUpdateWithoutSponsorsInput = {
        id?: StringFieldUpdateOperationsInput | string
        type?: Enumsponsor_sponsorship_typeFieldUpdateOperationsInput | sponsor_sponsorship_type
        value?: StringFieldUpdateOperationsInput | string
        tenant_id?: StringFieldUpdateOperationsInput | string
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    }

    export type Sponsor_sponsorshipUncheckedUpdateManyWithoutSponsor_sponsorshipInput = {
        id?: StringFieldUpdateOperationsInput | string
        type?: Enumsponsor_sponsorship_typeFieldUpdateOperationsInput | sponsor_sponsorship_type
        value?: StringFieldUpdateOperationsInput | string
        tenant_id?: StringFieldUpdateOperationsInput | string
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    }

    export type BenefactorsCreateManyTenantsInput = {
        id: string
        deleted_at?: Date | string | null
        created_at?: Date | string | null
        updated_at?: Date | string | null
    }

    export type DomainsCreateManyTenantsInput = {
        id: string
        domain: string
        created_at?: Date | string | null
        updated_at?: Date | string | null
    }

    export type FamiliesCreateManyTenantsInput = {
        id: string
        name: string
        report: string
        created_at?: Date | string | null
        updated_at?: Date | string | null
    }

    export type Family_sponsorshipCreateManyTenantsInput = {
        id: string
        family_id: string
        type: family_sponsorship_type
        value: string
        created_at?: Date | string | null
        updated_at?: Date | string | null
    }

    export type Income_sponsorCreateManyTenantsInput = {
        id: string
        income_id: string
        sponsor_id: string
        value: number
        created_at?: Date | string | null
        updated_at?: Date | string | null
    }

    export type Orphan_sponsorshipCreateManyTenantsInput = {
        id: string
        orphan_id: string
        type: orphan_sponsorship_type
        value?: string | null
        created_at?: Date | string | null
        updated_at?: Date | string | null
    }

    export type OrphansCreateManyTenantsInput = {
        id: string
        first_name: string
        last_name: string
        birth_date: Date | string
        family_status: string
        health_status: string
        academic_level: string
        shoes_size: string
        pants_size: string
        shirt_size: string
        note: string
        family_id: string
        created_by: string
        deleted_by?: string | null
        created_at?: Date | string | null
        updated_at?: Date | string | null
    }

    export type Second_sponsorsCreateManyTenantsInput = {
        id: string
        first_name: string
        last_name: string
        degree_of_kinship: string
        phone_number: string
        address: string
        income: number
        family_id: string
        deleted_at?: Date | string | null
        created_at?: Date | string | null
        updated_at?: Date | string | null
    }

    export type Sponsor_sponsorshipCreateManyTenantsInput = {
        id: string
        sponsor_id: string
        type: sponsor_sponsorship_type
        value: string
        created_at?: Date | string | null
        updated_at?: Date | string | null
    }

    export type SponsorsCreateManyTenantsInput = {
        id: string
        zone_id: string
        file_number: number
        start_date: Date | string
        name: string
        address: string
        phone_number: string
        sponsorship_type: string
        birth_date: Date | string
        father_name: string
        mother_name: string
        birth_certificate_number: string
        academic_level: string
        function: string
        health_status: string
        diploma?: string | null
        card_number?: string | null
        created_by: string
        deleted_by?: string | null
        deleted_at?: Date | string | null
        created_at?: Date | string | null
        updated_at?: Date | string | null
    }

    export type SponsorshipsCreateManyTenantsInput = {
        id: string
        type: sponsorship_type
        name: string
        deleted_at?: Date | string | null
        created_at?: Date | string | null
        updated_at?: Date | string | null
    }

    export type SpousesCreateManyTenantsInput = {
        id: string
        first_name: string
        last_name: string
        birth_date: Date | string
        death_date: Date | string
        function: string
        income: number
        family_id: string
        created_at?: Date | string | null
        updated_at?: Date | string | null
    }

    export type UsersCreateManyTenantsInput = {
        id: string
        first_name: string
        last_name: string
        phone: string
        email: string
        email_verified_at?: Date | string | null
        password: string
        remember_token?: string | null
        created_at?: Date | string | null
        updated_at?: Date | string | null
    }

    export type BenefactorsUpdateWithoutTenantsInput = {
        id?: StringFieldUpdateOperationsInput | string
        deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    }

    export type BenefactorsUncheckedUpdateWithoutTenantsInput = {
        id?: StringFieldUpdateOperationsInput | string
        deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    }

    export type BenefactorsUncheckedUpdateManyWithoutBenefactorsInput = {
        id?: StringFieldUpdateOperationsInput | string
        deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    }

    export type DomainsUpdateWithoutTenantsInput = {
        id?: StringFieldUpdateOperationsInput | string
        domain?: StringFieldUpdateOperationsInput | string
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    }

    export type DomainsUncheckedUpdateWithoutTenantsInput = {
        id?: StringFieldUpdateOperationsInput | string
        domain?: StringFieldUpdateOperationsInput | string
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    }

    export type DomainsUncheckedUpdateManyWithoutDomainsInput = {
        id?: StringFieldUpdateOperationsInput | string
        domain?: StringFieldUpdateOperationsInput | string
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    }

    export type FamiliesUpdateWithoutTenantsInput = {
        id?: StringFieldUpdateOperationsInput | string
        name?: StringFieldUpdateOperationsInput | string
        report?: StringFieldUpdateOperationsInput | string
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        family_furnishing?: Family_furnishingUpdateManyWithoutFamiliesNestedInput
        family_housing?: Family_housingUpdateManyWithoutFamiliesNestedInput
        family_sponsorship?: Family_sponsorshipUpdateManyWithoutFamiliesNestedInput
        orphans?: OrphansUpdateManyWithoutFamiliesNestedInput
        second_sponsors?: Second_sponsorsUpdateManyWithoutFamiliesNestedInput
        spouses?: SpousesUpdateManyWithoutFamiliesNestedInput
    }

    export type FamiliesUncheckedUpdateWithoutTenantsInput = {
        id?: StringFieldUpdateOperationsInput | string
        name?: StringFieldUpdateOperationsInput | string
        report?: StringFieldUpdateOperationsInput | string
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        family_furnishing?: Family_furnishingUncheckedUpdateManyWithoutFamiliesNestedInput
        family_housing?: Family_housingUncheckedUpdateManyWithoutFamiliesNestedInput
        family_sponsorship?: Family_sponsorshipUncheckedUpdateManyWithoutFamiliesNestedInput
        orphans?: OrphansUncheckedUpdateManyWithoutFamiliesNestedInput
        second_sponsors?: Second_sponsorsUncheckedUpdateManyWithoutFamiliesNestedInput
        spouses?: SpousesUncheckedUpdateManyWithoutFamiliesNestedInput
    }

    export type FamiliesUncheckedUpdateManyWithoutFamiliesInput = {
        id?: StringFieldUpdateOperationsInput | string
        name?: StringFieldUpdateOperationsInput | string
        report?: StringFieldUpdateOperationsInput | string
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    }

    export type Family_sponsorshipUpdateWithoutTenantsInput = {
        id?: StringFieldUpdateOperationsInput | string
        type?: Enumfamily_sponsorship_typeFieldUpdateOperationsInput | family_sponsorship_type
        value?: StringFieldUpdateOperationsInput | string
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        families?: FamiliesUpdateOneRequiredWithoutFamily_sponsorshipNestedInput
    }

    export type Family_sponsorshipUncheckedUpdateWithoutTenantsInput = {
        id?: StringFieldUpdateOperationsInput | string
        family_id?: StringFieldUpdateOperationsInput | string
        type?: Enumfamily_sponsorship_typeFieldUpdateOperationsInput | family_sponsorship_type
        value?: StringFieldUpdateOperationsInput | string
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    }

    export type Income_sponsorUpdateWithoutTenantsInput = {
        id?: StringFieldUpdateOperationsInput | string
        value?: FloatFieldUpdateOperationsInput | number
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        incomes?: IncomesUpdateOneRequiredWithoutIncome_sponsorNestedInput
        sponsors?: SponsorsUpdateOneRequiredWithoutIncome_sponsorNestedInput
    }

    export type Income_sponsorUncheckedUpdateWithoutTenantsInput = {
        id?: StringFieldUpdateOperationsInput | string
        income_id?: StringFieldUpdateOperationsInput | string
        sponsor_id?: StringFieldUpdateOperationsInput | string
        value?: FloatFieldUpdateOperationsInput | number
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    }

    export type Orphan_sponsorshipUpdateWithoutTenantsInput = {
        id?: StringFieldUpdateOperationsInput | string
        type?: Enumorphan_sponsorship_typeFieldUpdateOperationsInput | orphan_sponsorship_type
        value?: NullableStringFieldUpdateOperationsInput | string | null
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        orphans?: OrphansUpdateOneRequiredWithoutOrphan_sponsorshipNestedInput
    }

    export type Orphan_sponsorshipUncheckedUpdateWithoutTenantsInput = {
        id?: StringFieldUpdateOperationsInput | string
        orphan_id?: StringFieldUpdateOperationsInput | string
        type?: Enumorphan_sponsorship_typeFieldUpdateOperationsInput | orphan_sponsorship_type
        value?: NullableStringFieldUpdateOperationsInput | string | null
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    }

    export type OrphansUpdateWithoutTenantsInput = {
        id?: StringFieldUpdateOperationsInput | string
        first_name?: StringFieldUpdateOperationsInput | string
        last_name?: StringFieldUpdateOperationsInput | string
        birth_date?: DateTimeFieldUpdateOperationsInput | Date | string
        family_status?: StringFieldUpdateOperationsInput | string
        health_status?: StringFieldUpdateOperationsInput | string
        academic_level?: StringFieldUpdateOperationsInput | string
        shoes_size?: StringFieldUpdateOperationsInput | string
        pants_size?: StringFieldUpdateOperationsInput | string
        shirt_size?: StringFieldUpdateOperationsInput | string
        note?: StringFieldUpdateOperationsInput | string
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        orphan_sponsorship?: Orphan_sponsorshipUpdateManyWithoutOrphansNestedInput
        users_orphans_created_byTousers?: UsersUpdateOneRequiredWithoutOrphans_orphans_created_byTousersNestedInput
        users_orphans_deleted_byTousers?: UsersUpdateOneWithoutOrphans_orphans_deleted_byTousersNestedInput
        families?: FamiliesUpdateOneRequiredWithoutOrphansNestedInput
    }

    export type OrphansUncheckedUpdateWithoutTenantsInput = {
        id?: StringFieldUpdateOperationsInput | string
        first_name?: StringFieldUpdateOperationsInput | string
        last_name?: StringFieldUpdateOperationsInput | string
        birth_date?: DateTimeFieldUpdateOperationsInput | Date | string
        family_status?: StringFieldUpdateOperationsInput | string
        health_status?: StringFieldUpdateOperationsInput | string
        academic_level?: StringFieldUpdateOperationsInput | string
        shoes_size?: StringFieldUpdateOperationsInput | string
        pants_size?: StringFieldUpdateOperationsInput | string
        shirt_size?: StringFieldUpdateOperationsInput | string
        note?: StringFieldUpdateOperationsInput | string
        family_id?: StringFieldUpdateOperationsInput | string
        created_by?: StringFieldUpdateOperationsInput | string
        deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        orphan_sponsorship?: Orphan_sponsorshipUncheckedUpdateManyWithoutOrphansNestedInput
    }

    export type Second_sponsorsUpdateWithoutTenantsInput = {
        id?: StringFieldUpdateOperationsInput | string
        first_name?: StringFieldUpdateOperationsInput | string
        last_name?: StringFieldUpdateOperationsInput | string
        degree_of_kinship?: StringFieldUpdateOperationsInput | string
        phone_number?: StringFieldUpdateOperationsInput | string
        address?: StringFieldUpdateOperationsInput | string
        income?: FloatFieldUpdateOperationsInput | number
        deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        families?: FamiliesUpdateOneRequiredWithoutSecond_sponsorsNestedInput
    }

    export type Second_sponsorsUncheckedUpdateWithoutTenantsInput = {
        id?: StringFieldUpdateOperationsInput | string
        first_name?: StringFieldUpdateOperationsInput | string
        last_name?: StringFieldUpdateOperationsInput | string
        degree_of_kinship?: StringFieldUpdateOperationsInput | string
        phone_number?: StringFieldUpdateOperationsInput | string
        address?: StringFieldUpdateOperationsInput | string
        income?: FloatFieldUpdateOperationsInput | number
        family_id?: StringFieldUpdateOperationsInput | string
        deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    }

    export type Sponsor_sponsorshipUpdateWithoutTenantsInput = {
        id?: StringFieldUpdateOperationsInput | string
        type?: Enumsponsor_sponsorship_typeFieldUpdateOperationsInput | sponsor_sponsorship_type
        value?: StringFieldUpdateOperationsInput | string
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        sponsors?: SponsorsUpdateOneRequiredWithoutSponsor_sponsorshipNestedInput
    }

    export type Sponsor_sponsorshipUncheckedUpdateWithoutTenantsInput = {
        id?: StringFieldUpdateOperationsInput | string
        sponsor_id?: StringFieldUpdateOperationsInput | string
        type?: Enumsponsor_sponsorship_typeFieldUpdateOperationsInput | sponsor_sponsorship_type
        value?: StringFieldUpdateOperationsInput | string
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    }

    export type SponsorsUpdateWithoutTenantsInput = {
        id?: StringFieldUpdateOperationsInput | string
        zone_id?: StringFieldUpdateOperationsInput | string
        file_number?: IntFieldUpdateOperationsInput | number
        start_date?: DateTimeFieldUpdateOperationsInput | Date | string
        name?: StringFieldUpdateOperationsInput | string
        address?: StringFieldUpdateOperationsInput | string
        phone_number?: StringFieldUpdateOperationsInput | string
        sponsorship_type?: StringFieldUpdateOperationsInput | string
        birth_date?: DateTimeFieldUpdateOperationsInput | Date | string
        father_name?: StringFieldUpdateOperationsInput | string
        mother_name?: StringFieldUpdateOperationsInput | string
        birth_certificate_number?: StringFieldUpdateOperationsInput | string
        academic_level?: StringFieldUpdateOperationsInput | string
        function?: StringFieldUpdateOperationsInput | string
        health_status?: StringFieldUpdateOperationsInput | string
        diploma?: NullableStringFieldUpdateOperationsInput | string | null
        card_number?: NullableStringFieldUpdateOperationsInput | string | null
        deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        income_sponsor?: Income_sponsorUpdateManyWithoutSponsorsNestedInput
        sponsor_sponsorship?: Sponsor_sponsorshipUpdateManyWithoutSponsorsNestedInput
        users_sponsors_created_byTousers?: UsersUpdateOneRequiredWithoutSponsors_sponsors_created_byTousersNestedInput
        users_sponsors_deleted_byTousers?: UsersUpdateOneWithoutSponsors_sponsors_deleted_byTousersNestedInput
    }

    export type SponsorsUncheckedUpdateWithoutTenantsInput = {
        id?: StringFieldUpdateOperationsInput | string
        zone_id?: StringFieldUpdateOperationsInput | string
        file_number?: IntFieldUpdateOperationsInput | number
        start_date?: DateTimeFieldUpdateOperationsInput | Date | string
        name?: StringFieldUpdateOperationsInput | string
        address?: StringFieldUpdateOperationsInput | string
        phone_number?: StringFieldUpdateOperationsInput | string
        sponsorship_type?: StringFieldUpdateOperationsInput | string
        birth_date?: DateTimeFieldUpdateOperationsInput | Date | string
        father_name?: StringFieldUpdateOperationsInput | string
        mother_name?: StringFieldUpdateOperationsInput | string
        birth_certificate_number?: StringFieldUpdateOperationsInput | string
        academic_level?: StringFieldUpdateOperationsInput | string
        function?: StringFieldUpdateOperationsInput | string
        health_status?: StringFieldUpdateOperationsInput | string
        diploma?: NullableStringFieldUpdateOperationsInput | string | null
        card_number?: NullableStringFieldUpdateOperationsInput | string | null
        created_by?: StringFieldUpdateOperationsInput | string
        deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
        deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        income_sponsor?: Income_sponsorUncheckedUpdateManyWithoutSponsorsNestedInput
        sponsor_sponsorship?: Sponsor_sponsorshipUncheckedUpdateManyWithoutSponsorsNestedInput
    }

    export type SponsorsUncheckedUpdateManyWithoutSponsorsInput = {
        id?: StringFieldUpdateOperationsInput | string
        zone_id?: StringFieldUpdateOperationsInput | string
        file_number?: IntFieldUpdateOperationsInput | number
        start_date?: DateTimeFieldUpdateOperationsInput | Date | string
        name?: StringFieldUpdateOperationsInput | string
        address?: StringFieldUpdateOperationsInput | string
        phone_number?: StringFieldUpdateOperationsInput | string
        sponsorship_type?: StringFieldUpdateOperationsInput | string
        birth_date?: DateTimeFieldUpdateOperationsInput | Date | string
        father_name?: StringFieldUpdateOperationsInput | string
        mother_name?: StringFieldUpdateOperationsInput | string
        birth_certificate_number?: StringFieldUpdateOperationsInput | string
        academic_level?: StringFieldUpdateOperationsInput | string
        function?: StringFieldUpdateOperationsInput | string
        health_status?: StringFieldUpdateOperationsInput | string
        diploma?: NullableStringFieldUpdateOperationsInput | string | null
        card_number?: NullableStringFieldUpdateOperationsInput | string | null
        created_by?: StringFieldUpdateOperationsInput | string
        deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
        deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    }

    export type SponsorshipsUpdateWithoutTenantsInput = {
        id?: StringFieldUpdateOperationsInput | string
        type?: Enumsponsorship_typeFieldUpdateOperationsInput | sponsorship_type
        name?: StringFieldUpdateOperationsInput | string
        deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    }

    export type SponsorshipsUncheckedUpdateWithoutTenantsInput = {
        id?: StringFieldUpdateOperationsInput | string
        type?: Enumsponsorship_typeFieldUpdateOperationsInput | sponsorship_type
        name?: StringFieldUpdateOperationsInput | string
        deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    }

    export type SponsorshipsUncheckedUpdateManyWithoutSponsorshipsInput = {
        id?: StringFieldUpdateOperationsInput | string
        type?: Enumsponsorship_typeFieldUpdateOperationsInput | sponsorship_type
        name?: StringFieldUpdateOperationsInput | string
        deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    }

    export type SpousesUpdateWithoutTenantsInput = {
        id?: StringFieldUpdateOperationsInput | string
        first_name?: StringFieldUpdateOperationsInput | string
        last_name?: StringFieldUpdateOperationsInput | string
        birth_date?: DateTimeFieldUpdateOperationsInput | Date | string
        death_date?: DateTimeFieldUpdateOperationsInput | Date | string
        function?: StringFieldUpdateOperationsInput | string
        income?: FloatFieldUpdateOperationsInput | number
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        families?: FamiliesUpdateOneRequiredWithoutSpousesNestedInput
    }

    export type SpousesUncheckedUpdateWithoutTenantsInput = {
        id?: StringFieldUpdateOperationsInput | string
        first_name?: StringFieldUpdateOperationsInput | string
        last_name?: StringFieldUpdateOperationsInput | string
        birth_date?: DateTimeFieldUpdateOperationsInput | Date | string
        death_date?: DateTimeFieldUpdateOperationsInput | Date | string
        function?: StringFieldUpdateOperationsInput | string
        income?: FloatFieldUpdateOperationsInput | number
        family_id?: StringFieldUpdateOperationsInput | string
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    }

    export type UsersUpdateWithoutTenantsInput = {
        id?: StringFieldUpdateOperationsInput | string
        first_name?: StringFieldUpdateOperationsInput | string
        last_name?: StringFieldUpdateOperationsInput | string
        phone?: StringFieldUpdateOperationsInput | string
        email?: StringFieldUpdateOperationsInput | string
        email_verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        password?: StringFieldUpdateOperationsInput | string
        remember_token?: NullableStringFieldUpdateOperationsInput | string | null
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        orphans_orphans_created_byTousers?: OrphansUpdateManyWithoutUsers_orphans_created_byTousersNestedInput
        orphans_orphans_deleted_byTousers?: OrphansUpdateManyWithoutUsers_orphans_deleted_byTousersNestedInput
        sessions?: SessionsUpdateManyWithoutUsersNestedInput
        settings?: SettingsUpdateManyWithoutUsersNestedInput
        sponsors_sponsors_created_byTousers?: SponsorsUpdateManyWithoutUsers_sponsors_created_byTousersNestedInput
        sponsors_sponsors_deleted_byTousers?: SponsorsUpdateManyWithoutUsers_sponsors_deleted_byTousersNestedInput
    }

    export type UsersUncheckedUpdateWithoutTenantsInput = {
        id?: StringFieldUpdateOperationsInput | string
        first_name?: StringFieldUpdateOperationsInput | string
        last_name?: StringFieldUpdateOperationsInput | string
        phone?: StringFieldUpdateOperationsInput | string
        email?: StringFieldUpdateOperationsInput | string
        email_verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        password?: StringFieldUpdateOperationsInput | string
        remember_token?: NullableStringFieldUpdateOperationsInput | string | null
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        orphans_orphans_created_byTousers?: OrphansUncheckedUpdateManyWithoutUsers_orphans_created_byTousersNestedInput
        orphans_orphans_deleted_byTousers?: OrphansUncheckedUpdateManyWithoutUsers_orphans_deleted_byTousersNestedInput
        sessions?: SessionsUncheckedUpdateManyWithoutUsersNestedInput
        settings?: SettingsUncheckedUpdateManyWithoutUsersNestedInput
        sponsors_sponsors_created_byTousers?: SponsorsUncheckedUpdateManyWithoutUsers_sponsors_created_byTousersNestedInput
        sponsors_sponsors_deleted_byTousers?: SponsorsUncheckedUpdateManyWithoutUsers_sponsors_deleted_byTousersNestedInput
    }

    export type UsersUncheckedUpdateManyWithoutUsersInput = {
        id?: StringFieldUpdateOperationsInput | string
        first_name?: StringFieldUpdateOperationsInput | string
        last_name?: StringFieldUpdateOperationsInput | string
        phone?: StringFieldUpdateOperationsInput | string
        email?: StringFieldUpdateOperationsInput | string
        email_verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        password?: StringFieldUpdateOperationsInput | string
        remember_token?: NullableStringFieldUpdateOperationsInput | string | null
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    }

    export type OrphansCreateManyUsers_orphans_created_byTousersInput = {
        id: string
        first_name: string
        last_name: string
        birth_date: Date | string
        family_status: string
        health_status: string
        academic_level: string
        shoes_size: string
        pants_size: string
        shirt_size: string
        note: string
        tenant_id: string
        family_id: string
        deleted_by?: string | null
        created_at?: Date | string | null
        updated_at?: Date | string | null
    }

    export type OrphansCreateManyUsers_orphans_deleted_byTousersInput = {
        id: string
        first_name: string
        last_name: string
        birth_date: Date | string
        family_status: string
        health_status: string
        academic_level: string
        shoes_size: string
        pants_size: string
        shirt_size: string
        note: string
        tenant_id: string
        family_id: string
        created_by: string
        created_at?: Date | string | null
        updated_at?: Date | string | null
    }

    export type SessionsCreateManyUsersInput = {
        id: string
        ip_address?: string | null
        user_agent?: string | null
        payload: string
        last_activity: number
    }

    export type SettingsCreateManyUsersInput = {
        id: string
        theme: theme
        color_scheme: color_scheme
        layout: layout
        appearance: appearance
        notifications?: NullableJsonNullValueInput | InputJsonValue
        created_at?: Date | string | null
        updated_at?: Date | string | null
    }

    export type SponsorsCreateManyUsers_sponsors_created_byTousersInput = {
        id: string
        zone_id: string
        file_number: number
        start_date: Date | string
        name: string
        address: string
        phone_number: string
        sponsorship_type: string
        birth_date: Date | string
        father_name: string
        mother_name: string
        birth_certificate_number: string
        academic_level: string
        function: string
        health_status: string
        diploma?: string | null
        card_number?: string | null
        tenant_id: string
        deleted_by?: string | null
        deleted_at?: Date | string | null
        created_at?: Date | string | null
        updated_at?: Date | string | null
    }

    export type SponsorsCreateManyUsers_sponsors_deleted_byTousersInput = {
        id: string
        zone_id: string
        file_number: number
        start_date: Date | string
        name: string
        address: string
        phone_number: string
        sponsorship_type: string
        birth_date: Date | string
        father_name: string
        mother_name: string
        birth_certificate_number: string
        academic_level: string
        function: string
        health_status: string
        diploma?: string | null
        card_number?: string | null
        tenant_id: string
        created_by: string
        deleted_at?: Date | string | null
        created_at?: Date | string | null
        updated_at?: Date | string | null
    }

    export type OrphansUpdateWithoutUsers_orphans_created_byTousersInput = {
        id?: StringFieldUpdateOperationsInput | string
        first_name?: StringFieldUpdateOperationsInput | string
        last_name?: StringFieldUpdateOperationsInput | string
        birth_date?: DateTimeFieldUpdateOperationsInput | Date | string
        family_status?: StringFieldUpdateOperationsInput | string
        health_status?: StringFieldUpdateOperationsInput | string
        academic_level?: StringFieldUpdateOperationsInput | string
        shoes_size?: StringFieldUpdateOperationsInput | string
        pants_size?: StringFieldUpdateOperationsInput | string
        shirt_size?: StringFieldUpdateOperationsInput | string
        note?: StringFieldUpdateOperationsInput | string
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        orphan_sponsorship?: Orphan_sponsorshipUpdateManyWithoutOrphansNestedInput
        users_orphans_deleted_byTousers?: UsersUpdateOneWithoutOrphans_orphans_deleted_byTousersNestedInput
        families?: FamiliesUpdateOneRequiredWithoutOrphansNestedInput
        tenants?: TenantsUpdateOneRequiredWithoutOrphansNestedInput
    }

    export type OrphansUncheckedUpdateWithoutUsers_orphans_created_byTousersInput = {
        id?: StringFieldUpdateOperationsInput | string
        first_name?: StringFieldUpdateOperationsInput | string
        last_name?: StringFieldUpdateOperationsInput | string
        birth_date?: DateTimeFieldUpdateOperationsInput | Date | string
        family_status?: StringFieldUpdateOperationsInput | string
        health_status?: StringFieldUpdateOperationsInput | string
        academic_level?: StringFieldUpdateOperationsInput | string
        shoes_size?: StringFieldUpdateOperationsInput | string
        pants_size?: StringFieldUpdateOperationsInput | string
        shirt_size?: StringFieldUpdateOperationsInput | string
        note?: StringFieldUpdateOperationsInput | string
        tenant_id?: StringFieldUpdateOperationsInput | string
        family_id?: StringFieldUpdateOperationsInput | string
        deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        orphan_sponsorship?: Orphan_sponsorshipUncheckedUpdateManyWithoutOrphansNestedInput
    }

    export type OrphansUncheckedUpdateManyWithoutOrphans_orphans_created_byTousersInput = {
        id?: StringFieldUpdateOperationsInput | string
        first_name?: StringFieldUpdateOperationsInput | string
        last_name?: StringFieldUpdateOperationsInput | string
        birth_date?: DateTimeFieldUpdateOperationsInput | Date | string
        family_status?: StringFieldUpdateOperationsInput | string
        health_status?: StringFieldUpdateOperationsInput | string
        academic_level?: StringFieldUpdateOperationsInput | string
        shoes_size?: StringFieldUpdateOperationsInput | string
        pants_size?: StringFieldUpdateOperationsInput | string
        shirt_size?: StringFieldUpdateOperationsInput | string
        note?: StringFieldUpdateOperationsInput | string
        tenant_id?: StringFieldUpdateOperationsInput | string
        family_id?: StringFieldUpdateOperationsInput | string
        deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    }

    export type OrphansUpdateWithoutUsers_orphans_deleted_byTousersInput = {
        id?: StringFieldUpdateOperationsInput | string
        first_name?: StringFieldUpdateOperationsInput | string
        last_name?: StringFieldUpdateOperationsInput | string
        birth_date?: DateTimeFieldUpdateOperationsInput | Date | string
        family_status?: StringFieldUpdateOperationsInput | string
        health_status?: StringFieldUpdateOperationsInput | string
        academic_level?: StringFieldUpdateOperationsInput | string
        shoes_size?: StringFieldUpdateOperationsInput | string
        pants_size?: StringFieldUpdateOperationsInput | string
        shirt_size?: StringFieldUpdateOperationsInput | string
        note?: StringFieldUpdateOperationsInput | string
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        orphan_sponsorship?: Orphan_sponsorshipUpdateManyWithoutOrphansNestedInput
        users_orphans_created_byTousers?: UsersUpdateOneRequiredWithoutOrphans_orphans_created_byTousersNestedInput
        families?: FamiliesUpdateOneRequiredWithoutOrphansNestedInput
        tenants?: TenantsUpdateOneRequiredWithoutOrphansNestedInput
    }

    export type OrphansUncheckedUpdateWithoutUsers_orphans_deleted_byTousersInput = {
        id?: StringFieldUpdateOperationsInput | string
        first_name?: StringFieldUpdateOperationsInput | string
        last_name?: StringFieldUpdateOperationsInput | string
        birth_date?: DateTimeFieldUpdateOperationsInput | Date | string
        family_status?: StringFieldUpdateOperationsInput | string
        health_status?: StringFieldUpdateOperationsInput | string
        academic_level?: StringFieldUpdateOperationsInput | string
        shoes_size?: StringFieldUpdateOperationsInput | string
        pants_size?: StringFieldUpdateOperationsInput | string
        shirt_size?: StringFieldUpdateOperationsInput | string
        note?: StringFieldUpdateOperationsInput | string
        tenant_id?: StringFieldUpdateOperationsInput | string
        family_id?: StringFieldUpdateOperationsInput | string
        created_by?: StringFieldUpdateOperationsInput | string
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        orphan_sponsorship?: Orphan_sponsorshipUncheckedUpdateManyWithoutOrphansNestedInput
    }

    export type OrphansUncheckedUpdateManyWithoutOrphans_orphans_deleted_byTousersInput = {
        id?: StringFieldUpdateOperationsInput | string
        first_name?: StringFieldUpdateOperationsInput | string
        last_name?: StringFieldUpdateOperationsInput | string
        birth_date?: DateTimeFieldUpdateOperationsInput | Date | string
        family_status?: StringFieldUpdateOperationsInput | string
        health_status?: StringFieldUpdateOperationsInput | string
        academic_level?: StringFieldUpdateOperationsInput | string
        shoes_size?: StringFieldUpdateOperationsInput | string
        pants_size?: StringFieldUpdateOperationsInput | string
        shirt_size?: StringFieldUpdateOperationsInput | string
        note?: StringFieldUpdateOperationsInput | string
        tenant_id?: StringFieldUpdateOperationsInput | string
        family_id?: StringFieldUpdateOperationsInput | string
        created_by?: StringFieldUpdateOperationsInput | string
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    }

    export type SessionsUpdateWithoutUsersInput = {
        id?: StringFieldUpdateOperationsInput | string
        ip_address?: NullableStringFieldUpdateOperationsInput | string | null
        user_agent?: NullableStringFieldUpdateOperationsInput | string | null
        payload?: StringFieldUpdateOperationsInput | string
        last_activity?: IntFieldUpdateOperationsInput | number
    }

    export type SessionsUncheckedUpdateWithoutUsersInput = {
        id?: StringFieldUpdateOperationsInput | string
        ip_address?: NullableStringFieldUpdateOperationsInput | string | null
        user_agent?: NullableStringFieldUpdateOperationsInput | string | null
        payload?: StringFieldUpdateOperationsInput | string
        last_activity?: IntFieldUpdateOperationsInput | number
    }

    export type SessionsUncheckedUpdateManyWithoutSessionsInput = {
        id?: StringFieldUpdateOperationsInput | string
        ip_address?: NullableStringFieldUpdateOperationsInput | string | null
        user_agent?: NullableStringFieldUpdateOperationsInput | string | null
        payload?: StringFieldUpdateOperationsInput | string
        last_activity?: IntFieldUpdateOperationsInput | number
    }

    export type SettingsUpdateWithoutUsersInput = {
        id?: StringFieldUpdateOperationsInput | string
        theme?: EnumthemeFieldUpdateOperationsInput | theme
        color_scheme?: Enumcolor_schemeFieldUpdateOperationsInput | color_scheme
        layout?: EnumlayoutFieldUpdateOperationsInput | layout
        appearance?: EnumappearanceFieldUpdateOperationsInput | appearance
        notifications?: NullableJsonNullValueInput | InputJsonValue
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    }

    export type SettingsUncheckedUpdateWithoutUsersInput = {
        id?: StringFieldUpdateOperationsInput | string
        theme?: EnumthemeFieldUpdateOperationsInput | theme
        color_scheme?: Enumcolor_schemeFieldUpdateOperationsInput | color_scheme
        layout?: EnumlayoutFieldUpdateOperationsInput | layout
        appearance?: EnumappearanceFieldUpdateOperationsInput | appearance
        notifications?: NullableJsonNullValueInput | InputJsonValue
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    }

    export type SettingsUncheckedUpdateManyWithoutSettingsInput = {
        id?: StringFieldUpdateOperationsInput | string
        theme?: EnumthemeFieldUpdateOperationsInput | theme
        color_scheme?: Enumcolor_schemeFieldUpdateOperationsInput | color_scheme
        layout?: EnumlayoutFieldUpdateOperationsInput | layout
        appearance?: EnumappearanceFieldUpdateOperationsInput | appearance
        notifications?: NullableJsonNullValueInput | InputJsonValue
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    }

    export type SponsorsUpdateWithoutUsers_sponsors_created_byTousersInput = {
        id?: StringFieldUpdateOperationsInput | string
        zone_id?: StringFieldUpdateOperationsInput | string
        file_number?: IntFieldUpdateOperationsInput | number
        start_date?: DateTimeFieldUpdateOperationsInput | Date | string
        name?: StringFieldUpdateOperationsInput | string
        address?: StringFieldUpdateOperationsInput | string
        phone_number?: StringFieldUpdateOperationsInput | string
        sponsorship_type?: StringFieldUpdateOperationsInput | string
        birth_date?: DateTimeFieldUpdateOperationsInput | Date | string
        father_name?: StringFieldUpdateOperationsInput | string
        mother_name?: StringFieldUpdateOperationsInput | string
        birth_certificate_number?: StringFieldUpdateOperationsInput | string
        academic_level?: StringFieldUpdateOperationsInput | string
        function?: StringFieldUpdateOperationsInput | string
        health_status?: StringFieldUpdateOperationsInput | string
        diploma?: NullableStringFieldUpdateOperationsInput | string | null
        card_number?: NullableStringFieldUpdateOperationsInput | string | null
        deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        income_sponsor?: Income_sponsorUpdateManyWithoutSponsorsNestedInput
        sponsor_sponsorship?: Sponsor_sponsorshipUpdateManyWithoutSponsorsNestedInput
        users_sponsors_deleted_byTousers?: UsersUpdateOneWithoutSponsors_sponsors_deleted_byTousersNestedInput
        tenants?: TenantsUpdateOneRequiredWithoutSponsorsNestedInput
    }

    export type SponsorsUncheckedUpdateWithoutUsers_sponsors_created_byTousersInput = {
        id?: StringFieldUpdateOperationsInput | string
        zone_id?: StringFieldUpdateOperationsInput | string
        file_number?: IntFieldUpdateOperationsInput | number
        start_date?: DateTimeFieldUpdateOperationsInput | Date | string
        name?: StringFieldUpdateOperationsInput | string
        address?: StringFieldUpdateOperationsInput | string
        phone_number?: StringFieldUpdateOperationsInput | string
        sponsorship_type?: StringFieldUpdateOperationsInput | string
        birth_date?: DateTimeFieldUpdateOperationsInput | Date | string
        father_name?: StringFieldUpdateOperationsInput | string
        mother_name?: StringFieldUpdateOperationsInput | string
        birth_certificate_number?: StringFieldUpdateOperationsInput | string
        academic_level?: StringFieldUpdateOperationsInput | string
        function?: StringFieldUpdateOperationsInput | string
        health_status?: StringFieldUpdateOperationsInput | string
        diploma?: NullableStringFieldUpdateOperationsInput | string | null
        card_number?: NullableStringFieldUpdateOperationsInput | string | null
        tenant_id?: StringFieldUpdateOperationsInput | string
        deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
        deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        income_sponsor?: Income_sponsorUncheckedUpdateManyWithoutSponsorsNestedInput
        sponsor_sponsorship?: Sponsor_sponsorshipUncheckedUpdateManyWithoutSponsorsNestedInput
    }

    export type SponsorsUncheckedUpdateManyWithoutSponsors_sponsors_created_byTousersInput = {
        id?: StringFieldUpdateOperationsInput | string
        zone_id?: StringFieldUpdateOperationsInput | string
        file_number?: IntFieldUpdateOperationsInput | number
        start_date?: DateTimeFieldUpdateOperationsInput | Date | string
        name?: StringFieldUpdateOperationsInput | string
        address?: StringFieldUpdateOperationsInput | string
        phone_number?: StringFieldUpdateOperationsInput | string
        sponsorship_type?: StringFieldUpdateOperationsInput | string
        birth_date?: DateTimeFieldUpdateOperationsInput | Date | string
        father_name?: StringFieldUpdateOperationsInput | string
        mother_name?: StringFieldUpdateOperationsInput | string
        birth_certificate_number?: StringFieldUpdateOperationsInput | string
        academic_level?: StringFieldUpdateOperationsInput | string
        function?: StringFieldUpdateOperationsInput | string
        health_status?: StringFieldUpdateOperationsInput | string
        diploma?: NullableStringFieldUpdateOperationsInput | string | null
        card_number?: NullableStringFieldUpdateOperationsInput | string | null
        tenant_id?: StringFieldUpdateOperationsInput | string
        deleted_by?: NullableStringFieldUpdateOperationsInput | string | null
        deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    }

    export type SponsorsUpdateWithoutUsers_sponsors_deleted_byTousersInput = {
        id?: StringFieldUpdateOperationsInput | string
        zone_id?: StringFieldUpdateOperationsInput | string
        file_number?: IntFieldUpdateOperationsInput | number
        start_date?: DateTimeFieldUpdateOperationsInput | Date | string
        name?: StringFieldUpdateOperationsInput | string
        address?: StringFieldUpdateOperationsInput | string
        phone_number?: StringFieldUpdateOperationsInput | string
        sponsorship_type?: StringFieldUpdateOperationsInput | string
        birth_date?: DateTimeFieldUpdateOperationsInput | Date | string
        father_name?: StringFieldUpdateOperationsInput | string
        mother_name?: StringFieldUpdateOperationsInput | string
        birth_certificate_number?: StringFieldUpdateOperationsInput | string
        academic_level?: StringFieldUpdateOperationsInput | string
        function?: StringFieldUpdateOperationsInput | string
        health_status?: StringFieldUpdateOperationsInput | string
        diploma?: NullableStringFieldUpdateOperationsInput | string | null
        card_number?: NullableStringFieldUpdateOperationsInput | string | null
        deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        income_sponsor?: Income_sponsorUpdateManyWithoutSponsorsNestedInput
        sponsor_sponsorship?: Sponsor_sponsorshipUpdateManyWithoutSponsorsNestedInput
        users_sponsors_created_byTousers?: UsersUpdateOneRequiredWithoutSponsors_sponsors_created_byTousersNestedInput
        tenants?: TenantsUpdateOneRequiredWithoutSponsorsNestedInput
    }

    export type SponsorsUncheckedUpdateWithoutUsers_sponsors_deleted_byTousersInput = {
        id?: StringFieldUpdateOperationsInput | string
        zone_id?: StringFieldUpdateOperationsInput | string
        file_number?: IntFieldUpdateOperationsInput | number
        start_date?: DateTimeFieldUpdateOperationsInput | Date | string
        name?: StringFieldUpdateOperationsInput | string
        address?: StringFieldUpdateOperationsInput | string
        phone_number?: StringFieldUpdateOperationsInput | string
        sponsorship_type?: StringFieldUpdateOperationsInput | string
        birth_date?: DateTimeFieldUpdateOperationsInput | Date | string
        father_name?: StringFieldUpdateOperationsInput | string
        mother_name?: StringFieldUpdateOperationsInput | string
        birth_certificate_number?: StringFieldUpdateOperationsInput | string
        academic_level?: StringFieldUpdateOperationsInput | string
        function?: StringFieldUpdateOperationsInput | string
        health_status?: StringFieldUpdateOperationsInput | string
        diploma?: NullableStringFieldUpdateOperationsInput | string | null
        card_number?: NullableStringFieldUpdateOperationsInput | string | null
        tenant_id?: StringFieldUpdateOperationsInput | string
        created_by?: StringFieldUpdateOperationsInput | string
        deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        income_sponsor?: Income_sponsorUncheckedUpdateManyWithoutSponsorsNestedInput
        sponsor_sponsorship?: Sponsor_sponsorshipUncheckedUpdateManyWithoutSponsorsNestedInput
    }

    export type SponsorsUncheckedUpdateManyWithoutSponsors_sponsors_deleted_byTousersInput = {
        id?: StringFieldUpdateOperationsInput | string
        zone_id?: StringFieldUpdateOperationsInput | string
        file_number?: IntFieldUpdateOperationsInput | number
        start_date?: DateTimeFieldUpdateOperationsInput | Date | string
        name?: StringFieldUpdateOperationsInput | string
        address?: StringFieldUpdateOperationsInput | string
        phone_number?: StringFieldUpdateOperationsInput | string
        sponsorship_type?: StringFieldUpdateOperationsInput | string
        birth_date?: DateTimeFieldUpdateOperationsInput | Date | string
        father_name?: StringFieldUpdateOperationsInput | string
        mother_name?: StringFieldUpdateOperationsInput | string
        birth_certificate_number?: StringFieldUpdateOperationsInput | string
        academic_level?: StringFieldUpdateOperationsInput | string
        function?: StringFieldUpdateOperationsInput | string
        health_status?: StringFieldUpdateOperationsInput | string
        diploma?: NullableStringFieldUpdateOperationsInput | string | null
        card_number?: NullableStringFieldUpdateOperationsInput | string | null
        tenant_id?: StringFieldUpdateOperationsInput | string
        created_by?: StringFieldUpdateOperationsInput | string
        deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
        updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    }

    /**
     * Batch Payload for updateMany & deleteMany & createMany
     */

    export type BatchPayload = {
        count: number
    }

    /**
     * DMMF
     */
    export const dmmf: runtime.BaseDMMF
}

type Buffer = Omit<Uint8Array, 'set'>
